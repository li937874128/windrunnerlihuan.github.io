<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android SurfaceFlinger 学习之路(三)----Android开机动画流程简述]]></title>
      <url>http://windrunnerlihuan.com/2017/05/02/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%B8%89-Android%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;在详细分析SurfaceFlinger模块之前要先看看Android的开机动画，因为这个BootAnimation是一个C++应用程序，需要使用SurfaceFlinger服务来创建和渲染自己的Surface，并且不涉及与用户进行交互，所以能以最简洁的方式体现Android与SurfaceFlinger服务的关系。<br><a id="more"></a></p>
<h1 id="开机动画的启动"><a href="#开机动画的启动" class="headerlink" title="开机动画的启动"></a>开机动画的启动</h1><p>&#160; &#160; &#160; &#160;第一个开机画面是在内核启动的过程中出现的，它是一个静态的画面。第二个开机画面是在init进程启动的过程中出现的，它也是一个静态的画面。第三个开机画面BootAnimation是在系统服务启动的过程中出现的，它是一个动态的画面。无论是哪一个画面，它们都是在一个称为帧缓冲区（frame buffer，简称fb）的硬件设备上进行渲染的。接下来，我们就分别分析第三个画面是如何在fb上显示的。</p>
<h2 id="bootanimation的启动过程"><a href="#bootanimation的启动过程" class="headerlink" title="bootanimation的启动过程"></a>bootanimation的启动过程</h2><p>&#160; &#160; &#160; &#160;第三个开机动画使用应用程序BootAnimation来负责显示的，它在启动脚本init.rc中被配置成了一个服务，位于system/core/rootdir/Init.rc：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">service bootanim /system/bin/bootanimation</span><br><span class="line">    <span class="keyword">class</span> core</span><br><span class="line">    user graphics <span class="comment">//用户</span></span><br><span class="line">    group graphics audio <span class="comment">//用户组</span></span><br><span class="line">    disabled <span class="comment">//init进程启动时，不会自动启动bootanimation</span></span><br><span class="line">    oneshot</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;应用程序bootanimation的用户和用户组名称分别被设置为graphics。注意， 用来启动应用程序bootanimation的服务是disable的，即init进程在启动的时候，不会主动将应用程序bootanimation启动起来。<br>&#160; &#160; &#160; &#160;当SurfaceFlinger服务启动的时候，它会通过修改系统属性ctl.start的值来通知init进程启动应用程序bootanimation，以便可以显示第三个开机画面。</p>
<p>&#160; &#160; &#160; &#160;在早期的Android版本中，SurfaceFlinger服务是由SystemServer启动的。但在Android5.0中，该服务是init进程启动过程中就启动了。在init.rc中能看到对该服务的描述：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    <span class="keyword">class</span> core</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;SurfaceFlinger服务的源码路径位于framework/native/services/surfaceflinger/下面，服务的入口在下面的main_surfaceflinger.cpp中，我们查看它的main函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></span><br><span class="line">    <span class="comment">// binder threads to 4.</span></span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the thread pool</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> SurfaceFlinger();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PTHREADS)</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize before clients can connect</span></span><br><span class="line">    flinger-&gt;init(); <span class="comment">//我们主要看这里，其他忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// publish surface flinger</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run in this thread</span></span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;主要工作就是新建一个SurfaceFlinger对象，然后调用其中的init函数，最后调用run函数。我们的重点在init方法，位于framework/native/services/surfaceflinger/SurfaceFlinger.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">...省略大量代码...</span><br><span class="line">    <span class="comment">// start boot animation</span></span><br><span class="line">    startBootAnim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后一行调用了startBootAnim函数，我们继续往下看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::startBootAnim() &#123;</span><br><span class="line">    <span class="comment">// start boot animation</span></span><br><span class="line">    property_set(<span class="string">"service.bootanim.exit"</span>, <span class="string">"0"</span>);</span><br><span class="line">    property_set(<span class="string">"ctl.start"</span>, <span class="string">"bootanim"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里讲系统属性”service.bootanim.exit”设置为”0”，并将”ctl.start”设置为”bootanim”。重点是第二个。</p>
<p>&#160; &#160; &#160; &#160;<strong>当系统属性发生改变时，init进程就会接收到一个系统属性变化通知，这个通知最终是由在init进程中的函数handle_property_set_fd来处理的</strong>。我们可以查看init进程的入口main函数，位于system/core/init/Init.c中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">...省略大量代码...</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> nr, i, timeout = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        ...省略一些代码...</span><br><span class="line">        <span class="comment">//poll函数用来轮询事件</span></span><br><span class="line">        nr = poll(ufds, fd_count, timeout);</span><br><span class="line">        <span class="keyword">if</span> (nr &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fd_count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ufds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">//我们关注这里，当系统属性值被修改时，得到该事件，会执行handle_property_set_fd函数</span></span><br><span class="line">                <span class="keyword">if</span> (ufds[i].fd == get_property_set_fd())</span><br><span class="line">                    handle_property_set_fd();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ufds[i].fd == get_keychord_fd())</span><br><span class="line">                    handle_keychord();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ufds[i].fd == get_signal_fd())</span><br><span class="line">                    handle_signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到，init进程会使用poll机制来轮询事件，其中一个事件是系统属性值被修改。得到该事件后，会执行handle_property_set_fd()，位于system/core/init/Property_service.c中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_property_set_fd</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    prop_msg msg; <span class="comment">//init进程是通过一个socket来接收系统属性变化事件的</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">struct</span> ucred cr;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_un addr;</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_size = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    <span class="keyword">socklen_t</span> cr_size = <span class="keyword">sizeof</span>(cr);</span><br><span class="line">    <span class="keyword">char</span> * source_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> pollfd ufds[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> timeout_ms = <span class="number">2</span> * <span class="number">1000</span>;  <span class="comment">/* Default 2 sec timeout for caller to send property. */</span></span><br><span class="line">    <span class="keyword">int</span> nr;</span><br><span class="line">    <span class="comment">//接收TCP连接 服务端阻塞？等待客户端连接</span></span><br><span class="line">    <span class="keyword">if</span> ((s = accept(property_set_fd, (<span class="keyword">struct</span> sockaddr *) &amp;addr, &amp;addr_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check socket options here */</span></span><br><span class="line">    <span class="comment">//取出socket的可选内容，可能包括客户端进程的权限等属性 </span></span><br><span class="line">    <span class="keyword">if</span> (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(s); </span><br><span class="line">        ERROR(<span class="string">"Unable to receive socket options\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ufds[<span class="number">0</span>].fd = s;</span><br><span class="line">    ufds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    ufds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//轮询客户端事件</span></span><br><span class="line">    nr = TEMP_FAILURE_RETRY(poll(ufds, <span class="number">1</span>, timeout_ms));</span><br><span class="line">    <span class="comment">//轮询事件超时</span></span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"sys_prop: timeout waiting for uid=%d to send property message.\n"</span>, cr.uid);</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//等待错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"sys_prop: error waiting for uid=%d to send property message. err=%d %s\n"</span>, cr.uid, errno, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收socket的主体数据 </span></span><br><span class="line">    r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, <span class="keyword">sizeof</span>(msg), MSG_DONTWAIT));</span><br><span class="line">    <span class="comment">//接收事件不匹配，return</span></span><br><span class="line">    <span class="keyword">if</span>(r != <span class="keyword">sizeof</span>(prop_msg)) &#123;</span><br><span class="line">        ERROR(<span class="string">"sys_prop: mis-match msg size received: %d expected: %zu errno: %d\n"</span>,</span><br><span class="line">              r, <span class="keyword">sizeof</span>(prop_msg), errno);</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始条件判断接收事件</span></span><br><span class="line">    <span class="keyword">switch</span>(msg.cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> PROP_MSG_SETPROP: <span class="comment">//如果是属性发生变化</span></span><br><span class="line">        msg.name[PROP_NAME_MAX<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        msg.value[PROP_VALUE_MAX<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//检查属性名，不能有特殊字符，或者两个点..这样的名字</span></span><br><span class="line">        <span class="keyword">if</span> (!is_legal_property_name(msg.name, <span class="built_in">strlen</span>(msg.name))) &#123;</span><br><span class="line">            ERROR(<span class="string">"sys_prop: illegal property name. Got: \"%s\"\n"</span>, msg.name);</span><br><span class="line">            close(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        getpeercon(s, &amp;source_ctx);</span><br><span class="line"><span class="comment">/* </span><br><span class="line">        如果是ctl开头的消息，则认为是控制消息，控制消息用来执行一些命令，例如用adb shell登录后，输入setprop ctl.start bootanim就可以查看开机动画了;输入setprop service.bootanim.exit 1就可以退出开机动画了</span><br><span class="line">    */</span>  </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(msg.name,<span class="string">"ctl."</span>,<span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Keep the old close-socket-early behavior when handling</span></span><br><span class="line">            <span class="comment">// ctl.* properties.</span></span><br><span class="line">            close(s);</span><br><span class="line">            <span class="comment">//改变系统属性是需要权限,所以需要减产是否有权限</span></span><br><span class="line">            <span class="keyword">if</span> (check_control_mac_perms(msg.value, source_ctx)) &#123;</span><br><span class="line">                <span class="comment">//通过了权限检查之后，另外一个函数handle_control_message就会被调用，以便可以执行一个名称为“bootanim”的命令</span></span><br><span class="line">                handle_control_message((<span class="keyword">char</span>*) msg.name + <span class="number">4</span>, (<span class="keyword">char</span>*) msg.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ERROR(<span class="string">"sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n"</span>,</span><br><span class="line">                        msg.name + <span class="number">4</span>, msg.value, cr.uid, cr.gid, cr.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/* </span><br><span class="line">            不是ctl开头的属性，则首先检查其权限。例如，设置net.开头的属性需要AID_SYSTEM权限，log.开头的属性需要AID_SHELL属性等。 </span><br><span class="line">        */</span> </span><br><span class="line">            <span class="keyword">if</span> (check_perms(msg.name, source_ctx)) &#123;</span><br><span class="line">            <span class="comment">// 最后通过property_set函数设置客户端需要设置的属性  </span></span><br><span class="line">                property_set((<span class="keyword">char</span>*) msg.name, (<span class="keyword">char</span>*) msg.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ERROR(<span class="string">"sys_prop: permission denied uid:%d  name:%s\n"</span>,</span><br><span class="line">                      cr.uid, msg.name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Note: bionic's property client code assumes that the</span></span><br><span class="line">            <span class="comment">// property server will not close the socket until *AFTER*</span></span><br><span class="line">            <span class="comment">// the property is written to memory.</span></span><br><span class="line">            close(s);</span><br><span class="line">        &#125;</span><br><span class="line">        freecon(source_ctx);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;init进程是通过一个socket来接收系统属性变化事件的。每一个系统属性变化事件的内容都是通过一个prop_msg对象来描述的。在prop_msg对象对，成员变量name用来描述发生变化的系统属性的名称，而成员变量value用来描述发生变化的系统属性的值。系统属性分为两种类型，一种是普通类型的系统属性，另一种是控制类型的系统属性（属性名称以“ctl.”开头）。控制类型的系统属性在发生变化时，会触发init进程执行一个命令，而普通类型的系统属性就不具有这个特性。注意，改变系统属性是需要权限，因此，函数handle_property_set_fd在处理一个系统属性变化事件之前，首先会检查修改系统属性的进程是否具有相应的权限，这是通过调用函数check_control_perms或者check_perms来实现的。</p>
<p>&#160; &#160; &#160; &#160;从前面的调用过程可以知道，当前发生变化的系统属性的名称为“ctl.start”，它的值被设置为“bootanim”。由于这是一个控制类型的系统属性，因此，在通过了权限检查之后，另外一个函数handle_control_message就会被调用，以便可以执行一个名称为“bootanim”的命令。</p>
<p>&#160; &#160; &#160; &#160;函数handle_control_message实现在system/core/init/Init.c中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_control_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg, <span class="keyword">const</span> <span class="keyword">char</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(msg,<span class="string">"start"</span>)) &#123;<span class="comment">//所以进入了这里</span></span><br><span class="line">        msg_start(arg);<span class="comment">//arg是bootanimation</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(msg,<span class="string">"stop"</span>)) &#123;</span><br><span class="line">        msg_stop(arg);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(msg,<span class="string">"restart"</span>)) &#123;</span><br><span class="line">        msg_restart(arg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ERROR(<span class="string">"unknown control msg '%s'\n"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;控制类型的系统属性的名称是以”ctl.”开头，并且是以“start”或者“stop”结尾的，其中，“start”表示要启动某一个服务，而“stop”表示要停止某一个服务，它们是分别通过函数msg_start和msg_stop来实现的。由于当前发生变化的系统属性是以“start”来结尾的，因此，接下来就会调用函数msg_start来启动一个名称为“bootanim”的服务。 </p>
<p>&#160; &#160; &#160; &#160;函数msg_start实现在文件system/core/init/Init.c中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">msg_start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><span class="comment">//bootanim</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> service *svc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *args = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strchr</span>(name, <span class="string">':'</span>))<span class="comment">//into</span></span><br><span class="line">        <span class="comment">//查找init.rc中配置的service列表</span></span><br><span class="line">        svc = service_find_by_name(name);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp = strdup(name);</span><br><span class="line">        <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">            args = <span class="built_in">strchr</span>(tmp, <span class="string">':'</span>);</span><br><span class="line">            *args = <span class="string">'\0'</span>;</span><br><span class="line">            args++;</span><br><span class="line"></span><br><span class="line">            svc = service_find_by_name(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (svc) &#123;<span class="comment">//如果在列表中找到了bootanim，则启动它</span></span><br><span class="line">        service_start(svc, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ERROR(<span class="string">"no such service '%s'\n"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;该函数首先调用service_find_by_name()，从service_list中查询要启动的服务是否有存在，若存在，返回服务的相关信息。因为init.rc中有bootanimation的定义，因此在init进程执行parse_config()时，会将该服务添加到service_list中，所以bootanimation应用是存在的。然后，如果找到了该服务，就调用service_start启动服务。</p>
<p>&#160; &#160; &#160; &#160;到此，bootanimation应用就启动了。</p>
<h2 id="开机动画显示"><a href="#开机动画显示" class="headerlink" title="开机动画显示"></a>开机动画显示</h2><p>&#160; &#160; &#160; &#160;从前面的内容可以知道，名称等于“bootanim”的服务所对应的应用程序为/system/bin/bootanimation，这个应用程序实现在frameworks/base/cmds/bootanimation目录中，其中，应用程序入口函数main是实现在frameworks/base/cmds/bootanimation/Bootanimation_main.cpp中的，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PTHREADS)</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, ANDROID_PRIORITY_DISPLAY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    property_get(<span class="string">"debug.sf.nobootanimation"</span>, value, <span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">int</span> noBootAnimation = atoi(value);</span><br><span class="line">    ALOGI_IF(noBootAnimation,  <span class="string">"boot animation disabled"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!noBootAnimation) &#123;<span class="comment">//检查系统属性“debug.sf.nobootnimaition”的值是否不等于0</span></span><br><span class="line">        <span class="comment">//启动一个Binder线程池</span></span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create the boot animation object</span></span><br><span class="line">        <span class="comment">//创建一个BootAnimation对象</span></span><br><span class="line">        sp&lt;BootAnimation&gt; boot = <span class="keyword">new</span> BootAnimation();</span><br><span class="line"></span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数首先检查系统属性“debug.sf.nobootnimaition”的值是否不等于0。如果不等于的话，那么接下来就会启动一个Binder线程池，并且创建一个BootAnimation对象。这个BootAnimation对象就是用来显示第三个开机画面的。由于BootAnimation对象在显示第三个开机画面的过程中，需要与SurfaceFlinger服务通信，因此，应用程序bootanimation就需要启动一个Binder线程池。</p>
<p>&#160; &#160; &#160; &#160;接着我们看看BootAnimation类的声明，位于frameworks/base/cmds/bootanimation/BootAnimation.h中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BootAnimation : <span class="keyword">public</span> Thread, <span class="keyword">public</span> IBinder::DeathRecipient  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">                BootAnimation();  </span><br><span class="line">    <span class="keyword">virtual</span>     ~BootAnimation();    </span><br><span class="line">    .......  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>        <span class="title">threadLoop</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t    <span class="title">readyToRun</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>        <span class="title">onFirstRef</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>        <span class="title">binderDied</span><span class="params">(<span class="keyword">const</span> wp&lt;IBinder&gt;&amp; who)</span></span>;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">status_t</span> initTexture(Texture* texture, AssetManager&amp; asset, <span class="keyword">const</span> <span class="keyword">char</span>* name);  </span><br><span class="line">    <span class="keyword">status_t</span> initTexture(<span class="keyword">const</span> Animation::Frame&amp; frame);  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">android</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">readFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, String8&amp; outString)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">movie</span><span class="params">()</span></span>;  </span><br><span class="line">    ......  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;BootAnimation类继承了Thread类和IBinder::DeathRecipient类，其中几个重要的函数说明如下：</p>
<ul>
<li><strong>onFirstRef()</strong> —– 属于其父类RefBase，该函数在强引用sp新增引用计数時调用，就是当有sp包装的类初始化的时候调用；</li>
<li><strong>binderDied()</strong> —– 当对象死掉或者其他情况导致该Binder结束时，就会回调binderDied()方法;</li>
<li><strong>readyToRun()</strong> —– Thread执行前的初始化工作；</li>
<li><strong>threadLoop()</strong> —– 每个线程类都要实现的，在这里定义thread的执行内容。这个函数如果返回true，且没有requestExist()没有被调用，则该函数会再次执行；如果返回false，则threadloop中的内容仅仅执行一次，线程就会退出。<br>&#160; &#160; &#160; &#160;其他主要函数的说明如下：</li>
<li><strong>android()</strong> —– 显示系统默认的开机画面；</li>
<li><strong>movie()</strong> —– 显示用户自定义的开机动画。</li>
</ul>
<p>&#160; &#160; &#160; &#160;BootAnimation类成员函数的实现位于frameworks/base/cmds/bootanimation/BootAnimation.cpp。</p>
<p>&#160; &#160; &#160; &#160;BootAnimation类间接地继承了RefBase类，并且重写了RefBase类的成员函数onFirstRef，因此，当一个BootAnimation对象第一次被智能指针引用的时，这个BootAnimation对象的成员函数onFirstRef就会被调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BootAnimation::onFirstRef() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mSession-&gt;linkToComposerDeath(<span class="keyword">this</span>);</span><br><span class="line">    ALOGE_IF(err, <span class="string">"linkToComposerDeath failed (%s) "</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        run(<span class="string">"BootAnimation"</span>, PRIORITY_DISPLAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mSession是BootAnimation类的一个成员变量，它的类型为SurfaceComposerClient，是用来和SurfaceFlinger执行Binder进程间通信的，它是在BootAnimation类的构造函数中创建的，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BootAnimation::BootAnimation() : Thread(<span class="literal">false</span>), mZip(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mSession = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;SurfaceComposerClient类内部有一个实现了ISurfaceComposerClient接口的Binder代理对象mClient，这个Binder代理对象引用了SurfaceFlinger服务，SurfaceComposerClient类就是通过它来和SurfaceFlinger服务通信的。这个我们后面章节会详细分析。</p>
<p>&#160; &#160; &#160; &#160;回到BootAnimation类的成员函数onFirstRef中，由于BootAnimation类引用了SurfaceFlinger服务，因此，当SurfaceFlinger服务意外死亡时，BootAnimation类就需要得到通知，这是通过调用成员变量mSession的成员函数linkToComposerDeath来注册SurfaceFlinger服务的死亡接收通知来实现的。</p>
<p>&#160; &#160; &#160; &#160;BootAnimation类继承了Thread类，因此，当BootAnimation类的成员函数onFirstRef调用了父类Thread的成员函数run之后，系统就会创建一个线程，这个线程在第一次运行之前，会调用BootAnimation类的成员函数readyToRun来执行一些初始化工作，后面再调用BootAnimation类的成员函数htreadLoop来显示第三个开机画面。</p>
<p>&#160; &#160; &#160; &#160;BootAnimation类的成员函数readyToRun的实现如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BootAnimation::readyToRun() &#123;</span><br><span class="line">    mAssets.addDefaultAssets();</span><br><span class="line">    <span class="comment">//检查显示屏信息是否正确</span></span><br><span class="line">    sp&lt;IBinder&gt; dtoken(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">            ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">    DisplayInfo dinfo;</span><br><span class="line">    <span class="keyword">status_t</span> status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo);</span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the native surface</span></span><br><span class="line">    <span class="comment">//调用SurfaceComposerClient对象mSession的成员函数createSurface可以获得一个SurfaceControl对象control</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; control = session()-&gt;createSurface(String8(<span class="string">"BootAnimation"</span>),</span><br><span class="line">            dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    control-&gt;setLayer(<span class="number">0x40000000</span>);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line">    <span class="comment">//调用SurfaceControl对象control的成员函数getSurface会返回一个Surface对象s</span></span><br><span class="line">    sp&lt;Surface&gt; s = control-&gt;getSurface();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize opengl and egl</span></span><br><span class="line">    <span class="comment">//初始化OPENEGL和EGL</span></span><br><span class="line">    <span class="keyword">const</span> EGLint attribs[] = &#123;</span><br><span class="line">            EGL_RED_SIZE,   <span class="number">8</span>,</span><br><span class="line">            EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">            EGL_BLUE_SIZE,  <span class="number">8</span>,</span><br><span class="line">            EGL_DEPTH_SIZE, <span class="number">0</span>,</span><br><span class="line">            EGL_NONE</span><br><span class="line">    &#125;;</span><br><span class="line">    EGLint w, h, dummy;</span><br><span class="line">    EGLint numConfigs;</span><br><span class="line">    EGLConfig config;</span><br><span class="line">    EGLSurface surface;</span><br><span class="line">    EGLContext context;</span><br><span class="line"></span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    eglInitialize(display, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    eglChooseConfig(display, attribs, &amp;config, <span class="number">1</span>, &amp;numConfigs);</span><br><span class="line">    surface = eglCreateWindowSurface(display, config, s.get(), <span class="literal">NULL</span>);</span><br><span class="line">    context = eglCreateContext(display, config, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_WIDTH, &amp;w);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line"></span><br><span class="line">    mDisplay = display;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mSurface = surface;</span><br><span class="line">    mWidth = w;</span><br><span class="line">    mHeight = h;</span><br><span class="line">    mFlingerSurfaceControl = control;</span><br><span class="line">    mFlingerSurface = s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the device has encryption turned on or is in process</span></span><br><span class="line">    <span class="comment">// of being encrypted we show the encrypted boot animation.</span></span><br><span class="line">    <span class="comment">//如果设备加密功能开启了，就要显示加密的开机动画</span></span><br><span class="line">    <span class="keyword">char</span> decrypt[PROPERTY_VALUE_MAX];</span><br><span class="line">    property_get(<span class="string">"vold.decrypt"</span>, decrypt, <span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> encryptedAnimation = atoi(decrypt) != <span class="number">0</span> || !<span class="built_in">strcmp</span>(<span class="string">"trigger_restart_min_framework"</span>, decrypt);</span><br><span class="line">    <span class="comment">//选取动画文件</span></span><br><span class="line">    ZipFileRO* zipFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((encryptedAnimation &amp;&amp;</span><br><span class="line">            (access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            ((zipFile = ZipFileRO::open(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE)) != <span class="literal">NULL</span>)) ||</span><br><span class="line"></span><br><span class="line">            ((access(OEM_BOOTANIMATION_FILE, R_OK) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            ((zipFile = ZipFileRO::open(OEM_BOOTANIMATION_FILE)) != <span class="literal">NULL</span>)) ||</span><br><span class="line"></span><br><span class="line">            ((access(SYSTEM_BOOTANIMATION_FILE, R_OK) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            ((zipFile = ZipFileRO::open(SYSTEM_BOOTANIMATION_FILE)) != <span class="literal">NULL</span>))) &#123;</span><br><span class="line">        mZip = zipFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;readyToRun主要做了如下工作：</p>
<p>&#160; &#160; &#160; &#160;1）BootAnimation类的成员函数session用来返回BootAnimation类的成员变量mSession所描述的一个SurfaceComposerClient对象。通过调用SurfaceComposerClient对象mSession的成员函数createSurface可以获得一个SurfaceControl对象control。</p>
<p>&#160; &#160; &#160; &#160;SurfaceComposerClient类的成员函数createSurface首先调用内部的Binder代理对象mClient(frameworks/native/services/surfaceflinger/Client.cpp)来请求SurfaceFlinger返回一个类型为(class Handle : public BBinder, public LayerCleaner)Binder代理对象（封装了SurfaceFlinger的sp指针和Layer对象）handle，和一个IGraphicBufferProducer的sp指针（封装了SurfaceFlinger的sp指针）gbp，接着再使用这两个对象来创建一个SurfaceControl对象。创建出来的SurfaceControl对象的成员变量handle就指向了从SurfaceFlinger返回来的类型为Handle 的Binder代理对象。有了这个Binder代理对象之后，SurfaceControl对象就可以和SurfaceFlinger服务通信了。(下一章节会分析)</p>
<p>&#160; &#160; &#160; &#160;调用SurfaceControl对象control的成员函数getSurface会返回一个Surface对象s。这个Surface对象s内部也有一个类型为IGraphicBufferProducer的sp指针mGraphicBufferProducer，这个sp指针与前面所创建的SurfaceControl对象control的内部的sp指针（封装了SurfaceFlinger的sp指针）gbp引用的是同一个对象。这样，Surface对象s也可以通过其内部的sp指针mGraphicBufferProducer来和SurfaceFlinger服务通信。（下一章节会分析）</p>
<p>&#160; &#160; &#160; &#160;Surface类继承了ANativeWindow类。ANativeWindow类是连接OpenGL和Android窗口系统的桥梁，即OpenGL需要通过ANativeWindow类来间接地操作Android窗口系统。这种桥梁关系是通过EGL库来建立的，所有以egl为前缀的函数名均为EGL库提供的接口。</p>
<p>&#160; &#160; &#160; &#160;2）为了能够在OpenGL和Android窗口系统之间的建立一个桥梁，我们需要一个EGLDisplay对象display，一个EGLConfig对象config，一个EGLSurface对象surface，以及一个EGLContext对象context，其中，EGLDisplay对象display用来描述一个EGL显示屏，EGLConfig对象config用来描述一个EGL帧缓冲区配置参数，EGLSurface对象surface用来描述一个EGL绘图表面，EGLContext对象context用来描述一个EGL绘图上下文（状态），它们是分别通过调用egl库函数eglGetDisplay、eglChooseConfig、eglCreateWindowSurface和eglCreateContext来获得的。注意，EGLConfig对象config、EGLSurface对象surface和EGLContext对象context都是用来描述EGLDisplay对象display的。有了这些对象之后，就可以调用函数eglMakeCurrent来设置当前EGL库所使用的绘图表面以及绘图上下文。</p>
<p>&#160; &#160; &#160; &#160;还有另外一个地方需要注意的是，每一个EGLSurface对象surface有一个关联的ANativeWindow对象。这个ANativeWindow对象是通过函数eglCreateWindowSurface的第三个参数来指定的。在我们这个场景中，这个ANativeWindow对象正好对应于前面所创建的 Surface对象s。每当OpenGL需要绘图的时候，它就会找到前面所设置的绘图表面，即EGLSurface对象surface。有了EGLSurface对象surface之后，就可以找到与它关联的ANativeWindow对象，即Surface对象s。有了Surface对象s之后，就可以通过其内部的sp指针mGraphicBufferProducer来请求SurfaceFlinger服务返回帧缓冲区硬件设备的一个图形访问接口。这样，OpenGL最终就可以将要绘制的图形渲染到帧缓冲区硬件设备中去，即显示在实际屏幕上。屏幕的大小，即宽度和高度，可以通过函数eglQuerySurface来获得。</p>
<p>&#160; &#160; &#160; &#160;3）动画文件的读取是按顺序进行的，如果读取成功，则不再读取后续的文件，如果失败，则读取下一个文件。顺序如下：</p>
<ol>
<li><p>如果设备的加密功能已经开启，或者设备正在进行加密，则读取加密开机动画文件，路径为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_ENCRYPTED_BOOTANIMATION_FILE <span class="string">"/system/media/bootanimation-encrypted.zip"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>OEM厂商指定的开机动画，路径为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OEM_BOOTANIMATION_FILE <span class="string">"/oem/media/bootanimation.zip"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>系统开机动画，路径为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_BOOTANIMATION_FILE <span class="string">"/system/media/bootanimation.zip"</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;这一步执行完成之后，用来显示第三个开机画面的线程的初始化工作就执行完成了，接下来，就会执行这个线程的主体函数，即BootAnimation类的成员函数threadLoop。<br>&#160; &#160; &#160; &#160;BootAnimation类的成员函数threadLoop的实现如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BootAnimation::threadLoop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> r;</span><br><span class="line">    <span class="comment">// We have no bootanimation file, so we use the stock android logo</span></span><br><span class="line">    <span class="comment">// animation.</span></span><br><span class="line">    <span class="keyword">if</span> (mZip == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        r = android();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = movie();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);</span><br><span class="line">    eglDestroyContext(mDisplay, mContext);</span><br><span class="line">    eglDestroySurface(mDisplay, mSurface);</span><br><span class="line">    mFlingerSurface.clear();</span><br><span class="line">    mFlingerSurfaceControl.clear();</span><br><span class="line">    eglTerminate(mDisplay);</span><br><span class="line">    IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数流程比较简单，首先判断自定义的开机动画文件mZip是否存在，如果存在就调用movie()完成自定义开机画面的显示；如果不存在，调用android()完成系统默认开机画面的显示。然后进行开机动画显示后的销毁、释放工作，主要就是readyToRun中初始化的一些EGL对象。最后终止线程，并return。注意，movie()和android()的返回值都是false，因此线程结束也会返回false。threadLoop()函数如果返回值为false，则该函数中的内容只会执行一次；如果返回true，则会不停的执行。这里返回false，因此只会执行一次。</p>
<p>&#160; &#160; &#160; &#160;接下来，我们就分别分析BootAnimation类的成员函数android和movie的实现。</p>
<h3 id="系统默认开机动画android"><a href="#系统默认开机动画android" class="headerlink" title="系统默认开机动画android()"></a>系统默认开机动画android()</h3><p>&#160; &#160; &#160; &#160;BootAnimation类的成员函数android的实现如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BootAnimation::android()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取开机动画默认图片，根据图片创建两个纹理对象</span></span><br><span class="line">    <span class="comment">//"android"字样图片</span></span><br><span class="line">    initTexture(&amp;mAndroid[<span class="number">0</span>], mAssets, <span class="string">"images/android-logo-mask.png"</span>);</span><br><span class="line">    <span class="comment">//闪光图片</span></span><br><span class="line">    initTexture(&amp;mAndroid[<span class="number">1</span>], mAssets, <span class="string">"images/android-logo-shine.png"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear screen</span></span><br><span class="line">    <span class="comment">//清理屏幕</span></span><br><span class="line">    glShadeModel(GL_FLAT);</span><br><span class="line">    glDisable(GL_DITHER);</span><br><span class="line">    glDisable(GL_SCISSOR_TEST);</span><br><span class="line">    glClearColor(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line"></span><br><span class="line">    glEnable(GL_TEXTURE_2D);</span><br><span class="line">    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);</span><br><span class="line">    <span class="comment">//图片在屏幕中现实位置</span></span><br><span class="line">    <span class="keyword">const</span> GLint xc = (mWidth  - mAndroid[<span class="number">0</span>].w) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> GLint yc = (mHeight - mAndroid[<span class="number">0</span>].h) / <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Rect <span class="title">updateRect</span><span class="params">(xc, yc, xc + mAndroid[<span class="number">0</span>].w, yc + mAndroid[<span class="number">0</span>].h)</span></span>;</span><br><span class="line"></span><br><span class="line">    glScissor(updateRect.left, mHeight - updateRect.bottom, updateRect.width(),</span><br><span class="line">            updateRect.height());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Blend state</span></span><br><span class="line">    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> startTime = systemTime();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//计算每次偏移时间，然后计算出偏移位置</span></span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">        <span class="keyword">double</span> time = now - startTime;</span><br><span class="line">        <span class="keyword">float</span> t = <span class="number">4.0f</span> * <span class="keyword">float</span>(time / us2ns(<span class="number">16667</span>)) / mAndroid[<span class="number">1</span>].w;</span><br><span class="line">        GLint offset = (<span class="number">1</span> - (t - floorf(t))) * mAndroid[<span class="number">1</span>].w;</span><br><span class="line">        GLint x = xc - offset;</span><br><span class="line"></span><br><span class="line">        glDisable(GL_SCISSOR_TEST);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glEnable(GL_SCISSOR_TEST);</span><br><span class="line">        glDisable(GL_BLEND);</span><br><span class="line">        <span class="comment">//绘制闪光图片，这个会根据上面计算的位置来显示</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, mAndroid[<span class="number">1</span>].name);</span><br><span class="line">        glDrawTexiOES(x,                 yc, <span class="number">0</span>, mAndroid[<span class="number">1</span>].w, mAndroid[<span class="number">1</span>].h);</span><br><span class="line">        glDrawTexiOES(x + mAndroid[<span class="number">1</span>].w, yc, <span class="number">0</span>, mAndroid[<span class="number">1</span>].w, mAndroid[<span class="number">1</span>].h);</span><br><span class="line"></span><br><span class="line">        glEnable(GL_BLEND);</span><br><span class="line">        <span class="comment">//绘制Android字样的图片，这个不动</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, mAndroid[<span class="number">0</span>].name);</span><br><span class="line">        glDrawTexiOES(xc, yc, <span class="number">0</span>, mAndroid[<span class="number">0</span>].w, mAndroid[<span class="number">0</span>].h);</span><br><span class="line">        <span class="comment">//交换缓冲区，以显示到屏幕</span></span><br><span class="line">        EGLBoolean res = eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line">        <span class="keyword">if</span> (res == EGL_FALSE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 12fps: don't animate too fast to preserve CPU</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">nsecs_t</span> sleepTime = <span class="number">83333</span> - ns2us(systemTime() - now);</span><br><span class="line">        <span class="keyword">if</span> (sleepTime &gt; <span class="number">0</span>)</span><br><span class="line">            usleep(sleepTime);</span><br><span class="line">        <span class="comment">//最后执行checkExit函数，判断是否退出了</span></span><br><span class="line">        checkExit();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!exitPending());</span><br><span class="line"></span><br><span class="line">    glDeleteTextures(<span class="number">1</span>, &amp;mAndroid[<span class="number">0</span>].name);</span><br><span class="line">    glDeleteTextures(<span class="number">1</span>, &amp;mAndroid[<span class="number">1</span>].name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;一共有以下几个步骤：<br>&#160; &#160; &#160; &#160;1） Android系统默认的开机动画是由两张图片android-logo-mask.png和android-logo-shine.png中。这两张图片保存在frameworks/base/core/res/assets/images目录中，它们最终会被编译在framework-res模块（frameworks/base/core/res）中，即编译在framework-res.apk文件中。编译在framework-res模块中的资源文件可以通过AssetManager类来访问。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----Android%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/img.jpg" alt="开机两张图片"></p>
<p>&#160; &#160; &#160; &#160;BootAnimation类的成员函数android首先调用另外一个成员函数initTexture来将根据图片android-logo-mask.png和android-logo-shine.png的内容来分别创建两个纹理对象，这两个纹理对象就分别保存在BootAnimation类的成员变量mAndroid所描述的一个数组中。通过混合渲染这两个纹理对象，我们就可以得到一个开机动画，这是通过中间的while循环语句来实现的。</p>
<p>&#160; &#160; &#160; &#160;2）图片android-logo-mask.png用作动画前景，它是一个镂空的“ANDROID”图像。图片android-logo-shine.png用作动画背景，它的中间包含有一个高亮的呈45度角的条纹。在每一次循环中，图片android-logo-shine.png被划分成左右两部分内容来显示。左右两个部分的图像宽度随着时间的推移而此消彼长，这样就可以使得图片android-logo-shine.png中间高亮的条纹好像在移动一样。另一方面，在每一次循环中，图片android-logo-mask.png都作为一个整体来渲染，而且它的位置是恒定不变的。由于它是一个镂空的“ANDROID”图像，因此，我们就可以通过它的镂空来看到它背后的图片android-logo-shine.png的条纹一闪一闪地划过。这个while循环语句会一直被执行，直到应用程序/system/bin/bootanimation被结束为止。</p>
<p>&#160; &#160; &#160; &#160;3）在循环语句最后会执行checkExit()函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BootAnimation::checkExit() &#123;</span><br><span class="line">    <span class="comment">// Allow surface flinger to gracefully request shutdown</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    property_get(EXIT_PROP_NAME, value, <span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">int</span> exitnow = atoi(value);</span><br><span class="line">    <span class="keyword">if</span> (exitnow) &#123;</span><br><span class="line">        requestExit();</span><br><span class="line">        <span class="keyword">if</span> (mAudioPlayer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mAudioPlayer-&gt;requestExit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;首先调用property_get获取属性EXIT_PROP_NAME的值:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_PROP_NAME <span class="string">"service.bootanim.exit"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后判断该值，如果为1，则调用requestExit（）要求退出当前线程，该函数是异步的。位于system/core/libutils/Thread.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::requestExit()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">//这里将mExitPending 赋值为true</span></span><br><span class="line">    mExitPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;回到android()代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">while</span> (!exitPending());</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;调用exitPending()，改函数判断requestExit（）是否被调用过，如果调用过则返回true，否则为false。依然位于system/core/libutils/Thread.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Thread::exitPending() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">//上面我们在requestExit赋过值了</span></span><br><span class="line">    <span class="keyword">return</span> mExitPending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样，当属性“service.bootanim.exit”值被设为”1”时，android()就会调用requestExit()，exitPending()返回值为true。于是do…while()循环就会退出，开机动画绘制就会结束。<br>&#160; &#160; &#160; &#160;至于什么时候是哪个服务将属性“service.bootanim.exit”的值设置为1的，我们后面讲开机动画的停止的时候会提到。</p>
<h3 id="自定义开机动画movie"><a href="#自定义开机动画movie" class="headerlink" title="自定义开机动画movie()"></a>自定义开机动画movie()</h3><p>&#160; &#160; &#160; &#160;BootAnimation类的成员函数movie的实现比较长，我们分段来阅读：<br>&#160; &#160; &#160; &#160;Part.1：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BootAnimation::movie()&#123;</span><br><span class="line">String8 desString;</span><br><span class="line">    <span class="comment">//读取desc.txt文件内容</span></span><br><span class="line">    <span class="keyword">if</span> (!readFile(<span class="string">"desc.txt"</span>, desString)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s = desString.<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and initialize an AudioPlayer if we have an audio_conf.txt file</span></span><br><span class="line">    <span class="comment">//如果存在audio_conf.txt文件，则会创建一个AudioPlayer，并根据读取的字符串初始化</span></span><br><span class="line">    <span class="comment">//ignore it</span></span><br><span class="line">    String8 audioConf;</span><br><span class="line">    <span class="keyword">if</span> (readFile(<span class="string">"audio_conf.txt"</span>, audioConf)) &#123;</span><br><span class="line">        mAudioPlayer = <span class="keyword">new</span> AudioPlayer;</span><br><span class="line">        <span class="keyword">if</span> (!mAudioPlayer-&gt;init(audioConf.<span class="built_in">string</span>())) &#123;</span><br><span class="line">            ALOGE(<span class="string">"mAudioPlayer.init failed"</span>);</span><br><span class="line">            mAudioPlayer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从前面BootAnimation类的成员函数readyToRun的实现可以知道，如果目标设备上存在压缩文件/system/media/bootanimation.zip(另外两种我们忽略)，那么BootAnimation类的成员变量mZip就会指向它，这段代码作用是读取开机动画文件mZip中的描述文件“desc.txt”。每个动画文件压缩包中必须要包含一个desc.txt，该文件用来描述开机动画如何显示。下面以一个示例来分析一下该文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">480</span> <span class="number">640</span> <span class="number">20</span>  </span><br><span class="line">p <span class="number">1</span> <span class="number">0</span> folder1  </span><br><span class="line">p <span class="number">2</span> <span class="number">20</span> folder2  </span><br><span class="line">c <span class="number">0</span> <span class="number">0</span> folder3  </span><br><span class="line">c <span class="number">1</span> <span class="number">0</span> folder4</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Part.2：<br>&#160; &#160; &#160; &#160;第1行用来描述开机动画在屏幕显示的大小及速度。具体为：开机动画的宽度为480个像素，高度为640个像素，显示频率为每秒20帧，即每帧显示1/20秒。</p>
<p>&#160; &#160; &#160; &#160;下面的每一行代表一个片段，显示的时候会按照顺序从上到下依次显示。第1个字符为片段类型，有’c’和’p’两种，两者的区别后面会结合代码说明。</p>
<p>&#160; &#160; &#160; &#160;第2个数字为该片段重复显示的次数，如果为‘0’，表示会无限重复显示；第3个数字为两次显示之间的间隔，单位为第一行中定义的每帧显示的时间；第4个字符串为该片段所在的文件夹，一个片段可以由多个png图片组成，都存放在folder文件夹中。</p>
<p>&#160; &#160; &#160; &#160;“p 1 0 folder1”代表该片段显示1次，与下一个片段间隔0s，该片段的显示图片路径为bootanimation.zip/folder1。<br>&#160; &#160; &#160; &#160;“p 2 20 folder2”代表该片段显示2次，且两次之间显示的间隔为20<em>(1/20)=1s，与下一个片段间隔20</em>(1/20)=1s，该片段的显示图片路径为bootanimation.zip/folder2。<br>&#160; &#160; &#160; &#160;“c 0 0 folder3”代表该片段无限循环显示，且两次显示的间隔为0s，与下一个片段间隔0s，该片段的显示图路径为bootanimation.zip/folder3。<br>&#160; &#160; &#160; &#160;“c 1 10 folder4”代表该片段显示1次，显示后暂停10*(1/20)=0.5s，该片段的显示图路径为bootanimation.zip/folder4。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BootAnimation::movie()&#123;</span><br><span class="line"></span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    Animation animation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the description file</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">endl</span> = <span class="built_in">strstr</span>(s, <span class="string">"\n"</span>);<span class="comment">//检测首次出现换行符的地址</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">endl</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//每次读取一行</span></span><br><span class="line">        <span class="function">String8 <span class="title">line</span><span class="params">(s, <span class="built_in">endl</span> - s)</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* l = line.<span class="built_in">string</span>();</span><br><span class="line">        <span class="keyword">int</span> fps, width, height, count, pause;</span><br><span class="line">        <span class="keyword">char</span> path[ANIM_ENTRY_NAME_MAX];</span><br><span class="line">        <span class="keyword">char</span> color[<span class="number">7</span>] = <span class="string">"000000"</span>; <span class="comment">// default to black if unspecified</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> pathType;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(l, <span class="string">"%d %d %d"</span>, &amp;width, &amp;height, &amp;fps) == <span class="number">3</span>) &#123;<span class="comment">//每行如果有三个字符串，则依次是宽、高、帧率</span></span><br><span class="line">            <span class="comment">// ALOGD("&gt; w=%d, h=%d, fps=%d", width, height, fps);</span></span><br><span class="line">            animation.width = width;</span><br><span class="line">            animation.height = height;</span><br><span class="line">            animation.fps = fps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是大于等于四个字符串，则依次是显示类型、显示次数、与下一次间隔时间、显示颜色</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sscanf</span>(l, <span class="string">" %c %d %d %s #%6s"</span>, &amp;pathType, &amp;count, &amp;pause, path, color) &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// ALOGD("&gt; type=%c, count=%d, pause=%d, path=%s, color=%s", pathType, count, pause, path, color);</span></span><br><span class="line">            Animation::Part part;</span><br><span class="line">            part.playUntilComplete = pathType == <span class="string">'c'</span>;</span><br><span class="line">            part.count = count;</span><br><span class="line">            part.pause = pause;</span><br><span class="line">            part.path = path;</span><br><span class="line">            part.audioFile = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (!parseColor(color, part.backgroundColor)) &#123;</span><br><span class="line">                ALOGE(<span class="string">"&gt; invalid color '#%s'"</span>, color);</span><br><span class="line">                part.backgroundColor[<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">                part.backgroundColor[<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">                part.backgroundColor[<span class="number">2</span>] = <span class="number">0.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            animation.parts.add(part);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = ++<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上面的for循环语句分析完成desc.txt文件的内容后，就得到了开机动画的显示大小、速度以及片断信息。这些信息都保存在Animation对象animation中，其中，每一个动画片断都使用一个Animation::Part对象来描述，并且保存在Animation对象animation的成员变量parts所描述的一个片断列表中。</p>
<p>&#160; &#160; &#160; &#160;Part.3：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">bool BootAnimation::movie()&#123;</span><br><span class="line"></span><br><span class="line">    ...Part.1...</span><br><span class="line">    ...Part.2...</span><br><span class="line"></span><br><span class="line">    // read all the data structures</span><br><span class="line">    //开始读取zip文件</span><br><span class="line">    const size_t pcount = animation.parts.size();</span><br><span class="line">    void *cookie = NULL;</span><br><span class="line">    if (!mZip-&gt;startIteration(&amp;cookie)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZipEntryRO entry;</span><br><span class="line">    char name[ANIM_ENTRY_NAME_MAX];</span><br><span class="line">    //开始循环遍历每一个文件</span><br><span class="line">    while ((entry = mZip-&gt;nextEntry(cookie)) != NULL) &#123;</span><br><span class="line">        const int foundEntryName = mZip-&gt;getEntryFileName(entry, name, ANIM_ENTRY_NAME_MAX);</span><br><span class="line">        if (foundEntryName &gt; ANIM_ENTRY_NAME_MAX || foundEntryName == -1) &#123;</span><br><span class="line">            ALOGE("Error fetching entry file name");</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const String8 entryName(name);</span><br><span class="line">        const String8 path(entryName.getPathDir());</span><br><span class="line">        const String8 leaf(entryName.getPathLeaf());</span><br><span class="line">        if (leaf.size() &gt; 0) &#123;</span><br><span class="line">            for (size_t j=0 ; j&lt;pcount ; j++) &#123;</span><br><span class="line">                if (path == animation.parts[j].path) &#123;</span><br><span class="line">                    int method;</span><br><span class="line">                    // supports only stored png files</span><br><span class="line">                    if (mZip-&gt;getEntryInfo(entry, &amp;method, NULL, NULL, NULL, NULL, NULL)) &#123;</span><br><span class="line">                        if (method == ZipFileRO::kCompressStored) &#123;</span><br><span class="line">                            FileMap* map = mZip-&gt;createEntryFileMap(entry);</span><br><span class="line">                            if (map) &#123;</span><br><span class="line">                                Animation::Part&amp; part(animation.parts.editItemAt(j));</span><br><span class="line">                                if (leaf == "audio.wav") &#123;</span><br><span class="line">                                    // a part may have at most one audio file</span><br><span class="line">                                    part.audioFile = map;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    Animation::Frame frame;</span><br><span class="line">                                    frame.name = leaf;</span><br><span class="line">                                    frame.map = map;</span><br><span class="line">                                    part.frames.add(frame);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mZip-&gt;endIteration(cookie);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接下来，BootAnimation类的成员函数movie再断续将每一个片断所对应的png图片读取出来。每一个png图片都表示一个动画帧，使用一个Animation::Frame对象来描述，并且保存在对应的Animation::Part对象的成员变量frames所描述的一个帧列表中。</p>
<p>&#160; &#160; &#160; &#160;Part.4：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool BootAnimation::movie()&#123;</span><br><span class="line"></span><br><span class="line">    ...Part.1...</span><br><span class="line">    ...Part.2...</span><br><span class="line">    ...Part.3...</span><br><span class="line"></span><br><span class="line">    // clear screen</span><br><span class="line">    glShadeModel(GL_FLAT);</span><br><span class="line">    glDisable(GL_DITHER);</span><br><span class="line">    glDisable(GL_SCISSOR_TEST);</span><br><span class="line">    glDisable(GL_BLEND);</span><br><span class="line">    glClearColor(0,0,0,1);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line"></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class="line">    glEnable(GL_TEXTURE_2D);</span><br><span class="line">    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);</span><br><span class="line">    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">    const int xc = (mWidth - animation.width) / 2;</span><br><span class="line">    const int yc = ((mHeight - animation.height) / 2);</span><br><span class="line">    nsecs_t lastFrame = systemTime();</span><br><span class="line">    nsecs_t frameDuration = s2ns(1) / animation.fps;</span><br><span class="line"></span><br><span class="line">    Region clearReg(Rect(mWidth, mHeight));</span><br><span class="line">    clearReg.subtractSelf(Rect(xc, yc, xc+animation.width, yc+animation.height));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;前面的一系列gl函数首先用来清理屏幕，接下来的一系列gl函数用来设置OpenGL的纹理显示方式。<br>&#160; &#160; &#160; &#160;变量xc和yc的值用来描述开机动画的显示位置，即需要在屏幕中间显示开机动画，另外一个变量frameDuration的值用来描述每一帧的显示时间，它是以纳秒为单位的。<br>&#160; &#160; &#160; &#160;Region对象clearReg用来描述屏幕中除了开机动画之外的其它区域，它是用整个屏幕区域减去开机动画所点据的区域来得到的。</p>
<p>&#160; &#160; &#160; &#160;Part.5：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">bool BootAnimation::movie()&#123;</span><br><span class="line"></span><br><span class="line">    ...Part.1...</span><br><span class="line">    ...Part.2...</span><br><span class="line">    ...Part.3...</span><br><span class="line">    ...Part.4...</span><br><span class="line"></span><br><span class="line">    //第一层for循环用来显示每一个动画片断</span><br><span class="line">    for (size_t i=0 ; i&lt;pcount ; i++) &#123;</span><br><span class="line">        const Animation::Part&amp; part(animation.parts[i]);</span><br><span class="line">        const size_t fcount = part.frames.size();</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, 0);</span><br><span class="line">        //第二层的for循环用来循环显示每一个动画片断</span><br><span class="line">        for (int r=0 ; !part.count || r&lt;part.count ; r++) &#123;</span><br><span class="line">            // Exit any non playuntil complete parts immediately</span><br><span class="line">            if(exitPending() &amp;&amp; !part.playUntilComplete)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            // only play audio file the first time we animate the part</span><br><span class="line">            if (r == 0 &amp;&amp; mAudioPlayer != NULL &amp;&amp; part.audioFile) &#123;</span><br><span class="line">                mAudioPlayer-&gt;playFile(part.audioFile);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            glClearColor(</span><br><span class="line">                    part.backgroundColor[0],</span><br><span class="line">                    part.backgroundColor[1],</span><br><span class="line">                    part.backgroundColor[2],</span><br><span class="line">                    1.0f);</span><br><span class="line">            //第三层的for循环用来显示每一个动画片断所对应的png图片</span><br><span class="line">            //可以看到，如果exitPending()返回值为true且part.playUntilComplete=false，则会break。</span><br><span class="line">            //即：当SurfaceFlinger服务要求bootanimation停止显示动画时，以‘p’标识的片段会停止，</span><br><span class="line">            //而以'c'标识的片段会继续显示。这就是两者之间的主要区别。 </span><br><span class="line">            for (size_t j=0 ; j&lt;fcount &amp;&amp; (!exitPending() || part.playUntilComplete) ; j++) &#123;</span><br><span class="line">                const Animation::Frame&amp; frame(part.frames[j]);</span><br><span class="line">                nsecs_t lastFrame = systemTime();</span><br><span class="line"></span><br><span class="line">                if (r &gt; 0) &#123;</span><br><span class="line">                    glBindTexture(GL_TEXTURE_2D, frame.tid);</span><br><span class="line">                &#125; else &#123;//如果一个动画片断的循环显示次数不等于1，那么就说明这个动画片断中的png图片需要重复地显示在屏幕中</span><br><span class="line">                    //第一次显示一个png图片的时候，会调用函数glGenTextures来为这个png图片创建一个纹理对象,</span><br><span class="line">                    //并且将这个纹理对象的名称保存在对应的Animation::Frame对象的成员变量tid中</span><br><span class="line">                    if (part.count != 1) &#123;</span><br><span class="line">                        glGenTextures(1, &amp;frame.tid);</span><br><span class="line">                        glBindTexture(GL_TEXTURE_2D, frame.tid);</span><br><span class="line">                        glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">                        glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">                    &#125;</span><br><span class="line">                    initTexture(frame);</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果Region对象clearReg所包含的区域不为空,首先要将它所包含的区域裁剪掉，避免开机动画可以显示在指定的位置以及大小中</span><br><span class="line">                if (!clearReg.isEmpty()) &#123;</span><br><span class="line">                    Region::const_iterator head(clearReg.begin());</span><br><span class="line">                    Region::const_iterator tail(clearReg.end());</span><br><span class="line">                    glEnable(GL_SCISSOR_TEST);</span><br><span class="line">                    while (head != tail) &#123;</span><br><span class="line">                        const Rect&amp; r(*head++);</span><br><span class="line">                        glScissor(r.left, mHeight - r.bottom,</span><br><span class="line">                                r.width(), r.height());</span><br><span class="line">                        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    glDisable(GL_SCISSOR_TEST);</span><br><span class="line">                &#125;</span><br><span class="line">                glDrawTexiOES(xc, yc, 0, animation.width, animation.height);</span><br><span class="line">                eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line"></span><br><span class="line">                nsecs_t now = systemTime();</span><br><span class="line">                nsecs_t delay = frameDuration - (now - lastFrame);</span><br><span class="line">                //ALOGD("%lld, %lld", ns2ms(now - lastFrame), ns2ms(delay));</span><br><span class="line">                lastFrame = now;</span><br><span class="line">                //调用函数usleep函数来让线程睡眠一下，以保证每一个png图片，即每一帧动画都按照预先指定好的速度来显示</span><br><span class="line">                if (delay &gt; 0) &#123;</span><br><span class="line">                    struct timespec spec;</span><br><span class="line">                    spec.tv_sec  = (now + delay) / 1000000000;</span><br><span class="line">                    spec.tv_nsec = (now + delay) % 1000000000;</span><br><span class="line">                    int err;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, NULL);</span><br><span class="line">                    &#125; while (err&lt;0 &amp;&amp; errno == EINTR);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                checkExit();</span><br><span class="line">            &#125;</span><br><span class="line">            //每当循环显示完成一个片断时，需要调用usleep函数来使得线程睡眠part.pause * ns2us(frameDuration)毫秒，以便可以按照预先设定的节奏来显示开机动画。</span><br><span class="line">            usleep(part.pause * ns2us(frameDuration));</span><br><span class="line"></span><br><span class="line">            // For infinite parts, we've now played them at least once, so perhaps exit</span><br><span class="line">            //如果无限循环，则检查是否有退出消息来了，上面android()函数分析过了</span><br><span class="line">            if(exitPending() &amp;&amp; !part.count)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // free the textures for this part</span><br><span class="line">        //最后一个if语句判断一个动画片断是否是循环显示的，即循环次数不等于1。</span><br><span class="line">        //如果是的话，那么就说明前面为它所对应的每一个png图片都创建过一个纹理对象。</span><br><span class="line">        //现在既然这个片断的显示过程已经结束了，因此，就需要释放前面为它所创建的纹理对象。</span><br><span class="line">        if (part.count != 1) &#123;</span><br><span class="line">            for (size_t j=0 ; j&lt;fcount ; j++) &#123;</span><br><span class="line">                const Animation::Frame&amp; frame(part.frames[j]);</span><br><span class="line">                glDeleteTextures(1, &amp;frame.tid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;1）第一层for循环用来显示每一个动画片断，第二层的for循环用来循环显示每一个动画片断，第三层的for循环用来显示每一个动画片断所对应的png图片。这些png图片以纹理的方式来显示在屏幕中。</p>
<p>&#160; &#160; &#160; &#160;2）注意，如果一个动画片断的循环显示次数不等于1，那么就说明这个动画片断中的png图片需要重复地显示在屏幕中。由于每一个png图片都需要转换为一个纹理对象之后才能显示在屏幕中，因此，为了避免重复地为同一个png图片创建纹理对象，第三层的for循环在第一次显示一个png图片的时候，会调用函数glGenTextures来为这个png图片创建一个纹理对象，并且将这个纹理对象的名称保存在对应的Animation::Frame对象的成员变量tid中，这样，下次再显示相同的图片时，就可以使用前面已经创建好了的纹理对象，即调用函数glBindTexture来指定当前要操作的纹理对象。</p>
<p>&#160; &#160; &#160; &#160;3）如果Region对象clearReg所包含的区域不为空，那么在调用函数glDrawTexiOES和eglSwapBuffers来显示每一个png图片之前，首先要将它所包含的区域裁剪掉，避免开机动画可以显示在指定的位置以及大小中。</p>
<p>&#160; &#160; &#160; &#160;4） 每当显示完成一个png图片之后，都要将变量frameDuration的值从纳秒转换为毫秒。如果转换后的值大小于，那么就需要调用函数usleep函数来让线程睡眠一下，以保证每一个png图片，即每一帧动画都按照预先指定好的速度来显示。注意，函数usleep指定的睡眠时间只能精确到毫秒，因此，如果预先指定的帧显示时间小于1毫秒，那么BootAnimation类的成员函数movie是无法精确地控制地每一帧的显示时间的。</p>
<p>&#160; &#160; &#160; &#160;5）还有另外一个地方需要注意的是，每当循环显示完成一个片断时，需要调用usleep函数来使得线程睡眠part.pause * ns2us(frameDuration)毫秒，以便可以按照预先设定的节奏来显示开机动画。</p>
<p>&#160; &#160; &#160; &#160;6）最后一个if语句判断一个动画片断是否是循环显示的，即循环次数不等于1。如果是的话，那么就说明前面为它所对应的每一个png图片都创建过一个纹理对象。现在既然这个片断的显示过程已经结束了，因此，就需要释放前面为它所创建的纹理对象。</p>
<p>附注：<br>&#160; &#160; &#160; &#160;可以看到，如果exitPending()返回值为true且part.playUntilComplete=false，则会break。即：当SurfaceFlinger服务要求bootanimation停止显示动画时，以‘p’标识的片段会停止，而以’c’标识的片段会继续显示。这就是两者之间的主要区别。 我猜想”c”标识的意思是continue，即：即使SurfaceFlinger要求bootanimation停止动画，bootanimation也不会立刻停止动画，它会等c标识片段都显示完毕后，再停止。</p>
<p>&#160; &#160; &#160; &#160;至此，第三个开机画面的显示过程就分析完成了。</p>
<h2 id="开机动画的停止"><a href="#开机动画的停止" class="headerlink" title="开机动画的停止"></a>开机动画的停止</h2><p>&#160; &#160; &#160; &#160;接下来，我们再继续分析第三个开机画面是如何停止显示的。</p>
<p>&#160; &#160; &#160; &#160;当System进程将系统中的关键服务启动起来之后，就会将Launcher启动起来。Android应用程序的启动过程实际上就是它的根Activity组件的启动过程。对于应用程序Launcher来说，它的根Activity组件即为Launcher组件。</p>
<p>&#160; &#160; &#160; &#160;一个Activity组件在启动起来之后，就会被记录起来，等到它所运行在的主线程空闲的时候，这个主线程就会向ActivityManagerService发送一个Activity组件空闲的通知。由于应用程序Launcher是系统中第一个被启动的应用程序，即它的根Activity组件是系统中第一个被启动的Activity组件，因此，当ActivityManagerService接收到它的空闲通知的时候，就可以知道系统是刚刚启动起来的。在这种情况下，ActivityManagerService就会停止显示开机动画，以便可以在屏幕中显示应用程序Lancher的界面。</p>
<p>&#160; &#160; &#160; &#160;如果一个线程想要在空闲的时候处理一些事务，那么就必须要向这个线程的消息队列注册一个空闲消息处理器。自定义的空闲消息处理器灯必须要从MessageQueue.IdleHandler类继承下来，并且重写成员函数queueIdle。当一个线程空闲的时候，即消息队列中没有新的消息需要处理的时候，那些注册了的空闲消息处理器的成员函数queueIdle就会被调用。</p>
<p>&#160; &#160; &#160; &#160;应用程序的主线程是通过ActivityThread类来描述的，它实现在文件frameworks/base/core/Java/android/app/ActivityThread.java中。每当有一个新的Activity组件启动起来的时候，ActivityThread类都会向它所描述的应用程序主线程的消息队列注册一个类型为Idler的空闲消息处理器。这样一个应用程序的主线程就可以在空闲的时候，向ActivityManagerService发送一个Activity组件空闲通知，相当于是通知ActivityManagerService，一个新的Activity组件已经准备就绪了。</p>
<p>&#160; &#160; &#160; &#160;Idler类定义在frameworks/base/core/java/android/app/ActivityThread.java中， 它的成员函数queueIdle的实现如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord a = mNewActivities;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">            IActivityManager am = ActivityManagerNative.getDefault();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            do &#123;</span><br><span class="line">                .....</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="comment">// Ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;ActivityThread类有一个类型为ActivityClientRecord的成员变量mNewActivities，用来描述所有在当前应用程序主线程中新启动起来的Activity组件。这些新启动起来的Activity组件通过ActivityClientRecord类的成员变量nextIdle连接在一起。一旦当前应用程序主线程向ActivityManagerService发送了这些新启动的Activity组件的空闲通知之后，这些新启动起来的Activity组件就不会再被保存在ActivityThread类的成员变量mNewActivities中了，即每一个新启动的Activity组件只有一次机会向ActivityManagerService发送一个空闲通知。</p>
<p>&#160; &#160; &#160; &#160;向ActivityManagerService发送一个Activity组件空闲通知是通过调用ActivityManagerService代理对象的成员函数activityIdle来实现的，而ActivityManagerService代理对象可以通过调用ActivityManagerNative类的静态成员函数getDefault来获得。</p>
<p>&#160; &#160; &#160; &#160;ActivityManagerService代理对象的类型为ActivityManagerProxy，它的成员函数activityIdle实现在文件frameworks/base/core/java/android/app/ActivityManagerNative.java中，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config)</span> <span class="keyword">throws</span> RemoteException  </span><br><span class="line">    </span>&#123;  </span><br><span class="line">        Parcel data = Parcel.obtain();  </span><br><span class="line">        Parcel reply = Parcel.obtain();  </span><br><span class="line">        data.writeInterfaceToken(IActivityManager.descriptor);  </span><br><span class="line">        data.writeStrongBinder(token);  </span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            data.writeInt(<span class="number">1</span>);  </span><br><span class="line">            config.writeToParcel(data, <span class="number">0</span>);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            data.writeInt(<span class="number">0</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        mRemote.transact(ACTIVITY_IDLE_TRANSACTION, data, reply, IBinder.FLAG_ONEWAY);  </span><br><span class="line">        reply.readException();  </span><br><span class="line">        data.recycle();  </span><br><span class="line">        reply.recycle();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;ActivityManagerProxy类的成员函数activityIdle实际上是向ActivityManagerService发送一个类型为ACTIVITY_IDLE_TRANSACTION的Binder进程间通信请求，其中，参数token用来描述与这个进程间通信请求所关联的一个Activity组件，在我们这个场景中，这个Activity组件即为应用程序Launcher的根Activity组件Launcher。</p>
<p>&#160; &#160; &#160; &#160;类型为ACTIVITY_IDLE_TRANSACTION的Binder进程间通信请求是由ActivityManagerService类的成员函数activityIdle来处理的，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span>  </span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>&#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">            <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ActivityRecord r =</span><br><span class="line">                        mStackSupervisor.activityIdleInternalLocked(token, <span class="keyword">false</span>, config);</span><br><span class="line">                <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((mProfileProc == r.app) &amp;&amp; (mProfileFd != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mProfileFd.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        clearProfilerLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;ActivityManagerService有一个类型为ActivityStackSupervisor的成员变量mStackSupervisor，Run all ActivityStacks through this，运行所有的ActivityStacks 通过这个，它的成员函数activityIdleInternalLocked如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Checked.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span><br><span class="line">        Configuration config)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">boolean</span> booting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> enableScreen = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> activityRemoved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ActivityRecord r = ActivityRecord.forToken(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (isFrontStack(r.task.stack) || fromTimeout) &#123;</span><br><span class="line">            booting = mService.mBooting;</span><br><span class="line">            mService.mBooting = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!mService.mBooted) &#123;</span><br><span class="line">                mService.mBooted = <span class="keyword">true</span>;</span><br><span class="line">                enableScreen = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (booting || enableScreen) &#123;</span><br><span class="line">        mService.postFinishBooting(booting, enableScreen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;所以进入if判断中，将booting置为true，mService.mBooted和enableScreen也为true，进入下面的if判断，ActivityManagerService调用postFinishBooting方法完成系统启动。我们进入往下看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postFinishBooting</span><span class="params">(<span class="keyword">boolean</span> finishBooting, <span class="keyword">boolean</span> enableScreen)</span> </span>&#123;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(FINISH_BOOTING_MSG,</span><br><span class="line">            finishBooting? <span class="number">1</span> : <span class="number">0</span>, enableScreen ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> MainHandler mHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> FINISH_BOOTING_MSG: &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.arg1 != <span class="number">0</span>) &#123;</span><br><span class="line">                finishBooting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg.arg2 != <span class="number">0</span>) &#123;</span><br><span class="line">                enableScreenAfterBoot();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里最后调用enableScreenAfterBoot方法，以便可以将屏幕让出来显示应用程序Launcher的界面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enableScreenAfterBoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_ENABLE_SCREEN,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line">    mWindowManager.enableScreenAfterBoot();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        updateEventDispatchingLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;ActivityManagerService类的成员变量mWindowManager指向了系统中的Window管理服务WindowManagerService，ActivityManagerService服务通过调用它的成员函数enableScreenAfterBoot来停止显示开机动画。</p>
<p>&#160; &#160; &#160; &#160;WindowManagerService类的成员函数enableScreenAfterBoot的实现如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableScreenAfterBoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BOOT) &#123;</span><br><span class="line">            RuntimeException here = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</span><br><span class="line">            here.fillInStackTrace();</span><br><span class="line">            Slog.i(TAG, <span class="string">"enableScreenAfterBoot: mDisplayEnabled="</span> + mDisplayEnabled</span><br><span class="line">                    + <span class="string">" mForceDisplayEnabled="</span> + mForceDisplayEnabled</span><br><span class="line">                    + <span class="string">" mShowingBootMessages="</span> + mShowingBootMessages</span><br><span class="line">                    + <span class="string">" mSystemBooted="</span> + mSystemBooted, here);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mSystemBooted) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mSystemBooted = <span class="keyword">true</span>;</span><br><span class="line">        hideBootMessagesLocked();</span><br><span class="line">        <span class="comment">// If the screen still doesn't come up after 30 seconds, give</span></span><br><span class="line">        <span class="comment">// up and turn it on.</span></span><br><span class="line">        mH.sendEmptyMessageDelayed(H.BOOT_TIMEOUT, <span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPolicy.systemBooted();</span><br><span class="line"></span><br><span class="line">    performEnableScreen();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;WindowManagerService类的成员变量mSystemBooted用来记录系统是否已经启动完成的。如果已经启动完成的话，那么这个成员变量的值就会等于true，这时候WindowManagerService类的成员函数enableScreenAfterBoot什么也不做就返回了，否则的话，WindowManagerService类的成员函数enableScreenAfterBoot首先将这个成员变量的值设置为true，接着再调用另外一个成员函数performEnableScreen来执行停止显示开机动画的操作。<br>&#160; &#160; &#160; &#160;WindowManagerService类的成员函数performEnableScreen的实现如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performEnableScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (mDisplayEnabled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mSystemBooted &amp;&amp; !mShowingBootMessages) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't enable the screen until all existing windows have been drawn.</span></span><br><span class="line">        <span class="keyword">if</span> (!mForceDisplayEnabled &amp;&amp; checkWaitingForWindowsLocked()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mBootAnimationStopped) &#123;</span><br><span class="line">            <span class="comment">// Do this one time.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                IBinder surfaceFlinger = ServiceManager.getService(<span class="string">"SurfaceFlinger"</span>);</span><br><span class="line">                <span class="keyword">if</span> (surfaceFlinger != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//Slog.i(TAG, "******* TELLING SURFACE FLINGER WE ARE BOOTED!");</span></span><br><span class="line">                    Parcel data = Parcel.obtain();</span><br><span class="line">                    data.writeInterfaceToken(<span class="string">"android.ui.ISurfaceComposer"</span>);</span><br><span class="line">                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, <span class="comment">// BOOT_FINISHED</span></span><br><span class="line">                            data, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">                    data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Boot completed: SurfaceFlinger is dead!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mBootAnimationStopped = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;WindowManagerService类的另外一个成员变量mDisplayEnabled用来描述WindowManagerService是否已经初始化过系统的屏幕了，只有当它的值等于false，并且系统已经完成启动，即WindowManagerService类的成员变量mSystemBooted等于true的情况下，WindowManagerService类的成员函数performEnableScreen才通知SurfaceFlinger服务停止显示开机动画。</p>
<p>&#160; &#160; &#160; &#160;注意，WindowManagerService类的成员函数performEnableScreen是通过一个类型为IBinder.FIRST_CALL_TRANSACTION的进程间通信请求来通知SurfaceFlinger服务停止显示开机动画的。</p>
<p>&#160; &#160; &#160; &#160;在SurfaceFlinger服务，类型为IBinder.FIRST_CALL_TRANSACTION的进程间通信请求被定义为停止显示开机动画的请求，位于frameworks/native/include/gui/ISurfaceComposer.h中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BnSurfaceComposer : <span class="keyword">public</span> BnInterface&lt;ISurfaceComposer&gt;  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">enum</span> &#123;  </span><br><span class="line">        <span class="comment">// Note: BOOT_FINISHED must remain this value, it is called from  </span></span><br><span class="line">        <span class="comment">// Java by ActivityManagerService.  </span></span><br><span class="line">        BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,  </span><br><span class="line">        ......  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t    <span class="title">onTransact</span><span class="params">( <span class="keyword">uint32_t</span> code,  </span><br><span class="line">                                    <span class="keyword">const</span> Parcel&amp; data,  </span><br><span class="line">                                    Parcel* reply,  </span><br><span class="line">                                    <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;BnSurfaceComposer类它是SurfaceFlinger服务所要继承的Binder本地对象类，其中。当SurfaceFlinger服务接收到类型为IBinder::FIRST_CALL_TRANSACTION，即类型为BOOT_FINISHED的进程间通信请求时，它就会将该请求交给它的成员函数bootFinished来处理。</p>
<p>&#160; &#160; &#160; &#160;SurfaceFlinger服务的成员函数bootFinished实现在文件frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::bootFinished()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> duration = now - mBootTime;</span><br><span class="line">    ALOGI(<span class="string">"Boot is finished (%ld ms)"</span>, <span class="keyword">long</span>(ns2ms(duration)) );</span><br><span class="line">    mBootFinished = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait patiently for the window manager death</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> String16 <span class="title">name</span><span class="params">(<span class="string">"window"</span>)</span></span>;</span><br><span class="line">    sp&lt;IBinder&gt; window(defaultServiceManager()-&gt;getService(name));</span><br><span class="line">    <span class="keyword">if</span> (window != <span class="number">0</span>) &#123;</span><br><span class="line">        window-&gt;linkToDeath(<span class="keyword">static_cast</span>&lt;IBinder::DeathRecipient*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stop boot animation</span></span><br><span class="line">    <span class="comment">// formerly we would just kill the process, but we now ask it to exit so it</span></span><br><span class="line">    <span class="comment">// can choose where to stop the animation.</span></span><br><span class="line">    property_set(<span class="string">"service.bootanim.exit"</span>, <span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到，该函数将属性“service.bootanim.exit”设置为”1”。在第2节分析android()代码的时候，我们讲到：当属性“service.bootanim.exit”值被设为”1”时，android()就会退出，开机动画显示自然也就结束了。由于android()退出且返回值为false，BootAnimation::threadLoop()线程也就结束了。再回到BootAnimation.cpp的main()函数中，threadLoop()线程结束，main函数也就结束，至此，bootanimaiton进程就自行结束，开机动画的显示完成了。 </p>
<p>&#160; &#160; &#160; &#160;至此，Android系统的三个开机画面的显示过程就分析完成了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;本文的目的并不是单纯为了介绍Android系统的开机画面，而是希望能够以Android系统的开机画面来作为切入点来分析SurfaceFlinger。后续文章我们会详细分析SurfaceFlinger的每个模块和功能。没图了，等过一阵子再去拍一波~</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----Android%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/mm.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android SurfaceFlinger 学习之路(二)----SurfaceFlinger概述]]></title>
      <url>http://windrunnerlihuan.com/2017/04/27/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C-SurfaceFlinger%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;因为还有很多烦人的事情需要处理，所以暂时没有离职，也挺忙的。最近一段时间稍微轻松些，所以更新一下这个进度。<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;Android的Graphic系统是设计的很精妙，但是也很复杂。SurfaceFlinger也是Graphic系统中十分重要的组成部分，要从正面分析不是一件容易的事情。所以我们先从侧面窥视它的重要模块，积累起足够的模块基础，再统一分析，就会一目了然。</p>
<h1 id="GUI框架"><a href="#GUI框架" class="headerlink" title="GUI框架"></a>GUI框架</h1><h2 id="图形显示过程"><a href="#图形显示过程" class="headerlink" title="图形显示过程"></a>图形显示过程</h2><p>&#160; &#160; &#160; &#160;一般应用开发都要将UI数据使用Activity这个载体去展示，典型的Activity显示流程为：</p>
<ol>
<li>startActivity启动Activity；</li>
<li>为Activity创建一个window(PhoneWindow)，并在WindowManagerService中注册这个window；</li>
<li>切换到前台显示时，WindowManagerService会要求SurfaceFlinger为这个window创建一个surface用来绘图。SurfaceFlinger创建一个”layer”（surface）。（以想象一下C/S架构，SF对应Server，对应Layer；App对应Client，对应Surface）,这个layer的核心即是一个BufferQueue，这时候app就可以在这个layer上render了；</li>
<li>将所有的layer进行合成，显示到屏幕上。</li>
</ol>
<p>&#160; &#160; &#160; &#160;<strong>一般app而言，在任何屏幕上起码有三个layer：屏幕顶端的status bar，屏幕下面的navigation bar，还有就是app的UI部分。</strong>一些特殊情况下，app的layer可能多余或者少于3个，例如对全屏显示的app就没有status bar，而对launcher，还有个为了wallpaper显示的layer。status bar和navigation bar是由系统进行去render，因为不是普通app的组成部分嘛。而app的UI部分对应的layer当然是自己去render，所以就有了第4条中的所有layer进行“合成”。 </p>
<h2 id="GUI框架-1"><a href="#GUI框架-1" class="headerlink" title="GUI框架"></a>GUI框架</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%8C%29----SurfaceFlinger%E6%A6%82%E8%BF%B0/gui.jpg" alt="GUI"></p>
<p>&#160; &#160; &#160; &#160;SurfaceFlinger：每当用户程序刷新UI的时候，会中介BufferQueue申请一个buffer（dequeueBuffer），然后把UI的信息填入，丢给SurfaceFlinger，SurfaceFlinger通过计算多重计算合成visibleRegion之后，丢给openGL层处理，处理之后送到显示器display上显示。</p>
<p>根据整个Android系统的GUI设计理念，我们不难猜想到至少需要两种本地窗口：</p>
<ul>
<li>面向管理者(SurfaceFlinger)：既然SurfaceFlinger扮演了系统中所有UI界面的管理者，那么它无可厚非地需要直接或间接地持有“本地窗口”，这个窗口就是FramebufferNativeWindow</li>
<li>面向应用程序：这类窗口是Surface（这里和以前版本出入比较大，之前的版本本地窗口是SurfaceTextureClient）</li>
</ul>
<p>&#160; &#160; &#160; &#160;第二种窗口是能直接显示在终端屏幕上的——它使用了帧缓冲区，而第一种Window实际上是从内存缓冲区分配的空间。当系统中存在多个应用程序时，这能保证它们都可以获得一个“本地窗口”，并且这些窗口最终也能显示到屏幕上——SurfaceFlinger会收集所有程序的显示需求，对它们做统一的图像混合操作。</p>
<h1 id="Render过程"><a href="#Render过程" class="headerlink" title="Render过程"></a>Render过程</h1><p>&#160; &#160; &#160; &#160;android提供了两种方式：Canvas ，OpenGL ES。这两种方式在我认为都应该算是标准，提供了一套固定的API，实现和平台无关。Java中类似于给你提供了一个interface接口，这个接口你可以用任何方式去实现，只要满足功能要求即可。不同的人可以有不同的实现方式，对10个数进行排序，A可以用冒泡法，B可以用选择法，最终结果只要保证把这10个数排好序了，唯一差别就是实现难度和效率问题。</p>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>&#160; &#160; &#160; &#160;android提供了Canvas 2D API用来进行普通图形的绘制的，类似TextView这种应该都是用Canvas API来完成的。而Canvas这个”标准”的具体实现是由/external/skia库来完成的，真正干活的是skia。<strong>上层Canvas调用的API到下层其实封装了skia的实现。</strong></p>
<h2 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h2><p>&#160; &#160; &#160; &#160;OpenGL ES相关的API是为了3D图形的绘制而准备的。<br>&#160; &#160; &#160; &#160;android上有个EGL库，EGL和OpenGL ES是什么关系？代码在frameworks\native\opengl\libs\，我们查看frameworks\native\opengl\libs\Android.mk中：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">LOCAL_SHARED_LIBRARIES += libcutils libutils liblog libGLES_trace</span><br><span class="line"><span class="comment">#编译的库文件为/system/lib/libEGL.so</span></span><br><span class="line">LOCAL_MODULE:= libEGL</span><br><span class="line">LOCAL_LDFLAGS += -Wl,--exclude-libs=ALL</span><br><span class="line">LOCAL_SHARED_LIBRARIES += libdl</span><br><span class="line"><span class="comment"># we need to access the private Bionic header &lt;bionic_tls.h&gt;</span></span><br><span class="line">LOCAL_C_INCLUDES += bionic/libc/private</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;SurfaceFlinger这个非常重要的系统服务依赖EGL库，包含了EGL头文件，使用了EGL中的函数，查看frameworks/native/services/surfaceflinger/Android.mk：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">LOCAL_SHARED_LIBRARIES := \</span><br><span class="line">    libcutils \</span><br><span class="line">    liblog \</span><br><span class="line">    libdl \</span><br><span class="line">    libhardware \</span><br><span class="line">    libutils \</span><br><span class="line">    libEGL \</span><br><span class="line">    libGLESv1_CM \</span><br><span class="line">    libGLESv2 \</span><br><span class="line">    libbinder \</span><br><span class="line">    libui \</span><br><span class="line">    libgui \</span><br><span class="line">    libpowermanager</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE:= libsurfaceflinger</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在SurfaceFlinger::init()中，调用了egl开头的函数，位于frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    ALOGI(  <span class="string">"SurfaceFlinger's main thread ready to run. "</span></span><br><span class="line">            <span class="string">"Initializing graphics H/W..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize EGL for the default display</span></span><br><span class="line">    <span class="comment">//#define EGL_DEFAULT_DISPLAY       ((EGLNativeDisplayType)0)</span></span><br><span class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    eglInitialize(mEGLDisplay, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在eglGetDisplay()中调用了egl_init_drivers()，位于frameworks/native/opengl/libs/egl/eglApi.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EGLDisplay <span class="title">eglGetDisplay</span><span class="params">(EGLNativeDisplayType display)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    clearError();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> index = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(display);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= NUM_DISPLAYS) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//egl_init_drivers函数载入OpenGL ES相关库</span></span><br><span class="line">    <span class="keyword">if</span> (egl_init_drivers() == EGL_FALSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLDisplay dpy = <span class="keyword">egl_display_t</span>::getFromNativeDisplay(display);</span><br><span class="line">    <span class="keyword">return</span> dpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;关于egl_init_drivers()函数，载入OpenGL ES相关库，限于本篇只是简单介绍，所以不详细分析。相关文件如下：</p>
<ol>
<li>frameworks/native/opengl/libs/egl/Egl.cpp</li>
<li>frameworks/native/opengl/libs/egl/Loader.cpp</li>
</ol>
<p>&#160; &#160; &#160; &#160;代码也不多，主要做的事情：</p>
<p>&#160; &#160; &#160; &#160;1. 首先在frameworks\native\opengl\libs\EGL\egl_entries.in中保存了EGL的相关API，函数都是以egl开头；在frameworks\native\opengl\libs\entries.in中保存了OpenGL ES相关API，函数都是以gl开头。函数egl_init_drivers()需要做的就是找到EGL和OpenGL ES本地的实现，然后对这些函数进行赋值。可以查看frameworks/native/opengl/libs/egl/Egl.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> gl_names[] = &#123;</span><br><span class="line">    #include <span class="string">"../entries.in"</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> egl_names[] = &#123;</span><br><span class="line">    #include <span class="string">"egl_entries.in"</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2. <strong>在/vendor/lib/egl或/system/lib/egl下(不是/system/lib/下)，寻找libGLES.so，如果未找到，则寻找libGLES_*.so</strong>，上面两种库只要找到一个，则打开库，这个库里包含了EGL和OpenGL ES具体实现的库，然后“取出”库中具体的函数实现进行赋值。<br>&#160; &#160; &#160; &#160;但是较新版本的android已经不使用软件实现，即libagl，所以即使找到libGLES_android.so也不会去用。位于frameworks/native/opengl/libs/egl/Loader.cpp中load_driver函数实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *Loader::load_driver(<span class="keyword">const</span> <span class="keyword">char</span>* kind,</span><br><span class="line">        <span class="keyword">egl_connection_t</span>* cnx, <span class="keyword">uint32_t</span> mask)</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">"libGLES_android.so"</span>)) &#123;</span><br><span class="line">                        <span class="comment">// always skip the software renderer</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> ......                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果libGLES.so和libGLES_<em>.so都未找到，需要分别去加载/vendor/lib/egl或/system/lib/egl下libEGL.so, libGLESv1<em>CM.so, libGLESv2.so这三个库或者libEGL</em></em>.so, libGLESv1<em>CM</em><em>.so, libGLESv2_</em>.so，然后分别对EGL、OpenGL ES V1、OpenGL ES V2的具体实现去赋值(<strong>那意思是libGLES_*.so中其实囊括了三个库所有的具体实现</strong>)。至此，就将OpenGL ES“标准”和“实现”挂钩了。</p>
<p>&#160; &#160; &#160; &#160;所以android中OpenGL ES的实现方式有2种：</p>
<ul>
<li>一种是软件实现，用cpu去绘图，这就是所谓的agl(libGLES_android.so)，代码路径在frameworks/native/opengl/libagl，即the software OpenGL ES library；</li>
<li>另一种是硬件厂商根据自己GPU提供的实现，一般都不开放源代码，就是上面介绍的需要去/vendor/lib/egl或/system/lib/egl找的几个库，但是只要把API 函数赋值上正确的实现函数即可。 </li>
</ul>
<p>&#160; &#160; &#160; &#160;此外由于OpenGL ES的实现是系统无关的，所以EGL库的另一个作用就是将OpenGL ES和本地窗口系统结合起来，举个例子好理解，如果你要画个纹理多边形，调用OpenGL ES接口，如果要把图形render到屏幕，需要调用EGL接口。例如在使用OpenGL ES前首先需要调用EGL的相关函数去搭建好OpenGL ES的本地环境等，EGL是android使用OpenGL ES API绘图的助手！</p>
<h2 id="hardware-accelerated-Canvas"><a href="#hardware-accelerated-Canvas" class="headerlink" title="hardware-accelerated Canvas"></a>hardware-accelerated Canvas</h2><p>&#160; &#160; &#160; &#160;从android 4.0开始，支持了硬件加速的Canvas，应该就是修改了Canvas的具体实现，不用skia了，而改调用EGL和OpenGL ES API了。</p>
<h2 id="android的封装"><a href="#android的封装" class="headerlink" title="android的封装"></a>android的封装</h2><p>&#160; &#160; &#160; &#160;那么我们平时写app时为何不用调用上面的Canvas和OpenGL ES，也能出现漂亮的UI呢？因为我们使用的都是android上层封装好的类，例如TextView就是用了Canvas，而GLSurfaceView就是使用了OpenGL ES，android已经帮我们做了大部分的工作。当然完全可以不用调用上层的Java类，而用c++/c去直接调用Canvas和OpenGL ES。 </p>
<h1 id="如何去合成"><a href="#如何去合成" class="headerlink" title="如何去合成"></a>如何去合成</h1><p>首先介绍个概念，<strong>hardware overlay</strong>，来自<a href="https://en.wikipedia.org/wiki/Hardware_overlay" target="_blank" rel="external">维基百科</a>。</p>
<blockquote>
<p>From Wikipedia, the free encyclopedia<br>In computing, hardware overlay, a type of video overlay, provides a method of rendering an image to a display screen with a dedicated memory buffer inside computer video hardware. The technique aims to improve the display of a fast-moving video image — such as a computer game, a DVD, or the signal from a TV card. Most video cards manufactured since about 1998 and most media players support hardware overlay.[1]</p>
<p>The overlay is a dedicated buffer into which one app can render (typically video), without incurring the significant performance cost of checking for clipping and overlapping rendering by other apps. The framebuffer has hardware support for importing and rendering the buffer contents without going through the GPU.[citation needed]</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;hardware overlay 是提供一种机制，直接render到display screen的硬件内存中，提高显示效率吧。<br>&#160; &#160; &#160; &#160;而android对layer的合成主要包括2部分：在GPU中合成和在display的硬件中进行buffer的合成。<br>&#160; &#160; &#160; &#160;<strong>在GPU中进行合成，既是利用OpenGL ES进行合成，需要注意，画图的时候我们用了OpenGL ES，这里合成时也用了，功能真是强大，开始一直奇怪为何SurfaceFlinger也要去调用EGL的函数，原来是需要用OpenGL ES去合成layer</strong>；在display的硬件中进行合成，也就是hardware overlay机制。</p>
<h2 id="Hardware-Composer"><a href="#Hardware-Composer" class="headerlink" title="Hardware Composer"></a>Hardware Composer</h2><p>&#160; &#160; &#160; &#160;那么android是如何使用这两种合成机制的呢？这里就是Hardware Composer的功劳。处理流程为：</p>
<ul>
<li>1.SurfaceFlinger给HWC提供layer list，询问如何处理这些layer；</li>
<li>2.HWC将每个layer标记为overlay或者GLES composition，然后回馈给SurfaceFlinger；</li>
<li>3.SurfaceFlinger需要去处理那些GLES的合成，而不用去管overlay的合成，最后将overlay的layer和GLES合成后的buffer发送给HWC处理。</li>
</ul>
<p>&#160; &#160; &#160; &#160;借用google一张图说明，可以将上面讲的很多概念展现，很清晰。地址位于 <a href="https://source.android.com/devices/graphics/" target="_blank" rel="external">https://source.android.com/devices/graphics/</a><br><img src="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%8C%29----SurfaceFlinger%E6%A6%82%E8%BF%B0/hw.png" alt="合成"><br>&#160; &#160; &#160; &#160;<strong>在我认为使用overlay后，可以将SurfaceFlinger的工作减轻，即少一些GLES的合成，HWC承担了部分OpenGL ES 和GPU的工作， 从而减少了功耗。</strong></p>
<blockquote>
<p>注：如果屏幕上的画面基本不变化，这时候用GLES 合成的效率要高于overlay(overlay主要是为了render快速变化的图形等)；android 4.4往上支持4个oveylay，如果要合成超过4个layer，系统就会对剩余的使用GLES合成，所以app的layer个数对手机的功耗影响挺大。</p>
</blockquote>
<h1 id="SurfaceFlinger和BufferQueue"><a href="#SurfaceFlinger和BufferQueue" class="headerlink" title="SurfaceFlinger和BufferQueue"></a>SurfaceFlinger和BufferQueue</h1><h2 id="生产模型"><a href="#生产模型" class="headerlink" title="生产模型"></a>生产模型</h2><p>&#160; &#160; &#160; &#160;一个UI完全显示到diplay的过程，SurfaceFlinger扮演着重要的角色但是它的职责是“Flinger”，即把系统中所有应用程序的最终的“绘图结果”进行“混合”，然后统一显示到物理屏幕上，而其他方面比如各个程序的绘画过程，就由其他东西来担任了。这个光荣的任务自然而然地落在了BufferQueue的肩膀上，它是每个应用程序“一对一”的辅导老师，指导着UI程序的“画板申请”、“作画流程”等一系列细节。下面的图描述了这三者的关系：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%8C%29----SurfaceFlinger%E6%A6%82%E8%BF%B0/PC1.jpg" alt="P/C"></p>
<p>&#160; &#160; &#160; &#160;虽说是三者的关系，但是他们所属的层却只有两个，app属于Java层，BufferQueue/SurfaceFlinger属于native层。也就是说BufferQueue也是隶属SurfaceFlinger，所有工作围绕SurfaceFlinger展开。<br>&#160; &#160; &#160; &#160;这里IGraphicBufferProducer就是app和BufferQueue重要桥梁，GraphicBufferProducer承担着单个应用进程中的UI显示需求，与BufferQueue打交道的就是它。它的工作流程如下：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%8C%29----SurfaceFlinger%E6%A6%82%E8%BF%B0/PC2.jpg" alt="P/C"></p>
<p>&#160; &#160; &#160; &#160;BpGraphicBufferProducer是GraphicBufferProducer在客户端这边的代理对象，负责和SF交互，GraphicBufferProducer通过gbp（IGraphicBufferProducer类对象）向BufferQueue获取buffer，然后进行填充UI信息，当填充完毕会通知SF，SF知道后就对该Buffer进行下一步操作。<strong>典型的生产-消费者模式</strong>。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>&#160; &#160; &#160; &#160;接下来具体说明客户端（producer）和服务端SurfaceFlinger（consumer）工作的模式：<br>&#160; &#160; &#160; &#160;首先这里的buffer是共享缓冲区，故肯定会涉及到互斥锁，所以buffer的状态也会有多种，一般的buffer大致会经过<strong>FREE-&gt;DEQUEUED-&gt;QUEUED-&gt;ACQUIRED-&gt;FREE</strong>这个流程，如下图：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%8C%29----SurfaceFlinger%E6%A6%82%E8%BF%B0/PC3.jpg" alt="P/C"></p>
<ul>
<li><strong>BufferQueue</strong>：可以认为BufferQueue是一个服务中心，其它两个owner必须要通过它来管理buffer。比如说当producer想要获取一个buffer时，它不能越过BufferQueue直接与consumer进行联系，反之亦然。</li>
<li><strong>Producer</strong>：生产者就是“填充”buffer空间的人，通常情况下当然就是应用程序。因为应用程序不断地刷新UI，从而将产生的显示数据源源不断地写到buffer中。当Producer需要使用一块buffer时，它首先会向中介BufferQueue发起dequeue申请，然后才能对指定的缓冲区进行操作。这种情况下buffer就属于producer一个人的了，它可以对buffer进行任何必要的操作，而其它owner此刻绝不能擅自插手。<br>当生产者认为一块buffer已经写入完成后，它进一步调用BufferQueue的queue。从字面上看这个函数是“入列”的意思，形象地表达了buffer此时的操作——把buffer归还到BufferQueue的队列中。一旦queue成功后，owner也就随之改变为BufferQueue了。</li>
<li><p><strong>Consumer</strong>：消费者是与生产者相对应的，它的操作同样受到BufferQueue的管控。当一块buffer已经就绪后，Consumer就可以开始工作了。这里需要特别留意的是，从各个对象所扮演的角色来看，BufferQueue是中介机构，属于服务提供方;Producer属于buffer内容的产出方，它对缓冲区的操作是一个“主动”的过程;反之，Consumer对buffer的处理则是“被动”的、“等待式”的——它必须要等到一块buffer填充完成后才能做工作。在这样的模型下，我们怎么保证Consumer可以及时的处理buffer呢？换句话说，当一块buffer数据ready后，应该怎么告知Consumer来操作呢？<br>仔细观察的话，可以看到BufferQueue里还同时提供了一个特别的类，名称为ProxyConsumerListener，其中的函数接口包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">classProxyConsumerListener : <span class="keyword">public</span> BnConsumerListener &#123;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:       </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//省略构造函数  </span></span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onFrameAvailable</span><span class="params">()</span></span>;<span class="comment">/*当一块buffer可以被消费时，这个函数会被调用，特别注意此时没有共享锁的保护*/</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="title">voidonBuffersReleased</span><span class="params">()</span></span>;<span class="comment">/*BufferQueue通知consumer它已经释放其slot中的一个或多个 GraphicBuffer引用*/</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:  </span><br><span class="line">  </span><br><span class="line">   wp&lt;ConsumerListener&gt;mConsumerListener;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子就很清楚了，当有一帧数据准备就绪后，BufferQueue就会调用onFrameAvailable()来通知Consumer进行消费。</p>
</li>
</ul>
<h2 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h2><p>&#160; &#160; &#160; &#160;BufferQueue和SurfaceFlinger之间的通信模式如下：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%8C%29----SurfaceFlinger%E6%A6%82%E8%BF%B0/consumer.jpg" alt="Consumer"></p>
<p>&#160; &#160; &#160; &#160;也是有一对BpGraphicBufferConsumer/BnGraphicBufferConsumer支持他们之间的信息传输。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;本篇只是简单科普一下SurfaceFlinger的轮廓，我们从下一篇开始详细分析每个流程。<br>&#160; &#160; &#160; &#160;突然觉得上一篇开头太中二了=。= 唉，事情太多了，有点烦，感觉没了以前那份心若冰清的沉稳和奋不顾身的勇气了，唉(第二次唉)，慢慢来，需要时间去消化。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%8C%29----SurfaceFlinger%E6%A6%82%E8%BF%B0/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android性能优化之内存优化实战]]></title>
      <url>http://windrunnerlihuan.com/2017/04/07/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;事情依旧很多，生活的、工作的，成长总是需要代价的。一直憧憬童年和大学，那是两种异曲同工的生活态度。假装自己是个孩子，一直不想长大，被自己小小的愿望襁褓着，不去理会外面世界的沧海桑田。白驹过隙，岁月在脸上留下了痕迹，不再隐瞒早已不年轻的事实。伴随着时光点滴流逝，心也在渐渐老去。也许成长就是一种淡然吧，从锋芒毕露到心如止水，从棱角分明到不露声色。少了昔日偶尔破釜沉舟的勇气，更多的是经常瞻前顾后的思虑。时光荏苒，没有留下刻骨铭心的记忆，更多的是平淡、安静。我渐渐喜欢这种感觉，岁月静好，没有跌宕起伏的生活剧情，没有扣人心弦的情景环节，一切安好，便是生活最美好的恩赐。<br>&#160; &#160; &#160; &#160;记忆渐渐模糊，没有留下印记。没有选择性忘记，但却真实在一点一点消逝。那些旧照片也没能留下，早已不见了踪影，那些故人，都逐渐失去了联系，那些雨天泥泞的小路，还有路边在儿时植树节时新栽的小树，也都变得那么陌生。只有那些花儿，却开的愈加鲜艳茂密。就像一颗顽强的心，一颗不服输的心，在抗拒随波逐流的人生。<br>&#160; &#160; &#160; &#160;多年之前，我们都还是个孩子。经过岁月的洗礼，也许会变得更加沉稳，也会变得更加冷静，亦或者是……冷漠。回忆往昔，这一路走来，还是渐渐变成了孩时最讨厌的自己，一个冷漠的自己，一个绝情的自己。安静也许是一个借口，一种掩饰，透过镜子，终于看清了真实的自己，那个自私的自己。有人说，社会会逼着一个人成长，是啊，虽然不愿承认，但是至少褪去了青年时怕事嫌烦表选出来的虚伪，获得更多的是学会了处事不惊的态度，和勇于承担责任的勇气。如果选择对生活妥协，是不会答应的，即使没了追梦赤子心，至少还有追逐本心的动力。不忘初心，坚持自己的初衷。青春即使如同《老男孩》的歌词唱的那样：”青春如同奔流的江河,一去不回来不及道别,只剩下麻木的我,没有了当年的热血……”即便如此，依然要做不一样的我，一个不退缩、不妥协的我，一个默默前行的我，一个坚持本心的我————“我就是我，是颜色不一样的烟火，天空海阔，要做最坚强的泡沫，我喜欢我，让蔷薇开出一种结果，孤独的沙漠里一样盛放的赤裸裸”</p>
<hr>
<p>&#160; &#160; &#160; &#160;这次带来一篇性能优化的文章，内容来自<code>APP架构师</code>,我稍微修改了一些部分，加了一些内容。</p>
<a id="more"></a>
<h1 id="Memory-Leak"><a href="#Memory-Leak" class="headerlink" title="Memory Leak"></a>Memory Leak</h1><p>&#160; &#160; &#160; &#160;内存泄漏：对于Java来说，就是new出来的Object 放在Heap上无法被GC回收（内存中存在无法被回收的对象）；内存泄漏发生时的主要表现为内存抖动，可用内存慢慢变少。</p>
<h2 id="Memory-Monitor"><a href="#Memory-Monitor" class="headerlink" title="Memory Monitor"></a>Memory Monitor</h2><p>&#160; &#160; &#160; &#160;AndroidStudio自带的Memory Monitor可以方便的观察堆内存的分配情况，并且可以粗略的观察有没有Memory Leak。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/arrow.jpg" alt="内存显示"></p>
<p>&#160; &#160; &#160; &#160;频繁的内存抖动，可能存在内存泄漏</p>
<ul>
<li>A：initiate GC 手动触发GC操作；</li>
<li>B：Dump Java Heap 获取当前的堆栈信息，生成一个.hprof文件，AndroidStudip会自动使用HeapViewer打开；一般用于操作之后检测内存泄漏的情况；</li>
<li>C：Start Allocation Tracking 内存分配追踪工具，用于追踪一段时间的内存分配使用情况，能够知道执行一些列操作后，有哪些对象被分配空间。一般用于追踪某项操作之后的内存分配，调整相关的方法调用来优化app性能与内存使用；</li>
<li>D：剩余可用内存；</li>
<li>E：已经使用的内存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;点击Memory Monitor的Dump Java Heap，会生成一个.hprof文件，位于<strong>工程名/captures/</strong>文件夹下。AndroidStudio会自动使用HeapViewer打开。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/hprof.jpg" alt="Hprof Viewer打开.hprof文件"></p>
<p>&#160; &#160; &#160; &#160;左面板说明：</p>
<ul>
<li>Total Count 该类的实例个数</li>
<li>Heap Count 选定的Heap中实例的个数</li>
<li>Sizeof 每个实例占用的内存大小</li>
<li>Shallow Size 所有该类的实例占用的内存大小</li>
<li>Retained Size 该类的所有实例可支配的内存大小</li>
</ul>
<p>&#160; &#160; &#160; &#160;右面板说明：</p>
<ul>
<li>Instance 该类的所有实例对象（左侧Total Count为15，此处就有15个对象）</li>
<li>Depth 深度, GC Root点到该实例的最短链路数</li>
<li>Dominating Size 该实例可支配的内存大小</li>
</ul>
<p>&#160; &#160; &#160; &#160;<strong>此处可以看出MainActivity存在了15个示例对象，怀疑此处有问题。</strong></p>
<p>&#160; &#160; &#160; &#160;<strong>附：Android Device Monitor抓取：（可忽略，直接跳过）</strong></p>
<p>&#160; &#160; &#160; &#160;1. 首先打开AS中的Android Device Monitor工具 ，Tools—&gt;Android—&gt;Android Device Monitor,打开如下：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/adm.png" alt="Android Device Monitor"></p>
<p>&#160; &#160; &#160; &#160;2. 先选中你要检测的应用的包名，然后点击下图画圈的地方，会在程序包名后标记一个图标 </p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/click.png" alt="点击一下"></p>
<p>&#160; &#160; &#160; &#160;3. 接下来要做的就是操作我们的app 。 之后点击下图的图标 就可导出hprof文件进行分析了</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/export.png" alt="导出"></p>
<h2 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h2><p>&#160; &#160; &#160; &#160;上述只是可以粗略的看出是不是有问题，而要知道问题出在哪里就需要借助MAT了。</p>
<p>&#160; &#160; &#160; &#160;打开MAT工具 ，如果没有 可以在下面网址下载 ：<br>&#160; &#160; &#160; &#160;<a href="https://www.eclipse.org/mat/" target="_blank" rel="external">MAT工具下载地址</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/matdownload.png" alt="打开MAT"></p>
<p>&#160; &#160; &#160; &#160;打开我们先前导出的hprof文件 ，不出意外会报下面的错误 :</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/error.png" alt="错误"></p>
<p>&#160; &#160; &#160; &#160;这是因为MAT是用来分析<code>Java</code>程序的hprof文件的 与Android导出的hprof有一定的格式区别，因此我们需要把导出的hprof文件转换一下，sdk中提供给我们转换的工具 hprof-conv.exe 在下图的位置 </p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/conv.png" alt="转换"></p>
<p>&#160; &#160; &#160; &#160;我们看到adb.exe和hprof-conv.exe在同一个目录，这就比较幸运了，因为我们一般都会把adb路径加入环境变量，所以这个hprof-conv也会位于环境变量当中，因此我们不用cd进入这个目录去敲命令了，直接随便哪个控制台路径都可以。比如我们利用AS自带的Terminal。</p>
<p>&#160; &#160; &#160; &#160;将生成的.hprof文件进行转换</p>
<blockquote>
<p>格式转换命令：hprof-conv 原文件路径 转换后文件路径</p>
</blockquote>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/terminal.png" alt="转换命令"></p>
<p>&#160; &#160; &#160; &#160;然后用MAT打开转换后的.hprof文件<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/matshow.jpg" alt="MAT打开.hprof"></p>
<p>&#160; &#160; &#160; &#160;注意下面的Actions：</p>
<ul>
<li><strong>Histogram可以列出内存中每个对象的名字、数量以及大小。</strong></li>
<li><strong>Dominator Tree会将所有内存中的对象按大小进行排序，并且我们可以分析对象之间的引用结构。</strong></li>
</ul>
<p>&#160; &#160; &#160; &#160;一般使用最多的也是这两个功能。</p>
<p>&#160; &#160; &#160; &#160;Retained Heap表示这个对象以及它所持有的其它引用（包括直接和间接）所占的总内存</p>
<ul>
<li><strong>使用Histogram：</strong></li>
<li>点击Histogram并在顶部的Regex中输入MainActivity会进行正则匹配，会将包含“MainActivity”的所有对象全部列出了出来，其中第一行就是MainActivity的实例。</li>
</ul>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/histogram.jpg" alt="Histogram"></p>
<ul>
<li>对着想查看的对象点击右键 -&gt; List objects -&gt; with incoming references 查看具体MainActivity实例。</li>
</ul>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/reference.jpg" alt="reference"></p>
<ul>
<li>对想要查看的对象实例点击右键-&gt; Path To Gc Roots -&gt; exclude weak reference（排除掉软引用）。</li>
</ul>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/noweak.jpg" alt="noweak"></p>
<p>&#160; &#160; &#160; &#160;注意：<br>&#160; &#160; &#160; &#160;<strong>this$0前面的图标的左下角有个圆圈，这代表这个引用可以被Gc Roots引用到，由于MainActivity$LeakClass能被GC Roots访问到导致其不能被回收，从而它所持有的其它引用也无法被回收了，包括MainActivity，也包括MainActivity中所包含的其它资源。</strong></p>
<p>&#160; &#160; &#160; &#160;此时我们就找到了内存泄漏的原因。</p>
<ul>
<li><strong>使用Dominator Tree</strong></li>
</ul>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/dominator.jpg" alt="dominator"></p>
<p>&#160; &#160; &#160; &#160;使用上面Histogram的操作方式也可以找到泄漏的具体原因，此处不再累述。<br>&#160; &#160; &#160; &#160;注意：<strong>每个对象前的图标的圆圈，并不代表一定是导致内存泄漏的原因，有些对象就是需要在内存中存活的，需要区别对待。</strong></p>
<h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>&#160; &#160; &#160; &#160;<a href="https://github.com/square/leakcanary" target="_blank" rel="external">LeakCanary</a>是square出品的一个检测内存泄漏的库，集成到App之后便无需关心，在发生内存泄漏之后会Toast、通知栏弹出等方式提示，可以指出泄漏的引用路径，而且可以抓取当前的堆栈信息供详细分析。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/leakcanary.jpg" alt="LeakCanary"></p>
<h1 id="Out-Of-Memory"><a href="#Out-Of-Memory" class="headerlink" title="Out Of Memory"></a>Out Of Memory</h1><h2 id="Android-OOM"><a href="#Android-OOM" class="headerlink" title="Android OOM"></a>Android OOM</h2><p>&#160; &#160; &#160; &#160;Android系统的每个进程都有一个最大内存限制，如果申请的内存资源超过这个限制，系统就会抛出OOM错误。</p>
<ul>
<li>Android 2.x系统，当dalvik allocated + external allocated + 新分配的大小 &gt;= dalvik heap 最大值时候就会发生OOM。其中bitmap是放于external中 。</li>
<li>Android 4.x系统，废除了external的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 &gt;= dalvik heap 最大值的时候就会发生OOM（art运行环境的统计规则还是和dalvik保持一致）<br>&#160; &#160; &#160; &#160;内存溢出是程序运行到某一阶段的最终结果，直接原因是剩余的内存不能满足内存的申请，但是再分析间接原因内存为什么没有了：</li>
<li>内存泄漏的存在可能导致可用内存越来越少；</li>
<li>内存申请的峰值超过了系统时间点剩余的内存；(例如：某手机单个进程可用最大内存为192M，目前分配内存80M，此时申请5M内存，但是当前时间点整个系统可用内存只有3M，此时没有超出单个进程可用最大内存，但是OOM也会发生)</li>
</ul>
<h2 id="Avoid-Android-OOM"><a href="#Avoid-Android-OOM" class="headerlink" title="Avoid Android OOM"></a>Avoid Android OOM</h2><p>&#160; &#160; &#160; &#160;除了避免内存泄漏之外，根据《Manage Your App’s Memory》，我们可以对内存的状态进行监听，在Activity中覆写此方法，根据不同的case进行不同的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">super</span>.onTrimMemory(level);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>TRIM_MEMORY_RUNNING_MODERATE：</strong>你的应用正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。<br><strong>TRIM_MEMORY_RUNNING_LOW：</strong>你的应用正在运行且没有被列为可杀死的。但是设备正运行于更低内存的状态下，你应该释放不用的资源用来提升系统性能。<br><strong>TRIM_MEMORY_RUNNING_CRITICAL：</strong>你的应用仍在运行，但是系统已经把LRU Cache中的大多数进程都已经杀死，因此你应该立即释放所有非必须的资源。如果系统不能回收到足够的RAM数量，系统将会清除所有的LRU缓存中的进程，并且开始杀死那些之前被认为不应该杀死的进程，例如那个包含了一个运行态Service的进程。<br>当应用进程退到后台正在被Cached的时候，可能会接收到从onTrimMemory()中返回的下面的值之一：<br><strong>TRIM_MEMORY_BACKGROUND：</strong> 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的应用进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的应用的时候才能够迅速恢复。<br><strong>TRIM_MEMORY_MODERATE：</strong>系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。<br><strong>TRIM_MEMORY_COMPLETE：</strong>系统正运行于低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的应用恢复状态的资源。</p>
</blockquote>
<h1 id="Memory-Churn"><a href="#Memory-Churn" class="headerlink" title="Memory Churn"></a>Memory Churn</h1><p>&#160; &#160; &#160; &#160;<strong>Memory Churn内存抖动：大量的对象被创建又在短时间内马上被释放。</strong><br>&#160; &#160; &#160; &#160;瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。<strong>系统花费在GC上的时间越多，进行界面绘制或流音频处理的时间就越短。</strong>即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/memchurn.jpg" alt="Drop Frame Occur"></p>
<p>&#160; &#160; &#160; &#160;常见的可能引发内存抖动的情形：</p>
<ul>
<li>循环中创建临时对象；</li>
<li>onDraw中创建Paint或Bitmap对象等；</li>
</ul>
<p>&#160; &#160; &#160; &#160;例如之前使用过的有些下拉刷新控件的实现方式，在onDraw中创建Bitmap等多个临时大对象会导致内存抖动。</p>
<h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><p>&#160; &#160; &#160; &#160;Bitmap的处理也是Android中的一个难点，当然使用第三方框架的话就屏蔽掉了这个难点。</p>
<ul>
<li><strong>Bitmap的内存模型；</strong></li>
<li><strong>Bitmap的加载、压缩、缓存等策略；</strong></li>
<li><strong>版本的兼容等；</strong></li>
</ul>
<p>&#160; &#160; &#160; &#160;关于Bitmap之后会写专门的一篇文章来介绍，此处可以参考《Handling Bitmaps》。也可以查看我之前的一片文章：<a href="http://windrunnerlihuan.com/2016/07/12/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/">浅析Bitmap占据内存大小</a>。</p>
<h1 id="Program-Advice"><a href="#Program-Advice" class="headerlink" title="Program Advice"></a>Program Advice</h1><h2 id="节制地使用Service"><a href="#节制地使用Service" class="headerlink" title="节制地使用Service"></a>节制地使用Service</h2><p>&#160; &#160; &#160; &#160;<strong>内存管理最大的错误之一就是让Service一直运行。在后台使用service时，除非它需要被触发并执行一个任务，否则其他时候Service都应该是停止状态。另外需要注意Service工作完毕之后需要被停止，以免造成内存泄漏。</strong></p>
<p>&#160; &#160; &#160; &#160;系统会倾向于保留有Service所在的进程，这使得进程的运行代价很高，<strong>因为系统没有办法把Service所占用的RAM空间腾出来让给其他组件，另外Service还不能被Paged out</strong>。这减少了系统能够存放到LRU缓存当中的进程数量，它会影响应用之间的切换效率，甚至会导致系统内存使用不稳定，从而无法继续保持住所有目前正在运行的service。</p>
<p>&#160; &#160; &#160; &#160;<strong>建议使用JobScheduler，而尽量避免使用持久性的Service。还有建议使用IntentService，它会在处理完交代给它的任务之后尽快结束自己。</strong></p>
<h2 id="使用优化过的集合"><a href="#使用优化过的集合" class="headerlink" title="使用优化过的集合"></a>使用优化过的集合</h2><p>&#160; &#160; &#160; &#160;<strong>Android API当中提供了一些优化过后的数据集合工具类，如SparseArray，SparseBooleanArray，以及LongSparseArray等，使用这些API可以让我们的程序更加高效。</strong>传统Java API中提供的HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p>
<h2 id="谨慎对待面向抽象"><a href="#谨慎对待面向抽象" class="headerlink" title="谨慎对待面向抽象"></a>谨慎对待面向抽象</h2><p>&#160; &#160; &#160; &#160;开发者经常把抽象作为好的编程实践，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的开销：<strong>面向抽象需要额外的代码（不会被执行到），同样会被咨映射到内存中，耗费了更多的时间以及内存空间。因此如果面向抽象对你的代码没有显著的收益，那你应该避免使用</strong>。<br>&#160; &#160; &#160; &#160;例如：<strong>使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举</strong>。</p>
<h2 id="使用nano-protobufs序列化数据"><a href="#使用nano-protobufs序列化数据" class="headerlink" title="使用nano protobufs序列化数据"></a>使用nano protobufs序列化数据</h2><p>&#160; &#160; &#160; &#160;Protocol buffers是Google为序列化数据设计的一种语言无关、平台无关、具有良好扩展性的数据描述语言，与XML类似，但是更加轻量、快速、简单。如果使用protobufs来实现数据的序列化及反序列化，<strong>建议在客户端使用nano protobufs，因为通常的protobufs会生成冗余代码，会导致可用内存减少，Apk体积变大，运行速度减慢。</strong></p>
<h2 id="避免内存抖动"><a href="#避免内存抖动" class="headerlink" title="避免内存抖动"></a>避免内存抖动</h2><p>&#160; &#160; &#160; &#160;<strong>垃圾回收通常不会影响应用的表现，但是短时间内多次的垃圾回收会消耗掉界面绘制的时间。系统花费在GC上的时间越多，进行界面绘制或流音频处理的时间就越短</strong>。通常内存抖动会导致多次的GC，实践中内存抖动代表了一段时间内分配了临时对象。<br>&#160; &#160; &#160; &#160;例如：在For循环中分配了多个临时对象，或在onDraw()方法中创建了Paint、Bitmap对象，应用产生了大量的对象；这会很快耗尽young generation的可用内存，导致GC发生。<br>&#160; &#160; &#160; &#160;使用Analyze your RAM usage中的工具找出代码里内存抖动的地方。考虑把操作移出内部循环，或者将其移动到基于工厂的分配结构中。</p>
<h2 id="移除消耗内存的库、缩减Apk的大小"><a href="#移除消耗内存的库、缩减Apk的大小" class="headerlink" title="移除消耗内存的库、缩减Apk的大小"></a>移除消耗内存的库、缩减Apk的大小</h2><p>&#160; &#160; &#160; &#160;查看Apk的大小，包括三方库和内嵌的资源，这些都会影响应用消耗的内存。通过减少冗余、非必须或大的组件、库、图片、资源、动画等，都可以改善应用的内存消耗。</p>
<h2 id="使用Dagger-2进行依赖注入"><a href="#使用Dagger-2进行依赖注入" class="headerlink" title="使用Dagger 2进行依赖注入"></a>使用Dagger 2进行依赖注入</h2><p>&#160; &#160; &#160; &#160;如果您打算在应用程序中使用依赖注入框架，请考虑使用Dagger 2。 Dagger不使用反射来扫描应用程序的代码。 <strong>Dagger的编译时注解技术实现意味着它不需要不必要的运行时成本。而使用反射的其它依赖注入框架通常通过扫描代码来初始化过程。 此过程可能需要显着更多的CPU周期和RAM，并可能导致应用程序启动时明显的卡顿。</strong><br>&#160; &#160; &#160; &#160;<strong>备注：之前的文档是不建议使用依赖注入框架，因为实现原理是使用反射，而进化为编译时注解之后，就不再有反射带来的影响了。</strong></p>
<h2 id="谨慎使用第三方库"><a href="#谨慎使用第三方库" class="headerlink" title="谨慎使用第三方库"></a>谨慎使用第三方库</h2><p>&#160; &#160; &#160; &#160;很多开源的library代码都不是为移动端而编写的，如果运用在移动设备上，并不一定适合。<strong>即使是针对Android而设计的library，也需要特别谨慎，特别是在你不知道引入的library具体做了什么事情的时候</strong>。例如，其中一个library使用的是nano protobufs, 而另外一个使用的是micro protobufs。这样一来，在你的应用里面就有2种protobuf的实现方式。这样类似的冲突还可能发生在输出日志，加载图片，缓存等等模块里面。<strong>另外不要为了1个或者2个功能而导入整个library，如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案</strong>。</p>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="谨慎使用LargeHeap属性"><a href="#谨慎使用LargeHeap属性" class="headerlink" title="谨慎使用LargeHeap属性"></a>谨慎使用LargeHeap属性</h2><blockquote>
<p>&#160; &#160; &#160; &#160;可以通过在manifest的application标签下添加largeHeap=true的属性来为应用声明一个更大的heap空间(可以通过getLargeMemoryClass()来获取到这个更大的heap size阈值)。然而，<strong>声明得到更大Heap阈值的本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用更多的内存而去请求一个大的Heap Size</strong>。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用large heap，<strong>使用额外的内存空间会影响系统整体的用户体验，并且会使得每次gc的运行时间更长。在任务切换时，系统的性能会大打折扣</strong>。另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。</p>
</blockquote>
<h2 id="谨慎使用多进程"><a href="#谨慎使用多进程" class="headerlink" title="谨慎使用多进程"></a>谨慎使用多进程</h2><blockquote>
<p>&#160; &#160; &#160; &#160;多进程确实是一种可以帮助我们节省和管理内存的高级技巧。<strong>如果你要使用它的话一定要谨慎使用，因为绝大多数的应用程序都不应该在多个进程当中运行的，一旦使用不当，它甚至会增加额外的内存而不是帮我们节省内存；同时需要知晓多进程带来的缺点</strong>。这个技巧比较适用于那些需要在后台去完成一项独立的任务，和前台的功能是可以完全区分开的场景。</p>
<p>&#160; &#160; &#160; &#160;这里举一个比较适合去使用多进程技巧的场景，比如说我们正在做一个音乐播放器软件，其中播放音乐的功能应该是一个独立的功能，它不需要和UI方面有任何关系，即使软件已经关闭了也应该可以正常播放音乐。如果此时我们只使用一个进程，那么即使用户关闭了软件，已经完全由Service来控制音乐播放了，系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个则用于在后台持续地播放音乐。</p>
</blockquote>
<h2 id="实现方式可能存在的问题：例如启动页闪屏图，show完毕之后应该释放掉Bitmap。"><a href="#实现方式可能存在的问题：例如启动页闪屏图，show完毕之后应该释放掉Bitmap。" class="headerlink" title="实现方式可能存在的问题：例如启动页闪屏图，show完毕之后应该释放掉Bitmap。"></a>实现方式可能存在的问题：例如启动页闪屏图，show完毕之后应该释放掉Bitmap。</h2><p>&#160; &#160; &#160; &#160;一些实现方式看起来没有问题实现了功能但是实际上可能对内存造成了影响。我在使用Heap Viewer查看Bitmap对象时发现了一张只需下载不应该被加载的图。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/other1.jpg" alt="HeapViewer查找Bitmap"></p>
<p>&#160; &#160; &#160; &#160;使用HeapViewer可直接查看Bitmap</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/other2.jpg" alt="HeapViewer直接查看图片"></p>
<p>&#160; &#160; &#160; &#160;内存中出现的不应该被加载的图</p>
<p>&#160; &#160; &#160; &#160;<strong>通过查阅代码，发现问题出在：此处下载图片作为另一个模块的使用图，但是下载的方法竟然是使用图片加载器加载出来Bitmap然后再保存到本地；而且保存之后也没有将Bitmap对象释放掉。</strong><br>&#160; &#160; &#160; &#160;<strong>与之类似的还有：首页闪屏图展示之后，Bitmap对象应该及时释放掉。</strong></p>
<h2 id="使用try-catch进行捕获"><a href="#使用try-catch进行捕获" class="headerlink" title="使用try catch进行捕获"></a>使用try catch进行捕获</h2><p>&#160; &#160; &#160; &#160;<strong>对高风险OOM代码块如展示高清大图等进行try catch，在catch块加载非高清的图片并做相应内存回收的处理。注意OOM是OutOfMemoryError，不能使用Exception进行捕获。</strong></p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>&#160; &#160; &#160; &#160;内存优化的套路：<br>&#160; &#160; &#160; &#160;1. <strong>解决所有的内存泄漏</strong></p>
<ul>
<li>集成LeakCanary，可以方便的定位出90%的内存泄漏问题；</li>
<li>通过反复进出可疑界面，观察内存增减的情况，Dump Java Heap获取当前堆栈信息使用MAT进行分析。</li>
<li>内存泄漏的常见情形可参照《Android 内存泄漏分析心得》</li>
</ul>
<p>&#160; &#160; &#160; &#160;2. <strong>避免内存抖动</strong></p>
<ul>
<li>避免在循环中创建临时对象；</li>
<li>避免在onDraw中创建Paint、Bitmap对象等。</li>
</ul>
<p>&#160; &#160; &#160; &#160;3. <strong>Bitmap的使用</strong></p>
<ul>
<li>使用三方库加载图片一般不会出内存问题，但是需要注意图片使用完毕的释放，而不是被动等待释放。</li>
</ul>
<p>&#160; &#160; &#160; &#160;4. <strong>使用优化过的数据结构</strong></p>
<p>&#160; &#160; &#160; &#160;5. <strong>使用onTrimMemory根据不同的内存状态做相应处理</strong></p>
<p>&#160; &#160; &#160; &#160;6. <strong>Library的使用</strong></p>
<ul>
<li>去掉无用的Library，对生成的Apk进行反编译查看使用到的Library，避免出现无用的Lib仍然被打进Apk；</li>
<li>避免引入巨大的Library；</li>
<li>使用Proguard进行混淆、压缩。</li>
</ul>
<p>&#160; &#160; &#160; &#160;参考：</p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">Android性能优化典范</a></li>
<li><a href="http://android.xsoftlab.net/training/articles/memory.html" target="_blank" rel="external">Manage Your App’s Memory</a></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;最近还是很忙，主要是生活上有多多事情需要处理，所以没空闲时间更新博客了，唉。。。。。。结尾处继续放妹子&lt;(▰˘◡˘▰)&gt;    这次也是征求了<code>守望妹子</code>的同意，用她的靓照作为文章末尾─=≡Σ((( つ•̀ω•́)つ再次感谢守望妹子对本文的贡献( “３” )╱~~难的这个机会，就多放几张 (●’◡’●)ﾉ♥</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/shouwang1.JPG" alt="守望1"></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/shouwang2.JPG" alt="守望1"></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/shouwang3.JPG" alt="守望1"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现]]></title>
      <url>http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%B8%80-Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;好久没更新了，主要是因为年前和年后太忙了，尤其是年后这一段时间，忙得把身体都忙坏了。。。。。。终于在我GG之前，提交了离职，总算赢得了一些空闲时间，赶紧养养身体。。。现在处于即将待业状态，正好有时间研究一下年前就想了解的surfaceflinger模块。。。不过最近我也看了下，surfaceflinger内容太多太复杂了，<code>也许这个系列我坚持不了多久</code>，不能像上一个MediaPlayer系列那样。。。。。。<code>同时，因为目前我处于即将待业状况，所以求好心HR或者大牛带我入新坑，感激不尽(~ToT~)</code><br><a id="more"></a></p>
<h1 id="下载内核代码-准备工作"><a href="#下载内核代码-准备工作" class="headerlink" title="下载内核代码(准备工作)"></a>下载内核代码(准备工作)</h1><p>&#160; &#160; &#160; &#160;因为接下来分析需要用到部分kernel代码，所有我们需要先把kernel代码下载下来。</p>
<h2 id="更换hosts文件"><a href="#更换hosts文件" class="headerlink" title="更换hosts文件"></a>更换hosts文件</h2><p>&#160; &#160; &#160; &#160;因为天朝<code>GFW</code>的原因，所以不能直接访问google放置android source code的网站 <a href="https://source.android.com/" target="_blank" rel="external">https://source.android.com/</a> 。这个上面有很详细的教程，教大家下载、编译源码，和其他变动相关的知识。所以我们需要<strong>Fan Qiang</strong>。</p>
<p>&#160; &#160; &#160; &#160;如果买了VPN的土豪；找到免费vpn（GreenVPN、FreeVPN、hideVPN、rssVPN等等，好多都失效了）；还有可以去<strong>亚马逊</strong>申请一个免费服务器（一年），可以搭建自己的FQ服务器（这个需要绑定一张VISA信用卡，银联的不行），<a href="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/AWS%E8%AF%A6%E7%BB%86FQ%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.doc" target="_blank" rel="external">这里</a> 有个教程，我上传到了自己博客服务器，大家可以下载下来；或者有稳定且流量大的FQ软件（比如赛风、自由门、蓝灯、畅游无限浏览器、影梭等）；或者有靠谱的hosts文件的，可以跳过这一步。</p>
<p>&#160; &#160; &#160; &#160;因为要拉kernel代码，文件比较大，所以我推荐更换hosts文件。这里推荐<code>老D</code> hosts，地址是 <a href="https://laod.cn/hosts/2017-google-hosts.html" target="_blank" rel="external">https://laod.cn/hosts/2017-google-hosts.html</a> 。都是傻瓜式教程，应该都会。</p>
<h2 id="下载kernel代码"><a href="#下载kernel代码" class="headerlink" title="下载kernel代码"></a>下载kernel代码</h2><p>&#160; &#160; &#160; &#160;更换完hosts文件后，进入android源码官网，然后找到里面的<strong>Explore the Source</strong>标题下面描述里面的<strong>AOSP repository</strong>，点击进入源码仓库 <a href="https://android.googlesource.com/" target="_blank" rel="external">https://android.googlesource.com/</a> 。<br>&#160; &#160; &#160; &#160;1) 因为我们要下kernel源码，所以选择<strong>kenrnel/common</strong>,下载这一个通用代码；<br>&#160; &#160; &#160; &#160;2) 用git下载代码：git clone <a href="https://android.googlesource.com/kernel/common" target="_blank" rel="external">https://android.googlesource.com/kernel/common</a> ；<br>&#160; &#160; &#160; &#160;3) 切换分支，我选了一个release版本：android-4.4-n-release，所以要git checkout -b android-4.4-n-release remotes/origin/android-4.4-n-release，然后pull一下，common文件夹下就有代码了。<br>&#160; &#160; &#160; &#160;4) 最后将下载好的代码导入source insight，这一步就不用细说了。</p>
<h1 id="初识Gralloc模块"><a href="#初识Gralloc模块" class="headerlink" title="初识Gralloc模块"></a>初识Gralloc模块</h1><h2 id="Gralloc模块简介"><a href="#Gralloc模块简介" class="headerlink" title="Gralloc模块简介"></a>Gralloc模块简介</h2><p>&#160; &#160; &#160; &#160;Android设备的显示屏被抽象为一个帧缓冲区，而Android系统中的SurfaceFlinger服务就是通过向这个帧缓冲区写入内容来绘制应用程序的用户界面的。Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对帧缓冲区的所有访问操作。<br>&#160; &#160; &#160; &#160;Linux内核在启动的过程中会创建一个类别和名称分别为“graphics”和“fb0”的设备，用来描述系统中的第一个帧缓冲区，即第一个显示屏，其中，数字0表示从设备号。注意，系统中至少要存在一个显示屏，因此，名称为“fb0”的设备是肯定会存在的，否则的话，就是出错了。<br>&#160; &#160; &#160; &#160;init进程在启动的过程中，会启动另外一个进程ueventd来管理系统的设备文件。当ueventd进程启动起来之后，会通过netlink接口来Linux内核通信，以便可以获得内核中的硬件设备变化通知。而当ueventd进程发现内核中创建了一个类型和名称分别为“graphics”和“fb0”的设备的时候，就会这个设备创建一个/dev/graphics/fb0设备文件。这样，用户空间的应用程序就可以通过设备文件/dev/graphics/fb0来访问内核中的帧缓冲区，即在设备的显示屏中绘制指定的画面。注意，用户空间的应用程序一般是通过内存映射的方式来访问设备文件/dev/graphics/fb0的。<br>&#160; &#160; &#160; &#160;Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对帧缓冲区的所有访问操作。用户空间的应用程序在使用帧缓冲区之间，首先要加载Gralloc模块，并且获得一个gralloc设备和一个fb设备。有了gralloc设备之后，用户空间中的应用程序就可以申请分配一块图形缓冲区，并且将这块图形缓冲区映射到应用程序的地址空间来，以便可以向里面写入要绘制的画面的内容。最后，用户空间中的应用程序就通过fb设备来将已经准备好了的图形缓冲区渲染到帧缓冲区中去，即将图形缓冲区的内容绘制到显示屏中去。相应地，当用户空间中的应用程序不再需要使用一块图形缓冲区的时候，就可以通过gralloc设备来释放它，并且将它从地址空间中解除映射。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>&#160; &#160; &#160; &#160;Gralloc模块实现源码位于：hardware/libhardware/modules/gralloc ：</p>
<p>&#160; &#160; &#160; &#160;|——– Android.mk<br>&#160; &#160; &#160; &#160;|——– framebuffer.cpp<br>&#160; &#160; &#160; &#160;|——– gralloc.cpp<br>&#160; &#160; &#160; &#160;|——– gralloc_priv.h<br>&#160; &#160; &#160; &#160;|——– gr.h<br>&#160; &#160; &#160; &#160;|——– mapper.cpp</p>
<h1 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h1><p>&#160; &#160; &#160; &#160;接下来，我们就按照上述使用情景来分析Gralloc模块的实现。</p>
<h2 id="Gralloc模块的加载过程"><a href="#Gralloc模块的加载过程" class="headerlink" title="Gralloc模块的加载过程"></a>Gralloc模块的加载过程</h2><p>&#160; &#160; &#160; &#160;每一个HAL模块都有一个ID值，以这些ID值为参数来调用硬件抽象层提供的函数<strong>hw_get_module</strong>就可以将指定的模块加载到内存来，并且获得一个<strong>hw_module_t</strong>接口来打开相应的设备。<br>&#160; &#160; &#160; &#160;Gralloc模块的ID值定义在hardware/libhardware/include/hardware/gralloc.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * The id of this module</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_MODULE_ID <span class="string">"gralloc"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;函数<strong>hw_get_module</strong>实现在hardware/libhardware/hardware.c文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span> **module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hw_get_module_by_class(id, <span class="literal">NULL</span>, module);<span class="comment">//调用hw_get_module_by_class函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hw_get_module_by_class函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span> **module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> prop[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> name[PATH_MAX]; <span class="comment">//PATH_MAX为256</span></span><br><span class="line">    <span class="keyword">char</span> prop_name[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inst)<span class="comment">//NULL</span></span><br><span class="line">        <span class="built_in">snprintf</span>(name, PATH_MAX, <span class="string">"%s.%s"</span>, class_id, inst);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        strlcpy(name, class_id, PATH_MAX);<span class="comment">//字符串拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Here we rely on the fact that calling dlopen multiple times on</span><br><span class="line">     * the same .so will simply increment a refcount (and not load</span><br><span class="line">     * a new copy of the library).</span><br><span class="line">     * We also assume that dlopen() is thread-safe.</span><br><span class="line">     */</span></span><br><span class="line">     <span class="comment">//我们依赖的事实是，调用dlopen方法多次打开相同的so库会简单的增加引用计数(而不会重复加载多次库的拷贝)</span></span><br><span class="line">     <span class="comment">//我们认为dlopen方法是线程安全的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First try a property specific to the class and possibly instance */</span></span><br><span class="line">    <span class="comment">//先查找确定系统属性的值是否为空</span></span><br><span class="line">    <span class="built_in">snprintf</span>(prop_name, <span class="keyword">sizeof</span>(prop_name), <span class="string">"ro.hardware.%s"</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (property_get(prop_name, prop, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果不为空，则找到属性对应的so库是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, prop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop through the configuration variants looking for a module */</span></span><br><span class="line">    <span class="comment">//如果上面没找到指定的so库，则循环遍历指定数组里的属性，然后找到第一个存在的so并跳出</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;HAL_VARIANT_KEYS_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property_get(variant_keys[i], prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, prop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing found, try the default */</span></span><br><span class="line">    <span class="comment">//如果第二步查找也没找到，就用默认的default属性</span></span><br><span class="line">    <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, <span class="string">"default"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">/* load the module, if this fails, we're doomed, and we should not try</span><br><span class="line">     * to load a different variant. */</span></span><br><span class="line">    <span class="comment">//如果我们找到了相关so，则加载它</span></span><br><span class="line">    <span class="keyword">return</span> load(class_id, path, module);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * There are a set of variant filename for modules. The form of the filename</span><br><span class="line"> * is "&lt;MODULE_ID&gt;.variant.so" so for the led module the Dream variants </span><br><span class="line"> * of base "ro.product.board", "ro.board.platform" and "ro.arch" would be:</span><br><span class="line"> *</span><br><span class="line"> * led.trout.so</span><br><span class="line"> * led.msm7k.so</span><br><span class="line"> * led.ARMV6.so</span><br><span class="line"> * led.default.so</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *variant_keys[] = &#123;</span><br><span class="line">    <span class="string">"ro.hardware"</span>,  <span class="comment">/* This goes first so that it can pick up a different</span><br><span class="line">                       file on the emulator. */</span></span><br><span class="line">    <span class="string">"ro.product.board"</span>,</span><br><span class="line">    <span class="string">"ro.board.platform"</span>,</span><br><span class="line">    <span class="string">"ro.arch"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面流程我们分步来看：</p>
<h3 id="查询对应动态库"><a href="#查询对应动态库" class="headerlink" title="查询对应动态库"></a>查询对应动态库</h3><p>&#160; &#160; &#160; &#160;1）先查找确定系统属性的值是否为空，property_get函数到系统属性，可以在shell环境下用getprop ro.hardware.%s找到ro.hardware.%s属性，最后一个字符串自己指定；然后调用hw_module_exists函数顺着<strong>/system/lib/hw和/vendor/lib/hw或者/system/lib64/hw和/vendor/lib64/hw</strong>查找相应so库是否存在，我们看看hw_module_exists函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Check if a HAL with given name and subname exists, if so return 0, otherwise</span><br><span class="line"> * otherwise return negative.  On success path will contain the path to the HAL.</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//检查HAL层给的文件名是否存在，如果存在返回0，否则返回负无穷</span></span><br><span class="line"> <span class="comment">//如果成功了，会把这个路径包含进HAL</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hw_module_exists</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">size_t</span> path_len, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">char</span> *subname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(path, path_len, <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">             HAL_LIBRARY_PATH2, name, subname);</span><br><span class="line">    <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(path, path_len, <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">             HAL_LIBRARY_PATH1, name, subname);</span><br><span class="line">    <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Base path of the hal modules */</span></span><br><span class="line"><span class="comment">//主要在下面目录下找相关so库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="string">"/system/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="string">"/vendor/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="string">"/system/lib/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="string">"/vendor/lib/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2）如果第一步GG了，就进入第二步，则循环遍历指定数组里的属性，然后找到第一个存在的so并跳出。<br>&#160; &#160; &#160; &#160;函数hw_get_module依次在目录/system/lib/hw和/vendor/lib/hw中(或64位对应目录)查找一个名称为”<module_id>.variant.so”的文件，其中，&lt; MODULE_ID &gt;是一个模块ID，而variant表示”ro.hardware”、”ro.product.board”、”ro.board.platform”和”ro.arch”四个系统属性值之一。例如，对于Gralloc模块来说，函数hw_get_module依次在目录/system/lib/hw和/vendor/lib/hw中检查是否存在以下四个文件：</module_id></p>
<ul>
<li><strong>gralloc.&lt; ro.hardware &gt;.so</strong></li>
<li><strong>gralloc.&lt; ro.product.board &gt;.so</strong></li>
<li><strong>gralloc.&lt; ro.board.platform &gt;.so</strong></li>
<li><strong>gralloc.&lt; ro.arch &gt;.so</strong></li>
</ul>
<p>&#160; &#160; &#160; &#160;只要其中的一个文件存在，  函数hw_get_module就会停止查找过程，并且调用另外一个函数load来将这个文件加载到内存中来。</p>
<p>&#160; &#160; &#160; &#160;3）如果第二步也GG了，就进入第三步，如果第二步查找也没找到，就用默认的default属性。如果在/system/lib/hw和/vendor/lib/hw中均不存这些文件，那么函数hw_get_module就会在目录/system/lib/hw中查找是否存在一个名称为<strong>gralloc.default.so</strong>的文件。如果存在的话，那么也会调用函数load将它加载到内存中来。</p>
<p>&#160; &#160; &#160; &#160;4）找到对应的so库后，就要调用<strong>load</strong>函数将他加载到内存中。</p>
<h3 id="加载对应动态库"><a href="#加载对应动态库" class="headerlink" title="加载对应动态库"></a>加载对应动态库</h3><p>&#160; &#160; &#160; &#160;函数load也是实现在文件hardware/libhardware/hardware.c文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Load the file defined by the variant and if successful</span><br><span class="line"> * return the dlopen handle and the hmi.</span><br><span class="line"> * @return 0 = success, !0 = failure.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span> **pHmi)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">void</span> *handle;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">hw_module_t</span> *hmi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * load the symbols resolving undefined symbols before</span><br><span class="line">     * dlopen returns. Since RTLD_GLOBAL is not or'd in with</span><br><span class="line">     * RTLD_NOW the external symbols will not be global</span><br><span class="line">     */</span></span><br><span class="line">    handle = dlopen(path, RTLD_NOW);<span class="comment">//用dlopen函数将对应so库加载到内存中</span></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> <span class="keyword">const</span> *err_str = dlerror();</span><br><span class="line">        ALOGE(<span class="string">"load: module=%s\n%s"</span>, path, err_str?err_str:<span class="string">"unknown"</span>);</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the address of the struct hal_module_info. */</span></span><br><span class="line">    <span class="comment">//调用函数dlsym来获得它所导出的符号HMI</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sym = HAL_MODULE_INFO_SYM_AS_STR;</span><br><span class="line">    hmi = (<span class="keyword">struct</span> <span class="keyword">hw_module_t</span> *)dlsym(handle, sym);</span><br><span class="line">    <span class="keyword">if</span> (hmi == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"load: couldn't find symbol %s"</span>, sym);</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that the id matches */</span></span><br><span class="line">    <span class="comment">//检查id是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(id, hmi-&gt;id) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"load: id=%s != hmi-&gt;id=%s"</span>, id, hmi-&gt;id);</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hmi-&gt;dso = handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* success */</span></span><br><span class="line">    status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    done:</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        hmi = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (handle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dlclose(handle);</span><br><span class="line">            handle = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGV(<span class="string">"loaded HAL id=%s path=%s hmi=%p handle=%p"</span>,</span><br><span class="line">                id, path, *pHmi, handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pHmi = hmi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在Linux系统中，后缀名为”so”的文件为动态链接库文件，可能通过函数dlopen来加载到内存中。硬件抽象层模块编写规范规定每一个硬件抽象层模块都必须导出一个符号名称为<strong>HAL_MODULE_INFO_SYM_AS_STR</strong>的符号，而且这个符号必须是用来描述一个类型为<strong>hw_module_t</strong>的结构体的。<br>&#160; &#160; &#160; &#160;<strong>HAL_MODULE_INFO_SYM_AS_STR</strong>是一个宏，定义在文件hardware/libhardware/include/hardware/hardware.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Name of the hal_module_info as a string</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_MODULE_INFO_SYM_AS_STR  <span class="string">"HMI"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;将Gralloc模块加载到内存中来之后，就可以调用函数dlsym来获得它所导出的符号<strong>HMI</strong>。由于这个符号指向的是一个<strong>hw_module_t</strong>结构体，因此，最后函数load就可以强制地将这个符号转换为一个hw_module_t结构体指针，并且保存在输出参数pHmi中返回给调用者。调用者获得了这个hw_module_t结构体指针之后，就可以创建一个gralloc设备或者一个fb设备。</p>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>&#160; &#160; &#160; &#160;模块Gralloc实现在目录hardware/libhardware/modules/gralloc中，它导出的符号<strong>HMI</strong>定义在文件hardware/libhardware/modules/gralloc/gralloc.cpp文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">hw_module_methods_t</span> gralloc_module_methods = &#123;</span><br><span class="line">        .open = gralloc_device_open</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">private_module_t</span> HAL_MODULE_INFO_SYM = &#123;</span><br><span class="line">    .base = &#123;</span><br><span class="line">        .common = &#123;</span><br><span class="line">            .tag = HARDWARE_MODULE_TAG,</span><br><span class="line">            .version_major = <span class="number">1</span>,</span><br><span class="line">            .version_minor = <span class="number">0</span>,</span><br><span class="line">            .id = GRALLOC_HARDWARE_MODULE_ID,</span><br><span class="line">            .name = <span class="string">"Graphics Memory Allocator Module"</span>,</span><br><span class="line">            .author = <span class="string">"The Android Open Source Project"</span>,</span><br><span class="line">            .methods = &amp;gralloc_module_methods</span><br><span class="line">        &#125;,</span><br><span class="line">        .registerBuffer = gralloc_register_buffer,</span><br><span class="line">        .unregisterBuffer = gralloc_unregister_buffer,</span><br><span class="line">        .lock = gralloc_lock,</span><br><span class="line">        .unlock = gralloc_unlock,</span><br><span class="line">    &#125;,</span><br><span class="line">    .framebuffer = <span class="number">0</span>,</span><br><span class="line">    .flags = <span class="number">0</span>,</span><br><span class="line">    .numBuffers = <span class="number">0</span>,</span><br><span class="line">    .bufferMask = <span class="number">0</span>,</span><br><span class="line">    .lock = PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    .currentBuffer = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>HAL_MODULE_INFO_SYM</strong>也是一个宏，它的值是与宏HAL_MODULE_INFO_SYM_AS_STR对应的，它也是定义在文件hardware/libhardware/include/hardware/hardware.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Name of the hal_module_info</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_MODULE_INFO_SYM         HMI</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;符号<strong>HAL_MODULE_INFO_SYM</strong>的类型为<strong>private_module_t</strong>。前面提到，符号HAL_MODULE_INFO_SYM必须指向一个<strong>hw_module_t</strong>结构体，但是这里它指向的却是一个private_module_t结构体，是不是有问题呢？为了弄清楚这个问题，我们首先了解一下结构体private_module_t的定义，如下图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/jicheng.jpg" alt="继承关系"></p>
<p>&#160; &#160; &#160; &#160;结构体<strong>private_module_t</strong>的第一个成员变量<strong>base</strong>指向一个<strong>gralloc_module_t</strong>结构体，而gralloc_module_t结构体的第一个成员变量<strong>common</strong>又指向了一个<strong>hw_module_t</strong>结构体，这意味着，指向一个private_module_t结构体的指针同时可以用作一个gralloc_module_t或者hw_module_t结构体提针来使用。<code>事实上，这是使用C语言来实现的一种继承关系</code>，等价于结构体private_module_t继承结构体gralloc_module_t，而结构体gralloc_module_t继承hw_module_t结构体。这样，<strong>我们就可以把在Gralloc模块中定义的符号HAL_MODULE_INFO_SYM看作是一个hw_module_t结构体</strong>。</p>
<p>&#160; &#160; &#160; &#160;<strong>hw_module_t</strong>结构体有一个重要的成员变量<strong>methods</strong>，它的类型为<strong>hw_module_methods_t</strong>，它用来描述一个HAL模块的操作方法列表。结构体hw_module_methods_t只定义有一个操作方法open，用来打开一个指定的设备。在Gralloc模块中，用来打开指定设备的函数被指定为gralloc_device_open，通过这个函数就可以打开Gralloc模块中的gralloc或者fb设备，后面我们再详细分析。</p>
<p>&#160; &#160; &#160; &#160;1）结构体<strong>gralloc_module_t</strong>定义在文件hardware/libhardware/include/hardware/gralloc.h中，它主要是定义了四个用来操作图形缓冲区的成员函数，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> &#123;  </span><br><span class="line">　　<span class="keyword">struct</span> <span class="keyword">hw_module_t</span> common;  </span><br><span class="line">　　<span class="comment">//映射一块图形缓冲区到一个进程的地址空间去  </span></span><br><span class="line">　　<span class="keyword">int</span> (*registerBuffer)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">buffer_handle_t</span> handle);  </span><br><span class="line">　　<span class="comment">//取消映射一块图形缓冲区到一个进程的地址空间去  </span></span><br><span class="line">　　<span class="keyword">int</span> (*unregisterBuffer)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">buffer_handle_t</span> handle);  </span><br><span class="line">　　<span class="comment">//锁定一个指定的图形缓冲区  </span></span><br><span class="line">    <span class="keyword">int</span> (*lock)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">buffer_handle_t</span> handle, <span class="keyword">int</span> usage,  </span><br><span class="line">            <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> h,<span class="keyword">void</span>** vaddr);  </span><br><span class="line">    <span class="comment">//解锁一个指定的图形缓冲区  </span></span><br><span class="line">　　<span class="keyword">int</span> (*unlock)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">buffer_handle_t</span> handle);  </span><br><span class="line">    <span class="keyword">int</span> (*perform)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">int</span> operation, ... );  </span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">3</span>];  </span><br><span class="line">&#125; <span class="keyword">gralloc_module_t</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>成员函数registerBuffer和unregisterBuffer分别用来注册和注销一个指定的图形缓冲区，这个指定的图形缓冲区使用一个buffer_handle_t句柄来描述。所谓注册图形缓冲区，实际上就是将一块图形缓冲区映射到一个进程的地址空间去，而注销图形缓冲区就是执行相反的操作。</li>
<li>成员函数lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，这个指定的图形缓冲区同样是使用一个buffer_handle_t句柄来描述。在访问一块图形缓冲区的时候，例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突。在锁定一块图形缓冲区的时候，可以指定要锁定的图形绘冲区的位置以及大小，这是通过参数l、t、w和h来指定的，其中，参数l和t指定的是要访问的图形缓冲区的左上角位置，而参数w和h指定的是要访问的图形缓冲区的宽度和长度。锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中。另一方面，在访问完成一块图形缓冲区之后，需要解除这块图形缓冲区的锁定。</li>
<li>在Gralloc模块中，符号HAL_MODULE_INFO_SYM指向的gralloc结构体的成员函数registerBuffer、unregisterBuffer、lock和unlock分别被指定为函数gralloc_register_buffer、gralloc_unregister_buffer、gralloc_lock和gralloc_unlock，后面我们再详细分析它们的实现。</li>
</ul>
<p>&#160; &#160; &#160; &#160;2）结构体<strong>private_module_t</strong>定义在文件hardware/libhardware/modules/gralloc/gralloc_priv.h中，它主要是用来描述帧缓冲区的属性，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">private_module_t</span> &#123;  </span><br><span class="line">    <span class="keyword">gralloc_module_t</span> base;  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* framebuffer; <span class="comment">//指向系统帧缓冲区的句柄  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags; <span class="comment">//用来标志系统帧缓冲区是否支持双缓冲  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> numBuffers;<span class="comment">//表示系统帧缓冲区包含有多少个图形缓冲区  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> bufferMask; <span class="comment">//记录系统帧缓冲区中的图形缓冲区的使用情况  </span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock; <span class="comment">//一个互斥锁，用来保护结构体private_module_t的并行访问  </span></span><br><span class="line">    <span class="keyword">buffer_handle_t</span> currentBuffer; <span class="comment">//用来描述当前正在被渲染的图形缓冲区  </span></span><br><span class="line">    <span class="keyword">int</span> pmem_master;  </span><br><span class="line">    <span class="keyword">void</span>* pmem_master_base;  </span><br><span class="line">    <span class="keyword">struct</span> fb_var_screeninfo info; <span class="comment">//保存设备显示屏的动态属性信息  </span></span><br><span class="line">    <span class="keyword">struct</span> fb_fix_screeninfo finfo; <span class="comment">////保存设备显示屏的固定属性信息  </span></span><br><span class="line">    <span class="keyword">float</span> xdpi; <span class="comment">//描述设备显示屏在宽度  </span></span><br><span class="line">    <span class="keyword">float</span> ydpi; <span class="comment">//描述设备显示屏在高度  </span></span><br><span class="line">    <span class="keyword">float</span> fps; <span class="comment">//用来描述显示屏的刷新频率  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>成员变量framebuffer的类型为private_handle_t，它是一个指向系统帧缓冲区的句柄，后面我们再分析结构体private_handle_t的定义。</li>
<li>成员变量flags用来标志系统帧缓冲区是否支持双缓冲。如果支持的话，那么它的PAGE_FLIP位就等于1，否则的话，就等于0。</li>
<li>成员变量numBuffers表示系统帧缓冲区包含有多少个图形缓冲区。一个帧缓冲区包含有多少个图形缓冲区是与它的可视分辨率以及虚拟分辨率的大小有关的。例如，如果一个帧缓冲区的可视分辨率为800 x 600，而虚拟分辨率为1600 x 600，那么这个帧缓冲区就可以包含有两个图形缓冲区。</li>
<li>成员变量bufferMask用来记录系统帧缓冲区中的图形缓冲区的使用情况。例如，假设系统帧缓冲区有两个图形缓冲区，这时候成员变量bufferMask就有四种取值，分别是二进制的00、01、10和11，其中，00分别表示两个图缓冲区都是空闲的，01表示第1个图形缓冲区已经分配出去，而第2个图形缓冲区是空闲的，10表示第1个图形缓冲区是空闲的，而第2个图形缓冲区已经分配出去，11表示两个图缓冲区都已经分配出去。</li>
<li>成员变量lock是一个互斥锁，用来保护结构体private_module_t的并行访问。</li>
<li>成员变量<strong>currentBuffer</strong>的类型为<strong>buffer_handle_t</strong>，用来描述当前正在被渲染的图形缓冲区，后面我们再分析它的定义。</li>
<li>成员变量pmem_master和pmem_master_base目前没有使用。</li>
<li>成员变量info和finfo的类型分别为fb_var_screeninfo和fb_fix_screeninfo，它们用来保存设备显示屏的属性信息，其中，成员变量info保存的属性信息是可以动态设置的，而成员变量finfo保存的属性信息是只读的。这两个成员变量的值可以通过IO控制命令FBIOGET_VSCREENINFO和FBIOGET_FSCREENINFO来从帧缓冲区驱动模块中获得。</li>
<li>成员变量xdpi和ydpi分别用来描述设备显示屏在宽度和高度上的密度，即每英寸有多少个像素点。</li>
<li><p>成员变量fps用来描述显示屏的刷新频率，它的单位的fps，即每秒帧数。</p>
<p>&#160; &#160; &#160; &#160;3）接下来， 我们再分析结构体<strong>buffer_handle_t</strong>的定义。结构体buffer_handle_t定义在文件hardware/libhardware/include/hardware/gralloc.h文件中，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> native_handle* <span class="keyword">buffer_handle_t</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&#160; &#160; &#160; &#160;它是一个类型为<strong>native_handle_t</strong>的指针，而结构体native_handle_t用来描述一个本地句柄值，它定义在系统运行时层的文件system/core/include/cutils/native_handle.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> native_handle  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> version; <span class="comment">//设置为结构体native_handle_t的大小，用来标识结构体native_handle_t的版本  </span></span><br><span class="line">    <span class="keyword">int</span> numFds;  <span class="comment">//表示结构体native_handle_t所包含的文件描述符的个数，这些文件描述符保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> numInts; <span class="comment">//表示结构体native_handle_t所包含的整数值的个数，这些整数保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>]; <span class="comment">//指向的一块缓冲区中  </span></span><br><span class="line">&#125; <span class="keyword">native_handle_t</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>成员变量version的大小被设置为结构体native_handle_t的大小，用来标识结构体native_handle_t的版本。</li>
<li>成员变量numFds和numInts表示结构体native_handle_t所包含的文件描述符以及整数值的个数，这些文件描述符和整数保存在成员变量data所指向的一块缓冲区中。</li>
</ul>
<p>&#160; &#160; &#160; &#160;4）我们一般不直接使用native_handle_t结构体来描述一个本地句柄值，而是通过它的子类来描述一个具体的本地句柄值。接下来我们就通过结构体private_handle_t的定义来说明native_handle_t结构体的用法。<br>&#160; &#160; &#160; &#160;结构体<strong>private_handle_t</strong>用来描述一块图形缓冲区，这块图形缓冲区可能是在帧缓冲区中分配的，也可能是在内存中分配的，视具体情况而定，它定义在文件hardware/libhardware/modules/gralloc/gralloc_priv.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">private_handle_t</span> : <span class="keyword">public</span> native_handle &#123;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">private_handle_t</span> &#123;  </span><br><span class="line">    <span class="keyword">struct</span> native_handle nativeHandle;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">enum</span> &#123;  </span><br><span class="line">        PRIV_FLAGS_FRAMEBUFFER = <span class="number">0x00000001</span>  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// file-descriptors  </span></span><br><span class="line">    <span class="keyword">int</span>     fd;  <span class="comment">////指向一个文件描述符，这个文件描述符要么指向帧缓冲区设备，要么指向一块匿名共享内存 </span></span><br><span class="line">    <span class="comment">// ints  </span></span><br><span class="line">    <span class="keyword">int</span>     magic;  <span class="comment">//指向一个魔数，它的值由静态成员变量sMagic来指定，用来标识一个private_handle_t结构</span></span><br><span class="line">    <span class="keyword">int</span>     flags;  <span class="comment">//用来描述一个缓冲区的标志，它的值要么等于0，要么等于PRIV_FLAGS_FRAMEBUFFER  </span></span><br><span class="line">    <span class="keyword">int</span>     size;   <span class="comment">//用来描述一个缓冲区的大小。 </span></span><br><span class="line">    <span class="keyword">int</span>     offset; <span class="comment">//用来描述一个缓冲区的偏移地址。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> the attributes below should be out-of-line  </span></span><br><span class="line">    <span class="keyword">int</span>     base;  <span class="comment">//用来描述一个缓冲区的实际地址，它是通过成员变量offset来计算得到的。 </span></span><br><span class="line">    <span class="keyword">int</span>     pid;   <span class="comment">//用来描述一个缓冲区的创建者的PID。  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> sNumInts = <span class="number">6</span>;  <span class="comment">//包含有6个整数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> sNumFds = <span class="number">1</span>;   <span class="comment">//包含有1个文件描述符 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> sMagic = <span class="number">0x3141592</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private_handle_t</span>(<span class="keyword">int</span> fd, <span class="keyword">int</span> size, <span class="keyword">int</span> flags) :  </span><br><span class="line">        fd(fd), magic(sMagic), flags(flags), size(size), offset(<span class="number">0</span>),  </span><br><span class="line">        base(<span class="number">0</span>), pid(getpid())  </span><br><span class="line">    &#123;  </span><br><span class="line">        version = <span class="keyword">sizeof</span>(native_handle);  </span><br><span class="line">        numInts = sNumInts;  </span><br><span class="line">        numFds = sNumFds;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~<span class="keyword">private_handle_t</span>() &#123;  </span><br><span class="line">        magic = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">validate</span><span class="params">(<span class="keyword">const</span> native_handle* h)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">const</span> <span class="keyword">private_handle_t</span>*)h;  </span><br><span class="line">        <span class="keyword">if</span> (!h || h-&gt;version != <span class="keyword">sizeof</span>(native_handle) ||  </span><br><span class="line">                h-&gt;numInts != sNumInts || h-&gt;numFds != sNumFds ||  </span><br><span class="line">                hnd-&gt;magic != sMagic)  </span><br><span class="line">        &#123;  </span><br><span class="line">            LOGE(<span class="string">"invalid gralloc handle (at %p)"</span>, h);  </span><br><span class="line">            <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;为了方便描述，我们假设我们是在C++环境中编译文件gralloc_priv.h，即编译环境定义有宏__cplusplus。这样，结构体private_handle_t就是从结构体native_handle_t继承下来的，它包含有1个文件描述符以及6个整数，以及三个静态成员变量。</p>
<ul>
<li>成员变量fd指向一个文件描述符，这个文件描述符要么指向帧缓冲区设备，要么指向一块匿名共享内存，取决于它的宿主结构体private_handle_t描述的一个图形缓冲区是在帧缓冲区分配的，还是在内存中分配的。</li>
<li>成员变量magic指向一个魔数，它的值由静态成员变量sMagic来指定，用来标识一个private_handle_t结构体。</li>
<li>成员变量flags用来描述一个图形缓冲区的标志，它的值要么等于0，要么等于PRIV_FLAGS_FRAMEBUFFER。当一个图形缓冲区的标志值等于PRIV_FLAGS_FRAMEBUFFER的时候，就表示它是在帧缓冲区中分配的。</li>
<li>成员变量size用来描述一个图形缓冲区的大小。</li>
<li>成员变量offset用来描述一个图形缓冲区的偏移地址。例如，当一个图形缓冲区是在一块内存中分块的时候，假设这块内存的地址为start，那么这个图形缓冲区的起始地址就为start + offset。</li>
<li>成员变量base用来描述一个图形缓冲区的实际地址，它是通过成员变量offset来计算得到的。例如，上面计算得到的start + offset的值就保存在成员变量base中。</li>
<li>成员变量pid用来描述一个图形缓冲区的创建者的PID。例如，如果一个图形缓冲区是在ID值为1000的进程中创建的，那么用来描述这个图形缓冲区的private_handle_t结构体的成员变量pid的值就等于1000。</li>
</ul>
<p>&#160; &#160; &#160; &#160;结构体private_handle_t的静态成员变量sMagic前面已经描述过了，另外两个静态成员变量sNumInts和sNumFds的值分别等于1和6，表示结构体private_handle_t包含有1个文件描述符和6个整数，它们是用来初始化结构体private_handle_t的父类native_handle_t的成员变量numInts和numFds的，如结构体private_handle_t的构造函数所示。从这里就可以看出，结构体private_handle_t的父类native_handle_t的成员变量data所指向的缓冲区就是由结构体private_handle_t的成员变量fds、magic、flags、size、offset、base和pid所占用的连续内存块来组成的，一共包含有7个整数。<br>&#160; &#160; &#160; &#160;结构体private_handle_t还定义了一个静态成员函数validate，用来验证一个native_handle_t指针是否指向了一个private_handle_t结构体。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/leitu.png" alt="数据结构图"></p>
<p>&#160; &#160; &#160; &#160;至此，Gralloc模块的加载过程以及相关的数据结构体就介绍到这里，接下来我们分别分析定义在Gralloc模块中的gralloc和fb设备的打开过程。</p>
<h2 id="Gralloc设备的打开过程"><a href="#Gralloc设备的打开过程" class="headerlink" title="Gralloc设备的打开过程"></a>Gralloc设备的打开过程</h2><p>&#160; &#160; &#160; &#160;在Gralloc模块中，gralloc设备的ID值定义为<strong>GRALLOC_HARDWARE_GPU0</strong>。GRALLOC_HARDWARE_GPU0是一个宏，定义在文件hardware/libhardware/include/hardware/gralloc.h中， 如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Name of the graphics device to open</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_GPU0 <span class="string">"gpu0"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;gralloc设备使用结构体<strong>alloc_device_t</strong> 来描述。结构体alloc_device_t有两个成员函数<strong>alloc</strong>和<strong>free</strong>，分别用来分配和释放图形缓冲区。<br>&#160; &#160; &#160; &#160;结构体alloc_device_t 也是定义在文件hardware/libhardware/include/hardware/gralloc.h中， 如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">alloc_device_t</span> &#123;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">hw_device_t</span> common;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*alloc)(<span class="keyword">struct</span> <span class="keyword">alloc_device_t</span>* dev,  </span><br><span class="line">            <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,  </span><br><span class="line">            <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">int</span>* stride);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> <span class="keyword">alloc_device_t</span>* dev,  </span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);  </span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">alloc_device_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Gralloc模块在在文件hardware/libhardware/include/hardware/gralloc.h中定义了一个帮助函数gralloc_open，用来打开gralloc设备，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** convenience API for opening and closing a supported device */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gralloc_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span>* module, </span><br><span class="line">        <span class="keyword">struct</span> <span class="keyword">alloc_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> module-&gt;methods-&gt;open(module, </span><br><span class="line">            GRALLOC_HARDWARE_GPU0, (<span class="keyword">struct</span> <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;参数<strong>module</strong>指向的是一个用来描述Gralloc模块的<strong>hw_module_t</strong>结构体，它的成员变量<strong>methods</strong>所指向的一个<strong>hw_module_methods_t</strong>结构体的成员函数<strong>open</strong>指向了Gralloc模块中的函数<strong>gralloc_device_open</strong>。</p>
<p>&#160; &#160; &#160; &#160;函数<strong>gralloc_device_open</strong>定义在文件hardware/libhardware/modules/gralloc/gralloc.cpp文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">gralloc_context_t</span> &#123;  </span><br><span class="line">    <span class="keyword">alloc_device_t</span>  device;  </span><br><span class="line">    <span class="comment">/* our private data here */</span>  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* module, <span class="keyword">const</span> <span class="keyword">char</span>* name,  </span><br><span class="line">        <span class="keyword">hw_device_t</span>** device)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;  </span><br><span class="line">        <span class="keyword">gralloc_context_t</span> *dev;  </span><br><span class="line">        dev = (<span class="keyword">gralloc_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* initialize our state here */</span>  </span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* initialize the procs */</span>  </span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;  </span><br><span class="line">        dev-&gt;device.common.version = <span class="number">0</span>;  </span><br><span class="line">        dev-&gt;device.common.module = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(module);  </span><br><span class="line">        dev-&gt;device.common.close = gralloc_close;  </span><br><span class="line">  </span><br><span class="line">        dev-&gt;device.alloc   = gralloc_alloc;  </span><br><span class="line">        dev-&gt;device.<span class="built_in">free</span>    = gralloc_free;  </span><br><span class="line">  </span><br><span class="line">        *device = &amp;dev-&gt;device.common;  </span><br><span class="line">        status = <span class="number">0</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> status;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数主要是用来创建一个<strong>gralloc_context_t</strong>结构体，并且对它的成员变量<strong>device</strong>进行初始化。结构体gralloc_context_t的成员变量device的类型为<strong>gralloc_device_t</strong>，它用来描述一个gralloc设备。前面提到，gralloc设备是用来分配和释放图形缓冲区的，这是通过调用它的成员函数alloc和free来实现的。从这里可以看出，函数gralloc_device_open所打开的gralloc设备的成员函数alloc和free分别被设置为Gralloc模块中的函数<strong>gralloc_alloc</strong>和<strong>gralloc_free</strong>，后面我们再详细分析它们的实现。</p>
<p>&#160; &#160; &#160; &#160;至此，gralloc设备的打开过程就分析完成了，接下来我们继续分析fb设备的打开过程。</p>
<h2 id="fb设备的打开过程"><a href="#fb设备的打开过程" class="headerlink" title="fb设备的打开过程"></a>fb设备的打开过程</h2><p>&#160; &#160; &#160; &#160;在Gralloc模块中，fb设备的ID值定义为<strong>GRALLOC_HARDWARE_FB0</strong>。GRALLOC_HARDWARE_FB0是一个宏，定义在文件hardware/libhardware/include/hardware/fb.h中， 如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_FB0 <span class="string">"fb0"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;fb设备使用结构体framebuffer_device_t 来描述。结构体framebuffer_device_t是用来描述系统帧缓冲区的信息，它定义在文件hardware/libhardware/include/hardware/fb.h中， 如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span> &#123;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">hw_device_t</span> common;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* flags describing some attributes of the framebuffer */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  flags;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* dimensions of the framebuffer in pixels */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  width;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  height;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* frambuffer stride in pixels */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       stride;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* framebuffer pixel format */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       format;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* resolution of the framebuffer's display panel in pixel per inch*/</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     xdpi;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     ydpi;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* framebuffer's display panel refresh rate in frames per second */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     fps;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* min swap interval supported by this framebuffer */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       minSwapInterval;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* max swap interval supported by this framebuffer */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       maxSwapInterval;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> reserved[<span class="number">8</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*setSwapInterval)(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* window,  </span><br><span class="line">            <span class="keyword">int</span> interval);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*setUpdateRect)(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* window,  </span><br><span class="line">            <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*post)(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*compositionComplete)(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* dev);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">8</span>];  </span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">framebuffer_device_t</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>成员变量flags用来记录系统帧缓冲区的标志，目前没有使用这成员变量，它的值被设置为0。</li>
<li>成员变量width和height分别用来描述设备显示屏的宽度和高度，它们是以像素为单位的。</li>
<li>成员变量stride用来描述设备显示屏的一行有多少个像素点。</li>
<li>成员变量format用来描述系统帧缓冲区的像素格式，支持的像素格式主要有HAL_PIXEL_FORMAT_RGBX_8888和HAL_PIXEL_FORMAT_RGB_565两种。HAL_PIXEL_FORMAT_RGBX_8888表示一个像素使用32位来描述，R、G和B分别占8位，另外8位未使用。HAL_PIXEL_FORMAT_RGB_565表示一个像素使用16位来描述，R、G和B分别占5、6和5位。</li>
<li>成员变量xdpi和ydpi分别用来描述设备显示屏在宽度和高度上的密度，即每英寸有多少个像素点。</li>
<li>成员变量fps用来描述设备显示屏的刷新频率，它的单位是帧每秒。</li>
<li>成员变量minSwapInterval和maxSwapInterval用来描述帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔。</li>
<li>成员变量reserved是保留给将来使用的。</li>
<li>成员函数setSwapInterval用来设置帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔。</li>
<li>成员函数setUpdateRect用来设置帧缓冲区的更新区域。</li>
<li>成员函数post用来将图形缓冲区buffer的内容渲染到帧缓冲区中去，即显示在设备的显示屏中去。</li>
<li>成员函数compositionComplete用来通知fb设备device，图形缓冲区的组合工作已经完成，目前没有使用这个成员函数。</li>
<li>成员变量reserved是一个函数指针数组，它们是保留给将来使用的。</li>
</ul>
<p>&#160; &#160; &#160; &#160;在结构体framebuffer_device_t的一系列成员函数中，<strong>post</strong>是最重要的一个成员函数，用户空间的应用程序通过调用这个成员函数就可以在设备的显示屏中渲染指定的画面，后面我们将详细讲这个函数的实现。</p>
<p>Gralloc模块在在文件hardware/libhardware/include/hardware/fb.h中定义了一个帮助函数<strong>framebuffer_open</strong>，用来打开fb设备，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** convenience API for opening and closing a supported device */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">framebuffer_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span>* module,</span><br><span class="line">        <span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> module-&gt;methods-&gt;open(module,</span><br><span class="line">            GRALLOC_HARDWARE_FB0, (<span class="keyword">struct</span> <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;参数module指向的是一个用来描述Gralloc模块的<strong>hw_module_t</strong>结构体，前面提到，它的成员变量methods所指向的一个hw_module_methods_t结构体的成员函数open指向了Gralloc模块中的函数<strong>gralloc_device_open</strong>，这个函数打开fb设备的代码段如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* module, <span class="keyword">const</span> <span class="keyword">char</span>* name,  </span><br><span class="line">        <span class="keyword">hw_device_t</span>** device)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        status = fb_device_open(module, name, device);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> status;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;参数name的值等于<strong>GRALLOC_HARDWARE_FB0</strong>，因此，函数gralloc_device_open接下来会调用另外一个函数<strong>fb_device_open</strong>来执行打开fb设备的操作。</p>
<p>&#160; &#160; &#160; &#160;函数<strong>fb_device_open</strong>定义在文件hardware/libhardware/modules/gralloc/framebuffer.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">fb_context_t</span> &#123;  </span><br><span class="line">    <span class="keyword">framebuffer_device_t</span>  device;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fb_device_open</span><span class="params">(<span class="keyword">hw_module_t</span> <span class="keyword">const</span>* module, <span class="keyword">const</span> <span class="keyword">char</span>* name,  </span><br><span class="line">        <span class="keyword">hw_device_t</span>** device)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL; </span><br><span class="line">    <span class="comment">//判断打开的是fb设备  </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_FB0)) &#123;  </span><br><span class="line">        <span class="keyword">alloc_device_t</span>* gralloc_device;  </span><br><span class="line">        <span class="comment">//打开gpu设备 </span></span><br><span class="line">        status = gralloc_open(module, &amp;gralloc_device);  </span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> status;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* initialize our state here */</span>  </span><br><span class="line">        <span class="comment">//创建一个fb_context_t对象，用来描述fb设备上下文  </span></span><br><span class="line">        <span class="keyword">fb_context_t</span> *dev = (<span class="keyword">fb_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));  </span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* initialize the procs */</span>  </span><br><span class="line">        <span class="comment">//初始化fb_context_t对象  </span></span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;  </span><br><span class="line">        dev-&gt;device.common.version = <span class="number">0</span>;  </span><br><span class="line">        dev-&gt;device.common.module = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(module);  </span><br><span class="line">        <span class="comment">//注册fb设备的操作函数 </span></span><br><span class="line">        dev-&gt;device.common.close = fb_close;  </span><br><span class="line">        dev-&gt;device.setSwapInterval = fb_setSwapInterval;  </span><br><span class="line">        dev-&gt;device.post            = fb_post;  </span><br><span class="line">        dev-&gt;device.setUpdateRect = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private_module_t</span>* m = (<span class="keyword">private_module_t</span>*)module;  </span><br><span class="line">        <span class="comment">//将fb映射到当前进程地址空间 </span></span><br><span class="line">        status = mapFrameBuffer(m);  </span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">int</span> stride = m-&gt;finfo.line_length / (m-&gt;info.bits_per_pixel &gt;&gt; <span class="number">3</span>);  </span><br><span class="line">            <span class="keyword">int</span> format = (m-&gt;info.bits_per_pixel == <span class="number">32</span>)  </span><br><span class="line">                         ? HAL_PIXEL_FORMAT_RGBX_8888  </span><br><span class="line">                         : HAL_PIXEL_FORMAT_RGB_565;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NO_32BPP  </span></span><br><span class="line">            format = HAL_PIXEL_FORMAT_RGB_565;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.flags) = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.stride) = stride;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.format) = format;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.minSwapInterval) = <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.maxSwapInterval) = <span class="number">1</span>;  </span><br><span class="line">            *device = &amp;dev-&gt;device.common;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> status;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1）这个函数主要是用来创建一个<strong>fb_context_t</strong>结构体，并且对它的成员变量<strong>device</strong>进行初始化。结构体fb_context_t的成员变量device的类型为<strong>framebuffer_device_t</strong>，前面提到，它是用来描述fb设备的。fb设备主要是用来渲染图形缓冲区的，这是通过调用它的成员函数post来实现的。从这里可以看出，函数fb_device_open所打开的fb设备的成员函数<strong>post</strong>被设置为Gralloc模块中的函数<strong>fb_post</strong>，后面我们再详细分析它的实现。</p>
<p>&#160; &#160; &#160; &#160;2）函数fb_device_open在打开fb设备的过程中，会调用另外一个函数<strong>mapFrameBuffer</strong>来获得系统帧缓冲区的信息，并且将这些信息保存在参数<strong>module</strong>所描述的一个<strong>private_module_t</strong>结构体的各个成员变量中。有了系统帧缓冲区的信息之后，函数fb_device_open接下来就可以对前面所打开的一个fb设备的各个成员变量进行初始化。这些成员变量的含义可以参考前面对结构体<strong>framebuffer_device_t</strong>的介绍。接下来我们只简单介绍一下结构体framebuffer_device_t的成员变量<strong>stride</strong>和<strong>format</strong>的初始化过程。</p>
<p>&#160; &#160; &#160; &#160;3）变量<strong>m</strong>的成员变量<strong>finfo</strong>的类型为<strong>fb_fix_screeninfo</strong>，它是在函数mapFrameBuffer中被始化的。fb_fix_screeninfo是在内核中定义的一个结构体，<strong>用来描述设备显示屏的固定属性信息</strong>，其中，它的成员变量<strong>line_length</strong>用来描述显示屏一行像素总共所占用的字节数。<br>&#160; &#160; &#160; &#160;变量m的另外一个成员变量<strong>info</strong>的类型为<strong>fb_var_screeninfo</strong>，它也是在函数mapFrameBuffer中被始化的。fb_var_screeninfo也是内核中定义的一个结构体，<strong>用来描述可以动态设置的显示屏属性信息</strong>，其中，它的成员变量<strong>bits_per_pixel</strong>用来描述显示屏每一个像素所占用的位数。<br>&#160; &#160; &#160; &#160;这样，我们将<strong>m-&gt;info.bits_per_pixel</strong>的值向右移3位，就可以得到显示屏每一个像素所占用的字节数。用显示屏每一个像素所占用的字节数去除显示屏一行像素总共所占用的字节数<strong>m-&gt;finfo.line_length</strong>，就可以得到显示屏一行有多少个像素点。这个值最终就可以保存在前面所打开的fb设备的成员变量<strong>stride</strong>中。<br>&#160; &#160; &#160; &#160;当显示屏每一个像素所占用的位数等于<strong>32</strong>的时候，那么前面所打开的fb设备的像素格式<strong>format</strong>就会被设置为HAL_PIXEL_FORMAT_RGBX_8888，否则的话，就会被设置为HAL_PIXEL_FORMAT_RGB_565。另一方面，如果在编译的时候定义了<strong>NO_32BPP</strong>宏，即不要使用32位来描述一个像素，那么函数fb_device_open就会强制将前面所打开的fb设备的像素格式format设置为HAL_PIXEL_FORMAT_RGB_565。</p>
<p>&#160; &#160; &#160; &#160;3）函数<strong>mapFrameBuffer</strong>除了用来获得系统帧缓冲区的信息之外，还会将系统帧缓冲区映射到当前进程的地址空间来。<strong>在Android系统中，Gralloc模块中的fb设备是由SurfaceFlinger服务来负责打开和管理的，而SurfaceFlinger服是运行System进程中的，因此，系统帧缓冲区实际上是映射到System进程的地址空间中的</strong>。</p>
<p>&#160; &#160; &#160; &#160;函数mapFrameBuffer实现在文件hardware/libhardware/modules/gralloc/framebuffer.cpp，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapFrameBuffer</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;module-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> err = mapFrameBufferLocked(module);</span><br><span class="line">    pthread_mutex_unlock(&amp;module-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数调用了同一个文件中的另外一个函数mapFrameBufferLocked来初始化参数module以及将系统帧缓冲区映射到当前进程的地址空间来。</p>
<h3 id="映射内存过程"><a href="#映射内存过程" class="headerlink" title="映射内存过程"></a>映射内存过程</h3><p>&#160; &#160; &#160; &#160;函数mapFrameBufferLocked的实现比较长，我们分段来阅读：<br>&#160; &#160; &#160; &#160;Part.1：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="comment">// already initialized...  </span></span><br><span class="line">    <span class="keyword">if</span> (module-&gt;framebuffer) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> device_template[] = &#123;  </span><br><span class="line">            <span class="string">"/dev/graphics/fb%u"</span>,  </span><br><span class="line">            <span class="string">"/dev/fb%u"</span>,  </span><br><span class="line">            <span class="number">0</span> &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> ((fd==<span class="number">-1</span>) &amp;&amp; device_template[i]) &#123;  </span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="number">64</span>, device_template[i], <span class="number">0</span>);  </span><br><span class="line">        fd = open(name, O_RDWR, <span class="number">0</span>);  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码在首先在系统中检查是否存在设备文件/dev/graphics/fb0或者/dev/fb0。如果存在的话，那么就调用函数open来打开它，并且将得到的文件描述符保存在变量fd中。这样，接下来函数mapFrameBufferLocked就可以通过文件描述符fd来与内核中的帧缓冲区驱动程序交互。</p>
<p>&#160; &#160; &#160; &#160;Part.2：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> fb_fix_screeninfo finfo;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> fb_var_screeninfo info;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这几行代码分别通过IO控制命令FBIOGET_FSCREENINFO和FBIOGET_VSCREENINFO来获得系统帧缓冲区的信息，分别保存在fb_fix_screeninfo结构体finfo和fb_var_screeninfo结构体info中。</p>
<p>&#160; &#160; &#160; &#160;Part.3：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    </span><br><span class="line">    info.reserved[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    info.reserved[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    info.reserved[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    info.xoffset = <span class="number">0</span>;</span><br><span class="line">    info.yoffset = <span class="number">0</span>;</span><br><span class="line">    info.activate = FB_ACTIVATE_NOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Request NUM_BUFFERS screens (at lest 2 for page flipping)</span><br><span class="line">     */</span></span><br><span class="line">    info.yres_virtual = info.yres * NUM_BUFFERS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = PAGE_FLIP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_PAN_DISPLAY  <span class="comment">// 0</span></span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOPAN_DISPLAY, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"FBIOPAN_DISPLAY failed, page flipping not supported"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOPUT_VSCREENINFO, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"FBIOPUT_VSCREENINFO failed, page flipping not supported"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        info.yres_virtual = info.yres;</span><br><span class="line">        flags &amp;= ~PAGE_FLIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.yres_virtual &lt; info.yres * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// we need at least 2 for page-flipping</span></span><br><span class="line">        info.yres_virtual = info.yres;</span><br><span class="line">        flags &amp;= ~PAGE_FLIP;</span><br><span class="line">        ALOGW(<span class="string">"page flipping not supported (yres_virtual=%d, requested=%d)"</span>,</span><br><span class="line">                info.yres_virtual, info.yres*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码主要是用来设置设备显示屏的虚拟分辨率。结构体<strong>fb_var_screeninfo</strong>的成员变量<strong>xres</strong>和<strong>yres</strong>用来描述显示屏的可视分辨率，而成员变量<strong>xres_virtual</strong>和<strong>yres_virtual</strong>用来描述显示屏的虚拟分辨率。这里保持可视分辨率以及虚拟分辨率的宽度值不变，而将虚拟分辨率的高度值设置为可视分辨率的高度值的<strong>NUM_BUFFERS</strong>倍。NUM_BUFFERS是一个宏，它的值被定义为<code>2</code>。这样，我们就可以将系统帧缓冲区划分为两个图形缓冲区来使用，即可以通过硬件来实现双缓冲技术。<br>&#160; &#160; &#160; &#160;在结构体fb_var_screeninfo中，与显示屏的可视分辨率和虚拟分辨率相关的另外两个成员变量是<strong>xoffset</strong>和<strong>yoffset</strong>，它们用来告诉帧缓冲区当前要渲染的图形缓冲区是哪一个。</p>
<p>&#160; &#160; &#160; &#160;这段代码最终是通过IO控制命令<strong>FBIOPUT_VSCREENINFO</strong>来设置设备显示屏的虚拟分辨率以及像素格式的。如果设置失败，即调用函数<strong>ioctl</strong>的返回值等于-1，那么很可能是因为系统帧缓冲区在硬件上不支持双缓冲，因此，接下来的代码就会重新将显示屏的虚拟分辨率的高度值设置为可视分辨率的高度值，并且将变量<strong>flags</strong>的<strong>PAGE_FLIP</strong>位置为0。<br>&#160; &#160; &#160; &#160;另一方面，如果调用函数ioctl成功，但是最终获得的显示屏的虚拟分辨率的高度值小于可视分辨率的高度值的2倍，那么也说明系统帧缓冲区在硬件上不支持双缓冲。在这种情况下，接下来的代码也会重新将显示屏的虚拟分辨率的高度值设置为可视分辨率的高度值，并且将变量flags的PAGE_FLIP位置为0。</p>
<p>&#160; &#160; &#160; &#160;Part.4：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == <span class="number">-1</span>)  </span><br><span class="line">    <span class="keyword">return</span> -errno;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">uint64_t</span>  refreshQuotient =  </span><br><span class="line">(  </span><br><span class="line">        <span class="keyword">uint64_t</span>( info.upper_margin + info.lower_margin + info.yres )  </span><br><span class="line">        * ( info.left_margin  + info.right_margin + info.xres )  </span><br><span class="line">        * info.pixclock  </span><br><span class="line">);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Beware, info.pixclock might be 0 under emulation, so avoid a </span><br><span class="line"> * division-by-0 here (SIGFPE on ARM) */</span>  </span><br><span class="line"><span class="keyword">int</span> refreshRate = refreshQuotient &gt; <span class="number">0</span> ? (<span class="keyword">int</span>)(<span class="number">1000000000000000L</span>LU / refreshQuotient) : <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (refreshRate == <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="comment">// bleagh, bad info from the driver  </span></span><br><span class="line">    refreshRate = <span class="number">60</span>*<span class="number">1000</span>;  <span class="comment">// 60 Hz  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码再次通过IO控制命令<strong>FBIOGET_VSCREENINFO</strong>来获得系统帧缓冲区的可变属性信息，并且保存在<strong>fb_var_screeninfo</strong>结构体<strong>info</strong>中，接下来再计算设备显示屏的刷新频率。</p>
<p>&#160; &#160; &#160; &#160;显示屏的刷新频率与显示屏的扫描时序相关。显示屏的扫描时序可以参考Kernel代码目录下的Documentation/fb/framebuffer.txt文件。我们结合这个txt文件中的一幅图来简单说明上述代码是如何计算显示屏的刷新频率的：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/framebuffer.jpg" alt="显示屏扫描时序示意图"></p>
<p>&#160; &#160; &#160; &#160;中间由xres和yres组成的区域即为显示屏的图形绘制区，在绘制区的上、下、左和右分别有四个边距upper_margin、lower_margin、left_margin和right_margin。此外，在显示屏的最右边以及最下边还有一个水平同步区域hsync_len和一个垂直同步区域vsync_len。电子枪按照从左到右、从上到下的顺序来显示屏中打点，从而可以将要渲染的图形显示在屏幕中。前面所提到的区域信息分别保存在fb_var_screnninfo结构体info的成员变量xres、yres、upper_margin、lower_margin、left_margin、right_margin、hsync_len和vsync_len。</p>
<p>&#160; &#160; &#160; &#160;电子枪每在xres和yres所组成的区域中打一个点所花费的时间记录在fb_var_screnninfo结构体info的成员变量pixclock，单位为pico seconds，即10E-12秒。</p>
<p>&#160; &#160; &#160; &#160;电子枪从左到右扫描完成一行之后，都会处理关闭状态，并且会重新折回到左边去。由于电子枪在从右到左折回的过程中不需要打点，因此，这个过程会比从左到右扫描屏幕的过程要快，这个折回的时间大概就等于在xres和yres所组成的区域扫描（left_margin+right_margin）个点的时间。这样，我们就可以认为每渲染一行需要的时间为（xres + left_margin + right_margin）* pixclock。</p>
<p>&#160; &#160; &#160; &#160;同样，电子枪从上到下扫描完成显示屏之后，需要从右下角折回到左上角去，折回的时间大概等于在xres和yres所组成的区域中扫描（upper_margin + lower_margin）行所需要的时间。这样，我们就可以认为每渲染一屏图形所需要的时间等于在xres和yres所组成的区域中扫描（yres + upper_margin + lower_margin）行所需要的时间。由于在xres和yres所组成的区域中扫描一行所需要的时间为（xres + left_margin + right_margin）<em> pixclock，因此，每渲染一屏图形所需要的总时间就等于（yres + upper_margin + lower_margin）</em> （xres + left_margin + right_margin）* pixclock。</p>
<p>&#160; &#160; &#160; &#160;每渲染一屏图形需要的总时间经过计算之后，就保存在变量refreshQuotient中。注意，变量refreshQuotient所描述的时间的单位为1E-12秒。这样，将变量refreshQuotient的值倒过来，就可以得到设备显示屏的刷新频率。将这个频率值乘以10E15次方之后，就得到一个单位为10E-3 HZ的刷新频率，保存在变量refreshRate中。</p>
<p>&#160; &#160; &#160; &#160;当Android系统在模拟器运行的时候，保存在fb_var_screnninfo结构体info的成员变量pixclock中的值可能等于0。在这种情况下，前面计算得到的变量refreshRate的值就会等于0。在这种情况下，接下来的代码会将变量refreshRate的值设置为60 <em> 1000 </em> 10E-3 HZ，即将显示屏的刷新频率设置为60HZ。</p>
<p>&#160; &#160; &#160; &#160;Part.5：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">int</span>(info.width) &lt;= <span class="number">0</span> || <span class="keyword">int</span>(info.height) &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="comment">// the driver doesn't return that information  </span></span><br><span class="line">    <span class="comment">// default to 160 dpi  </span></span><br><span class="line">    info.width  = ((info.xres * <span class="number">25.4f</span>)/<span class="number">160.0f</span> + <span class="number">0.5f</span>);  </span><br><span class="line">    info.height = ((info.yres * <span class="number">25.4f</span>)/<span class="number">160.0f</span> + <span class="number">0.5f</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">float</span> xdpi = (info.xres * <span class="number">25.4f</span>) / info.width;  </span><br><span class="line"><span class="keyword">float</span> ydpi = (info.yres * <span class="number">25.4f</span>) / info.height;  </span><br><span class="line"><span class="keyword">float</span> fps  = refreshRate / <span class="number">1000.0f</span>; </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码首先计算显示屏的密度，即每英寸有多少个像素点，分别宽度和高度两个维度，分别保存在变量xdpi和ydpi中。注意，fb_var_screeninfo结构体info的成员变量width和height用来描述显示屏的宽度和高度，它们是以<strong>毫米</strong>（mm）为单位的。<br>&#160; &#160; &#160; &#160;这段代码接着再将前面计算得到的显示屏刷新频率的单位由10E-3 HZ转换为HZ，即帧每秒，并且保存在变量fps中。</p>
<p>&#160; &#160; &#160; &#160;Part.6：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line">    ...Part<span class="number">.5</span>...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == <span class="number">-1</span>)  </span><br><span class="line">    <span class="keyword">return</span> -errno;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (finfo.smem_len &lt;= <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> -errno;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">module-&gt;flags = flags;  </span><br><span class="line">module-&gt;info = info;  </span><br><span class="line">module-&gt;finfo = finfo;  </span><br><span class="line">module-&gt;xdpi = xdpi;  </span><br><span class="line">module-&gt;ydpi = ydpi;  </span><br><span class="line">module-&gt;fps = fps;  </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码再次通过IO控制命令<strong>FBIOGET_FSCREENINFO</strong>来获得系统帧缓冲区的固定信息，并且保存在<strong>fb_fix_screeninfo</strong>结构体<strong>finfo</strong>中，接下来再使用fb_fix_screeninfo结构体finfo以及前面得到的系统帧缓冲区的其它信息来初始化参数<strong>module</strong>所描述的一个<strong>private_module_t</strong>结构体。</p>
<p>&#160; &#160; &#160; &#160;Part.7：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line">    ...Part<span class="number">.5</span>...</span><br><span class="line">    ...Part<span class="number">.6</span>...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">     * map the framebuffer </span><br><span class="line">     */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> err;  </span><br><span class="line">    <span class="keyword">size_t</span> fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);  </span><br><span class="line">    module-&gt;framebuffer = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(dup(fd), fbSize, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    module-&gt;numBuffers = info.yres_virtual / info.yres;  </span><br><span class="line">    module-&gt;bufferMask = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span>* vaddr = mmap(<span class="number">0</span>, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (vaddr == MAP_FAILED) &#123;  </span><br><span class="line">        LOGE(<span class="string">"Error mapping the framebuffer (%s)"</span>, strerror(errno));  </span><br><span class="line">        <span class="keyword">return</span> -errno;  </span><br><span class="line">    &#125;  </span><br><span class="line">    module-&gt;framebuffer-&gt;base = <span class="keyword">intptr_t</span>(vaddr);  </span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, fbSize);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;表达式<strong>finfo.line_length * info.yres_virtual</strong>计算的是整个系统帧缓冲区的大小，它的值等于显示屏行数（虚拟分辨率的高度值，<strong>info.yres_virtual</strong>）乘以每一行所占用的字节数（<strong>finfo.line_length</strong>）。函数<strong>roundUpToPageSize</strong>用来将整个系统帧缓冲区的大小对齐到页面边界。对齐后的大小保存在变量<strong>fbSize</strong>中。</p>
<p>&#160; &#160; &#160; &#160;表达式<strong>finfo.yres_virtual / info.yres</strong>计算的是整个系统帧缓冲区可以划分为多少个图形缓冲区来使用，这个数值保存在参数module所描述的一个private_module_t结构体的成员变量<strong>nmBuffers</strong>中。参数module所描述的一个private_module_t结构体的另外一个成员变量<strong>bufferMask</strong>的值接着被设置为0，表示系统帧缓冲区中的所有图形缓冲区都是处于空闲状态，即它们可以分配出去给应用程序使用。</p>
<p>&#160; &#160; &#160; &#160;系统帧缓冲区是通过调用函数<strong>mmap</strong>来映射到当前进程的地址空间来的。映射后得到的地址空间使用一个<strong>private_handle_t</strong>结构体来描述，这个结构体的成员变量<strong>base</strong>保存的即为系统帧缓冲区在当前进程的地址空间中的起始地址。这样，Gralloc模块以后就可以从这块地址空间中分配图形缓冲区给当前进程使用。</p>
<p>&#160; &#160; &#160; &#160;至此，fb设备的打开过程就分析完成了。在打开fb设备的过程中，Gralloc模块还完成了对系统帧缓冲区的初始化工作。接下来我们继续分析Gralloc模块是如何分配图形缓冲区给用户空间的应用程序使用的。</p>
<h2 id="分配图形缓冲区"><a href="#分配图形缓冲区" class="headerlink" title="分配图形缓冲区"></a>分配图形缓冲区</h2><p>&#160; &#160; &#160; &#160;前面提到，用户空间的应用程序用到的图形缓冲区是由Gralloc模块中的函数gralloc_alloc来分配的，这个函数实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">        <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,</span><br><span class="line">        <span class="keyword">buffer_handle_t</span>* pHandle, <span class="keyword">int</span>* pStride)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHandle || !pStride)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size, stride;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> align = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> bpp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (format) &#123;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBA_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBX_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_BGRA_8888:</span><br><span class="line">            bpp = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_888:</span><br><span class="line">            bpp = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_565:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW_SENSOR:</span><br><span class="line">            bpp = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> bpr = (w*bpp + (align<span class="number">-1</span>)) &amp; ~(align<span class="number">-1</span>);</span><br><span class="line">    size = bpr * h;</span><br><span class="line">    stride = bpr / bpp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> (usage &amp; GRALLOC_USAGE_HW_FB) &#123;</span><br><span class="line">        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = gralloc_alloc_buffer(dev, size, usage, pHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pStride = stride;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>参数format用来描述要分配的图形缓冲区的颜色格式。当format值等于HAL_PIXEL_FORMAT_RGBA_8888、HAL_PIXEL_FORMAT_RGBX_8888或者HAL_PIXEL_FORMAT_BGRA_8888的时候，一个像素需要使用32位来表示，即4个字节。当format值等于HAL_PIXEL_FORMAT_RGB_888的时候，一个像素需要使用24位来描述，即3个字节。当format值等于HAL_PIXEL_FORMAT_RGB_565、HAL_PIXEL_FORMAT_RGBA_5551或者HAL_PIXEL_FORMAT_RGBA_4444的时候，一个像需要使用16位来描述，即2个字节。最终一个像素需要使用的字节数保存在变量bpp中。</li>
<li>参数w表示要分配的图形缓冲区所保存的图像的宽度，将它乘以bpp，就可以得到保存一行像素所需要使用的字节数。我们需要将这个字节数对齐到4个字节边界，最后得到一行像素所需要的字节数就保存在变量bpr中。</li>
<li>参数h表示要分配的图形缓冲区所保存的图像的高度，将它乘以bpr，就可以得到保存整个图像所需要使用的字节数。</li>
<li>将变量bpr的值除以变量bpp的值，就得到要分配的图形缓冲区一行包含有多少个像素点，这个结果需要保存在输出参数pStride中，以便可以返回给调用者。</li>
<li>参数usage用来描述要分配的图形缓冲区的用途。如果是用来在系统帧缓冲区中渲染的，即参数usage的GRALLOC_USAGE_HW_FB位等于1，那么就必须要系统帧缓冲区中分配，否则的话，就在内存中分配。注意，在内存中分配的图形缓冲区，最终是需要拷贝到系统帧缓冲区去的，以便可以将它所描述的图形渲染出来。</li>
<li>函数gralloc_alloc_framebuffer用来在系统帧缓冲区中分配图形缓冲区，而函数gralloc_alloc_buffer用来在内存在分配图形缓冲区，接下来我们就分别分析这两个函数的实现。</li>
</ul>
<h3 id="系统帧缓冲区中分配图形缓冲区"><a href="#系统帧缓冲区中分配图形缓冲区" class="headerlink" title="系统帧缓冲区中分配图形缓冲区"></a>系统帧缓冲区中分配图形缓冲区</h3><p>&#160; &#160; &#160; &#160;函数gralloc_alloc_framebuffer实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc_framebuffer</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">        <span class="keyword">size_t</span> size, <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            dev-&gt;common.module);</span><br><span class="line">    pthread_mutex_lock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle);</span><br><span class="line">    pthread_mutex_unlock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数调用了另外一个函数gralloc_alloc_framebuffer_locked来分配图形缓冲区。函数gralloc_alloc_framebuffer_locked也是实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc_framebuffer_locked</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">        <span class="keyword">size_t</span> size, <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            dev-&gt;common.module);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate the framebuffer</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;framebuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// initialize the framebuffer, the framebuffer is mapped once</span></span><br><span class="line">        <span class="comment">// and forever.</span></span><br><span class="line">        <span class="keyword">int</span> err = mapFrameBufferLocked(m);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> bufferMask = m-&gt;bufferMask;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> numBuffers = m-&gt;numBuffers;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line">    <span class="keyword">if</span> (numBuffers == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// If we have only one buffer, we never use page-flipping. Instead,</span></span><br><span class="line">        <span class="comment">// we return a regular buffer which will be memcpy'ed to the main</span></span><br><span class="line">        <span class="comment">// screen when post is called.</span></span><br><span class="line">        <span class="keyword">int</span> newUsage = (usage &amp; ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;</span><br><span class="line">        <span class="keyword">return</span> gralloc_alloc_buffer(dev, bufferSize, newUsage, pHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferMask &gt;= ((<span class="number">1L</span>U&lt;&lt;numBuffers)<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="comment">// We ran out of buffers.</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a "fake" handles for it</span></span><br><span class="line">    <span class="keyword">intptr_t</span> vaddr = <span class="keyword">intptr_t</span>(m-&gt;framebuffer-&gt;base);</span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(dup(m-&gt;framebuffer-&gt;fd), size,</span><br><span class="line">            <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find a free slot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i=<span class="number">0</span> ; i&lt;numBuffers ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((bufferMask &amp; (<span class="number">1L</span>U&lt;&lt;i)) == <span class="number">0</span>) &#123;</span><br><span class="line">            m-&gt;bufferMask |= (<span class="number">1L</span>U&lt;&lt;i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vaddr += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hnd-&gt;base = vaddr;</span><br><span class="line">    hnd-&gt;offset = vaddr - <span class="keyword">intptr_t</span>(m-&gt;framebuffer-&gt;base);</span><br><span class="line">    *pHandle = hnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在系统帧缓冲区分配图形缓冲区之前，首先要对系统帧缓冲区进行过初始化，即这里的变量<strong>m</strong>所指向的一个<strong>private_module_t</strong>结构体的成员变量<strong>framebuffer</strong>的值不能等于NULL。如果等于NULL的话，那么就必须要调用另外一个函数<strong>mapFrameBufferLocked</strong>来初始化系统帧缓冲区。初始化系统帧缓冲区的过程可以参考前面的内容。</p>
<p>&#160; &#160; &#160; &#160;变量<strong>bufferMask</strong>用来描述系统帧缓冲区的使用情况，而变量<strong>numBuffers</strong>用来描述系统帧缓冲区可以划分为多少个图形缓冲区来使用，另外一个变量<strong>bufferSize</strong>用来描述设备显示屏一屏内容所占用的内存的大小。</p>
<p>&#160; &#160; &#160; &#160;如果系统帧缓冲区只有一个图形缓冲区大小，即变量numBuffers的值等于1，那么这个图形缓冲区就始终用作系统主图形缓冲区来使用。在这种情况下，我们就不能够在系统帧缓冲区中分配图形缓冲区来给用户空间的应用程序使用，因此，<strong>这时候就会转向内存中来分配图形缓冲区</strong>，即调用函数<strong>gralloc_alloc_buffer</strong>来分配图形缓冲区。注意，<strong>这时候分配的图形缓冲区的大小为一屏内容的大小，即bufferSize</strong>。</p>
<p>&#160; &#160; &#160; &#160;如果bufferMask的值大于等于((1LU&lt;&lt;numBuffers)-1)的值，那么就说明系统帧缓冲区中的图形缓冲区全部都分配出去了，这时候分配图形缓冲区就失败了。例如，假设图形缓冲区的个数为2，那么((1LU&lt;&lt;numBuffers)-1)的值就等于3，即二制制0x11。如果这时候bufferMask的值也等于0x11，那么就表示第一个和第二个图形缓冲区都已经分配出去了。因此，这时候就不能再在系统帧缓冲区中分配图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;假设此时系统帧缓冲区中尚有空闲的图形缓冲区的，接下来函数就会创建一个private_handle_t结构体<strong>hnd</strong>来描述这个即将要分配出去的图形缓冲区。注意，这个图形缓冲区的标志值等于<strong>PRIV_FLAGS_FRAMEBUFFER</strong>，即表示这是一块在系统帧缓冲区中分配的图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;接下来的for循环从低位到高位检查变量bufferMask的值，并且找到第一个值等于0的位，这样就可以知道在系统帧缓冲区中，第几个图形缓冲区的是空闲的。注意，变量<strong>vadrr</strong>的值开始的时候指向系统帧缓冲区的基地址，在下面的for循环中，每循环一次它的值都会增加bufferSize。从这里就可以看出，每次从系统帧缓冲区中分配出去的图形缓冲区的大小都是刚好等于显示屏一屏内容大小的。</p>
<p>&#160; &#160; &#160; &#160;最后分配出去的图形缓冲区的开始地址就保存在前面所创建的private_handle_t结构体<strong>hnd</strong>的成员变量<strong>base</strong>中，这样，用户空间的应用程序就可以直接将要渲染的图形内容拷贝到这个地址上去，这就相当于是直接将图形渲染到系统帧缓冲区中去。</p>
<p>&#160; &#160; &#160; &#160;在将private_handle_t结构体hnd返回给调用者之前，还需要设置它的成员变量<strong>offset</strong>，以便可以知道它所描述的图形缓冲区的起始地址相对于系统帧缓冲区的基地址的偏移量。</p>
<p>&#160; &#160; &#160; &#160;至此，在系统帧缓冲区中分配图形缓冲区的过程就分析完成了，接下来我们再分析在内存在分析图形缓冲区的过程，即分析函数<strong>gralloc_alloc_buffer</strong>的实现。</p>
<h3 id="内存中分配图形缓冲区"><a href="#内存中分配图形缓冲区" class="headerlink" title="内存中分配图形缓冲区"></a>内存中分配图形缓冲区</h3><p> &#160; &#160; &#160; &#160;函数gralloc_alloc_buffer也是实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc_buffer</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,  </span><br><span class="line">        <span class="keyword">size_t</span> size, <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;  </span><br><span class="line">  </span><br><span class="line">    size = roundUpToPageSize(size);  </span><br><span class="line">  </span><br><span class="line">    fd = ashmem_create_region(<span class="string">"gralloc-buffer"</span>, size);  </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        LOGE(<span class="string">"couldn't create ashmem (%s)"</span>, strerror(-errno));  </span><br><span class="line">        err = -errno;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">private_handle_t</span>* hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(fd, size, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">gralloc_module_t</span>* module = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc_module_t</span>*&gt;(  </span><br><span class="line">                dev-&gt;common.module);  </span><br><span class="line">        err = mapBuffer(module, hnd);  </span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;  </span><br><span class="line">            *pHandle = hnd;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    LOGE_IF(err, <span class="string">"gralloc failed err=%s"</span>, strerror(-err));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> err;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;这个函数的实现很简单，它首先调用函数<strong>ashmem_create_region</strong>来创建一块匿名共享内存，接着再在这块匿名共享内存上分配一个图形缓冲区。注意，这个图形缓冲区也是使用一个private_handle_t结构体来描述的，不过这个图形缓冲区的标志值等于0，以区别于在系统帧缓冲区中分配的图形缓冲区。匿名共享内存的知识还没有入坑，以后再看。。。。。。</p>
<p> &#160; &#160; &#160; &#160;从匿名共享内存中分配的图形缓冲区还需要映射到进程的地址空间来，然后才可以使用，这是通过调用函数mapBuffer来实现的。</p>
<p> &#160; &#160; &#160; &#160;函数mapBuffer实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapBuffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,</span><br><span class="line">        <span class="keyword">private_handle_t</span>* hnd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">    <span class="keyword">return</span> gralloc_map(module, hnd, &amp;vaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;它通过调用另外一个函数<strong>gralloc_map</strong>来将参数hnd所描述的一个图形缓冲区映射到当前进程的地址空间来。后面在分析图形缓冲区的注册过程时，我们再分析函数gralloc_map的实现。</p>
<p> &#160; &#160; &#160; &#160;<strong>注意，在Android系统中，在系统帧缓冲区中分配的图形缓冲区是在SurfaceFlinger服务中使用的，而在内存中分配的图形缓冲区既可以在SurfaceFlinger服务中使用，也可以在其它的应用程序中使用。当其它的应用程序需要使用图形缓冲区的时候，它们就会请求SurfaceFlinger服务为它们分配，因此，对于其它的应用程序来说，它们只需要将SurfaceFlinger服务返回来的图形缓冲区映射到自己的进程地址空间来使用就可以了，这就是后面我们所要分析的图形缓冲区的注册过程</strong>。</p>
<p>&#160; &#160; &#160; &#160;至此，图形缓冲区的分配过程就分析完成了，接下来我们继续分析图形缓冲区的释放过程。</p>
<h2 id="图形缓冲区的释放过程"><a href="#图形缓冲区的释放过程" class="headerlink" title="图形缓冲区的释放过程"></a>图形缓冲区的释放过程</h2><p>&#160; &#160; &#160; &#160;前面提到，用户空间的应用程序用到的图形缓冲区是由Gralloc模块中的函数gralloc_free来释放的，这个函数实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_free</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private_handle_t</span> <span class="keyword">const</span>* hnd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_handle_t</span> <span class="keyword">const</span>*&gt;(handle);</span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &#123;</span><br><span class="line">        <span class="comment">// free this buffer</span></span><br><span class="line">        <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">                dev-&gt;common.module);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line">        <span class="keyword">int</span> index = (hnd-&gt;base - m-&gt;framebuffer-&gt;base) / bufferSize;</span><br><span class="line">        m-&gt;bufferMask &amp;= ~(<span class="number">1</span>&lt;&lt;index); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">gralloc_module_t</span>* module = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc_module_t</span>*&gt;(</span><br><span class="line">                dev-&gt;common.module);</span><br><span class="line">        terminateBuffer(module, <span class="keyword">const_cast</span>&lt;<span class="keyword">private_handle_t</span>*&gt;(hnd));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(hnd-&gt;fd);</span><br><span class="line">    <span class="keyword">delete</span> hnd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;要释放的图形缓冲区使用参数<strong>handle</strong>来描述。前面提到，从Gralloc模块中分配的图形缓冲区是使用private_handle_t结构体来描述的，因此，这里的参数handle应该指向一个<strong>private_handle_t</strong>结构体，这是通过调用private_handle_t类的静态成员函数<strong>validate</strong>来验证的。private_handle_t类的静态成员函数validate的实现可以参考前面的内容。</p>
<p>&#160; &#160; &#160; &#160;要释放的图形缓冲区有可能是在系统帧缓冲区分配的，也有可能是在内存中分配的，这可以通过检查它的标志值flags的<strong>PRIV_FLAGS_FRAMEBUFFER</strong>位是否等于1来确认。</p>
<p>&#160; &#160; &#160; &#160;如果要释放的图形缓冲区是在系统帧缓冲区中分配的，那么首先要知道这个图形缓冲区是系统帧缓冲区的第<strong>index</strong>个位置，接着再将变量m所描述的一个private_module_t结构体的成员变量<strong>bufferMask</strong>的第index位重置为0即可。我们只需要将要释放的图形缓冲区的开始地址减去系统帧缓冲区的基地址，再除以一个图形缓冲区的大小，就可以知道要释放的图形缓冲区是系统帧缓冲区的第几个位置。这个过程刚好是在系统帧缓冲区中分配图形缓冲区的逆操作。</p>
<p>&#160; &#160; &#160; &#160;如果要释放的图形缓冲区是内存中分配的，那么只需要调用另外一个函数<strong>terminateBuffer</strong>来解除要释放的图形缓冲区在当前进程的地址空间中的映射。</p>
<p>&#160; &#160; &#160; &#160;最后，这个函数还会将用来描述要释放的图形缓冲区的private_handle_t结构体所占用的内存释放掉，并且将要要释放的图形缓冲区所在的系统帧缓冲区或者匿名共享内存的文件描述符关闭掉。</p>
<p>&#160; &#160; &#160; &#160;函数terminateBuffer实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">terminateBuffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">private_handle_t</span>* hnd)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;base) &#123;  </span><br><span class="line">        <span class="comment">// this buffer was mapped, unmap it now  </span></span><br><span class="line">        gralloc_unmap(module, hnd);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它通过调用另外一个函数<strong>gralloc_unmap</strong>来解除参数hnd所描述的一个图形缓冲区在当前进程的地址空间中的映射。后面在分析图形缓冲区的注销过程时，我们再详细分析函数gralloc_unmap的实现。</p>
<p>&#160; &#160; &#160; &#160;至此，图形缓冲区的释放过程就分析完成了，接下来我们继续分析图形缓冲区的注册过程。</p>
<h2 id="图形缓冲区的注册过程"><a href="#图形缓冲区的注册过程" class="headerlink" title="图形缓冲区的注册过程"></a>图形缓冲区的注册过程</h2><p>&#160; &#160; &#160; &#160;<strong>前面提到，在Android系统中，所有的图形缓冲区都是由SurfaceFlinger服务分配的，而当一个图形缓冲区被分配的时候，它会同时被映射到请求分配的进程的地址空间去，即分配的过程同时也包含了注册的过程。但是对用户空间的其它的应用程序来说，它们所需要的图形缓冲区是在由SurfaceFlinger服务分配的，因此，当它们得到SurfaceFlinger服务分配的图形缓冲区之后，还需要将这块图形缓冲区映射到自己的地址空间来，以便可以使用这块图形缓冲区。这个映射的过程即为我们接下来要分析的图形缓冲区注册过程</strong>。</p>
<p>&#160; &#160; &#160; &#160;前面还提到，注册图形缓冲区的操作是由Gralloc模块中的函数<strong>gralloc_register_buffer</strong>来实现的，这个函数实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_register_buffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// if this handle was created in this process, then we keep it as is.  </span></span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;pid != getpid()) &#123;  </span><br><span class="line">        <span class="keyword">void</span> *vaddr;  </span><br><span class="line">        err = gralloc_map(module, handle, &amp;vaddr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> err;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数首先验证参数<strong>handle</strong>指向的一块图形缓冲区的确是由Gralloc模块分配的，方法是调用private_handle_t类的静态成员函数validate来验证，即如果参数handle指向的是一个private_handle_t结构体，那么它所指向的一块图形缓冲区就是由Gralloc模块分配的。</p>
<p>&#160; &#160; &#160; &#160;通过了上面的检查之后，函数<strong>gralloc_register_buffer</strong>还需要检查当前进程是否就是请求Gralloc模块分配图形缓冲区hnd的进程。如果是的话，那么当前进程在请求Gralloc模块分配图形缓冲区hnd的时候，就已经将图形缓冲区hnd映射进自己的地址空间来了，因此，这时候就不需要重复在当前进程中注册这个图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;真正执行注册图形缓冲区的操作是由函数<strong>gralloc_map</strong>来实现的，这个函数也是实现文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_map</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle,  </span><br><span class="line">        <span class="keyword">void</span>** vaddr)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    <span class="keyword">if</span> (!(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER)) &#123;  </span><br><span class="line">        <span class="keyword">size_t</span> size = hnd-&gt;size;  </span><br><span class="line">        <span class="keyword">void</span>* mappedAddress = mmap(<span class="number">0</span>, size,  </span><br><span class="line">                PROT_READ|PROT_WRITE, MAP_SHARED, hnd-&gt;fd, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span> (mappedAddress == MAP_FAILED) &#123;  </span><br><span class="line">            LOGE(<span class="string">"Could not mmap %s"</span>, strerror(errno));  </span><br><span class="line">            <span class="keyword">return</span> -errno;  </span><br><span class="line">        &#125;  </span><br><span class="line">        hnd-&gt;base = <span class="keyword">intptr_t</span>(mappedAddress) + hnd-&gt;offset;  </span><br><span class="line">        <span class="comment">//LOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p",  </span></span><br><span class="line">        <span class="comment">//        hnd-&gt;fd, hnd-&gt;offset, hnd-&gt;size, mappedAddress);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    *vaddr = (<span class="keyword">void</span>*)hnd-&gt;base;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;由于在系统帧缓冲区中分配的图形缓冲区只在SurfaceFlinger服务中使用，而SurfaceFlinger服务在初始化系统帧缓冲区的时候，已经将系统帧缓冲区映射到自己所在的进程中来了，因此，函数gralloc_map如果发现要注册的图形缓冲区是在系统帧缓冲区分配的时候，那么就不需要再执行映射图形缓冲区的操作了。</p>
<p>&#160; &#160; &#160; &#160;如果要注册的图形缓冲区是在内存中分配的，即它的标志值flags的PRIV_FLAGS_FRAMEBUFFER位等于1，那么接下来就需要将它映射到当前进程的地址空间来了。<strong>由于要注册的图形缓冲区是在文件描述符hnd-&gt;fd所描述的一块匿名共享内存中分配的，因此，我们只需要将文件描述符hnd-&gt;fd所描述的一块匿名共享内存映射到当前进程的地址空间来，就可以将参数hnd所描述的一个图形缓冲区映射到当前进程的地址空间来</strong>。</p>
<p>&#160; &#160; &#160; &#160;由于映射文件描述符hnd-&gt;fd得到的是一整块匿名共享内存在当前进程地址空间的基地址，而要注册的图形缓冲区可能只占据这块匿名共享内存的某一小部分，因此，我们还需要将要注册的图形缓冲区的在被映射的匿名共享内存中的偏移量<strong>hnd-&gt;offset</strong>加上被映射的匿名共享内存的基地址<strong>hnd-&gt;base</strong>，才可以得到要注册的图形缓冲区在当前进程中的访问地址，这个地址最终又被写入到<strong>hnd-&gt;base</strong>中去。</p>
<p>&#160; &#160; &#160; &#160;注册图形缓冲区的过程就是这么简单，接下来我们再分析图形缓冲区的注销过程。</p>
<h2 id="图形缓冲区的注销过程"><a href="#图形缓冲区的注销过程" class="headerlink" title="图形缓冲区的注销过程"></a>图形缓冲区的注销过程</h2><p>&#160; &#160; &#160; &#160;图形缓冲区使用完成之后，就需要从当前进程中注销。前面提到，注销图形缓冲区是由Gralloc模块中的函数<strong>gralloc_unregister_buffer</strong>来实现的，这个函数实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_unregister_buffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// never unmap buffers that were created in this process  </span></span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;pid != getpid()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (hnd-&gt;base) &#123;  </span><br><span class="line">            gralloc_unmap(module, handle);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数同样是首先调用private_handle_t类的静态成员函数validate来验证参数handle指向的一块图形缓冲区的确是由Gralloc模块分配的，接着再将将参数handle指向的一块图形缓冲区转换为一个private_handle_t结构体hnd来访问。</p>
<p>&#160; &#160; &#160; &#160;一块图形缓冲区只有被注册过，即被Gralloc模块中的函数gralloc_register_buffer注册过，才需要注销，而由函数gralloc_register_buffer注册的图形缓冲区都不是由当前进程分配的，因此，当前进程在注销一个图形缓冲区的时候，会检查要注销的图形缓冲区是否是由自己分配的。如果是由自己分配的话，那么它什么也不做就返回了。</p>
<p>&#160; &#160; &#160; &#160;假设要注销的图形缓冲区hnd不是由当前进程分配的，那么接下来就会调用另外一个函数<strong>galloc_unmap</strong>来注销图形缓冲区hnd。函数galloc_unmap也是实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_unmap</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    <span class="keyword">if</span> (!(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER)) &#123;  </span><br><span class="line">        <span class="keyword">void</span>* base = (<span class="keyword">void</span>*)hnd-&gt;base;  </span><br><span class="line">        <span class="keyword">size_t</span> size = hnd-&gt;size;  </span><br><span class="line">        <span class="comment">//LOGD("unmapping from %p, size=%d", base, size);  </span></span><br><span class="line">        <span class="keyword">if</span> (munmap(base, size) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            LOGE(<span class="string">"Could not unmap %s"</span>, strerror(errno));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    hnd-&gt;base = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数的实现与前面所分析的函数gralloc_map的实现是类似的，只不过它执行的是相反的操作，即将解除一个指定的图形缓冲区在当前进程的地址空间中的映射，从而完成对这个图形缓冲区的注销工作。</p>
<p>&#160; &#160; &#160; &#160;这样，图形缓冲区的注销过程就分析完成了，接下来我们再继续分析一个图形缓冲区是如何被渲染到系统帧缓冲区去的，即它的内容是如何绘制在设备显示屏中的。</p>
<h2 id="图形缓冲区的渲染过程"><a href="#图形缓冲区的渲染过程" class="headerlink" title="图形缓冲区的渲染过程"></a>图形缓冲区的渲染过程</h2><p>&#160; &#160; &#160; &#160;用户空间的应用程序将画面内容写入到图形缓冲区中去之后，还需要将图形缓冲区渲染到系统帧缓冲区中去，这样才可以把画面绘制到设备显示屏中去。前面提到，渲染图形缓冲区是由Gralloc模块中的函数<strong>fb_post</strong>来实现的，这个函数实现在文件hardware/libhardware/modules/gralloc/framebuffer.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fb_post</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(buffer) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">fb_context_t</span>* ctx = (<span class="keyword">fb_context_t</span>*)dev;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private_handle_t</span> <span class="keyword">const</span>* hnd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_handle_t</span> <span class="keyword">const</span>*&gt;(buffer);  </span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(  </span><br><span class="line">            dev-&gt;common.module);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> offset = hnd-&gt;base - m-&gt;framebuffer-&gt;base;  </span><br><span class="line">        m-&gt;info.activate = FB_ACTIVATE_VBL;  </span><br><span class="line">        m-&gt;info.yoffset = offset / m-&gt;finfo.line_length;  </span><br><span class="line">        <span class="keyword">if</span> (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPUT_VSCREENINFO, &amp;m-&gt;info) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            LOGE(<span class="string">"FBIOPUT_VSCREENINFO failed"</span>);  </span><br><span class="line">            m-&gt;base.unlock(&amp;m-&gt;base, buffer);  </span><br><span class="line">            <span class="keyword">return</span> -errno;  </span><br><span class="line">        &#125;  </span><br><span class="line">        m-&gt;currentBuffer = buffer;  </span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// If we can't do the page_flip, just copy the buffer to the front   </span></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> use copybit HAL instead of memcpy  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">void</span>* fb_vaddr;  </span><br><span class="line">        <span class="keyword">void</span>* buffer_vaddr;  </span><br><span class="line">  </span><br><span class="line">        m-&gt;base.lock(&amp;m-&gt;base, m-&gt;framebuffer,  </span><br><span class="line">                GRALLOC_USAGE_SW_WRITE_RARELY,  </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, m-&gt;info.xres, m-&gt;info.yres,  </span><br><span class="line">                &amp;fb_vaddr);  </span><br><span class="line">  </span><br><span class="line">        m-&gt;base.lock(&amp;m-&gt;base, buffer,  </span><br><span class="line">                GRALLOC_USAGE_SW_READ_RARELY,  </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, m-&gt;info.xres, m-&gt;info.yres,  </span><br><span class="line">                &amp;buffer_vaddr);  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">memcpy</span>(fb_vaddr, buffer_vaddr, m-&gt;finfo.line_length * m-&gt;info.yres);  </span><br><span class="line">  </span><br><span class="line">        m-&gt;base.unlock(&amp;m-&gt;base, buffer);  </span><br><span class="line">        m-&gt;base.unlock(&amp;m-&gt;base, m-&gt;framebuffer);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1）参数buffer用来描述要渲染的图形缓冲区，它指向的必须要是一个private_handle_t结构体，这是通过调用private_handle_t类的静态成员函数validate来验证的。验证通过之后，就可以将参数buffer所描述的一个buffer_handle_t结构体转换成一个private_handle_t结构体hnd。</p>
<p>&#160; &#160; &#160; &#160;参数<strong>*dev</strong>用来描述在Gralloc模块中的一个fb设备。从前面的内容可以知道，在打开fb设备的时候，Gralloc模块返回给调用者的实际上是一个fb_context_t结构体，因此，这里就可以将参数dev所描述的一个framebuffer_device_t结构体转换成一个<strong>fb_context_t</strong>结构体ctx。</p>
<p>&#160; &#160; &#160; &#160;参数dev的成员变量<strong>common</strong>指向了一个<strong>hw_device_t</strong>结构体，这个结构体的成员变量<strong>module</strong>指向了一个Gralloc模块。从前面的内容可以知道，一个Gralloc模块是使用一个<strong>private_module_t</strong>结构体来描述的，因此，我们可以将<strong>dev-&gt;common.moudle</strong>转换成一个private_module_t结构体m。</p>
<p>&#160; &#160; &#160; &#160;2）由于private_handle_t结构体hnd所描述的图形缓冲区可能是在系统帧缓冲区分配的，也有可能是内存中分配的，因此，我们分两种情况来讨论图形缓冲区渲染过程。</p>
<p>&#160; &#160; &#160; &#160;当private_handle_t结构体hnd所描述的图形缓冲区是在系统帧缓冲区中分配的时候，即这个图形缓冲区的标志值flags的PRIV_FLAGS_FRAMEBUFFER位等于1的时候，我们是不需要将图形缓冲区的内容拷贝到系统帧缓冲区去的，因为我们将内容写入到图形缓冲区的时候，已经相当于是将内容写入到了系统帧缓冲区中去了。虽然在这种情况下，我们不需要将图形缓冲区的内容拷贝到系统帧缓冲区去，但是我们需要告诉系统帧缓冲区设备将要渲染的图形缓冲区作为系统当前的输出图形缓冲区，这样才可以将要渲染的图形缓冲区的内容绘制到设备显示屏来。例如，假设系统帧缓冲区有2个图形缓冲区，当前是以第1个图形缓冲区作为输出图形缓冲区的，这时候如果我们需要渲染第2个图形缓冲区，那么就必须告诉系统帧绘冲区设备，将第2个图形缓冲区作为输出图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;设置系统帧缓冲区的当前输出图形缓冲区是通过IO控制命令FBIOPUT_VSCREENINFO来进行的。IO控制命令FBIOPUT_VSCREENINFO需要一个fb_var_screeninfo结构体作为参数。从前面的内容可以知道，private_module_t结构体m的成员变量<strong>info</strong>正好保存在我们所需要的这个fb_var_screeninfo结构体。有了个m-&gt;info这个fb_var_screeninfo结构体之后，我们只需要设置好它的成员变量<strong>yoffset</strong>的值（不用设置成员变量<strong>xoffset</strong>的值是因为所有的图形缓冲区的宽度是相等的），就可以将要渲染的图形缓冲区设置为系统帧缓冲区的当前输出图形缓冲区。fb_var_screeninfo结构体的成员变量<strong>yoffset</strong>保存的是当前输出图形缓冲区在整个系统帧缓冲区的纵向偏移量，即Y偏移量。我们只需要将要渲染的图形缓冲区的开始地址<strong>hnd-&gt;base</strong>的值减去系统帧缓冲区的基地址<strong>m-&gt;framebuffer-&gt;base</strong>的值，再除以图形缓冲区一行所占据的字节数<strong>m-&gt;finfo.line_length</strong>，就可以得到所需要的Y偏移量。</p>
<p>&#160; &#160; &#160; &#160;在执行IO控制命令FBIOPUT_VSCREENINFO之前，还会将作为参数的fb_var_screeninfo结构体的成员变量<strong>activate</strong>的值设置<strong>FB_ACTIVATE_VBL</strong>，表示要等到下一个垂直同步事件出现时，再将当前要渲染的图形缓冲区的内容绘制出来。这样做的目的是避免出现屏幕闪烁，即避免前后两个图形缓冲区的内容各有一部分同时出现屏幕中。</p>
<p>&#160; &#160; &#160; &#160;成功地执行完成IO控制命令FBIOPUT_VSCREENINFO之后，函数还会将当前被渲染的图形缓冲区保存在private_module_t结构体m的成员变量<strong>currentBuffer</strong>中，以便可以记录当前被渲染的图形缓冲区是哪一个。</p>
<p>&#160; &#160; &#160; &#160;当private_handle_t结构体hnd所描述的图形缓冲区是在内存中分配的时候，即这个图形缓冲区的标志值flags的PRIV_FLAGS_FRAMEBUFFER位等于0的时候，我们就需要将它的内容拷贝到系统帧缓冲区中去了。这个拷贝的工作是通过调用函数<strong>memcpy</strong>来完成的。在拷贝之前，我们需要<strong>三个参数</strong>。第一个参数是要渲染的图形缓冲区的起址地址，这个地址保存在参数<strong>buffer</strong>所指向的一个private_handle_t结构体中。第二个参数是要系统帧缓冲区的基地址，这个地址保存在private_module_t结构体m的成员变量framebuffer所指向的一个private_handle_t结构体中。第三个参数是要拷贝的内容的大小，这个大小就刚好是一个屏幕像素所占据的内存的大小。屏幕高度由m-&gt;info.yres来描述，而一行屏幕像素所占用的字节数由m-&gt;finfo.line_length来描述，将这两者相乘，就可以得到一个屏幕像素所占据的内存的大小。</p>
<p>&#160; &#160; &#160; &#160;3）在将一块内存缓冲区的内容拷贝到系统帧缓冲区中去之前，需要对这两块缓冲区进行锁定，以保证在拷贝的过程中，这两块缓冲区的内容不会被修改。这个锁定的工作是由Gralloc模块中的函数<strong>gralloc_lock</strong>来实现的。从前面第1部分的内容可以知道，Gralloc模块中的函数gralloc_lock的地址正好就保存在private_module_t结构体m的成员变量base所描述的一个gralloc_module_t结构体的成员函数lock中。</p>
<p>&#160; &#160; &#160; &#160;在调用函数gralloc_lock来锁定一块缓冲区之后，还可以通过最后一个输出参数来获得被锁定的缓冲区的开始地址，因此，通过调用函数gralloc_lock来锁定要渲染的图形缓冲区以及系统帧缓冲区，就可以得到前面所需要的第一个和第二个参数。</p>
<p>&#160; &#160; &#160; &#160;将要渲染的图形缓冲区的内容拷贝到系统帧缓冲区之后，就可以解除前面对它们的锁定了，这个解锁的工作是由Gralloc模块中的函数<strong>gralloc_unlock</strong>来实现的。从前面第1部分的内容可以知道，Gralloc模块中的函数gralloc_unlock的地址正好就保存在private_module_t结构体m的成员变量base所描述的一个gralloc_module_t结构体的成员函数unlock中。</p>
<p>&#160; &#160; &#160; &#160;这样，一个图形缓冲区的渲染过程就分析完成了。</p>
<h3 id="图形缓冲区的锁定和解锁"><a href="#图形缓冲区的锁定和解锁" class="headerlink" title="图形缓冲区的锁定和解锁"></a>图形缓冲区的锁定和解锁</h3><p>&#160; &#160; &#160; &#160;为了完整性起见，最后我们再简要分析函数gralloc_lock和gralloc_unlock的实现，以便可以了解一个图形缓冲区的锁定和解锁操作是如何实现的。</p>
<p>&#160; &#160; &#160; &#160;1）图形缓冲区的锁定：<br>&#160; &#160; &#160; &#160;函数gralloc_lock实现在文件hardware/libhardware/modules/gralloc/mapper.cpp文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_lock</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle, <span class="keyword">int</span> usage,  </span><br><span class="line">        <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> h,  </span><br><span class="line">        <span class="keyword">void</span>** vaddr)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="comment">// this is called when a buffer is being locked for software  </span></span><br><span class="line">    <span class="comment">// access. in thin implementation we have nothing to do since  </span></span><br><span class="line">    <span class="comment">// not synchronization with the h/w is needed.  </span></span><br><span class="line">    <span class="comment">// typically this is used to wait for the h/w to finish with  </span></span><br><span class="line">    <span class="comment">// this buffer if relevant. the data cache may need to be  </span></span><br><span class="line">    <span class="comment">// flushed or invalidated depending on the usage bits and the  </span></span><br><span class="line">    <span class="comment">// hardware.  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    *vaddr = (<span class="keyword">void</span>*)hnd-&gt;base;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从这里可以看出，函数gralloc_lock其实并没有执行锁定参数handle所描述的一个缓冲区的操作，它只简单地将要锁定的缓冲区的开始地址返回给调用者。</p>
<p>&#160; &#160; &#160; &#160;理论上来说，函数gralloc_lock应该检查参数handle所描述的一个缓冲区是否正在被其进程或者线程使用。如果是的话，那么函数gralloc_lock就必须要等待，直到要锁定的缓冲区被其它进程或者线程使用结束为止，以便接下来可以独占它。由于函数gralloc_lock实际上并没有作这些操作，<strong>因此，就必须要由调用者来保证要锁定的缓冲区当前是没有被其它进程或者线程使用的</strong>。</p>
<p>&#160; &#160; &#160; &#160;2）图形缓冲区的解锁：<br>&#160; &#160; &#160; &#160;函数gralloc_unlock也是实现在文件hardware/libhardware/modules/gralloc/mapper.cpp文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_unlock</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="comment">// we're done with a software buffer. nothing to do in this  </span></span><br><span class="line">    <span class="comment">// implementation. typically this is used to flush the data cache.  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;函数gralloc_unlock执行的操作本来是刚好与函数gralloc_lock相反的，但是由于函数gralloc_lock并没有真实地锁定参数handle所描述的一个缓冲区的，因此，函数gralloc_unlock是不需要执行实际的解锁工作的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;至此，我们就分析完成Android帧缓冲区硬件抽象层模块Gralloc的实现原理了。从分析的过程可以知道，为了在屏幕中绘制一个指定的画面，我们需要：</p>
<ol>
<li>分配一个匹配屏幕大小的图形缓冲区</li>
<li>将分配好的图形缓冲区注册（映射）到当前进程的地址空间来</li>
<li>将要绘制的画面的内容写入到已经注册好的图形缓冲区中去，并且渲染（拷贝）到系统帧缓冲区中去<br>&#160; &#160; &#160; &#160;为了实现以上三个操作，我们还需要：</li>
<li>加载Gralloc模块</li>
<li>打开Gralloc模块中的gralloc设备和fb设备</li>
</ol>
<p>&#160; &#160; &#160; &#160;其中，gralloc设备负责分配图形缓冲区，Gralloc模块负责注册图形缓冲区，而fb设备负责渲染图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;这个系列内容还是太多了，我估计坚持不了多久。。。。。另外，求HR或者大神带我入坑，妹子图敬上~<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(九)----Video Buffer传输与Audio Playback流程]]></title>
      <url>http://windrunnerlihuan.com/2017/01/13/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B9%9D-Video-Buffer%E4%BC%A0%E8%BE%93%E4%B8%8EAudio-Playback%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;上一篇我们简要分析了一下播放流程，主要讲了音频、视频播放和音视频同步的问题。但是对于视频读取buffer还有音频start之后发生的流程都没有分析。本节我们就这两点再分析一番。<br><a id="more"></a></p>
<h1 id="Video-Buffer传输流程"><a href="#Video-Buffer传输流程" class="headerlink" title="Video Buffer传输流程"></a>Video Buffer传输流程</h1><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B9%9D%29----Video%20Buffer%E4%BC%A0%E8%BE%93%E4%B8%8EAudio%20Playback%E6%B5%81%E7%A8%8B/videobuffer.jpg" alt="video buffer"></p>
<p>&#160; &#160; &#160; &#160;上一节的play流程中，OMXCodec会在一开始的时候透过read函数来传送未解码的data给decoder，并要求decoder将解码后的data传回来。<br>&#160; &#160; &#160; &#160;我们看看OMXCodec的read方法，位于framework/av/media/libstagefright/OMXCodec.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> OMXCodec::read(</span><br><span class="line">        MediaBuffer **buffer, <span class="keyword">const</span> ReadOptions *options) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    *buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">//状态已经置为EXECUTING </span></span><br><span class="line">    <span class="keyword">if</span> (mState != EXECUTING &amp;&amp; mState != RECONFIGURING) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> seeking = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> seekTimeUs;</span><br><span class="line">    ReadOptions::SeekMode seekMode;</span><br><span class="line">    <span class="comment">//如果有seek，则要设置一下seek相关参数</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options-&gt;getSeekTo(&amp;seekTimeUs, &amp;seekMode)) &#123;</span><br><span class="line">        seeking = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个mInitialBufferSubmit默认为true,第一次会进来</span></span><br><span class="line">    <span class="keyword">if</span> (mInitialBufferSubmit) &#123;</span><br><span class="line">        mInitialBufferSubmit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seeking) &#123;</span><br><span class="line">            CHECK(seekTimeUs &gt;= <span class="number">0</span>);</span><br><span class="line">            mSeekTimeUs = seekTimeUs;</span><br><span class="line">            mSeekMode = seekMode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// There's no reason to trigger the code below, there's</span></span><br><span class="line">            <span class="comment">// nothing to flush yet.</span></span><br><span class="line">            seeking = <span class="literal">false</span>;</span><br><span class="line">            mPaused = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个很重要：读取需要解码的data，并送往omx解码</span></span><br><span class="line">        drainInputBuffers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mState == EXECUTING) &#123;</span><br><span class="line">            <span class="comment">// Otherwise mState == RECONFIGURING and this code will trigger</span></span><br><span class="line">            <span class="comment">// after the output port is reenabled.</span></span><br><span class="line">            <span class="comment">//这个也很重要：从输入端口读取解码好的data</span></span><br><span class="line">            fillOutputBuffers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seeking) &#123;</span><br><span class="line">       </span><br><span class="line">       ...省略seek相关处理，这个不重要...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当输出缓冲区mFilledBuffers为空时会等待解码器解码并填充数据，如果有数据，则直接取走数据</span></span><br><span class="line">    <span class="keyword">while</span> (mState != ERROR &amp;&amp; !mNoMoreOutputData &amp;&amp; mFilledBuffers.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err = waitForBufferFilled_l()) != OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态出错</span></span><br><span class="line">    <span class="keyword">if</span> (mState == ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果输出缓冲区为空，判断是否是文件结尾</span></span><br><span class="line">    <span class="keyword">if</span> (mFilledBuffers.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> mSignalledEOS ? mFinalStatus : ERROR_END_OF_STREAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断输入端口设置是否发生了变化</span></span><br><span class="line">    <span class="keyword">if</span> (mOutputPortSettingsHaveChanged) &#123;</span><br><span class="line">        mOutputPortSettingsHaveChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INFO_FORMAT_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*这里我们将输出缓冲区中的bufferinfo取出来，并将其中的mediabuffer赋值给传递进来的参数buffer*/</span></span><br><span class="line">    <span class="comment">/*当decoder解码出来数据后会将存放数据的buffer放在mFilledBuffers中，因此audioplayer每次从omxcodec读取数据时，会从mFilledBuffers中取*/</span></span><br><span class="line">    <span class="keyword">size_t</span> index = *mFilledBuffers.begin();</span><br><span class="line">    mFilledBuffers.erase(mFilledBuffers.begin());</span><br><span class="line"></span><br><span class="line">    BufferInfo *info = &amp;mPortBuffers[kPortIndexOutput].editItemAt(index);</span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)OWNED_BY_US);</span><br><span class="line">    <span class="comment">//说明此info归client所有，client释放后会归还的</span></span><br><span class="line">    info-&gt;mStatus = OWNED_BY_CLIENT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//info-&gt;mMediaBuffer-&gt;add_ref();是增加一个引用，估计release的时候用~~</span></span><br><span class="line">    info-&gt;mMediaBuffer-&gt;add_ref();</span><br><span class="line">    <span class="keyword">if</span> (mSkipCutBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSkipCutBuffer-&gt;submit(info-&gt;mMediaBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    *buffer = info-&gt;mMediaBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个流程比较长，我们分步来看：<br>&#160; &#160; &#160; &#160;1）设置相关参数。前面设置好参数mState 后，会经过几次回调将状态设置成EXECUTING，不会return；获取seek的拖动进度，拿到时间戳等，更改拖动参数变量。</p>
<p>&#160; &#160; &#160; &#160;2）<strong>解封装读取数据，送往omx解码组件解码，并返回解码后的数据</strong>。（这一部分是整个流程的核心，我们接下来会讲到）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略后相关代码如下</span></span><br><span class="line"> <span class="keyword">if</span> (mInitialBufferSubmit) &#123;  </span><br><span class="line">       mInitialBufferSubmit = <span class="literal">false</span>;  </span><br><span class="line">        drainInputBuffers();  </span><br><span class="line">      fillOutputBuffers();  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里需要注意的是mInitialBufferSubmit默认是true。drainInputBuffers可以认为从extractor读取一包数据。fillOutputBuffers是解码一包数据并放在输出buffer中。</p>
<p>&#160; &#160; &#160; &#160;3）将输出缓冲区中的bufferinfo取出来，并将其中的mediabuffer赋值给传递进来的参数buffer。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略后相关代码如下</span></span><br><span class="line"><span class="keyword">size_t</span> index = *mFilledBuffers.begin();</span><br><span class="line">mFilledBuffers.erase(mFilledBuffers.begin());  </span><br><span class="line">BufferInfo *info = &amp;mPortBuffers[kPortIndexOutput].editItemAt(index);  </span><br><span class="line">CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)OWNED_BY_US);  </span><br><span class="line">info-&gt;mStatus = OWNED_BY_CLIENT;  </span><br><span class="line">info-&gt;mMediaBuffer-&gt;add_ref();  </span><br><span class="line"><span class="keyword">if</span> (mSkipCutBuffer != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">    mSkipCutBuffer-&gt;submit(info-&gt;mMediaBuffer);  </span><br><span class="line"> &#125;  </span><br><span class="line"> *buffer = info-&gt;mMediaBuffer;  </span><br><span class="line"><span class="keyword">return</span> OK;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里我们将输出缓冲区中的bufferinfo取出来，并将其中的mediabuffer赋值给传递进来的参数buffer，当decoder解码出来数据后会将存放数据的buffer放在mFilledBuffers中，因此每次从omxcodec读取数据时，会从mFilledBuffers中取。区别在于，当mFilledBuffers为空时会等待解码器解码并填充数据，如果有数据，则直接取走数据。</p>
<p>&#160; &#160; &#160; &#160;<strong>在读取这一步之前，将info-&gt;mStatus 已经设置为OWNED_BY_CLIENT，说明此info归client所有，client释放后会归还的。</strong><br>&#160; &#160; &#160; &#160;通过设置mStatus可以让这一块内存由不同的模块来支配，如其角色有如下几个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BufferStatus &#123;</span><br><span class="line">    OWNED_BY_US,</span><br><span class="line">    OWNED_BY_COMPONENT,</span><br><span class="line">    OWNED_BY_NATIVE_WINDOW,</span><br><span class="line">    OWNED_BY_CLIENT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;显然component是解码器的，client是外部的。</p>
<p>&#160; &#160; &#160; &#160;info-&gt;mMediaBuffer-&gt;add_ref();是增加一个引用，估计release的时候用~~</p>
<p>&#160; &#160; &#160; &#160;下面着重分析下如何从extractor读数据，和如何解码数据。</p>
<h2 id="drainInputBuffers实现"><a href="#drainInputBuffers实现" class="headerlink" title="drainInputBuffers实现"></a>drainInputBuffers实现</h2><p>&#160; &#160; &#160; &#160;先找到这个方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> OMXCodec::drainInputBuffers() &#123;</span><br><span class="line">    CHECK(mState == EXECUTING || mState == RECONFIGURING);</span><br><span class="line">    <span class="comment">//DRM相关，忽略</span></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; kUseSecureInputBuffers) &#123;</span><br><span class="line">        Vector&lt;BufferInfo&gt; *buffers = &amp;mPortBuffers[kPortIndexInput];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; buffers-&gt;size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!drainAnyInputBuffer()</span><br><span class="line">                    || (mFlags &amp; kOnlySubmitOneInputBufferAtOneTime)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//kPortIndexInput为0，kPortIndexOutput为1，一个输入一个输出</span></span><br><span class="line">        Vector&lt;BufferInfo&gt; *buffers = &amp;mPortBuffers[kPortIndexInput];</span><br><span class="line">        <span class="comment">//我们可能申请了多个输入缓冲区，因此是一个循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; buffers-&gt;size(); ++i) &#123;</span><br><span class="line">            BufferInfo *info = &amp;buffers-&gt;editItemAt(i);</span><br><span class="line">            <span class="comment">//先检查我们有没有权限使用即OWNED_BY_US</span></span><br><span class="line">            <span class="keyword">if</span> (info-&gt;mStatus != OWNED_BY_US) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!drainInputBuffer(info)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//kOnlySubmitOneInputBufferAtOneTime即每次只允许读一个包，否则循环都读满</span></span><br><span class="line">            <span class="keyword">if</span> (mFlags &amp; kOnlySubmitOneInputBufferAtOneTime) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里解释下，我们可能申请了多个输入缓冲区，因此是一个循环，先检查我们有没有权限使用即OWNED_BY_US，这一缓冲区获取完数据后会检测。<br>&#160; &#160; &#160; &#160;kOnlySubmitOneInputBufferAtOneTime即每次只允许读一个包，否则循环都读满。</p>
<p>&#160; &#160; &#160; &#160;我们继续看drainInputBuffer实现。这一段代码很长，我们只能分部贴出分析：</p>
<h3 id="Part-1："><a href="#Part-1：" class="headerlink" title="Part.1："></a>Part.1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> OMXCodec::drainInputBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)OWNED_BY_US);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSignalledEOS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有未处理的mCodecSpecificData则先mOMX-&gt;emptyBuffer(info-&gt;Buffer,OMX_BUFFERFLAG_CODECCONFIG)处理这些配置数据</span></span><br><span class="line">    <span class="keyword">if</span> (mCodecSpecificDataIndex &lt; mCodecSpecificData.size()) &#123;</span><br><span class="line">        CHECK(!(mFlags &amp; kUseSecureInputBuffers));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> CodecSpecificData *specific =</span><br><span class="line">            mCodecSpecificData[mCodecSpecificDataIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> size = specific-&gt;mSize;</span><br><span class="line">        <span class="comment">//如果是avc/h264或者hevc/h265，则要处理NAL头部</span></span><br><span class="line">        <span class="keyword">if</span> ((!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mMIME) ||</span><br><span class="line">             !strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mMIME))</span><br><span class="line">                &amp;&amp; !(mQuirks &amp; kWantsNALFragments)) &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint8_t</span> kNALStartCode[<span class="number">4</span>] =</span><br><span class="line">                    &#123; <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span> &#125;;</span><br><span class="line"></span><br><span class="line">            CHECK(info-&gt;mSize &gt;= specific-&gt;mSize + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            size += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(info-&gt;mData, kNALStartCode, <span class="number">4</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span> *)info-&gt;mData + <span class="number">4</span>,</span><br><span class="line">                   specific-&gt;mData, specific-&gt;mSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CHECK(info-&gt;mSize &gt;= specific-&gt;mSize);</span><br><span class="line">            <span class="built_in">memcpy</span>(info-&gt;mData, specific-&gt;mData, specific-&gt;mSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mNoMoreOutputData = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        CODEC_LOGV(<span class="string">"calling emptyBuffer with codec specific data"</span>);</span><br><span class="line">        <span class="comment">//处理mCodecSpecificData，mOMX-&gt;emptyBuffer我们后面会讲到</span></span><br><span class="line">        <span class="keyword">status_t</span> err = mOMX-&gt;emptyBuffer(</span><br><span class="line">                mNode, info-&gt;mBuffer, <span class="number">0</span>, size,</span><br><span class="line">                OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_CODECCONFIG,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line">        CHECK_EQ(err, (<span class="keyword">status_t</span>)OK);</span><br><span class="line"></span><br><span class="line">        info-&gt;mStatus = OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">        ++mCodecSpecificDataIndex;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...未完，待续...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;如果有未处理的mCodecSpecificData则先mOMX-&gt;emptyBuffer(info-&gt;Buffer,OMX_BUFFERFLAG_CODECCONFIG)处理这些配置数据。（mOMX-&gt;emptyBuffer我们后边会讲到）<br>&#160; &#160; &#160; &#160;如果是avc/h264或者hevc/h265，则要处理NAL头部。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;在H.264/AVC视频编码标准中，整个系统框架被分为了两个层面：视频编码层面（VCL）和网络抽象层面（NAL）。其中，前者负责有效表示视频数据的内容，而后者则负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输。因此我们平时的每帧数据就是一个NAL单元（SPS与PPS除外）。在实际的H264数据帧中，往往帧前面带有00 00 00 01 或 00 00 01分隔符，一般来说编码器编出的首帧数据为PPS与SPS，接着为I帧……</p>
</blockquote>
<h3 id="Part-2："><a href="#Part-2：" class="headerlink" title="Part.2："></a>Part.2：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> OMXCodec::drainInputBuffer(BufferInfo *info) &#123;</span><br><span class="line">    </span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> signalEOS = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> timestampUs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        MediaBuffer *srcBuffer;</span><br><span class="line">        <span class="comment">//如果有seek，处理seek相关</span></span><br><span class="line">        <span class="keyword">if</span> (mSeekTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mLeftOverBuffer) &#123;</span><br><span class="line">                mLeftOverBuffer-&gt;release();</span><br><span class="line">                mLeftOverBuffer = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MediaSource::ReadOptions options;</span><br><span class="line">            options.setSeekTo(mSeekTimeUs, mSeekMode);</span><br><span class="line"></span><br><span class="line">            mSeekTimeUs = <span class="number">-1</span>;</span><br><span class="line">            mSeekMode = ReadOptions::SEEK_CLOSEST_SYNC;</span><br><span class="line">            mBufferFilled.signal();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里的mSource是在AwesomePlayer里面设置的mVideoTrack，从extractor读取数据,用于不同数据源的解封装</span></span><br><span class="line">            err = mSource-&gt;read(&amp;srcBuffer, &amp;options);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> targetTimeUs;</span><br><span class="line">                <span class="keyword">if</span> (srcBuffer-&gt;meta_data()-&gt;findInt64(</span><br><span class="line">                            kKeyTargetTime, &amp;targetTimeUs)</span><br><span class="line">                        &amp;&amp; targetTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    CODEC_LOGV(<span class="string">"targetTimeUs = %lld us"</span>, targetTimeUs);</span><br><span class="line">                    mTargetTimeUs = targetTimeUs;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTargetTimeUs = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLeftOverBuffer) &#123;<span class="comment">//如果是读取溢出了，下面代码会有判断逻辑</span></span><br><span class="line">            srcBuffer = mLeftOverBuffer;</span><br><span class="line">            mLeftOverBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            err = OK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//同上，只不过没有seek的进度</span></span><br><span class="line">            err = mSource-&gt;read(&amp;srcBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            signalEOS = <span class="literal">true</span>;</span><br><span class="line">            mFinalStatus = err;</span><br><span class="line">            mSignalledEOS = <span class="literal">true</span>;</span><br><span class="line">            mBufferFilled.signal();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//DRM相关，忽略</span></span><br><span class="line">        <span class="keyword">if</span> (mFlags &amp; kUseSecureInputBuffers) &#123;</span><br><span class="line">            info = findInputBufferByDataPointer(srcBuffer-&gt;data());</span><br><span class="line">            CHECK(info != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*下面是判断从extractor读取到的数据是不是超过了总大小*/</span></span><br><span class="line">        <span class="comment">//计算输入缓冲区剩余容量大小</span></span><br><span class="line">        <span class="keyword">size_t</span> remainingBytes = info-&gt;mSize - offset;</span><br><span class="line">        <span class="comment">//如果剩余容量小于解封装后读取的data大小</span></span><br><span class="line">        <span class="keyword">if</span> (srcBuffer-&gt;range_length() &gt; remainingBytes) &#123;</span><br><span class="line">            <span class="comment">//如果是每次读取的开始</span></span><br><span class="line">            <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">                CODEC_LOGE(</span><br><span class="line">                     <span class="string">"Codec's input buffers are too small to accomodate "</span></span><br><span class="line">                     <span class="string">"buffer read from source (info-&gt;mSize = %d, srcLength = %d)"</span>,</span><br><span class="line">                     info-&gt;mSize, srcBuffer-&gt;range_length());</span><br><span class="line">                <span class="comment">//解码申请的输入缓冲区大小太小了，无法容纳解封装读取的数据大小</span></span><br><span class="line">                <span class="comment">//释放读取的data </span></span><br><span class="line">                srcBuffer-&gt;release();</span><br><span class="line">                srcBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//设置错误状态</span></span><br><span class="line">                setState(ERROR);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mLeftOverBuffer = srcBuffer;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> releaseBuffer = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mFlags &amp; kStoreMetaDataInVideoBuffers) &#123;</span><br><span class="line">                releaseBuffer = <span class="literal">false</span>;</span><br><span class="line">                info-&gt;mMediaBuffer = srcBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFlags &amp; kUseSecureInputBuffers) &#123;<span class="comment">//DRM，忽略</span></span><br><span class="line">                <span class="comment">// Data in "info" is already provided at this time.</span></span><br><span class="line"></span><br><span class="line">                releaseBuffer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                CHECK(info-&gt;mMediaBuffer == <span class="literal">NULL</span>);</span><br><span class="line">                info-&gt;mMediaBuffer = srcBuffer;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//将读取到的数据拷贝到申请的读取缓冲区中</span></span><br><span class="line">            CHECK(srcBuffer-&gt;data() != <span class="literal">NULL</span>) ;</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span> *)info-&gt;mData + offset,</span><br><span class="line">                    (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)srcBuffer-&gt;data()</span><br><span class="line">                        + srcBuffer-&gt;range_offset(),</span><br><span class="line">                    srcBuffer-&gt;range_length());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//读取，拷贝后，将读取位置偏移量加上读取大小</span></span><br><span class="line">        offset += srcBuffer-&gt;range_length();</span><br><span class="line">        <span class="comment">//如果是OGG Vobis格式的音频</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(MEDIA_MIMETYPE_AUDIO_VORBIS, mMIME)) &#123;</span><br><span class="line">            CHECK(!(mQuirks &amp; kSupportsMultipleFramesPerInputBuffer));</span><br><span class="line">            CHECK_GE(info-&gt;mSize, offset + <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int32_t</span> numPageSamples;</span><br><span class="line">            <span class="keyword">if</span> (!srcBuffer-&gt;meta_data()-&gt;findInt32(</span><br><span class="line">                        kKeyValidSamples, &amp;numPageSamples)) &#123;</span><br><span class="line">                numPageSamples = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span> *)info-&gt;mData + offset,</span><br><span class="line">                   &amp;numPageSamples,</span><br><span class="line">                   <span class="keyword">sizeof</span>(numPageSamples));</span><br><span class="line"></span><br><span class="line">            offset += <span class="keyword">sizeof</span>(numPageSamples);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (releaseBuffer) &#123;</span><br><span class="line">            srcBuffer-&gt;release();</span><br><span class="line">            srcBuffer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取次数，读了几帧</span></span><br><span class="line">        ++n;</span><br><span class="line">        <span class="comment">//如果不支持每次读取多帧，则一次就直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (!(mQuirks &amp; kSupportsMultipleFramesPerInputBuffer)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理本次读取时间</span></span><br><span class="line">        <span class="keyword">int64_t</span> coalescedDurationUs = lastBufferTimeUs - timestampUs;</span><br><span class="line">        <span class="comment">//如果时间超过250毫秒则舍弃</span></span><br><span class="line">        <span class="keyword">if</span> (coalescedDurationUs &gt; <span class="number">250000l</span>l) &#123;</span><br><span class="line">            <span class="comment">// Don't coalesce more than 250ms worth of encoded data at once.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...未完，待续...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;Part2的代码虽然多，但核心不多。<br>&#160; &#160; &#160; &#160;1）从extractor读取数据，用于不同数据源的解封装。这里的mSource是在AwesomePlayer里面设置的mVideoTrack，我们可以回到以前设置数据源那里查看，如果不记得了可回顾一下以前的<a href="http://windrunnerlihuan.com/2016/12/12/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%9B%9B-AwesomePlayer%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%84%E7%90%86/#网络类型数据源">Android多媒体开发(四)—-AwesomePlayer数据源处理</a>。我们假设是MEDIA_MIMETYPE_CONTAINER_MPEG2TS封装格式，取得它的视频流信息，我们要查看MPEG2TSExtractor这个类的getTrack函数，位于frameworks/av/media/libstagefright/mpeg2ts/MPEG2TSExtractor.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;MediaSource&gt; MPEG2TSExtractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mSourceImpls.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> seekable = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSourceImpls.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        CHECK_EQ(mSourceImpls.size(), <span class="number">2u</span>);</span><br><span class="line"></span><br><span class="line">        sp&lt;MetaData&gt; meta = mSourceImpls.editItemAt(index)-&gt;getFormat();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strncasecmp(<span class="string">"audio/"</span>, mime, <span class="number">6</span>)) &#123;</span><br><span class="line">            seekable = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MPEG2TSSource(<span class="keyword">this</span>, mSourceImpls.editItemAt(index), seekable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;要解封装读取数据，是MPEG2TSSource的read方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG2TSSource::read(</span><br><span class="line">        MediaBuffer **out, <span class="keyword">const</span> ReadOptions *options) &#123;</span><br><span class="line">    *out = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> seekTimeUs;</span><br><span class="line">    ReadOptions::SeekMode seekMode;</span><br><span class="line">    <span class="keyword">if</span> (mSeekable &amp;&amp; options &amp;&amp; options-&gt;getSeekTo(&amp;seekTimeUs, &amp;seekMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> finalResult;</span><br><span class="line">    <span class="keyword">while</span> (!mImpl-&gt;hasBufferAvailable(&amp;finalResult)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (finalResult != OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_END_OF_STREAM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> err = mExtractor-&gt;feedMore();</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            mImpl-&gt;signalEOS(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mImpl-&gt;read(out, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;不过遗憾的是这里涉及MPEG-TS文件格式问题，并且上述read方法主要是使用mImpl来实现的。由于文件格式比较复杂，这里就止步了，有兴趣的同学可以下去自行研究。</p>
<p>&#160; &#160; &#160; &#160;2）判断从extractor读取到的数据是不是超过了总大小 。先计算申请的缓冲区剩余容量，然后根据上一步读取的大小和她进行比大小，从而判断是否读取溢出。</p>
<p>&#160; &#160; &#160; &#160;3）将读取的数据拷贝进申请的读入缓冲区中。这里读取完毕后将缓冲区的状态设置成OWNED_BY_COMPONENT 解码器就可以解码了。这里可以看出来读取数据时实现了一次拷贝~~，而不是用的同一块缓冲区(省略一些细节)</p>
<h3 id="Part-3"><a href="#Part-3" class="headerlink" title="Part.3"></a>Part.3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> OMXCodec::drainInputBuffer(BufferInfo *info) &#123;</span><br><span class="line"></span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"coalesced %d frames into one input buffer"</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signalEOS) &#123;</span><br><span class="line">        flags |= OMX_BUFFERFLAG_EOS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNoMoreOutputData = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//将解封装的数据送往OMX去解码</span></span><br><span class="line">    err = mOMX-&gt;emptyBuffer(</span><br><span class="line">            mNode, info-&gt;mBuffer, <span class="number">0</span>, offset,</span><br><span class="line">            flags, timestampUs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        setState(ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;mStatus = OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这里读取完毕后将缓冲区的状态设置成OWNED_BY_COMPONENT 解码器就可以解码了。<br>&#160; &#160; &#160; &#160;下面看读取数据完毕后调用mOMX-&gt;emptyBuffer都干了些啥。位于frameworks/av/media/libstagefright/omx/OMX.cpp中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> OMX::emptyBuffer(</span><br><span class="line">        node_id node,</span><br><span class="line">        buffer_id buffer,</span><br><span class="line">        OMX_U32 range_offset, OMX_U32 range_length,</span><br><span class="line">        OMX_U32 flags, OMX_TICKS timestamp) &#123;</span><br><span class="line">    <span class="keyword">return</span> findInstance(node)-&gt;emptyBuffer(</span><br><span class="line">            buffer, range_offset, range_length, flags, timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后根绝node节点找到自己的OMXNodeInstance，找到emptyBuffer方法，位于frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> OMXNodeInstance::emptyBuffer(</span><br><span class="line">        OMX::buffer_id buffer,</span><br><span class="line">        OMX_U32 rangeOffset, OMX_U32 rangeLength,</span><br><span class="line">        OMX_U32 flags, OMX_TICKS timestamp) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);</span><br><span class="line">    header-&gt;nFilledLen = rangeLength;</span><br><span class="line">    header-&gt;nOffset = rangeOffset;</span><br><span class="line">    header-&gt;nFlags = flags;</span><br><span class="line">    header-&gt;nTimeStamp = timestamp;</span><br><span class="line"></span><br><span class="line">    BufferMeta *buffer_meta =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;BufferMeta *&gt;(header-&gt;pAppPrivate);</span><br><span class="line">    buffer_meta-&gt;CopyToOMX(header);</span><br><span class="line">    <span class="comment">//此处mHandle对应相应解码组件的</span></span><br><span class="line">    OMX_ERRORTYPE err = OMX_EmptyThisBuffer(mHandle, header);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StatusFromOMXError(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这时候就是调用OMX的方法了，我们在<a href="http://windrunnerlihuan.com/2016/12/29/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%83-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/">Android多媒体开发(七)—-Android中OpenMax的实现</a> 讲过，OMX适配层会去查找匹配的相应解码组件，如果忘掉的可以查看这这一节。</p>
<p>&#160; &#160; &#160; &#160;以前我们分析的都是硬解，比如高通、TI的平台，但这里我们为了更清晰分析这个流程，我们选择软解组件，及OMX.google.XX.XX.Decoder。<br>&#160; &#160; &#160; &#160;我们假设视频编码格式hevc/h265的，因此找到对应的软解组件SoftHEVC，位于frameworks/av/media/libstagefright/codecs/hevcdec/SoftHEVC.cpp。但是我们没有找到emptyThisBuffer方法，所以得去它父类的父类SimpleSoftOMXComponent中去查找，位于frameworks/av/media/libstagefright/omx/SimpleSoftOMXComponent.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OMX_ERRORTYPE SimpleSoftOMXComponent::emptyThisBuffer(</span><br><span class="line">        OMX_BUFFERHEADERTYPE *buffer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatEmptyThisBuffer, mHandler-&gt;id());</span><br><span class="line">    msg-&gt;setPointer(<span class="string">"header"</span>, buffer);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到就是发了一条命令kWhatEmptyThisBuffer，通过handler-&gt;id确定了自己发的还得自己收，处理函数如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SimpleSoftOMXComponent::onMessageReceived(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> msgType = msg-&gt;what();</span><br><span class="line">    ALOGV(<span class="string">"msgType = %d"</span>, msgType);</span><br><span class="line">    <span class="keyword">switch</span> (msgType) &#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatEmptyThisBuffer:</span><br><span class="line">        <span class="keyword">case</span> kWhatFillThisBuffer:</span><br><span class="line">        &#123;</span><br><span class="line">            OMX_BUFFERHEADERTYPE *header;</span><br><span class="line">            CHECK(msg-&gt;findPointer(<span class="string">"header"</span>, (<span class="keyword">void</span> **)&amp;header));</span><br><span class="line"></span><br><span class="line">            CHECK(mState == OMX_StateExecuting &amp;&amp; mTargetState == mState);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">size_t</span> portIndex = (kWhatEmptyThisBuffer == msgType)?</span><br><span class="line">                    header-&gt;nInputPortIndex: header-&gt;nOutputPortIndex;</span><br><span class="line">            PortInfo *port = &amp;mPorts.editItemAt(portIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; port-&gt;mBuffers.size(); ++j) &#123;</span><br><span class="line">                BufferInfo *buffer = &amp;port-&gt;mBuffers.editItemAt(j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (buffer-&gt;mHeader == header) &#123;</span><br><span class="line">                    CHECK(!buffer-&gt;mOwnedByUs);</span><br><span class="line"></span><br><span class="line">                    buffer-&gt;mOwnedByUs = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    CHECK((msgType == kWhatEmptyThisBuffer</span><br><span class="line">                            &amp;&amp; port-&gt;mDef.eDir == OMX_DirInput)</span><br><span class="line">                            || (port-&gt;mDef.eDir == OMX_DirOutput));</span><br><span class="line"></span><br><span class="line">                    port-&gt;mQueue.push_back(buffer);</span><br><span class="line">                    onQueueFilled(portIndex);</span><br><span class="line"></span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CHECK(found);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            TRESPASS();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从代码这里来看这两个case都走同一套代码，而且都是通过onQueueFilled来处理，这样我们就引出了实际的处理函数，也就是onQueueFilled。此时我们就得去子类SoftHEVC.cpp中查找：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SoftHEVC::onQueueFilled(OMX_U32 portIndex) &#123;</span><br><span class="line"></span><br><span class="line">    UNUSED(portIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOutputPortSettingsChange != NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取输入输出链表 </span></span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;inQueue = getPortQueue(kInputPortIndex);</span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;outQueue = getPortQueue(kOutputPortIndex);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">while</span> (!outQueue.empty()) &#123;</span><br><span class="line">        <span class="comment">//输入缓冲区</span></span><br><span class="line">        BufferInfo *inInfo;</span><br><span class="line">        OMX_BUFFERHEADERTYPE *inHeader;</span><br><span class="line">        <span class="comment">//输出缓冲区</span></span><br><span class="line">        BufferInfo *outInfo;</span><br><span class="line">        OMX_BUFFERHEADERTYPE *outHeader;</span><br><span class="line">        <span class="keyword">size_t</span> timeStampIx;</span><br><span class="line"></span><br><span class="line">        inInfo = <span class="literal">NULL</span>;</span><br><span class="line">        inHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各自取输入输出缓冲区中的第一个缓冲区  </span></span><br><span class="line">        outInfo = *outQueue.begin();</span><br><span class="line">        outHeader = outInfo-&gt;mHeader;</span><br><span class="line">        outHeader-&gt;nFlags = <span class="number">0</span>;</span><br><span class="line">        outHeader-&gt;nTimeStamp = <span class="number">0</span>;</span><br><span class="line">        outHeader-&gt;nOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断缓冲区是不是没有数据，若果第一个都没有那就是没有 </span></span><br><span class="line">        <span class="keyword">if</span> (inHeader != <span class="literal">NULL</span> &amp;&amp; (inHeader-&gt;nFlags &amp; OMX_BUFFERFLAG_EOS)) &#123;</span><br><span class="line">            ALOGD(<span class="string">"EOS seen on input"</span>);</span><br><span class="line">            mReceivedEOS = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (inHeader-&gt;nFilledLen == <span class="number">0</span>) &#123;</span><br><span class="line">                inQueue.erase(inQueue.begin());</span><br><span class="line">                inInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//如果输入缓冲区数据没有了，则调用notifyEmptyBufferDone </span></span><br><span class="line">                notifyEmptyBufferDone(inHeader);</span><br><span class="line">                inHeader = <span class="literal">NULL</span>;</span><br><span class="line">                setFlushMode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***************************省略解码相关细节******************************/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s_dec_op.u4_output_present) &#123;</span><br><span class="line">                outHeader-&gt;nFilledLen = (mWidth * mHeight * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                outHeader-&gt;nTimeStamp = mTimeStamps[s_dec_op.u4_ts];</span><br><span class="line">                mTimeStampsValid[s_dec_op.u4_ts] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                outInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                outQueue.erase(outQueue.begin());</span><br><span class="line">                outInfo = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//这是将解码出来的数据告诉外部，通过调用notifyFillBufferDone </span></span><br><span class="line">                notifyFillBufferDone(outHeader);</span><br><span class="line">                outHeader = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* If in flush mode and no output is returned by the codec,</span><br><span class="line">                 * then come out of flush mode */</span></span><br><span class="line">                mIsInFlush = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* If EOS was recieved on input port and there is no output</span><br><span class="line">                 * from the codec, then signal EOS on output port */</span></span><br><span class="line">                <span class="keyword">if</span> (mReceivedEOS) &#123;</span><br><span class="line">                    outHeader-&gt;nFilledLen = <span class="number">0</span>;</span><br><span class="line">                    outHeader-&gt;nFlags |= OMX_BUFFERFLAG_EOS;</span><br><span class="line"></span><br><span class="line">                    outInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                    outQueue.erase(outQueue.begin());</span><br><span class="line">                    outInfo = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="comment">//这是将解码出来的数据告诉外部，通过调用notifyFillBufferDone </span></span><br><span class="line">                    notifyFillBufferDone(outHeader);</span><br><span class="line">                    outHeader = <span class="literal">NULL</span>;</span><br><span class="line">                    resetPlugin();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Handle more than one picture data</span></span><br><span class="line">        <span class="keyword">if</span> (inHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">            inQueue.erase(inQueue.begin());</span><br><span class="line">            inInfo = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 如果输入缓冲区数据都解码完了，则调用notifyEmptyBufferDone </span></span><br><span class="line">            notifyEmptyBufferDone(inHeader);</span><br><span class="line">            inHeader = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;以上就是输入缓冲区数据解码再从输出缓冲区传递出去部分。流程大概是：<br>&#160; &#160; &#160; &#160;1）读取输入缓冲区数据，如果空了则表示结束了，则调用notifyEmptyBufferDone，输入部分清空；<br>&#160; &#160; &#160; &#160;2）如果读取到了数据，则送去解码（因为这里设计编码格式等等，因此省略解码细节）；<br>&#160; &#160; &#160; &#160;3）然后将解码出来的数据告诉外部，通过调用notifyFillBufferDone ；<br>&#160; &#160; &#160; &#160;4）循环上述过程。</p>
<p>&#160; &#160; &#160; &#160;所以上述过程的重点就是notifyEmptyBufferDone 和notifyFillBufferDone ，如何将输入缓冲区释放和将输出缓冲区中的数据传递出去。接下来我们分析这两个过程。</p>
<h3 id="输入部分的清空notifyEmptyBufferDone"><a href="#输入部分的清空notifyEmptyBufferDone" class="headerlink" title="输入部分的清空notifyEmptyBufferDone"></a>输入部分的清空notifyEmptyBufferDone</h3><p>&#160; &#160; &#160; &#160;notifyEmptyBufferDone位于它父类的父类的父类，位于frameworks/av/media/libstagefright/omx/SoftOMXComponent.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SoftOMXComponent::notifyEmptyBufferDone(OMX_BUFFERHEADERTYPE *header) &#123;</span><br><span class="line">    (*mCallbacks-&gt;EmptyBufferDone)(</span><br><span class="line">            mComponent, mComponent-&gt;pApplicationPrivate, header);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们在<a href="http://windrunnerlihuan.com/2016/12/29/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%83-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/">Android多媒体开发(七)—-Android中OpenMax的实现</a> 讲过，这里最后还是会回到OMXNodeInstance。通知外面我们emptythisbuffer完工了，具体回调的是OMXNodeInstance中的方法OnEmptyBufferDone，所以看看它的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">OMX_ERRORTYPE OMXNodeInstance::OnEmptyBufferDone(</span><br><span class="line">        OMX_IN OMX_HANDLETYPE <span class="comment">/* hComponent */</span>,</span><br><span class="line">        OMX_IN OMX_PTR pAppData,</span><br><span class="line">        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer) &#123;</span><br><span class="line">    OMXNodeInstance *instance = <span class="keyword">static_cast</span>&lt;OMXNodeInstance *&gt;(pAppData);</span><br><span class="line">    <span class="keyword">if</span> (instance-&gt;mDying) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;owner()-&gt;OnEmptyBufferDone(instance-&gt;nodeID(),</span><br><span class="line">            instance-&gt;findBufferID(pBuffer), pBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OMXNodeInstance的ownner是OMX，因此代码在OMX.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OMX_ERRORTYPE OMX::OnEmptyBufferDone(</span><br><span class="line">        node_id node, buffer_id buffer, OMX_IN OMX_BUFFERHEADERTYPE *pBuffer) &#123;</span><br><span class="line">    ALOGV(<span class="string">"OnEmptyBufferDone buffer=%p"</span>, pBuffer);</span><br><span class="line"></span><br><span class="line">    omx_message msg;</span><br><span class="line">    msg.type = omx_message::EMPTY_BUFFER_DONE;</span><br><span class="line">    msg.node = node;</span><br><span class="line">    msg.u.buffer_data.buffer = buffer;</span><br><span class="line"></span><br><span class="line">    findDispatcher(node)-&gt;post(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其中findDispatcher定义如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;OMX::CallbackDispatcher&gt; OMX::findDispatcher(node_id node) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> index = mDispatchers.indexOfKey(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index &lt; <span class="number">0</span> ? <span class="literal">NULL</span> : mDispatchers.valueAt(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里mDispatcher在之前allocateNode中通过mDispatchers.add(*node, new CallbackDispatcher(instance)); 创建的,看下实际的实现可知道，CallbackDispatcher的post方法最终会调用dispatch：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OMX::CallbackDispatcher::dispatch(<span class="keyword">const</span> omx_message &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mOwner == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"Would have dispatched a message to a node that's already gone."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mOwner-&gt;onMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;而owner是OMXNodeInstance，因此消息饶了一圈还是到了OMXNodeInstance的OnMessage方法接收了:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OMXNodeInstance::onMessage(<span class="keyword">const</span> omx_message &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;GraphicBufferSource&gt;&amp; bufferSource(getGraphicBufferSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.type == omx_message::FILL_BUFFER_DONE) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.type == omx_message::EMPTY_BUFFER_DONE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bufferSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// This is one of the buffers used exclusively by</span></span><br><span class="line">            <span class="comment">// GraphicBufferSource.</span></span><br><span class="line">            <span class="comment">// Don't dispatch a message back to ACodec, since it doesn't</span></span><br><span class="line">            <span class="comment">// know that anyone asked to have the buffer emptied and will</span></span><br><span class="line">            <span class="comment">// be very confused.</span></span><br><span class="line"></span><br><span class="line">            OMX_BUFFERHEADERTYPE *buffer =</span><br><span class="line">                findBufferHeader(msg.u.buffer_data.buffer);</span><br><span class="line"></span><br><span class="line">            bufferSource-&gt;codecBufferEmptied(buffer);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mObserver-&gt;onMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;而onMessage又将消息传递到 mObserver中，也就是在OMXCodec::Create中构造的OMXCodecObserver对象，其OnMessage实现如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from IOMXObserver</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> omx_message &amp;msg)</span> </span>&#123;</span><br><span class="line">    sp&lt;OMXCodec&gt; codec = mTarget.promote();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(codec-&gt;mLock)</span></span>;</span><br><span class="line">        codec-&gt;on_message(msg);</span><br><span class="line">        codec.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最终还是传递给了OMXCodec里，具体看下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OMXCodec::on_message(<span class="keyword">const</span> omx_message &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == ERROR) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * only drop EVENT messages, EBD and FBD are still</span><br><span class="line">         * processed for bookkeeping purposes</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type == omx_message::EVENT) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Dropping OMX EVENT message - we're in ERROR state."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msg.type) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> omx_message::EMPTY_BUFFER_DONE:</span><br><span class="line">        &#123;</span><br><span class="line">            IOMX::buffer_id buffer = msg.u.extended_buffer_data.buffer;</span><br><span class="line"></span><br><span class="line">            CODEC_LOGV(<span class="string">"EMPTY_BUFFER_DONE(buffer: %u)"</span>, buffer);</span><br><span class="line">            </span><br><span class="line">            Vector&lt;BufferInfo&gt; *buffers = &amp;mPortBuffers[kPortIndexInput];</span><br><span class="line">            <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; buffers-&gt;size() &amp;&amp; (*buffers)[i].mBuffer != buffer) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CHECK(i &lt; buffers-&gt;size());</span><br><span class="line">            <span class="keyword">if</span> ((*buffers)[i].mStatus != OWNED_BY_COMPONENT) &#123;</span><br><span class="line">                ALOGW(<span class="string">"We already own input buffer %u, yet received "</span></span><br><span class="line">                     <span class="string">"an EMPTY_BUFFER_DONE."</span>, buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BufferInfo* info = &amp;buffers-&gt;editItemAt(i);</span><br><span class="line">            info-&gt;mStatus = OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Buffer could not be released until empty buffer done is called.</span></span><br><span class="line">            <span class="keyword">if</span> (info-&gt;mMediaBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//此处虽然调用了info-&gt;mMediaBuffer-&gt;release();但是由于其引用始终大于0，因此不会真正的release</span></span><br><span class="line">                info-&gt;mMediaBuffer-&gt;release();</span><br><span class="line">                info-&gt;mMediaBuffer = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPortStatus[kPortIndexInput] == DISABLING) &#123;</span><br><span class="line">                CODEC_LOGV(<span class="string">"Port is disabled, freeing buffer %u"</span>, buffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">status_t</span> err = freeBuffer(kPortIndexInput, i);</span><br><span class="line">                CHECK_EQ(err, (<span class="keyword">status_t</span>)OK);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mState != ERROR</span><br><span class="line">                    &amp;&amp; mPortStatus[kPortIndexInput] != SHUTTING_DOWN) &#123;</span><br><span class="line">                CHECK_EQ((<span class="keyword">int</span>)mPortStatus[kPortIndexInput], (<span class="keyword">int</span>)ENABLED);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mFlags &amp; kUseSecureInputBuffers) &#123;</span><br><span class="line">                    drainAnyInputBuffer();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//重点在这里，会调用drainInputBuffer(&amp;buffers-&gt;editItemAt(i));来填充数据</span></span><br><span class="line">                    <span class="comment">//也就是说当我们启动一次解码播放后，会在此处循环读取数和据解码数据。而输出数据在后面的filloutbuffer中。</span></span><br><span class="line">                    drainInputBuffer(&amp;buffers-&gt;editItemAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;此处虽然调用了info-&gt;mMediaBuffer-&gt;release();但是由于其引用始终大于0，因此不会真正的release。<br>&#160; &#160; &#160; &#160;<strong>二是当release完毕后，会调用drainInputBuffer(&amp;buffers-&gt;editItemAt(i));来填充数据。也就是说当我们启动一次解码播放后，会在此处循环读取数和据解码数据。而输出数据在后面的filloutbuffer中</strong>。</p>
<p>&#160; &#160; &#160; &#160;输入部分的清空notifyEmptyBufferDone就分析完了这部分很绕，但搞清楚就好了，请大家仔细阅读。接着我们分析输出数据的清空notifyFillBufferDone(outHeader)。</p>
<h3 id="输出数据的清空notifyFillBufferDone-outHeader"><a href="#输出数据的清空notifyFillBufferDone-outHeader" class="headerlink" title="输出数据的清空notifyFillBufferDone(outHeader)"></a>输出数据的清空notifyFillBufferDone(outHeader)</h3><p>&#160; &#160; &#160; &#160;notifyFillBufferDone同样位于SoftOMXComponent.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SoftOMXComponent::notifyFillBufferDone(OMX_BUFFERHEADERTYPE *header) &#123;</span><br><span class="line">    (*mCallbacks-&gt;FillBufferDone)(</span><br><span class="line">            mComponent, mComponent-&gt;pApplicationPrivate, header);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个和上一步流程分析方法一样，最后回到OMX的OnFillBufferDone方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OMX_ERRORTYPE OMX::OnFillBufferDone(</span><br><span class="line">        node_id node, buffer_id buffer, OMX_IN OMX_BUFFERHEADERTYPE *pBuffer) &#123;</span><br><span class="line">    ALOGV(<span class="string">"OnFillBufferDone buffer=%p"</span>, pBuffer);</span><br><span class="line"></span><br><span class="line">    omx_message msg;</span><br><span class="line">    msg.type = omx_message::FILL_BUFFER_DONE;</span><br><span class="line">    msg.node = node;</span><br><span class="line">    msg.u.extended_buffer_data.buffer = buffer;</span><br><span class="line">    msg.u.extended_buffer_data.range_offset = pBuffer-&gt;nOffset;</span><br><span class="line">    msg.u.extended_buffer_data.range_length = pBuffer-&gt;nFilledLen;</span><br><span class="line">    msg.u.extended_buffer_data.flags = pBuffer-&gt;nFlags;</span><br><span class="line">    msg.u.extended_buffer_data.timestamp = pBuffer-&gt;nTimeStamp;</span><br><span class="line"></span><br><span class="line">    findDispatcher(node)-&gt;post(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最终处理在OMXCodec.cpp中:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OMXCodec::on_message(<span class="keyword">const</span> omx_message &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == ERROR) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * only drop EVENT messages, EBD and FBD are still</span><br><span class="line">         * processed for bookkeeping purposes</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type == omx_message::EVENT) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Dropping OMX EVENT message - we're in ERROR state."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msg.type) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> omx_message::FILL_BUFFER_DONE:</span><br><span class="line">        &#123;</span><br><span class="line">  IOMX::buffer_id buffer = msg.u.extended_buffer_data.buffer;</span><br><span class="line">            OMX_U32 flags = msg.u.extended_buffer_data.flags;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            Vector&lt;BufferInfo&gt; *buffers = &amp;mPortBuffers[kPortIndexOutput];</span><br><span class="line">            <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; buffers-&gt;size() &amp;&amp; (*buffers)[i].mBuffer != buffer) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CHECK(i &lt; buffers-&gt;size());</span><br><span class="line">            BufferInfo *info = &amp;buffers-&gt;editItemAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (info-&gt;mStatus != OWNED_BY_COMPONENT) &#123;</span><br><span class="line">                ALOGW(<span class="string">"We already own output buffer %u, yet received "</span></span><br><span class="line">                     <span class="string">"a FILL_BUFFER_DONE."</span>, buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先将mStatus设置成OWNED_BY_US，这样component便不能操作了</span></span><br><span class="line">            info-&gt;mStatus = OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPortStatus[kPortIndexOutput] == DISABLING) &#123;</span><br><span class="line">            ......</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPortStatus[kPortIndexOutput] != SHUTTING_DOWN) &#123;</span><br><span class="line">                CHECK_EQ((<span class="keyword">int</span>)mPortStatus[kPortIndexOutput], (<span class="keyword">int</span>)ENABLED);</span><br><span class="line"></span><br><span class="line">                MediaBuffer *buffer = info-&gt;mMediaBuffer;</span><br><span class="line">                <span class="keyword">bool</span> isGraphicBuffer = buffer-&gt;graphicBuffer() != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">/*buffer相关参数设置，可以忽略*/</span></span><br><span class="line">                buffer-&gt;set_range(</span><br><span class="line">                        msg.u.extended_buffer_data.range_offset,</span><br><span class="line">                        msg.u.extended_buffer_data.range_length);</span><br><span class="line"></span><br><span class="line">                buffer-&gt;meta_data()-&gt;clear();</span><br><span class="line"></span><br><span class="line">                buffer-&gt;meta_data()-&gt;setInt64(</span><br><span class="line">                        kKeyTime, msg.u.extended_buffer_data.timestamp);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.u.extended_buffer_data.flags &amp; OMX_BUFFERFLAG_SYNCFRAME) &#123;</span><br><span class="line">                    buffer-&gt;meta_data()-&gt;setInt32(kKeyIsSyncFrame, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">bool</span> isCodecSpecific = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (msg.u.extended_buffer_data.flags &amp; OMX_BUFFERFLAG_CODECCONFIG) &#123;</span><br><span class="line">                    buffer-&gt;meta_data()-&gt;setInt32(kKeyIsCodecConfig, <span class="literal">true</span>);</span><br><span class="line">                    isCodecSpecific = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isGraphicBuffer || mQuirks &amp; kOutputBuffersAreUnreadable) &#123;</span><br><span class="line">                    buffer-&gt;meta_data()-&gt;setInt32(kKeyIsUnreadable, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                buffer-&gt;meta_data()-&gt;setInt32(</span><br><span class="line">                        kKeyBufferID,</span><br><span class="line">                        msg.u.extended_buffer_data.buffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.u.extended_buffer_data.flags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">                    CODEC_LOGV(<span class="string">"No more output data."</span>);</span><br><span class="line">                    mNoMoreOutputData = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mIsEncoder &amp;&amp; mIsVideo) &#123;</span><br><span class="line">                    <span class="keyword">int64_t</span> decodingTimeUs = isCodecSpecific? <span class="number">0</span>: getDecodingTimeUs();</span><br><span class="line">                    buffer-&gt;meta_data()-&gt;setInt64(kKeyDecodingTime, decodingTimeUs);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">//核心是下面几句，将这个buffer push到mFilledBuffers中。</span></span><br><span class="line">                mFilledBuffers.push_back(i);</span><br><span class="line">                mBufferFilled.signal();</span><br><span class="line">                <span class="keyword">if</span> (mIsEncoder) &#123;</span><br><span class="line">                    sched_yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述代码主体也不多：<br>&#160; &#160; &#160; &#160;1）先将mStatus设置成OWNED_BY_US，这样component便不能操作了；<br>&#160; &#160; &#160; &#160;2）对于解码好的buffer进行相关参数设置；<br>&#160; &#160; &#160; &#160;2）后面将这个buffer push到mFilledBuffers中。</p>
<p>&#160; &#160; &#160; &#160;输出数据的清空notifyFillBufferDone就分析完了，这里我们的mFilledBuffers就有数据了，就能为Video Buffer传输流程的下一步fillOutputBuffers做准备了。</p>
<h2 id="fillOutputBuffers实现"><a href="#fillOutputBuffers实现" class="headerlink" title="fillOutputBuffers实现"></a>fillOutputBuffers实现</h2><p> &#160; &#160; &#160; &#160;回到开始的步骤，OMXCodec的read第一步drainInputBuffers实现完成了数据的解封装和送往OMX去解码，完成后返回给mFilledBuffers。<br> &#160; &#160; &#160; &#160;所以我们这一步fillOutputBuffers就是读取这些返回解码数据。我们先看看fillOutputBuffers函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">void</span> OMXCodec::fillOutputBuffers() &#123;</span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)mState, (<span class="keyword">int</span>)EXECUTING);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Vector&lt;BufferInfo&gt; *buffers = &amp;mPortBuffers[kPortIndexOutput];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; buffers-&gt;size(); ++i) &#123;</span><br><span class="line">        BufferInfo *info = &amp;buffers-&gt;editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == OWNED_BY_US) &#123;</span><br><span class="line">            <span class="comment">//找到一个输出缓冲区bufferinfo，启动输出</span></span><br><span class="line">            fillOutputBuffer(&amp;buffers-&gt;editItemAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;找到一个输出缓冲区bufferinfo，启动输出:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> OMXCodec::fillOutputBuffer(BufferInfo *info) &#123;</span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)OWNED_BY_US);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    CODEC_LOGV(<span class="string">"Calling fillBuffer on buffer %p"</span>, info-&gt;mBuffer);</span><br><span class="line">    <span class="comment">//依旧可以参考上一步的步骤，最后进入解码器组件里面</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mOMX-&gt;fillBuffer(mNode, info-&gt;mBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        CODEC_LOGE(<span class="string">"fillBuffer failed w/ error 0x%08x"</span>, err);</span><br><span class="line"></span><br><span class="line">        setState(ERROR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;mStatus = OWNED_BY_COMPONENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;这一步和上面分析过的步骤相同，最后还是会进入解码器的组件内部，依然以hevc/h265为例子。同样还是如下步骤：<br>&#160; &#160; &#160; &#160;<strong>OMXNodeInstance::fillBuffer—-&gt;SimpleSoftOMXComponent::fillThisBuffer—-&gt;SimpleSoftOMXComponent::onMessageReceived—-&gt;SoftHEVC::onQueueFilled。然后通过notifyEmptyBufferDone(inHeader);和notifyFillBufferDone(outHeader);两个函数来推进播放进度。只不过这次我们最后回到了OMXCodec的on_message回到函数，走了FILL_BUFFER_DONE这个case里的notifyFillBufferDone部分，这个我们上一步最后也分析过这个流程了</strong>。</p>
<p> &#160; &#160; &#160; &#160;到这里我们fillOutputBuffers实现部分也分析完了，主要就是传输输出缓冲区的数据。</p>
<h1 id="Video-Buffer传输流程总结"><a href="#Video-Buffer传输流程总结" class="headerlink" title="Video Buffer传输流程总结"></a>Video Buffer传输流程总结</h1><p> &#160; &#160; &#160; &#160;如果把这一流程总结一下，详细流程如下：<br> 1 调用OMXCodec:read()<br> 1.1 先读取ReadOptions看看是不是seek<br> 1.2 如果不是seek，则当前mState必须是EXECUTING或者RECONFIGURING<br> 1.3 如果是提交的第一帧，先调用drainInputBuffers()<br> 1.3.1 执行drainInputBuffers()必须是在mState为EXECUTING，RECONFIGURING和FLUSHING的状态<br> 1.3.2 从mPortBuffers[input]里循环取出每个BufferInfo,并对每个info-&gt;mStatus等于OWNED_BY_US的buffer调用drainInputBuffer(info)<br> 1.3.2.1 drainInputBuffer(BufferInfo)要求buffer必须是OWNED_BY_US<br> 1.3.2.2 如果有未处理的mCodecSpecificData则先mOMX-&gt;emptyBuffer(info-&gt;Buffer,OMX_BUFFERFLAG_CODECCONFIG)处理这些配置数据<br> 1.3.2.3 如果mSignalledEOS或者mPaused为true则停止drain并return false<br> 1.3.2.4 循环调用mSource-&gt;read()读取压缩源srcBuffer，读取失败的话则设置mSignalledEOS为true，如果成功则将其copy进info-&gt;mData里去<br> 1.3.2.5 结果是info-&gt;mData里装着从mSource中多次读取出来的数据总和，并将timestampUs设为第一块数据的kKeyTime值<br> 1.3.2.6 设置flags为OMX_BUFFERFLAG_ENDOFFRAME，如果刚才遇到EOS则再并一个OMX_BUFFERFLAG_EOS<br> 1.3.2.7 调用mOMX-&gt;emptyBuffer(mNode, info-&gt;mBuffer, 0, offset,flags, timestampUs);<br> 1.3.2.8 如果emptyBuffer返回OK，则设置info-&gt;mStatus为OWNED_BY_COMPONENT并return true，否则设置mState为ERROR并返回false<br> 1.4 再调用fillOutputBuffers()<br> 1.4.1 执行fillOutputBuffers()必须是在mState为EXECUTING，FLUSHING的状态<br> 1.4.2 从mPortBuffers[output]里循环取出每个BufferInfo,并对每个info-&gt;mStatus等于OWNED_BY_US的buffer调用fillOutputBuffer(info)<br> 1.4.2.1 如果mNoMoreOutputData为true则return<br> 1.4.2.2 如果info-&gt;mMediaBuffer不为空，则取出其中的GraphicBuffer，并调用mNativeWindow-&gt;lockBuffer(mNativeWindow,graphicBuffer)来锁定该buffer，出错则设置mState为ERROR<br> 1.4.2.3 调用mOMX-&gt;fillBuffer(mNode, info-&gt;mBuffer)<br> 1.4.2.4 如果emptyBuffer返回OK，则设置info-&gt;mStatus为OWNED_BY_COMPONENT，否则设置mState为ERROR，最后return<br> 1.5 如果mState不为ERROR，并且mNoMoreOutputData为false,并且mFilledBuffers为空，并且mOutputPortSettingsChangedPending为false的情况下，则调用waitForBufferFilled_l()，让mBufferFilled去wait lock<br> 1.6 从waitForBufferFilled_l()释放出来后，判断mFilledBuffers为空的话，如果mOutputPortSettingsChangedPending为true则去调用之前延迟执行的onPortSettingsChanged（），否则return EOS<br> 1.7 取出mFilledBuffers的第一个buffer，该buffer的mStatus此时必须为OWNED_BY_US<br> 1.8 然后设置其为OWNED_BY_CLIENT，给该buffer的mMediaBuffer-&gt;add_ref()增加一个引用，并把该mMediaBuffer赋值给buffer并返回给AwesomePlayer</p>
<h1 id="Audio-Playback-流程（简要分析）"><a href="#Audio-Playback-流程（简要分析）" class="headerlink" title="Audio Playback 流程（简要分析）"></a>Audio Playback 流程（简要分析）</h1><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B9%9D%29----Video%20Buffer%E4%BC%A0%E8%BE%93%E4%B8%8EAudio%20Playback%E6%B5%81%E7%A8%8B/audioplayback.jpg" alt="audio playback"></p>
<p> &#160; &#160; &#160; &#160;从上一篇可以看到，Audio播放是从AudioPlayer的start函数开始，位于frameworks/av/media/libstagefright/AudioPlayer.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioPlayer::start(<span class="keyword">bool</span> sourceAlreadyStarted) &#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//先处理seek操作</span></span><br><span class="line">    MediaSource::ReadOptions options;</span><br><span class="line">    <span class="keyword">if</span> (mSeeking) &#123;</span><br><span class="line">        options.setSeekTo(mSeekTimeUs);</span><br><span class="line">        mSeeking = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从mAudioTrack中读取音频数据，read方法我们在将Video Buffer时分析过了</span></span><br><span class="line">    mFirstBufferResult = mSource-&gt;read(&amp;mFirstBuffer, &amp;options);</span><br><span class="line">    <span class="keyword">if</span> (mFirstBufferResult == INFO_FORMAT_CHANGED) &#123;</span><br><span class="line">        ALOGV(<span class="string">"INFO_FORMAT_CHANGED!!!"</span>);</span><br><span class="line"></span><br><span class="line">        CHECK(mFirstBuffer == <span class="literal">NULL</span>);</span><br><span class="line">        mFirstBufferResult = OK;</span><br><span class="line">        mIsFirstBuffer = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mIsFirstBuffer = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略一些判断处理... </span><br><span class="line">    <span class="comment">//如果mAudioSink存在，这个我们在setDataSource已经设置过了，位于MediaPlayerService的AudioOutput</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioSink.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//调用AudioOutput的open函数，注意参数里有AudioPlayer::AudioSinkCallback，我们会用到这个回调</span></span><br><span class="line">        <span class="keyword">status_t</span> err = mAudioSink-&gt;open(</span><br><span class="line">                mSampleRate, numChannels, channelMask, audioFormat,</span><br><span class="line">                DEFAULT_AUDIOSINK_BUFFERCOUNT,</span><br><span class="line">                &amp;AudioPlayer::AudioSinkCallback,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                (<span class="keyword">audio_output_flags_t</span>)flags,</span><br><span class="line">                useOffload() ? &amp;offloadInfo : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            mLatencyUs = (<span class="keyword">int64_t</span>)mAudioSink-&gt;latency() * <span class="number">1000</span>;</span><br><span class="line">            mFrameSize = mAudioSink-&gt;frameSize();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (useOffload()) &#123;</span><br><span class="line">                <span class="comment">// If the playback is offloaded to h/w we pass the</span></span><br><span class="line">                <span class="comment">// HAL some metadata information</span></span><br><span class="line">                <span class="comment">// We don't want to do this for PCM because it will be going</span></span><br><span class="line">                <span class="comment">// through the AudioFlinger mixer before reaching the hardware</span></span><br><span class="line">                sendMetaDataToHal(mAudioSink, format);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            err = mAudioSink-&gt;start();</span><br><span class="line">            <span class="comment">// do not alter behavior for non offloaded tracks: ignore start status.</span></span><br><span class="line">            <span class="keyword">if</span> (!useOffload()) &#123;</span><br><span class="line">                err = OK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFirstBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mFirstBuffer-&gt;release();</span><br><span class="line">                mFirstBuffer = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!sourceAlreadyStarted) &#123;</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果mAudioSink不存在</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//需要创建一个AudioTrack</span></span><br><span class="line">        mAudioTrack = <span class="keyword">new</span> AudioTrack(</span><br><span class="line">                AUDIO_STREAM_MUSIC, mSampleRate, AUDIO_FORMAT_PCM_16_BIT, audioMask,</span><br><span class="line">                <span class="number">0</span> <span class="comment">/*frameCount*/</span>, AUDIO_OUTPUT_FLAG_NONE, &amp;AudioCallback, <span class="keyword">this</span>,</span><br><span class="line">                <span class="number">0</span> <span class="comment">/*notificationFrames*/</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        mLatencyUs = (<span class="keyword">int64_t</span>)mAudioTrack-&gt;latency() * <span class="number">1000</span>;</span><br><span class="line">        mFrameSize = mAudioTrack-&gt;frameSize();</span><br><span class="line">        <span class="comment">//然后调用AudioTrack的start函数</span></span><br><span class="line">        mAudioTrack-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    mPlaying = <span class="literal">true</span>;</span><br><span class="line">    mPinnedTimeUs = <span class="number">-1</span>ll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;依然是分部查看：<br>&#160; &#160; &#160; &#160;1）从mAudioTrack中读取音频数据，read方法我们在将Video Buffer时分析过了；<br>&#160; &#160; &#160; &#160;2）如果mAudioSink存在，这个我们在setDataSource已经设置过了，位于MediaPlayerService的AudioOutput，如果忘记了可以查看<a href="http://windrunnerlihuan.com/2017/01/06/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AB-%E6%92%AD%E6%94%BE%E6%B5%81%E7%A8%8B/#设置同步时钟">上一篇</a>的<strong>设置同步时钟部分</strong>。<br>&#160; &#160; &#160; &#160;3）如果mAudioSink不存在，则创建一个AudioTrack，然后start（这一步我们忽略，因为mAudioSink我们在setDataSource已经创建了）。</p>
<p>&#160; &#160; &#160; &#160;AudioPlayer在启动过程中会先去取第一帧解码的资料，并且开启audio output。这个过程和video buffer很相似。</p>
<p>&#160; &#160; &#160; &#160;开启audio output的同时，AudioPlayer会将callback回调函数指针设给他，之后每次callback函数都被回调，AudioPlayer便去audio decoder读取解码后的数据。我们可以看看这个回调函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="keyword">void</span> AudioPlayer::AudioCallback(<span class="keyword">int</span> event, <span class="keyword">void</span> *user, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;AudioPlayer *&gt;(user)-&gt;AudioCallback(event, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="keyword">size_t</span> AudioPlayer::AudioSinkCallback(</span><br><span class="line">        MediaPlayerBase::AudioSink * <span class="comment">/* audioSink */</span>,</span><br><span class="line">        <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *cookie,</span><br><span class="line">        MediaPlayerBase::AudioSink::<span class="keyword">cb_event_t</span> event) &#123;</span><br><span class="line">    AudioPlayer *me = (AudioPlayer *)cookie;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(event) &#123;</span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_FILL_BUFFER:</span><br><span class="line">        <span class="keyword">return</span> me-&gt;fillBuffer(buffer, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_STREAM_END:</span><br><span class="line">        ALOGV(<span class="string">"AudioSinkCallback: stream end"</span>);</span><br><span class="line">        me-&gt;mReachedEOS = <span class="literal">true</span>;</span><br><span class="line">        me-&gt;notifyAudioEOS();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_TEAR_DOWN:</span><br><span class="line">        ALOGV(<span class="string">"AudioSinkCallback: Tear down event"</span>);</span><br><span class="line">        me-&gt;mObserver-&gt;postAudioTearDown();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面两个回调分别对应上一步的mAudioSink存在和不存在的情况。但是最后都会调用到自己的fillBuffer方法，我们继续查看(省略大部分逻辑)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> AudioPlayer::fillBuffer(<span class="keyword">void</span> *data, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    ...省略大部分逻辑...</span><br><span class="line">    err = mSource-&gt;read(&amp;mInputBuffer, &amp;options);</span><br><span class="line">    ...省略大部分逻辑...</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)data + size_done,</span><br><span class="line">               (<span class="keyword">const</span> <span class="keyword">char</span> *)mInputBuffer-&gt;data() + mInputBuffer-&gt;range_offset(),</span><br><span class="line">               copy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;解码后audio数据的读取就是有callback回调函数所驱动。另一方面，fillBuffer数据(mInputBuffer)复制到data之后，audio output会去取这些data。</p>
<p>&#160; &#160; &#160; &#160;至于audio decoder的工作流程和video decoder相同，可以参照上面的video buffer流程。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;本节的重点其实是Video Buffer传输流程，它重点是输入缓冲区释放和将输出缓冲区中的数据传递出去。也算马马虎虎的，请恕我对多媒体的了解也是个未入门的渣渣，还正在自学途中，如有错误麻烦大家及时指出，我会在第一时间修正。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B9%9D%29----Video%20Buffer%E4%BC%A0%E8%BE%93%E4%B8%8EAudio%20Playback%E6%B5%81%E7%A8%8B/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(八)----播放流程]]></title>
      <url>http://windrunnerlihuan.com/2017/01/06/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AB-%E6%92%AD%E6%94%BE%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;前面几篇都是视频文件播放前的准备工作，比如设置数据源，初始化解码器等等，本节我们分析MediaPlayer播放器start之后的流程。<br><a id="more"></a></p>
<h1 id="播放流程"><a href="#播放流程" class="headerlink" title="播放流程"></a>播放流程</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>&#160; &#160; &#160; &#160;当MediaPlayer prepared成功之后，调用start就开始播放视频了。从前几篇我们知道底层会调用到StageFrightPlayer，最后到AwesomePlayer，我们继续跟踪下去：位于frameworks/av/media/libmediaplayerservice/StageFrightPlayer.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> StagefrightPlayer::start() &#123;</span><br><span class="line">    ALOGV(<span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StagefrightPlayer::StagefrightPlayer()</span><br><span class="line">    : mPlayer(<span class="keyword">new</span> AwesomePlayer) &#123;</span><br><span class="line">    ALOGV(<span class="string">"StagefrightPlayer"</span>);</span><br><span class="line"></span><br><span class="line">    mPlayer-&gt;setListener(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着会调用AwesomePlayer的paly函数，位于frameworks/av/media/libstagefright/AwesomePlayer.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::play() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    modifyFlags(CACHE_UNDERRUN, CLEAR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> play_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;play函数里有调用了play_l函数，表示是一个内部显示方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AwesomePlayer::play_l() &#123;</span><br><span class="line">    modifyFlags(SEEK_PREVIEW, CLEAR);</span><br><span class="line">    <span class="comment">//如果在播放，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PLAYING) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMediaRenderingStartGeneration = ++mStartGeneration;</span><br><span class="line">    <span class="comment">//如果还没有prepare，则先prepare</span></span><br><span class="line">    <span class="keyword">if</span> (!(mFlags &amp; PREPARED)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = prepare_l();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置标志位PLAYING</span></span><br><span class="line">    modifyFlags(PLAYING, SET);</span><br><span class="line">    <span class="comment">//设置标志位FIRST_FRAME，表示第一帧</span></span><br><span class="line">    modifyFlags(FIRST_FRAME, SET);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//音频解码器不为空</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//创建一个音频播放器，这一步还会设置播放同步时钟，即音频/视频/字幕播放的参考时间，下来我们会分析</span></span><br><span class="line">        <span class="keyword">if</span> (mAudioPlayer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            createAudioPlayer_l();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CHECK(!(mFlags &amp; AUDIO_RUNNING));</span><br><span class="line">        <span class="comment">//如果只有Audio没有Video，省略这一部分</span></span><br><span class="line">        <span class="keyword">if</span> (mVideoSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        ...忽略...</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有设置同步时钟，则用系统的UTC时间作为播放同步时钟</span></span><br><span class="line">    <span class="comment">//在createAudioPlayer_l里面已经设置了Audio时间轴为同步时钟，下面会讲到</span></span><br><span class="line">    <span class="keyword">if</span> (mTimeSource == <span class="literal">NULL</span> &amp;&amp; mAudioPlayer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mTimeSource = &amp;mSystemTimeSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归消息处理</span></span><br><span class="line">    <span class="keyword">if</span> (mVideoSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Kick off video playback</span></span><br><span class="line">        <span class="comment">//开球，开播</span></span><br><span class="line">        postVideoEvent_l();</span><br><span class="line">        <span class="comment">//解码状态回调，不重要</span></span><br><span class="line">        <span class="keyword">if</span> (mAudioSource != <span class="literal">NULL</span> &amp;&amp; mVideoSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            postVideoLagEvent_l();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果播放完了，则seek到开头</span></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; AT_EOS) &#123;</span><br><span class="line">        <span class="comment">// Legacy behaviour, if a stream finishes playing and then</span></span><br><span class="line">        <span class="comment">// is started again, we play from the start...</span></span><br><span class="line">        seekTo_l(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果是网络视频，则要一直发送bufferUpdate</span></span><br><span class="line">    <span class="keyword">if</span> (isStreamingHTTP()) &#123;</span><br><span class="line">        postBufferingEvent_l();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面代码虽然多，但核心只有两件事：</p>
<ul>
<li>创建一个音频播放器，这一步还会设置播放同步时钟，即音频/视频/字幕播放的参考时间</li>
<li>递归消息处理，这一步就是处理音频/视频/字幕的播放核心</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们一个一个分析：<br>&#160; &#160; &#160; &#160;1）创建音频播放器，设置同步时钟</p>
<h2 id="设置同步时钟"><a href="#设置同步时钟" class="headerlink" title="设置同步时钟"></a>设置同步时钟</h2><p>&#160; &#160; &#160; &#160;我们先看看createAudioPlayer_l这个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::createAudioPlayer_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cachedDurationUs;</span><br><span class="line">    <span class="keyword">bool</span> eos;</span><br><span class="line">    <span class="comment">//如果是offload模式，即音频分载，音频由dsp解码，不走omx框架</span></span><br><span class="line">    <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">        flags |= AudioPlayer::USE_OFFLOAD;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mVideoSource == <span class="literal">NULL</span></span><br><span class="line">            &amp;&amp; (mDurationUs &gt; AUDIO_SINK_MIN_DEEP_BUFFER_DURATION_US ||</span><br><span class="line">            (getCachedDuration_l(&amp;cachedDurationUs, &amp;eos) &amp;&amp;</span><br><span class="line">            cachedDurationUs &gt; AUDIO_SINK_MIN_DEEP_BUFFER_DURATION_US))) &#123;</span><br><span class="line">        flags |= AudioPlayer::ALLOW_DEEP_BUFFERING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isStreamingHTTP()) &#123;</span><br><span class="line">        flags |= AudioPlayer::IS_STREAMING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mVideoSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        flags |= AudioPlayer::HAS_VIDEO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个AudioPlayer，构造方法里传入了AudioSink，并设置进入音频解码器mAudioSource</span></span><br><span class="line">    mAudioPlayer = <span class="keyword">new</span> AudioPlayer(mAudioSink, flags, <span class="keyword">this</span>);</span><br><span class="line">    mAudioPlayer-&gt;setSource(mAudioSource);</span><br><span class="line">    <span class="comment">//这就是设置同步时钟，是以音频时间轴为参考时间的</span></span><br><span class="line">    mTimeSource = mAudioPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was a seek request before we ever started,</span></span><br><span class="line">    <span class="comment">// honor the request now.</span></span><br><span class="line">    <span class="comment">// Make sure to do this before starting the audio player</span></span><br><span class="line">    <span class="comment">// to avoid a race condition.</span></span><br><span class="line">    <span class="comment">//如果又一个seek请求在播放之前，我们要优先处理这个seek操作</span></span><br><span class="line">    seekAudioIfNecessary_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述函数先查看是不是<strong>offload模式</strong>，即<strong>音频分载</strong>，音频由dsp解码，不走omx框架。android L以后会支持音频的的offload播放。就高通的8994平台来看，即会把音频的编解码和后处理放到QDSP里面处理。但其实很多芯片不支持，这里我们这个不是重点，所以往下看。</p>
<p>&#160; &#160; &#160; &#160;接着就是构造AudioPlayer了，这里的构造方法传入了AudioSink，即用来输出声音。这个mAudioSink传入还要追溯到之前setDataSource那里，如果忘记了可以查看<a href="http://windrunnerlihuan.com/2016/12/12/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%9B%9B-AwesomePlayer%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%84%E7%90%86/#网络类型数据源">Android多媒体开发(四)—-AwesomePlayer数据源处理</a>。在最初的mediaplayerservice中，位于frameworks/av/media/libmediaplayerservice/MediaPlayerSrevice.cpp，调用setdatasource操作代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::setDataSource_pre(</span><br><span class="line">        player_type playerType)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"player type = %d"</span>, playerType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the right type of player</span></span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p = createPlayer(playerType);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心在这里</span></span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;hardwareOutput()) &#123;</span><br><span class="line">        mAudioOutput = <span class="keyword">new</span> AudioOutput(mAudioSessionId, IPCThreadState::self()-&gt;getCallingUid(),</span><br><span class="line">                mPid, mAudioAttributes);</span><br><span class="line">        <span class="comment">//这里会构造一个AudioOutput对象传入作为mAudioSink</span></span><br><span class="line">        <span class="keyword">static_cast</span>&lt;MediaPlayerInterface*&gt;(p.get())-&gt;setAudioSink(mAudioOutput);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里会构造一个AudioOutput对象传入作为mAudioSink，实际的播放顺序是 mAudioPlayer -&gt;mAudioSink -&gt;mAudioTrack（不要混淆，此处类是AudioTrack）。</p>
<p>&#160; &#160; &#160; &#160;最后就是设置同步时钟了，将mAudioPlayer赋值给mTimeSource 。我们可以看看AudioPlayer的继承关系，它也是继承与TimeSource类的，所以需要实现父类的<strong>getRealTimeUs</strong>这个虚函数定义位于frameworks/av/include/media/stagefright/AudioPlayer.h中，实现位于frameworks/av/media/libstagefright/AudioPlayer.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AudioPlayer : <span class="keyword">public</span> TimeSource &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> AudioPlayer::getRealTimeUs() &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;关于getRealTimeUs函数我们后面会分析到。<br>&#160; &#160; &#160; &#160;往下走play_l方法里还有这样的逻辑：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mTimeSource == <span class="literal">NULL</span> &amp;&amp; mAudioPlayer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    mTimeSource = &amp;mSystemTimeSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;设置同步时钟的，这里如果mAudioPlayer存在的话，以audio为基准进行播放，否则以系统时钟为基准控制播放。但我们的mAudioPlayer存在，所以已AudioPlayer作为参考基准控制播放。</p>
<p>&#160; &#160; &#160; &#160;<strong>注意：这里有一个重点，就是播放的同步时钟是以音频为参考时间的，后面的视频和字幕也是参考这个同步时钟来渲染和展示的。</strong></p>
<p>&#160; &#160; &#160; &#160;2）递归消息处理，这一步就是处理音频/视频/字幕的播放核心<br>&#160; &#160; &#160; &#160;然后就是递归postVideoEvent_l()消息处理，我们看看这个方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::postVideoEvent_l(<span class="keyword">int64_t</span> delayUs) &#123;<span class="comment">//缺省参数，int64_t delayUs = -1</span></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoEventPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVideoEventPending = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//因为delayUs 缺省为-1，所以每10ms触发一下回调</span></span><br><span class="line">    mQueue.postEventWithDelay(mVideoEvent, delayUs &lt; <span class="number">0</span> ? <span class="number">10000</span> : delayUs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;主要就是每10ms触发mVideoEvent事件，其响应函数是AwesomePlayer::onVideoEvent。这个方法很长，所以要一步一步查看：</p>
<h3 id="Part-1："><a href="#Part-1：" class="headerlink" title="Part.1："></a>Part.1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onVideoEvent() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mVideoEventPending) &#123;</span><br><span class="line">        <span class="comment">// The event has been cancelled in reset_l() but had already</span></span><br><span class="line">        <span class="comment">// been scheduled for execution at that time.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mVideoEventPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果有seek操作</span></span><br><span class="line">    <span class="keyword">if</span> (mSeeking != NO_SEEK) &#123;</span><br><span class="line">        <span class="comment">//先清空VideoBuffer视频数据缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (mVideoBuffer) &#123;</span><br><span class="line">            mVideoBuffer-&gt;release();</span><br><span class="line">            mVideoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是seek操作中，且是网络数据流</span></span><br><span class="line">        <span class="keyword">if</span> (mSeeking == SEEK &amp;&amp; isStreamingHTTP() &amp;&amp; mAudioSource != <span class="literal">NULL</span></span><br><span class="line">                &amp;&amp; !(mFlags &amp; SEEK_PREVIEW)) &#123;</span><br><span class="line">            <span class="comment">// We're going to seek the video source first, followed by</span></span><br><span class="line">            <span class="comment">// the audio source.</span></span><br><span class="line">            <span class="comment">// In order to avoid jumps in the DataSource offset caused by</span></span><br><span class="line">            <span class="comment">// the audio codec prefetching data from the old locations</span></span><br><span class="line">            <span class="comment">// while the video codec is already reading data from the new</span></span><br><span class="line">            <span class="comment">// locations, we'll "pause" the audio source, causing it to</span></span><br><span class="line">            <span class="comment">// stop reading input data until a subsequent seek.</span></span><br><span class="line">            <span class="comment">//我们将要seek视频的数据，然后跟着去seek音频数据</span></span><br><span class="line">            <span class="comment">//为了避免当音频预加载数据是旧的位置取到的而视频却早就取了新的位置的数据，所以我们要先pause住audio，先完成video的seek，后面再seek audio</span></span><br><span class="line">            <span class="keyword">if</span> (mAudioPlayer != <span class="literal">NULL</span> &amp;&amp; (mFlags &amp; AUDIO_RUNNING)) &#123;</span><br><span class="line">                mAudioPlayer-&gt;pause();</span><br><span class="line"></span><br><span class="line">                modifyFlags(AUDIO_RUNNING, CLEAR);</span><br><span class="line">            &#125;</span><br><span class="line">            mAudioSource-&gt;pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...未完，待续...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;首先是判断是否需要seek，若需要seek，则先pause住audio，先完成video的seek，后面再seek audio。</p>
<h3 id="Part-2："><a href="#Part-2：" class="headerlink" title="Part.2："></a>Part.2：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onVideoEvent() &#123;</span><br><span class="line"></span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mVideoBuffer) &#123;<span class="comment">//已经清空了VideoBuffer</span></span><br><span class="line">        MediaSource::ReadOptions options;</span><br><span class="line">        <span class="comment">//如果需要拖动</span></span><br><span class="line">        <span class="keyword">if</span> (mSeeking != NO_SEEK) &#123;</span><br><span class="line">            ALOGV(<span class="string">"seeking to %"</span> PRId64 <span class="string">" us (%.2f secs)"</span>, mSeekTimeUs, mSeekTimeUs / <span class="number">1E6</span>);</span><br><span class="line">            <span class="comment">//设置拖动标志</span></span><br><span class="line">            options.setSeekTo(</span><br><span class="line">                    mSeekTimeUs,</span><br><span class="line">                    mSeeking == SEEK_VIDEO_ONLY</span><br><span class="line">                        ? MediaSource::ReadOptions::SEEK_NEXT_SYNC</span><br><span class="line">                        : MediaSource::ReadOptions::SEEK_CLOSEST_SYNC);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//读取一个视频帧的画面，这个是调用omx解码后的数据，传入VideoBuffer，这个我们以后再讲</span></span><br><span class="line">            <span class="keyword">status_t</span> err = mVideoSource-&gt;read(&amp;mVideoBuffer, &amp;options);</span><br><span class="line">            options.clearSeekTo();</span><br><span class="line">            <span class="comment">//如果读取失败的处理，ignore</span></span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                CHECK(mVideoBuffer == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err == INFO_FORMAT_CHANGED) &#123;</span><br><span class="line">                    ALOGV(<span class="string">"VideoSource signalled format change."</span>);</span><br><span class="line">                    <span class="comment">//检查宽度高度是否发生变化</span></span><br><span class="line">                    notifyVideoSize_l();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mVideoRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        mVideoRendererIsPreview = <span class="literal">false</span>;</span><br><span class="line">                        initRenderer_l();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// So video playback is complete, but we may still have</span></span><br><span class="line">                <span class="comment">// a seek request pending that needs to be applied</span></span><br><span class="line">                <span class="comment">// to the audio track.</span></span><br><span class="line">                <span class="keyword">if</span> (mSeeking != NO_SEEK) &#123;</span><br><span class="line">                    ALOGV(<span class="string">"video stream ended while seeking!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                finishSeekIfNecessary(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mAudioPlayer != <span class="literal">NULL</span></span><br><span class="line">                        &amp;&amp; !(mFlags &amp; (AUDIO_RUNNING | SEEK_PREVIEW))) &#123;</span><br><span class="line">                    startAudioPlayer_l();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则即video播放完毕了，设置EOF标记</span></span><br><span class="line">                modifyFlags(VIDEO_AT_EOS, SET);</span><br><span class="line">                <span class="comment">//并触发mStreamDoneEvent消息</span></span><br><span class="line">                postStreamDoneEvent_l(err);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*如果读取一个视频帧成功，go on*/</span></span><br><span class="line">            <span class="comment">//检查读取到mVideoBuffer长度，如果长度小于0，则继续读取</span></span><br><span class="line">            <span class="keyword">if</span> (mVideoBuffer-&gt;range_length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Some decoders, notably the PV AVC software decoder</span></span><br><span class="line">                <span class="comment">// return spurious empty buffers that we just want to ignore.</span></span><br><span class="line">                <span class="comment">//一些解码器，尤其是MEPG4 h264的返回假的空buffers，我们需要忽略这些</span></span><br><span class="line">                mVideoBuffer-&gt;release();</span><br><span class="line">                mVideoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果读取一个视频帧成功了，则跳出for(;;)循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">            <span class="comment">//将解码的视频帧数+1</span></span><br><span class="line">            ++mStats.mNumVideoFramesDecoded;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...未完，待续...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上述代码分两部分：<br>&#160; &#160; &#160; &#160;①第一部分判断是否需要seek，若需要则设置option。<br>&#160; &#160; &#160; &#160;②第二部分是从mVideoSource中读取一帧画面，这里读取的时候会将option传入，如果需要seek，则读取出的数据直接就是seek后的解码数据。（中间还有些小细节：如果数据读取失败，则检查宽度高度是否发生变化，否则即video播放完毕了，设置EOF标记，并触发mStreamDoneEvent消息。）</p>
<p>&#160; &#160; &#160; &#160;mVideoSource-&gt;read是<strong>经过omx调用底层解码器后，读取返回的已经解码过的视频帧数据</strong>。关于和omx的调用关系我们以后会讲到。</p>
<h2 id="音频播放"><a href="#音频播放" class="headerlink" title="音频播放"></a>音频播放</h2><h3 id="Part-3："><a href="#Part-3：" class="headerlink" title="Part.3："></a>Part.3：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onVideoEvent() &#123;</span><br><span class="line"></span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> timeUs;<span class="comment">//从上一步读取到的视频解码帧数据中取出它的时间戳</span></span><br><span class="line">    CHECK(mVideoBuffer-&gt;meta_data()-&gt;findInt64(kKeyTime, &amp;timeUs));</span><br><span class="line">    <span class="comment">//因为这一帧即将播放，所以赋给mLastVideoTimeUs </span></span><br><span class="line">    mLastVideoTimeUs = timeUs;</span><br><span class="line">    <span class="comment">//如果仅仅seek视频，ignore</span></span><br><span class="line">    <span class="keyword">if</span> (mSeeking == SEEK_VIDEO_ONLY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSeekTimeUs &gt; timeUs) &#123;</span><br><span class="line">            ALOGI(<span class="string">"XXX mSeekTimeUs = %"</span> PRId64 <span class="string">" us, timeUs = %"</span> PRId64 <span class="string">" us"</span>,</span><br><span class="line">                 mSeekTimeUs, timeUs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mMiscStateLock)</span></span>;</span><br><span class="line">        <span class="comment">//将视频帧时间戳赋值</span></span><br><span class="line">        mVideoTimeUs = timeUs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SeekType wasSeeking = mSeeking;</span><br><span class="line">    <span class="comment">////完成audio的seek。之前说如果有seek请求，则先pause住audio，读取seek的video数据，拿到第一帧数据后，以此数据为标准，来seek audio，此处finishSeekIfNecessary便是完成此功能</span></span><br><span class="line">    finishSeekIfNecessary(timeUs);</span><br><span class="line">    <span class="comment">//如果音频没有开始播放，则开始播放音频</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioPlayer != <span class="literal">NULL</span> &amp;&amp; !(mFlags &amp; (AUDIO_RUNNING | SEEK_PREVIEW))) &#123;</span><br><span class="line">        <span class="comment">//播放音频</span></span><br><span class="line">        <span class="keyword">status_t</span> err = startAudioPlayer_l();</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Starting the audio player failed w/ err %d"</span>, err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果字幕没有开播，则播放字幕</span></span><br><span class="line">    <span class="keyword">if</span> ((mFlags &amp; TEXTPLAYER_INITIALIZED)</span><br><span class="line">            &amp;&amp; !(mFlags &amp; (TEXT_RUNNING | SEEK_PREVIEW))) &#123;</span><br><span class="line">        <span class="comment">//播放字幕    </span></span><br><span class="line">        mTextDriver-&gt;start();</span><br><span class="line">        modifyFlags(TEXT_RUNNING, SET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...未完，待续...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上述代码也分步完：<br>&#160; &#160; &#160; &#160;①从上一步读取到的视频解码帧数据中取出它的时间戳。<br>&#160; &#160; &#160; &#160;②完成audio的seek。之前说如果有seek请求，则先pause住audio，读取seek的video数据，拿到第一帧数据后，以此数据为标准，来seek audio，此处finishSeekIfNecessary便是完成此功能。我们可以看看finishSeekIfNecessary方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::finishSeekIfNecessary(<span class="keyword">int64_t</span> videoTimeUs) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">//如果是仅仅seek视频，则return</span></span><br><span class="line">    <span class="keyword">if</span> (mSeeking == SEEK_VIDEO_ONLY) &#123;</span><br><span class="line">        mSeeking = NO_SEEK;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有拖动或者是预览时候 </span></span><br><span class="line">    <span class="keyword">if</span> (mSeeking == NO_SEEK || (mFlags &amp; SEEK_PREVIEW)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we paused, then seeked, then resumed, it is possible that we have</span></span><br><span class="line">    <span class="comment">// signaled SEEK_COMPLETE at a copmletely different media time than where</span></span><br><span class="line">    <span class="comment">// we are now resuming.  Signal new position to media time provider.</span></span><br><span class="line">    <span class="comment">// Cannot signal another SEEK_COMPLETE, as existing clients may not expect</span></span><br><span class="line">    <span class="comment">// multiple SEEK_COMPLETE responses to a single seek() request.</span></span><br><span class="line">    <span class="comment">//一个seek请求在恢复拖动后可能会发送多个SEEK_COMPLETE消息，客户端当然不希望这样，所以需要处理掉多余的SEEK_COMPLETE</span></span><br><span class="line">    <span class="keyword">if</span> (mSeekNotificationSent &amp;&amp; <span class="built_in">abs</span>(mSeekTimeUs - videoTimeUs) &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">        <span class="comment">// notify if we are resuming more than 10ms away from desired seek time</span></span><br><span class="line">        notifyListener_l(MEDIA_SKIPPED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioPlayer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"seeking audio to %"</span> PRId64 <span class="string">" us (%.2f secs)."</span>, videoTimeUs, videoTimeUs / <span class="number">1E6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we don't have a video time, seek audio to the originally</span></span><br><span class="line">        <span class="comment">// requested seek time instead.</span></span><br><span class="line">        <span class="comment">//如果指定了拖动时间点mSeekTimeUs且它大于0，则拖到这个位置；如果没有则拖到原始请求拖动时候的时间点 </span></span><br><span class="line">        mAudioPlayer-&gt;seekTo(videoTimeUs &lt; <span class="number">0</span> ? mSeekTimeUs : videoTimeUs);</span><br><span class="line">        mWatchForAudioSeekComplete = <span class="literal">true</span>;</span><br><span class="line">        mWatchForAudioEOS = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mSeekNotificationSent) &#123;</span><br><span class="line">        <span class="comment">// If we're playing video only, report seek complete now,</span></span><br><span class="line">        <span class="comment">// otherwise audio player will notify us later.</span></span><br><span class="line">        <span class="comment">//若果仅仅是播放视频，则不用拖动音频</span></span><br><span class="line">        notifyListener_l(MEDIA_SEEK_COMPLETE);</span><br><span class="line">        mSeekNotificationSent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拖动完后要设置第一帧标志位FIRST_FRAME</span></span><br><span class="line">    modifyFlags(FIRST_FRAME, SET);</span><br><span class="line">    mSeeking = NO_SEEK;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;③seek完audio后，然后开始播放音频。我们看看startAudioPlayer_l：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::startAudioPlayer_l(<span class="keyword">bool</span> sendErrorNotification) &#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(mFlags &amp; AUDIOPLAYER_STARTED)) &#123;<span class="comment">//如果还没有开始播放</span></span><br><span class="line">        <span class="keyword">bool</span> wasSeeking = mAudioPlayer-&gt;isSeeking();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We've already started the MediaSource in order to enable</span></span><br><span class="line">        <span class="comment">// the prefetcher to read its data.</span></span><br><span class="line">        <span class="comment">//开始播放</span></span><br><span class="line">        err = mAudioPlayer-&gt;start(</span><br><span class="line">                <span class="literal">true</span> <span class="comment">/* sourceAlreadyStarted */</span>);</span><br><span class="line">        <span class="comment">//错误处理</span></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sendErrorNotification) &#123;</span><br><span class="line">                notifyListener_l(MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, err);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改标志位</span></span><br><span class="line">        modifyFlags(AUDIOPLAYER_STARTED, SET);</span><br><span class="line">        <span class="comment">//如果是拖动</span></span><br><span class="line">        <span class="keyword">if</span> (wasSeeking) &#123;</span><br><span class="line">            CHECK(!mAudioPlayer-&gt;isSeeking());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We will have finished the seek while starting the audio player.</span></span><br><span class="line">            <span class="comment">//发送完成拖动回调</span></span><br><span class="line">            postAudioSeekComplete();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            notifyIfMediaStarted_l();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果已经开始了，则恢复播放</span></span><br><span class="line">        err = mAudioPlayer-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//播放成功，设置标志位</span></span><br><span class="line">    <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">        modifyFlags(AUDIO_RUNNING, SET);</span><br><span class="line"></span><br><span class="line">        mWatchForAudioEOS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就开始播放音频了，关于AudioPlayer的playback流程我们以后再讲。</p>
<p>&#160; &#160; &#160; &#160;④然后播放字幕。</p>
<h2 id="音视频同步"><a href="#音视频同步" class="headerlink" title="音视频同步"></a>音视频同步</h2><h3 id="Part-4："><a href="#Part-4：" class="headerlink" title="Part.4："></a>Part.4：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onVideoEvent() &#123;</span><br><span class="line"></span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//同步时钟，是mTimeSource，即AudioPlayer</span></span><br><span class="line"> TimeSource *ts =</span><br><span class="line">        ((mFlags &amp; AUDIO_AT_EOS) || !(mFlags &amp; AUDIOPLAYER_STARTED))</span><br><span class="line">            ? &amp;mSystemTimeSource : mTimeSource;</span><br><span class="line">    <span class="keyword">int64_t</span> systemTimeUs = mSystemTimeSource.getRealTimeUs();</span><br><span class="line">    <span class="keyword">int64_t</span> looperTimeUs = ALooper::GetNowUs();</span><br><span class="line">    <span class="comment">//如果是第一帧</span></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; FIRST_FRAME) &#123;</span><br><span class="line">        modifyFlags(FIRST_FRAME, CLEAR);</span><br><span class="line">        mSinceLastDropped = <span class="number">0</span>;</span><br><span class="line">        mClockEstimator-&gt;reset();</span><br><span class="line">        <span class="comment">//在4.4以及往前的版本是 mTimeSourceDeltaUs = ts-&gt;getRealTimeUs() - timeUs; </span></span><br><span class="line">        <span class="comment">//5.0只是更精准了而已，使用了一个WindowedLinearFitEstimator工具类，有兴趣的可以研究。其实和4.4结果差别不大</span></span><br><span class="line">        mTimeSourceDeltaUs = estimateRealTimeUs(ts, systemTimeUs) - timeUs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int64_t</span> realTimeUs, mediaTimeUs;</span><br><span class="line">    <span class="comment">//如果不是第一帧，mAudioPlayer-&gt;getMediaTimeMapping(&amp;realTimeUs, &amp;mediaTimeUs)返回true，而在第一帧返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!(mFlags &amp; AUDIO_AT_EOS) &amp;&amp; mAudioPlayer != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; mAudioPlayer-&gt;getMediaTimeMapping(&amp;realTimeUs, &amp;mediaTimeUs)) &#123;</span><br><span class="line">        ALOGV(<span class="string">"updating TSdelta (%"</span> PRId64 <span class="string">" =&gt; %"</span> PRId64 <span class="string">" change %"</span> PRId64 <span class="string">")"</span>,</span><br><span class="line">              mTimeSourceDeltaUs, realTimeUs - mediaTimeUs,</span><br><span class="line">              mTimeSourceDeltaUs - (realTimeUs - mediaTimeUs));</span><br><span class="line">        ATRACE_INT(<span class="string">"TS delta change (ms)"</span>, (mTimeSourceDeltaUs - (realTimeUs - mediaTimeUs)) / <span class="number">1E3</span>);</span><br><span class="line">        mTimeSourceDeltaUs = realTimeUs - mediaTimeUs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是仅仅拖动视频</span></span><br><span class="line">    <span class="keyword">if</span> (wasSeeking == SEEK_VIDEO_ONLY) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> nowUs = estimateRealTimeUs(ts, systemTimeUs) - mTimeSourceDeltaUs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> latenessUs = nowUs - timeUs;</span><br><span class="line"></span><br><span class="line">        ATRACE_INT(<span class="string">"Video Lateness (ms)"</span>, latenessUs / <span class="number">1E3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (latenessUs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGI(<span class="string">"after SEEK_VIDEO_ONLY we're late by %.2f secs"</span>, latenessUs / <span class="number">1E6</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...未完，待续...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上面是更新时间信息：<br>&#160; &#160; &#160; &#160;①首先获取时钟源，系统时钟或者audio时钟。我们这里是audio时钟，即AudioPlayer。<br>&#160; &#160; &#160; &#160;②先要说明几个变量的意义：</p>
<ul>
<li>timeUs：这是下一视频帧画面的时间戳</li>
<li>ts-&gt;getRealTimeUs()：这是通过计算播放了多少audio帧换算出来的实际时间。这里我们可以看看AudioPlayer的getRealTimeUs函数的实现，填上上面的坑：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> AudioPlayer::getRealTimeUs() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (useOffload()) &#123;<span class="comment">//如果支持音频分载</span></span><br><span class="line">        <span class="keyword">if</span> (mSeeking) &#123;</span><br><span class="line">            <span class="keyword">return</span> mSeekTimeUs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//则从mAudioSink或者mAudioTrack处获取已经播放帧数消耗时间</span></span><br><span class="line">        mPositionTimeRealUs = getOutputPlayPositionUs_l();</span><br><span class="line">        <span class="keyword">return</span> mPositionTimeRealUs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接计算播放了多少帧消耗时间</span></span><br><span class="line">    <span class="keyword">return</span> getRealTimeUsLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> AudioPlayer::getRealTimeUsLocked() <span class="keyword">const</span> &#123;</span><br><span class="line">    CHECK(mStarted);</span><br><span class="line">    CHECK_NE(mSampleRate, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//已经播放的帧数 * 1s / 帧率 = 已经播放帧数消耗时间</span></span><br><span class="line">    <span class="keyword">int64_t</span> result = -mLatencyUs + (mNumFramesPlayed * <span class="number">1000000</span>) / mSampleRate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compensate for large audio buffers, updates of mNumFramesPlayed</span></span><br><span class="line">    <span class="comment">// are less frequent, therefore to get a "smoother" notion of time we</span></span><br><span class="line">    <span class="comment">// compensate using system time.</span></span><br><span class="line">    <span class="keyword">int64_t</span> diffUs;</span><br><span class="line">    <span class="keyword">if</span> (mPinnedTimeUs &gt;= <span class="number">0l</span>l) &#123;<span class="comment">//-1ll,小于0</span></span><br><span class="line">        diffUs = mPinnedTimeUs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        diffUs = ALooper::GetNowUs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mNumFramesPlayedSysTimeUs = ALooper::GetNowUs()</span></span><br><span class="line">    diffUs -= mNumFramesPlayedSysTimeUs;</span><br><span class="line">    <span class="comment">//上面都是障眼法</span></span><br><span class="line">    <span class="keyword">return</span> result + diffUs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> AudioPlayer::getOutputPlayPositionUs_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> playedSamples = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> sampleRate;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span>) &#123;<span class="comment">//mAudioSink 不为空，setDataSource时已经设置了</span></span><br><span class="line">        mAudioSink-&gt;getPosition(&amp;playedSamples);</span><br><span class="line">        sampleRate = mAudioSink-&gt;getSampleRate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果为空</span></span><br><span class="line">        mAudioTrack-&gt;getPosition(&amp;playedSamples);</span><br><span class="line">        sampleRate = mAudioTrack-&gt;getSampleRate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sampleRate != <span class="number">0</span>) &#123;</span><br><span class="line">        mSampleRate = sampleRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> playedUs;</span><br><span class="line">    <span class="comment">//一共播放时间</span></span><br><span class="line">    <span class="keyword">if</span> (mSampleRate != <span class="number">0</span>) &#123;</span><br><span class="line">        playedUs = (<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(playedSamples) * <span class="number">1000000</span> ) / mSampleRate;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        playedUs = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HAL position is relative to the first buffer we sent at mStartPosUs</span></span><br><span class="line">    <span class="comment">//计算出总的渲染时间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> renderedDuration = mStartPosUs + playedUs;</span><br><span class="line">    ALOGV(<span class="string">"getOutputPlayPositionUs_l %"</span> PRId64, renderedDuration);</span><br><span class="line">    <span class="keyword">return</span> renderedDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>realTimeUs： 这是从mAudioplayer中获取的信息（如果有audio的话），是当前播放位置的时间</li>
<li>mediaTimeUs：下一音频帧的时间戳</li>
</ul>
<blockquote>
<p>&#160; &#160; &#160; &#160;<strong>附注</strong>：音频跟视频很不一样，视频每一帧就是一张图像，而从上面的正玄波可以看出，音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。<br>&#160; &#160; &#160; &#160;这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的，我们可以计算一下一帧音频帧的大小：<br>&#160; &#160; &#160; &#160;假设某通道的音频信号是采样率为8kHz，位宽为16bit，20ms一帧，双通道，则一帧音频数据的大小为：<br>&#160; &#160; &#160; &#160;int size = 8000 x 16bit x 0.02s  x 2 = 5120 bit = 640 byte</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;这两个变量都是根据mAudioPlayer-&gt;getMediaTimeMapping(&amp;realTimeUs, &amp;mediaTimeUs)方法获取的，我们进入其中看看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*在构造函数里这两个变量初始赋值为-1</span><br><span class="line">    mPositionTimeMediaUs(-1), //这是从mAudioplayer中获取的信息（如果有audio的话），是当前播放位置的时间</span><br><span class="line">    mPositionTimeRealUs(-1),  //下一音频帧的时间戳</span><br><span class="line">    */</span></span><br><span class="line"><span class="keyword">bool</span> AudioPlayer::getMediaTimeMapping(</span><br><span class="line">        <span class="keyword">int64_t</span> *realtime_us, <span class="keyword">int64_t</span> *mediatime_us) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useOffload()) &#123;</span><br><span class="line">        mPositionTimeRealUs = getOutputPlayPositionUs_l();</span><br><span class="line">        *realtime_us = mPositionTimeRealUs;</span><br><span class="line">        *mediatime_us = mPositionTimeRealUs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *realtime_us = mPositionTimeRealUs;</span><br><span class="line">        *mediatime_us = mPositionTimeMediaUs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是第一帧，则两个变量都是-1，则返回false；如果不是第一帧，则返回true</span></span><br><span class="line">    <span class="keyword">return</span> mPositionTimeRealUs != <span class="number">-1</span> &amp;&amp; mPositionTimeMediaUs != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;③这正好应对了Part.4的逻辑：</p>
<ul>
<li>如果是第一帧画面则mTimeSourceDeltaUs=ts-&gt;getRealTimeUs() - timeUs;</li>
<li>如果不是第一帧画面则：mTimeSourceDeltaUs = realTimeUs - mediaTimeUs;</li>
</ul>
<p>&#160; &#160; &#160; &#160; 对于第一帧的处理，在4.4以及往前的版本是 mTimeSourceDeltaUs = ts-&gt;getRealTimeUs() - timeUs; 5.0只是更精准了而已，使用了一个WindowedLinearFitEstimator工具类，有兴趣的可以研究。其实和4.4结果差别不大，我为了方便分析，所以取这个值。</p>
<p>&#160; &#160; &#160; &#160;下面wasSeeking == SEEK_VIDEO_ONLY先忽略掉,我们继续往下：</p>
<h3 id="Part-5："><a href="#Part-5：" class="headerlink" title="Part.5："></a>Part.5：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> AwesomePlayer::onVideoEvent() &#123;</span><br><span class="line"></span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> latenessUs = <span class="number">0</span>;<span class="comment">//时间偏差latency</span></span><br><span class="line">    <span class="comment">//播放视频</span></span><br><span class="line">    <span class="keyword">if</span> (wasSeeking == NO_SEEK) &#123;</span><br><span class="line">        <span class="comment">// Let's display the first frame after seeking right away.</span></span><br><span class="line">        <span class="comment">//同4.4处理, int64_t nowUs = ts-&gt;getRealTimeUs() - mTimeSourceDeltaUs; </span></span><br><span class="line">        <span class="keyword">int64_t</span> nowUs = estimateRealTimeUs(ts, systemTimeUs) - mTimeSourceDeltaUs;</span><br><span class="line">        </span><br><span class="line">        latenessUs = nowUs - timeUs;</span><br><span class="line"></span><br><span class="line">        ATRACE_INT(<span class="string">"Video Lateness (ms)"</span>, latenessUs / <span class="number">1E3</span>);</span><br><span class="line">        <span class="comment">//如果latency过大，则要跳帧，seek到固定为止</span></span><br><span class="line">        <span class="keyword">if</span> (latenessUs &gt; <span class="number">500000l</span>l</span><br><span class="line">                &amp;&amp; mAudioPlayer != <span class="literal">NULL</span></span><br><span class="line">                &amp;&amp; mAudioPlayer-&gt;getMediaTimeMapping(</span><br><span class="line">                    &amp;realTimeUs, &amp;mediaTimeUs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWVMExtractor == <span class="literal">NULL</span>) &#123;<span class="comment">//如果不是google的私货</span></span><br><span class="line">                ALOGI(<span class="string">"we're much too late (%.2f secs), video skipping ahead"</span>,</span><br><span class="line">                     latenessUs / <span class="number">1E6</span>);</span><br><span class="line">                <span class="comment">//清空VideoBuffer，为下一次读取解码帧做准备</span></span><br><span class="line">                mVideoBuffer-&gt;release();</span><br><span class="line">                mVideoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//跳帧仅仅拖动视频</span></span><br><span class="line">                mSeeking = SEEK_VIDEO_ONLY;</span><br><span class="line">                mSeekTimeUs = mediaTimeUs;</span><br><span class="line">                <span class="comment">//postVideoEvent_l函数参数缺省为-1，所以10ms后下一次onVideoEvent</span></span><br><span class="line">                postVideoEvent_l();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是google的私货，good bye</span></span><br><span class="line">                <span class="comment">// The widevine extractor doesn't deal well with seeking</span></span><br><span class="line">                <span class="comment">// audio and video independently. We'll just have to wait</span></span><br><span class="line">                <span class="comment">// until the decoder catches up, which won't be long at all.</span></span><br><span class="line">                ALOGI(<span class="string">"we're very late (%.2f secs)"</span>, latenessUs / <span class="number">1E6</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果latency稍大，则要丢帧</span></span><br><span class="line">        <span class="keyword">if</span> (latenessUs &gt; <span class="number">40000</span>) &#123;</span><br><span class="line">            <span class="comment">// We're more than 40ms late.</span></span><br><span class="line">            ALOGV(<span class="string">"we're late by %"</span> PRId64 <span class="string">" us (%.2f secs)"</span>,</span><br><span class="line">                 latenessUs, latenessUs / <span class="number">1E6</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!(mFlags &amp; SLOW_DECODER_HACK)</span><br><span class="line">                    || mSinceLastDropped &gt; FRAME_DROP_FREQ)</span><br><span class="line">            &#123;</span><br><span class="line">                ALOGV(<span class="string">"we're late by %"</span> PRId64 <span class="string">" us (%.2f secs) dropping "</span></span><br><span class="line">                     <span class="string">"one after %d frames"</span>,</span><br><span class="line">                     latenessUs, latenessUs / <span class="number">1E6</span>, mSinceLastDropped);</span><br><span class="line"></span><br><span class="line">                mSinceLastDropped = <span class="number">0</span>;</span><br><span class="line">                mVideoBuffer-&gt;release();</span><br><span class="line">                mVideoBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line">                    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">                    <span class="comment">//丢帧数+1</span></span><br><span class="line">                    ++mStats.mNumVideoFramesDropped;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//丢帧后立刻下一次onVideoEvent</span></span><br><span class="line">                postVideoEvent_l(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果latency超前了，则要等待延时下一次onVideoEvent</span></span><br><span class="line">        <span class="keyword">if</span> (latenessUs &lt; <span class="number">-30000</span>) &#123;</span><br><span class="line">            <span class="comment">// We're more than 30ms early, schedule at most 20 ms before time due</span></span><br><span class="line">            postVideoEvent_l(latenessUs &lt; <span class="number">-60000</span> ? <span class="number">30000</span> : -latenessUs - <span class="number">20000</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...未完，待续...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上面代码和之前的时间处理要结合起来看，计算出来mTimeSourceDeltaUs之后，就可以分析播放信息如：</p>
<ul>
<li>当前播放进度，即int64_t nowUs = ts-&gt;getRealTimeUs() - mTimeSourceDeltaUs;</li>
<li>播放的latency： int64_t latenessUs = nowUs - timeUs; （这里timeUs是下一帧的时间戳）</li>
</ul>
<p>&#160; &#160; &#160; &#160;下面是处理latency过大的情况：这里比对参考是audio或者系统时钟，即与音视频同步的处理：</p>
<ul>
<li>超过500000ll US，则seek到对应位置，<strong>跳帧</strong></li>
<li>超过40000 则<strong>丢帧</strong>处理</li>
<li>当比参考时钟早了30ms，则通过postVideoEvent_l(latenessUs &lt; -60000 ? 30000 : -latenessUs - 20000);<strong>延迟触发下一次的mVideoEvent</strong></li>
</ul>
<p>&#160; &#160; &#160; &#160;音视频同步就分析到这里，自我感觉挺重要的。</p>
<h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><h3 id="Part-6："><a href="#Part-6：" class="headerlink" title="Part.6："></a>Part.6：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onVideoEvent() &#123;</span><br><span class="line"></span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line">    ...Part<span class="number">.5</span>...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((mNativeWindow != <span class="literal">NULL</span>)</span><br><span class="line">            &amp;&amp; (mVideoRendererIsPreview || mVideoRenderer == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        mVideoRendererIsPreview = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//初始化视窗</span></span><br><span class="line">        initRenderer_l();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSinceLastDropped++;</span><br><span class="line">        mVideoBuffer-&gt;meta_data()-&gt;setInt64(kKeyTime, looperTimeUs - latenessUs);</span><br><span class="line">        <span class="comment">//开始渲染画面</span></span><br><span class="line">        mVideoRenderer-&gt;render(mVideoBuffer);</span><br><span class="line">        <span class="keyword">if</span> (!mVideoRenderingStarted) &#123;</span><br><span class="line">            mVideoRenderingStarted = <span class="literal">true</span>;</span><br><span class="line">            notifyListener_l(MEDIA_INFO, MEDIA_INFO_RENDERING_START);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFlags &amp; PLAYING) &#123;</span><br><span class="line">            notifyIfMediaStarted_l();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVideoBuffer-&gt;release();</span><br><span class="line">    mVideoBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wasSeeking != NO_SEEK &amp;&amp; (mFlags &amp; SEEK_PREVIEW)) &#123;</span><br><span class="line">        modifyFlags(SEEK_PREVIEW, CLEAR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...未完，待续...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;最后就是显示此帧画面了，当播放过程一切正常时，则显示此帧画面。我们可以看看初始化Renderer的方法initRenderer_l：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::initRenderer_l() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNativeWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先获取视频元数据</span></span><br><span class="line">    sp&lt;MetaData&gt; meta = mVideoSource-&gt;getFormat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> format;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *component;</span><br><span class="line">    <span class="keyword">int32_t</span> decodedWidth, decodedHeight;</span><br><span class="line">    CHECK(meta-&gt;findInt32(kKeyColorFormat, &amp;format));<span class="comment">//颜色编码</span></span><br><span class="line">    CHECK(meta-&gt;findCString(kKeyDecoderComponent, &amp;component));<span class="comment">//解码组件</span></span><br><span class="line">    CHECK(meta-&gt;findInt32(kKeyWidth, &amp;decodedWidth));<span class="comment">//视频宽度</span></span><br><span class="line">    CHECK(meta-&gt;findInt32(kKeyHeight, &amp;decodedHeight));<span class="comment">//视频高度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> rotationDegrees;<span class="comment">//获取旋转角度</span></span><br><span class="line">    <span class="keyword">if</span> (!mVideoTrack-&gt;getFormat()-&gt;findInt32(</span><br><span class="line">                kKeyRotation, &amp;rotationDegrees)) &#123;</span><br><span class="line">        rotationDegrees = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVideoRenderer.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Must ensure that mVideoRenderer's destructor is actually executed</span></span><br><span class="line">    <span class="comment">// before creating a new one.</span></span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even if set scaling mode fails, we will continue anyway</span></span><br><span class="line">    setVideoScalingMode_l(mVideoScalingMode);</span><br><span class="line">    <span class="comment">//如果是硬解</span></span><br><span class="line">    <span class="keyword">if</span> (USE_SURFACE_ALLOC</span><br><span class="line">            &amp;&amp; !<span class="built_in">strncmp</span>(component, <span class="string">"OMX."</span>, <span class="number">4</span>)</span><br><span class="line">            &amp;&amp; <span class="built_in">strncmp</span>(component, <span class="string">"OMX.google."</span>, <span class="number">11</span>)) &#123;</span><br><span class="line">        <span class="comment">// Hardware decoders avoid the CPU color conversion by decoding</span></span><br><span class="line">        <span class="comment">// directly to ANativeBuffers, so we must use a renderer that</span></span><br><span class="line">        <span class="comment">// just pushes those buffers to the ANativeWindow.</span></span><br><span class="line">        mVideoRenderer =</span><br><span class="line">            <span class="keyword">new</span> AwesomeNativeWindowRenderer(mNativeWindow, rotationDegrees);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是软解</span></span><br><span class="line">        <span class="comment">// Other decoders are instantiated locally and as a consequence</span></span><br><span class="line">        <span class="comment">// allocate their buffers in local address space.  This renderer</span></span><br><span class="line">        <span class="comment">// then performs a color conversion and copy to get the data</span></span><br><span class="line">        <span class="comment">// into the ANativeBuffer.</span></span><br><span class="line">        sp&lt;AMessage&gt; format;</span><br><span class="line">        convertMetaDataToMessage(meta, &amp;format);</span><br><span class="line">        mVideoRenderer = <span class="keyword">new</span> AwesomeLocalRenderer(mNativeWindow, format);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;就是对硬解和软解选择不同的Renderer。</p>
<h3 id="Part-7："><a href="#Part-7：" class="headerlink" title="Part.7："></a>Part.7：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onVideoEvent() &#123;</span><br><span class="line"></span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line">    ...Part<span class="number">.5</span>...</span><br><span class="line">    ...Part<span class="number">.6</span>...</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* get next frame time 获取下一视频帧的时间*/</span></span><br><span class="line">    <span class="keyword">if</span> (wasSeeking == NO_SEEK) &#123;</span><br><span class="line">        MediaSource::ReadOptions options;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//同上，读取下一视频帧数据</span></span><br><span class="line">            <span class="keyword">status_t</span> err = mVideoSource-&gt;read(&amp;mVideoBuffer, &amp;options);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                <span class="comment">// deal with any errors next time</span></span><br><span class="line">                CHECK(mVideoBuffer == <span class="literal">NULL</span>);</span><br><span class="line">                postVideoEvent_l(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mVideoBuffer-&gt;range_length() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Some decoders, notably the PV AVC software decoder</span></span><br><span class="line">            <span class="comment">// return spurious empty buffers that we just want to ignore.</span></span><br><span class="line"></span><br><span class="line">            mVideoBuffer-&gt;release();</span><br><span class="line">            mVideoBuffer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">            ++mStats.mNumVideoFramesDecoded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> nextTimeUs;</span><br><span class="line">        <span class="comment">//下一视频帧时间戳</span></span><br><span class="line">        CHECK(mVideoBuffer-&gt;meta_data()-&gt;findInt64(kKeyTime, &amp;nextTimeUs));</span><br><span class="line">        systemTimeUs = mSystemTimeSource.getRealTimeUs();</span><br><span class="line">        <span class="comment">//延时时间</span></span><br><span class="line">        <span class="keyword">int64_t</span> delayUs = nextTimeUs - estimateRealTimeUs(ts, systemTimeUs) + mTimeSourceDeltaUs;</span><br><span class="line">        ATRACE_INT(<span class="string">"Frame delta (ms)"</span>, (nextTimeUs - timeUs) / <span class="number">1E3</span>);</span><br><span class="line">        ALOGV(<span class="string">"next frame in %"</span> PRId64, delayUs);</span><br><span class="line">        <span class="comment">// try to schedule 30ms before time due</span></span><br><span class="line">        <span class="comment">//延时处理</span></span><br><span class="line">        postVideoEvent_l(delayUs &gt; <span class="number">60000</span> ? <span class="number">30000</span> : (delayUs &lt; <span class="number">30000</span> ? <span class="number">0</span> : delayUs - <span class="number">30000</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在get next frame time上述逻辑return了，就不会触发这个了</span></span><br><span class="line">    postVideoEvent_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上述逻辑主要是获取下一视频帧的先关时间信息，然后通过计算延时处理下一次onVideEvent回调。如果在get next frame time上述逻辑return了，就不会触发末尾的postVideoEvent_l了。</p>
<p>&#160; &#160; &#160; &#160;分析到这里大家应该明白，awesoemplayer的播放驱动机制即通过递归的调用postVideoEvent_l(); 来完成。而且由于postVideoEvent_l(); 里有延迟触发消息机制，因此也不会阻塞。</p>
<p>&#160; &#160; &#160; &#160;现在应该回到play_l函数中，处理消息递归处理最后一步：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mVideoSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Kick off video playback</span></span><br><span class="line">    postVideoEvent_l();<span class="comment">//这个已经处理过了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != <span class="literal">NULL</span> &amp;&amp; mVideoSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        postVideoLagEvent_l();<span class="comment">//然后是这个消息处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;postVideoLagEvent看下此事件的处理方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> AwesomePlayer::onVideoLagUpdate() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mVideoLagEventPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mVideoLagEventPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> audioTimeUs = mAudioPlayer-&gt;getMediaTimeUs();</span><br><span class="line">    <span class="keyword">int64_t</span> videoLateByUs = audioTimeUs - mVideoTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(mFlags &amp; VIDEO_AT_EOS) &amp;&amp; videoLateByUs &gt; <span class="number">300000l</span>l) &#123;</span><br><span class="line">        ALOGV(<span class="string">"video late by %lld ms."</span>, videoLateByUs / <span class="number">1000l</span>l);</span><br><span class="line"></span><br><span class="line">        notifyListener_l(</span><br><span class="line">                MEDIA_INFO,</span><br><span class="line">                MEDIA_INFO_VIDEO_TRACK_LAGGING,</span><br><span class="line">                videoLateByUs / <span class="number">1000l</span>l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postVideoLagEvent_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一段其实没什么多大意义，主要是为了更新信息。我们可以看看MEDIA_INFO_VIDEO_TRACK_LAGGING 这个标志位的意义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The video is too complex for the decoder: it can't decode frames fast</span></span><br><span class="line"><span class="comment">// enough. Possibly only the audio plays fine at this stage.</span></span><br><span class="line">MEDIA_INFO_VIDEO_TRACK_LAGGING = <span class="number">700</span>,</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以知道当视频解码速度不够时，会通知上层，decoder不给力。</p>
<p>&#160; &#160; &#160; &#160;上述就是播放流程的大概过程。</p>
<h1 id="其他回调事件分析"><a href="#其他回调事件分析" class="headerlink" title="其他回调事件分析"></a>其他回调事件分析</h1><h2 id="mStreamDoneEvent"><a href="#mStreamDoneEvent" class="headerlink" title="mStreamDoneEvent"></a>mStreamDoneEvent</h2><p>&#160; &#160; &#160; &#160;这里是当vidoe播放结束后会触发，在onVideoEvent中当读取帧数据失败时。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onStreamDone() &#123;</span><br><span class="line">    <span class="comment">// Posted whenever any stream finishes playing.</span></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">//mStreamDoneEvent 事件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!mStreamDoneEventPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mStreamDoneEventPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">    <span class="keyword">if</span> (mStreamDoneStatus != ERROR_END_OF_STREAM) &#123;</span><br><span class="line">        ALOGV(<span class="string">"MEDIA_ERROR %d"</span>, mStreamDoneStatus);</span><br><span class="line"></span><br><span class="line">        notifyListener_l(</span><br><span class="line">                MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, mStreamDoneStatus);</span><br><span class="line"></span><br><span class="line">        pause_l(<span class="literal">true</span> <span class="comment">/* at eos */</span>);</span><br><span class="line"></span><br><span class="line">        modifyFlags(AT_EOS, SET);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否播放完了</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> allDone =</span><br><span class="line">        (mVideoSource == <span class="literal">NULL</span> || (mFlags &amp; VIDEO_AT_EOS))</span><br><span class="line">            &amp;&amp; (mAudioSource == <span class="literal">NULL</span> || (mFlags &amp; AUDIO_AT_EOS));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allDone) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是循环播放</span></span><br><span class="line">    <span class="keyword">if</span> ((mFlags &amp; LOOPING)</span><br><span class="line">            || ((mFlags &amp; AUTO_LOOPING)</span><br><span class="line">                &amp;&amp; (mAudioSink == <span class="literal">NULL</span> || mAudioSink-&gt;realtime()))) &#123;</span><br><span class="line">        <span class="comment">// Don't AUTO_LOOP if we're being recorded, since that cannot be</span></span><br><span class="line">        <span class="comment">// turned off and recording would go on indefinitely.</span></span><br><span class="line">        <span class="comment">//seek到起始位置</span></span><br><span class="line">        seekTo_l(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mVideoSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            postVideoEvent_l();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGV(<span class="string">"MEDIA_PLAYBACK_COMPLETE"</span>);</span><br><span class="line">        <span class="comment">//通知上层播放完毕</span></span><br><span class="line">        notifyListener_l(MEDIA_PLAYBACK_COMPLETE);</span><br><span class="line">        <span class="comment">//播放完毕，暂停</span></span><br><span class="line">        pause_l(<span class="literal">true</span> <span class="comment">/* at eos */</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If audio hasn't completed MEDIA_SEEK_COMPLETE yet,</span></span><br><span class="line">        <span class="comment">// notify MEDIA_SEEK_COMPLETE to observer immediately for state persistence.</span></span><br><span class="line">        <span class="keyword">if</span> (mWatchForAudioSeekComplete) &#123;</span><br><span class="line">            notifyListener_l(MEDIA_SEEK_COMPLETE);</span><br><span class="line">            mWatchForAudioSeekComplete = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modifyFlags(AT_EOS, SET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;主要做了这几件事：</p>
<ul>
<li>判断是否真的播放完毕了</li>
<li>若播放完毕了，是否需要循环，若需要则调用seekTo_l（0）继续播放</li>
<li>否则，通知上层本次播放结束，发送MEDIA_PLAYBACK_COMPLETE给调用者</li>
</ul>
<h2 id="mBufferingEvent"><a href="#mBufferingEvent" class="headerlink" title="mBufferingEvent"></a>mBufferingEvent</h2><p>&#160; &#160; &#160; &#160;awesomeplayer中通过调用postBufferingEvent_l来触发此事件，作用是缓冲数据。调用的位置有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onPrepareAsyncEvent() &#123;  </span><br><span class="line">   </span><br><span class="line">    ...... </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(isStreamingHTTP()) &#123;  </span><br><span class="line">        postBufferingEvent_l();  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        finishAsyncPrepare_l();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;当时网络流的时候，先缓冲一部分数据，看下具体实现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::postBufferingEvent_l() &#123;  </span><br><span class="line">    <span class="keyword">if</span>(mBufferingEventPending) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mBufferingEventPending =<span class="literal">true</span>;  </span><br><span class="line">    mQueue.postEventWithDelay(mBufferingEvent, <span class="number">1000000l</span>l);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;首先修改标志位mBufferingEventPending，之后触发消息。<br>&#160; &#160; &#160; &#160;这里就不贴代码了，说说原理：当需要cache数据的时候，在onPrepareAsyncEvent调用postBufferingEvent_l 后onPrepareAsyncEvent 就结束了。由于此时解码器已经开始解码，即数据链路已经建立。因此会不断的进行 读数据-解码的操作，而在onBufferingUpdate响应函数中，会先pause住输出，等数据缓存足够了之后，调用finishAsyncPrepare_l等完成prepareAsync的操作。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;到这里播放流程就分析完了，最复杂的还是递归消息处理那一段。流程中对于Video Buffer传入流程和Audio Playback流程还没分析，这个我们以后再讲。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AB%29----%E6%92%AD%E6%94%BE%E6%B5%81%E7%A8%8B/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(七)----Android中OpenMax的实现]]></title>
      <url>http://windrunnerlihuan.com/2016/12/29/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%83-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;preview篇是android对openmax的接口实现的一些规则，还有一些厂商的方案。本节就顺着上上篇的流程，分析一下从AwesomePlayer到OpenMax的调用流程。<br><a id="more"></a></p>
<h1 id="AwesomePlayer中openmax的入口"><a href="#AwesomePlayer中openmax的入口" class="headerlink" title="AwesomePlayer中openmax的入口"></a>AwesomePlayer中openmax的入口</h1><p>&#160; &#160; &#160; &#160;android中很多模块都是C/S架构的，这里AwesomePlayer中获取openmax的入口也不例外。如果要获取OMX服务，AwesomePlayer是作为Client端的。<br>&#160; &#160; &#160; &#160;<strong>AwesomePlayer</strong> 中有个变量，声明位于framework/av/media/libstagefright/include/AwesomePlayer.h中 ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OMXClient mClient;</span><br></pre></td></tr></table></figure></p>
<p>我们看看让我们看看 <strong>OMXClient</strong> 这个类，位于framework/av/include/media/stagefright/OMXClient.h：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> OMXClient &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OMXClient();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> connect();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;IOMX&gt; interface() &#123;</span><br><span class="line">        <span class="keyword">return</span> mOMX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;IOMX&gt; mOMX;</span><br><span class="line"></span><br><span class="line">    OMXClient(<span class="keyword">const</span> OMXClient &amp;);</span><br><span class="line">    OMXClient &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> OMXClient &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OMXClient 有个IOMX 的变量 mOMX ，这个就是和OMX服务进行binder通讯的。<br>&#160; &#160; &#160; &#160;<a href="http://windrunnerlihuan.com/2016/12/26/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AD-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0-preview/#Qualcomm-高通-OpenMax-IL的硬件实现">上一篇</a> 的Android中OpenMax的适配层中讲到，这个<strong>IOMX</strong>就是OpenMax的适配层接口。IOMX表示OpenMax的一个组件，根据Android的Binder IPC机制，<strong>BnOMX继承IOMX，实现者需要继承实现BnOMX</strong>。</p>
<p>&#160; &#160; &#160; &#160;在 AwesomePlayer 的构造函数中会调用如下代码，位于framework/av/media/libstagefright/AwesomePlayer.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AwesomePlayer::AwesomePlayer()</span><br><span class="line">    : ...... </span><br><span class="line">    &#123;</span><br><span class="line">    ......</span><br><span class="line">    CHECK_EQ(mClient.connect(), (<span class="keyword">status_t</span>)OK);</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造方法中会调用OMXClient的connect方法，位于framework/av/media/libstagefright/OMXClient.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> OMXClient::connect() &#123;</span><br><span class="line">    <span class="comment">/*获取MediaPlayerService服务*/</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">    sp&lt;IMediaPlayerService&gt; service = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    </span><br><span class="line">    CHECK(service.get() != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//然后通过MediaPlayerService来创建OMX的实例</span></span><br><span class="line">    mOMX = service-&gt;getOMX();</span><br><span class="line">    CHECK(mOMX.get() != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//什么情况会有不是在本地，貌似OMX是在MediaPlayerService当中new出来的，</span></span><br><span class="line">    <span class="comment">// OMXClient是在AwesomePlayer当中new出来的，而AwesomePlayer又是在MediaPlayerService当中new出来</span></span><br><span class="line">    <span class="comment">// 所以什么情况下会走到如下的这个using client-side OMX mux当中去(MuxOMX位于OMXClient.cpp当中)？</span></span><br><span class="line">    <span class="keyword">if</span> (!mOMX-&gt;livesLocally(<span class="number">0</span> <span class="comment">/* node */</span>, getpid())) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Using client-side OMX mux."</span>);</span><br><span class="line">        mOMX = <span class="keyword">new</span> MuxOMX(mOMX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OMXClient::connect函数是通过binder机制 获得到MediaPlayerService，然后通过MediaPlayerService来创建OMX的实例。这样OMXClient就获得到了OMX的入口，接下来就可以通过binder机制来获得OMX提供的服务：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IOMX&gt; MediaPlayerService::getOMX() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOMX.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mOMX = <span class="keyword">new</span> OMX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mOMX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;（什么情况会有不是在本地，貌似OMX是在MediaPlayerService当中new出来的，OMXClient是在AwesomePlayer当中new出来的，而AwesomePlayer又是在MediaPlayerService当中new出来， 所以什么情况下会走到如下的这个using client-side OMX mux当中去(MuxOMX位于OMXClient.cpp当中)？）</p>
<p>&#160; &#160; &#160; &#160;<strong>OMX</strong>的定义位于framework/av/media/libstagefright/include/OMX.h中，我们可以看到<strong>OMX继承于BnOMX，所以这里我们就获取了OpenMax的入口了</strong>。</p>
<p>&#160; &#160; &#160; &#160;在创建音视频解码mVideoSource、mAudioSource的时候会把OMXClient中的sp&lt; IOMX &gt; mOMX的实例 传给mVideoSource、mAudioSource来共享使用这个OMX的入口。<br>&#160; &#160; &#160; &#160;也就是说一个AwesomePlayer对应着 一个IOMX 变量，AwesomePlayer中的音视频解码器共用这个IOMX变量来获得OMX服务。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OMXClient.h中的interface函数</span></span><br><span class="line">sp&lt;IOMX&gt; interface() &#123;  </span><br><span class="line">      <span class="keyword">return</span> mOMX;  </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//AwesomePlayer.cpp中initAudioDecoder函数片段，创建音频解码器 </span></span><br><span class="line">mAudioSource = OMXCodec::Create(  </span><br><span class="line">                mClient.interface(), mAudioTrack-&gt;getFormat(),  </span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// createEncoder  </span></span><br><span class="line">                mAudioTrack);  </span><br><span class="line"><span class="comment">//AwesomePlayer.cpp中initVideoDecoder函数片段，创建视频解码器                 </span></span><br><span class="line">mVideoSource = OMXCodec::Create(  </span><br><span class="line">            mClient.interface(), mVideoTrack-&gt;getFormat(),  </span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// createEncoder  </span></span><br><span class="line">            mVideoTrack,  </span><br><span class="line">            <span class="literal">NULL</span>, flags, USE_SURFACE_ALLOC ? mNativeWindow : <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="OMX中的成员"><a href="#OMX中的成员" class="headerlink" title="OMX中的成员"></a>OMX中的成员</h1><p>&#160; &#160; &#160; &#160;每个AwesomePlayer 只有一个OMX服务的入口，但是AwesomePlayer不一定就只需要1种解码器。有可能音视频都有，或者有很多种。这个时候这些解码器都需要OMX的服务，也就是OMX那头需要建立不同的解码器的组件来对应着AwesomePlayer中不同的code。OMX中非常重要的2个成员就是 OMXMaster 和 OMXNodeInstance。OMX通过这俩个成员来创建和维护不同的openmax 解码器组件，为AwesomePlayer中不同解码提供服务。让我们看看他们是怎么实现这些工作的。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%83%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/openentry.jpg" alt="调用OMX流程"></p>
<ul>
<li>OMX中 OMXNodeInstance 负责创建并维护不同的实例，这些实例是根据上面需求创建的，以node作为唯一标识。这样播放器中每个OMXCodec在OMX服务端都对应有了自己的OMXNodeInstance实例。</li>
<li>OMXMaster 维护底层软硬件解码库，根据OMXNodeInstance中想要的解码器来创建解码实体组件。</li>
</ul>
<p>&#160; &#160; &#160; &#160;接下来我们来看看解码器创建的流程。</p>
<h2 id="准备工作初始化OMXMaster"><a href="#准备工作初始化OMXMaster" class="headerlink" title="准备工作初始化OMXMaster"></a>准备工作初始化OMXMaster</h2><p>&#160; &#160; &#160; &#160;OMX构造函数中会进行初始化OMXMaster，位于framework/av/media/libstagefright/omx/OMX.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个mMaster全部变量声明位于OMX.h中</span></span><br><span class="line">OMXMaster *mMaster;  </span><br><span class="line"></span><br><span class="line">OMX::OMX()</span><br><span class="line">    : mMaster(<span class="keyword">new</span> OMXMaster),</span><br><span class="line">      mNodeCounter(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着看OMXMaster的构造方法，位于framework/av/media/libstagefright/omx/OMXMaster.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OMXMaster::OMXMaster()</span><br><span class="line">    : mVendorLibHandle(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    addVendorPlugin();<span class="comment">//添加芯片商编解码插件(硬解)</span></span><br><span class="line">    addPlugin(<span class="keyword">new</span> SoftOMXPlugin);<span class="comment">//添加软解插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OMXMaster 负责OMX中编解码器插件管理，软件解码和硬件解码都是使用OMX标准，挂载plugins的方式来进行管理。接下来我们分析这两个流程：</p>
<h3 id="添加硬解插件"><a href="#添加硬解插件" class="headerlink" title="添加硬解插件"></a>添加硬解插件</h3><p>&#160; &#160; &#160; &#160;硬解插件查看addVendorPlugin函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> OMXMaster::addVendorPlugin() &#123;</span><br><span class="line">    addPlugin(<span class="string">"libstagefrighthw.so"</span>);<span class="comment">//添加libstagefrighthw.so</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> OMXMaster::addPlugin(<span class="keyword">const</span> <span class="keyword">char</span> *libname) &#123;</span><br><span class="line">    mVendorLibHandle = dlopen(libname, RTLD_NOW);<span class="comment">//动态打开libstagefrighthw.so</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVendorLibHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个OMXPluginBase 函数指针</span></span><br><span class="line">    <span class="keyword">typedef</span> OMXPluginBase *(*CreateOMXPluginFunc)();</span><br><span class="line">    <span class="comment">//调用插件类中的createOMXPlugin函数，创建一个编解码plugin</span></span><br><span class="line">    CreateOMXPluginFunc createOMXPlugin =</span><br><span class="line">        (CreateOMXPluginFunc)dlsym(</span><br><span class="line">                mVendorLibHandle, <span class="string">"createOMXPlugin"</span>);</span><br><span class="line">    <span class="comment">//度过调用上述方法失败，则调用如下函数(一般不会失败)            </span></span><br><span class="line">    <span class="keyword">if</span> (!createOMXPlugin)</span><br><span class="line">        createOMXPlugin = (CreateOMXPluginFunc)dlsym(</span><br><span class="line">                mVendorLibHandle, <span class="string">"_ZN7android15createOMXPluginEv"</span>);</span><br><span class="line">    <span class="comment">//如果创建编解码插件成功，则调用如下重载函数</span></span><br><span class="line">    <span class="keyword">if</span> (createOMXPlugin) &#123;</span><br><span class="line">        addPlugin((*createOMXPlugin)());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//保存软解和硬解的插件List</span></span><br><span class="line">    List&lt;OMXPluginBase *&gt; mPlugins;</span><br><span class="line">    <span class="comment">//保存所有编解码组件的map</span></span><br><span class="line">    KeyedVector&lt;String8, OMXPluginBase *&gt; mPluginByComponentName;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> OMXMaster::addPlugin(OMXPluginBase *plugin) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">//将硬解插件加入到list中</span></span><br><span class="line">    mPlugins.push_back(plugin);</span><br><span class="line"></span><br><span class="line">    OMX_U32 index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">128</span>];</span><br><span class="line">    OMX_ERRORTYPE err;</span><br><span class="line">    <span class="comment">//循环遍历所有的编解码组件</span></span><br><span class="line">    <span class="keyword">while</span> ((err = plugin-&gt;enumerateComponents(</span><br><span class="line">                    name, <span class="keyword">sizeof</span>(name), index++)) == OMX_ErrorNone) &#123;</span><br><span class="line">        <span class="function">String8 <span class="title">name8</span><span class="params">(name)</span></span>;</span><br><span class="line">        <span class="comment">//如果这个组件已经加载过了，则忽略，continue</span></span><br><span class="line">        <span class="keyword">if</span> (mPluginByComponentName.indexOfKey(name8) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"A component of name '%s' already exists, ignoring this one."</span>,</span><br><span class="line">                 name8.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后根据每一个组件的名字和硬解插件对象指针，保存进map</span></span><br><span class="line">        mPluginByComponentName.add(name8, plugin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OMX_ErrorNoMore) &#123;</span><br><span class="line">        ALOGE(<span class="string">"OMX plugin failed w/ error 0x%08x after registering %zu "</span></span><br><span class="line">             <span class="string">"components"</span>, err, mPluginByComponentName.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里主要分两步：<br>&#160; &#160; &#160; &#160;（1）动态打开libstagefrighthw.so库，然后获取硬解插件对象指针。<br>&#160; &#160; &#160; &#160;这个libstagefrighthw.so是和硬件相关的，每个厂商内部实现都不一样，编译目录都在hardware/[厂商]/{一些目录}/libstagefrighthw/  下面，以Qualcomm(高通)为例，就是hardware/qcom/media/libstagefrighthw/，这个目录下的文件都会被编译进入libstagefrighthw.so。</p>
<p>&#160; &#160; &#160; &#160;（2）先保存上一步获取的硬解码插件。<br>&#160; &#160; &#160; &#160;循环遍历所有的编解码组件，然后根据每一个组件的名字和硬解插件对象指针，保存进mPluginByComponentName这个类似map的变量。</p>
<p>&#160; &#160; &#160; &#160;循环遍历硬解插件的流程我们就得进入第一步提到的编译硬解插件的libstagefrighthw.so的源文件看看了。依然以高通为例，步入hardware/qcom/media/libstagefrighthw/QComOMXPlugin：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">OMX_ERRORTYPE QComOMXPlugin::enumerateComponents(</span><br><span class="line">        OMX_STRING name,</span><br><span class="line">        <span class="keyword">size_t</span> size,</span><br><span class="line">        OMX_U32 index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLibHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//会调用mComponentNameEnum函数指针，赋值位于构造函数</span></span><br><span class="line">    <span class="keyword">return</span> (*mComponentNameEnum)(name, size, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们第一步创建硬解插件的对象，然后将指针传递给上面保存*/</span></span><br><span class="line"><span class="function">OMXPluginBase *<span class="title">createOMXPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QComOMXPlugin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//QComOMXPlugin的构造函数</span></span><br><span class="line">QComOMXPlugin::QComOMXPlugin()</span><br><span class="line">    : mLibHandle(dlopen(<span class="string">"libOmxCore.so"</span>, RTLD_NOW)),</span><br><span class="line">      mInit(<span class="literal">NULL</span>),</span><br><span class="line">      mDeinit(<span class="literal">NULL</span>),</span><br><span class="line">      mComponentNameEnum(<span class="literal">NULL</span>),</span><br><span class="line">      mGetHandle(<span class="literal">NULL</span>),</span><br><span class="line">      mFreeHandle(<span class="literal">NULL</span>),</span><br><span class="line">      mGetRolesOfComponentHandle(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLibHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mInit = (InitFunc)dlsym(mLibHandle, <span class="string">"OMX_Init"</span>);</span><br><span class="line">        mDeinit = (DeinitFunc)dlsym(mLibHandle, <span class="string">"OMX_Deinit"</span>);</span><br><span class="line">        <span class="comment">//这个是我们需要的，在libOmxCore.so里面，调用OMX_ComponentNameEnum函数</span></span><br><span class="line">        mComponentNameEnum =</span><br><span class="line">            (ComponentNameEnumFunc)dlsym(mLibHandle, <span class="string">"OMX_ComponentNameEnum"</span>);</span><br><span class="line"></span><br><span class="line">        mGetHandle = (GetHandleFunc)dlsym(mLibHandle, <span class="string">"OMX_GetHandle"</span>);</span><br><span class="line">        mFreeHandle = (FreeHandleFunc)dlsym(mLibHandle, <span class="string">"OMX_FreeHandle"</span>);</span><br><span class="line"></span><br><span class="line">        mGetRolesOfComponentHandle =</span><br><span class="line">            (GetRolesOfComponentFunc)dlsym(</span><br><span class="line">                    mLibHandle, <span class="string">"OMX_GetRolesOfComponent"</span>);</span><br><span class="line"></span><br><span class="line">        (*mInit)();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后我们需要的，在libOmxCore.so里面，调用OMX_ComponentNameEnum函数。这时候我们就得查看上一篇文章，<a href="http://windrunnerlihuan.com/2016/12/26/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AD-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0-preview/#Qualcomm-高通-OpenMax-IL的硬件实现">Android多媒体开发(六)—-Android中OpenMax的实现(preview)</a> ，看看高通对于这一部分的而实现。<br>&#160; &#160; &#160; &#160;找到后进入hardware/qcom/media/mm-core/omxcore/src/common/qc_omx_core.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_API OMX_ERRORTYPE OMX_APIENTRY</span><br><span class="line"><span class="title">OMX_ComponentNameEnum</span><span class="params">(OMX_OUT OMX_STRING componentName,</span><br><span class="line">                      OMX_IN  OMX_U32          nameLen,</span><br><span class="line">                      OMX_IN  OMX_U32            index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  OMX_ERRORTYPE eRet = OMX_ErrorNone;</span><br><span class="line">  DEBUG_PRINT(<span class="string">"OMXCORE API - OMX_ComponentNameEnum %x %d %d\n"</span>,(<span class="keyword">unsigned</span>) componentName</span><br><span class="line">                                                              ,(<span class="keyword">unsigned</span>)nameLen</span><br><span class="line">                                                              ,(<span class="keyword">unsigned</span>)index);</span><br><span class="line">  <span class="keyword">if</span>(index &lt; SIZE_OF_CORE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _ANDROID_</span></span><br><span class="line">    <span class="comment">//其实就是这个core数组里面所有的组件名，这个core我们上一节也分析过omx_core_cb_type core[]</span></span><br><span class="line">    <span class="comment">//是不同型号中注册的编解码组件，在hardware/qcom/media/mm-core/src下面</span></span><br><span class="line">    strlcpy(componentName, core[index].name,nameLen);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">strncpy</span>(componentName, core[index].name,nameLen);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    eRet = OMX_ErrorNoMore;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因为要找到所有的硬件编解码组件，我们找到了上一盘文章分析到的数组core。其实就是这个core数组里面所有的组件名，这个core我们上一节也分析过omx_core_cb_type core[]，是不同型号中注册的编解码组件，在hardware/qcom/media/mm-core/src下面。会看到有许多型号，7627A、7630、8084、8226、8610、8660等等。比如这个8974的，位于hardware/qcom/media/mm-core/src/8974/qc_registry_table_android.c。里面有非常多的硬件编解码组件。</p>
<p>&#160; &#160; &#160; &#160;然后根据每一个组件的名字和硬解插件对象指针，保存进mPluginByComponentName这个类似map的变量。<br>&#160; &#160; &#160; &#160;硬解码插件添加就到这儿了。</p>
<h3 id="添加软解插件"><a href="#添加软解插件" class="headerlink" title="添加软解插件"></a>添加软解插件</h3><p>&#160; &#160; &#160; &#160;软解插件添加就简单了，addPlugin(new SoftOMXPlugin)。所以我们看看SoftOMXPlugin的enumerateComponents函数，位于framework/av/media/libstagefright/omx/SoftOMXPlugin.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OMX_ERRORTYPE SoftOMXPlugin::enumerateComponents(</span><br><span class="line">        OMX_STRING name,</span><br><span class="line">        <span class="keyword">size_t</span> <span class="comment">/* size */</span>,</span><br><span class="line">        OMX_U32 index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= kNumComponents) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorNoMore;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//软解查找所有的组件就是在kComponents这个数组里</span></span><br><span class="line">    <span class="built_in">strcpy</span>(name, kComponents[index].mName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;软解查找所有的组件就是在kComponents这个数组里，我们看看这个数组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mName;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mLibNameSuffix;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mRole;</span><br><span class="line"></span><br><span class="line">&#125; kComponents[] = &#123;</span><br><span class="line">    &#123; <span class="string">"OMX.google.aac.decoder"</span>, <span class="string">"aacdec"</span>, <span class="string">"audio_decoder.aac"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.aac.encoder"</span>, <span class="string">"aacenc"</span>, <span class="string">"audio_encoder.aac"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.amrnb.decoder"</span>, <span class="string">"amrdec"</span>, <span class="string">"audio_decoder.amrnb"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.amrnb.encoder"</span>, <span class="string">"amrnbenc"</span>, <span class="string">"audio_encoder.amrnb"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.amrwb.decoder"</span>, <span class="string">"amrdec"</span>, <span class="string">"audio_decoder.amrwb"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.amrwb.encoder"</span>, <span class="string">"amrwbenc"</span>, <span class="string">"audio_encoder.amrwb"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.h264.decoder"</span>, <span class="string">"h264dec"</span>, <span class="string">"video_decoder.avc"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.h264.encoder"</span>, <span class="string">"h264enc"</span>, <span class="string">"video_encoder.avc"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.hevc.decoder"</span>, <span class="string">"hevcdec"</span>, <span class="string">"video_decoder.hevc"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.g711.alaw.decoder"</span>, <span class="string">"g711dec"</span>, <span class="string">"audio_decoder.g711alaw"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.g711.mlaw.decoder"</span>, <span class="string">"g711dec"</span>, <span class="string">"audio_decoder.g711mlaw"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.h263.decoder"</span>, <span class="string">"mpeg4dec"</span>, <span class="string">"video_decoder.h263"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.h263.encoder"</span>, <span class="string">"mpeg4enc"</span>, <span class="string">"video_encoder.h263"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.mpeg4.decoder"</span>, <span class="string">"mpeg4dec"</span>, <span class="string">"video_decoder.mpeg4"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.mpeg4.encoder"</span>, <span class="string">"mpeg4enc"</span>, <span class="string">"video_encoder.mpeg4"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.mp3.decoder"</span>, <span class="string">"mp3dec"</span>, <span class="string">"audio_decoder.mp3"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.vorbis.decoder"</span>, <span class="string">"vorbisdec"</span>, <span class="string">"audio_decoder.vorbis"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.opus.decoder"</span>, <span class="string">"opusdec"</span>, <span class="string">"audio_decoder.opus"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.vp8.decoder"</span>, <span class="string">"vpxdec"</span>, <span class="string">"video_decoder.vp8"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.vp9.decoder"</span>, <span class="string">"vpxdec"</span>, <span class="string">"video_decoder.vp9"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.vp8.encoder"</span>, <span class="string">"vpxenc"</span>, <span class="string">"video_encoder.vp8"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.raw.decoder"</span>, <span class="string">"rawdec"</span>, <span class="string">"audio_decoder.raw"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.flac.encoder"</span>, <span class="string">"flacenc"</span>, <span class="string">"audio_encoder.flac"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.gsm.decoder"</span>, <span class="string">"gsmdec"</span>, <span class="string">"audio_decoder.gsm"</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;android 默认会提供一系列的软件解码器，我们会发现<strong>这些软解组件名都是以OMX.google开头的</strong>。</p>
<p>&#160; &#160; &#160; &#160;然后根据每一个组件的名字和软解插件对象指针，同样保存进mPluginByComponentName这个类似map的变量。</p>
<h1 id="创建mVideoSource-mAudioSource"><a href="#创建mVideoSource-mAudioSource" class="headerlink" title="创建mVideoSource/mAudioSource"></a>创建mVideoSource/mAudioSource</h1><p>&#160; &#160; &#160; &#160;有了上面的OMX，接下来会在AwesomePlayer::initVideoDecoder中创建mVideoSource，AwesomePlayer::initAudioDecoder中创建mAudioSource。</p>
<h2 id="创建mVideoSource"><a href="#创建mVideoSource" class="headerlink" title="创建mVideoSource"></a>创建mVideoSource</h2><p>&#160; &#160; &#160; &#160;创建视频解码器，依然位于AwesomePlayer中，省略部分代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::initVideoDecoder(<span class="keyword">uint32_t</span> flags) &#123;  </span><br><span class="line">    ATRACE_CALL();  </span><br><span class="line">    ......</span><br><span class="line">    mVideoSource = OMXCodec::Create(  </span><br><span class="line">            mClient.interface(), mVideoTrack-&gt;getFormat(),  </span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// createEncoder  </span></span><br><span class="line">            mVideoTrack,  </span><br><span class="line">            <span class="literal">NULL</span>, flags, USE_SURFACE_ALLOC ? mNativeWindow : <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">status_t</span> err = mVideoSource-&gt;start();  </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mVideoSource != <span class="literal">NULL</span> ? OK : UNKNOWN_ERROR;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;保留主要部分，然后查看OMXCodec的Create方法，位于framework/av/media/libstagefright/OMXCode.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">sp&lt;MediaSource&gt; OMXCodec::Create(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IOMX&gt; &amp;omx, <span class="comment">//OMX</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;MetaData&gt; &amp;meta, <span class="comment">//视频源的元数据</span></span><br><span class="line">        <span class="keyword">bool</span> createEncoder, <span class="comment">//false</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaSource&gt; &amp;source, <span class="comment">//mVideoTrack视频源</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *matchComponentName,<span class="comment">//NULl</span></span><br><span class="line">        <span class="keyword">uint32_t</span> flags,<span class="comment">//缺省，0</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;ANativeWindow&gt; &amp;nativeWindow) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int32_t</span> requiresSecureBuffers;</span><br><span class="line">    <span class="comment">//如果是安全的数据源，需要DRM处理</span></span><br><span class="line">    <span class="keyword">if</span> (source-&gt;getFormat()-&gt;findInt32(</span><br><span class="line">                kKeyRequiresSecureBuffers,</span><br><span class="line">                &amp;requiresSecureBuffers)</span><br><span class="line">            &amp;&amp; requiresSecureBuffers) &#123;</span><br><span class="line">        flags |= kIgnoreCodecSpecificData;</span><br><span class="line">        flags |= kUseSecureInputBuffers;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    <span class="comment">//获取视频源的mime</span></span><br><span class="line">    <span class="keyword">bool</span> success = meta-&gt;findCString(kKeyMIMEType, &amp;mime);</span><br><span class="line">    CHECK(success);</span><br><span class="line">    <span class="comment">//匹配的解码器组件</span></span><br><span class="line">    Vector&lt;CodecNameAndQuirks&gt; matchingCodecs;</span><br><span class="line">    <span class="comment">//查找和视频源mime匹配的所有解码器组件</span></span><br><span class="line">    findMatchingCodecs(</span><br><span class="line">            mime, createEncoder, matchComponentName, flags, &amp;matchingCodecs);</span><br><span class="line">    <span class="comment">//如果没找到解码器返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (matchingCodecs.isEmpty()) &#123;</span><br><span class="line">        ALOGV(<span class="string">"No matching codecs! (mime: %s, createEncoder: %s, "</span></span><br><span class="line">                <span class="string">"matchComponentName: %s, flags: 0x%x)"</span>,</span><br><span class="line">                mime, createEncoder ? <span class="string">"true"</span> : <span class="string">"false"</span>, matchComponentName, flags);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个OMXCodecObserver消息观察器，用于处理消息回调</span></span><br><span class="line">    sp&lt;OMXCodecObserver&gt; observer = <span class="keyword">new</span> OMXCodecObserver;</span><br><span class="line">    IOMX::node_id node = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历和视频源mime匹配的所有解码器组件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; matchingCodecs.size(); ++i) &#123;</span><br><span class="line">        <span class="comment">//解码组件名</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentNameBase = matchingCodecs[i].mName.<span class="built_in">string</span>();</span><br><span class="line">        <span class="comment">//解码组件的Quirk</span></span><br><span class="line">        <span class="keyword">uint32_t</span> quirks = matchingCodecs[i].mQuirks;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName = componentNameBase;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//如果是编码器，false</span></span><br><span class="line">        <span class="keyword">if</span> (createEncoder) &#123;</span><br><span class="line">            sp&lt;MediaSource&gt; softwareCodec =</span><br><span class="line">                InstantiateSoftwareEncoder(componentName, source, meta);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (softwareCodec != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGV(<span class="string">"Successfully allocated software codec '%s'"</span>, componentName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> softwareCodec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALOGV(<span class="string">"Attempting to allocate OMX node '%s'"</span>, componentName);</span><br><span class="line">        <span class="comment">//如果是安全的数据源，则需要OMX.SEC开头的解码器</span></span><br><span class="line">        <span class="keyword">if</span> (!createEncoder</span><br><span class="line">                &amp;&amp; (quirks &amp; kOutputBuffersAreUnreadable)</span><br><span class="line">                &amp;&amp; (flags &amp; kClientNeedsFramebuffer)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(componentName, <span class="string">"OMX.SEC."</span>, <span class="number">8</span>)) &#123;</span><br><span class="line">                <span class="comment">// For OMX.SEC.* decoders we can enable a special mode that</span></span><br><span class="line">                <span class="comment">// gives the client access to the framebuffer contents.</span></span><br><span class="line"></span><br><span class="line">                ALOGW(<span class="string">"Component '%s' does not give the client access to "</span></span><br><span class="line">                     <span class="string">"the framebuffer contents. Skipping."</span>,</span><br><span class="line">                     componentName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个allocateNode 就是文章最开始讲的，在OMX那头创建一个和mVideoSource相匹配的解码实例。用node值作为唯一标识。</span></span><br><span class="line">        <span class="keyword">status_t</span> err = omx-&gt;allocateNode(componentName, observer, &amp;node);</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            ALOGV(<span class="string">"Successfully allocated OMX node '%s'"</span>, componentName);</span><br><span class="line">            <span class="comment">//创建一个OMXCodec实例</span></span><br><span class="line">            sp&lt;OMXCodec&gt; codec = <span class="keyword">new</span> OMXCodec(</span><br><span class="line">                    omx, node, quirks, flags,</span><br><span class="line">                    createEncoder, mime, componentName,</span><br><span class="line">                    source, nativeWindow);</span><br><span class="line">            <span class="comment">//然后将这个OMXCodec实例设置给OMXCodecObserver，用于回调消息</span></span><br><span class="line">            observer-&gt;setCodec(codec);</span><br><span class="line">            <span class="comment">//根据元数据设置相关内容</span></span><br><span class="line">            err = codec-&gt;configureCodec(meta);</span><br><span class="line">            <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> codec;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ALOGV(<span class="string">"Failed to configure codec '%s'"</span>, componentName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;主要流程我们分步查看：</p>
<h3 id="查找所有匹配解码组件"><a href="#查找所有匹配解码组件" class="headerlink" title="查找所有匹配解码组件"></a>查找所有匹配解码组件</h3><p>&#160; &#160; &#160; &#160;根据mVideoTrack传进来的视频信息mime，查找相匹配的解码器组件。查看findMatchingCodecs方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="keyword">void</span> OMXCodec::findMatchingCodecs(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime, <span class="comment">//视频源mime</span></span><br><span class="line">        <span class="keyword">bool</span> createEncoder, <span class="comment">//false</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *matchComponentName,<span class="comment">//NULL</span></span><br><span class="line">        <span class="keyword">uint32_t</span> flags,<span class="comment">//0</span></span><br><span class="line">        Vector&lt;CodecNameAndQuirks&gt; *matchingCodecs) &#123;<span class="comment">//外部刚创建的空的Vector</span></span><br><span class="line">    matchingCodecs-&gt;clear();</span><br><span class="line">    <span class="comment">//获取本地配置的编解码器组件列表</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IMediaCodecList&gt; <span class="built_in">list</span> = MediaCodecList::getInstance();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//查找匹配的解码器在list中的index</span></span><br><span class="line">        <span class="keyword">ssize_t</span> matchIndex =</span><br><span class="line">            <span class="built_in">list</span>-&gt;findCodecByType(mime, createEncoder, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matchIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index = matchIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获取匹配解码器的MediaCodecInfo</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaCodecInfo&gt; info = <span class="built_in">list</span>-&gt;getCodecInfo(matchIndex);</span><br><span class="line">        CHECK(info != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName = info-&gt;getCodecName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a specific codec is requested, skip the non-matching ones.</span></span><br><span class="line">        <span class="comment">//如果已经确定了解码器组件名（即外部传入的那个matchComponentName，为NULL）,</span></span><br><span class="line">        <span class="comment">//并且本地配置组件列表中的匹配解码器名字和外部传入的解码器组件名不行等，则跳过这个列表中的组件，继续往下</span></span><br><span class="line">        <span class="keyword">if</span> (matchComponentName &amp;&amp; <span class="built_in">strcmp</span>(componentName, matchComponentName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When requesting software-only codecs, only push software codecs 如果仅仅需要软解</span></span><br><span class="line">        <span class="comment">// When requesting hardware-only codecs, only push hardware codecs 如果仅仅需要硬解</span></span><br><span class="line">        <span class="comment">// When there is request neither for software-only nor for 如果不是上面两种情况</span></span><br><span class="line">        <span class="comment">// hardware-only codecs, push all codecs</span></span><br><span class="line">        <span class="keyword">if</span> (((flags &amp; kSoftwareCodecsOnly) &amp;&amp;   IsSoftwareCodec(componentName)) ||</span><br><span class="line">            ((flags &amp; kHardwareCodecsOnly) &amp;&amp;  !IsSoftwareCodec(componentName)) ||</span><br><span class="line">            (!(flags &amp; (kSoftwareCodecsOnly | kHardwareCodecsOnly)))) &#123;</span><br><span class="line">            <span class="comment">//将匹配到的的解码器加入到外部传入的Vector当中</span></span><br><span class="line">            <span class="keyword">ssize_t</span> index = matchingCodecs-&gt;add();</span><br><span class="line">            CodecNameAndQuirks *entry = &amp;matchingCodecs-&gt;editItemAt(index);</span><br><span class="line">            entry-&gt;mName = String8(componentName);</span><br><span class="line">            entry-&gt;mQuirks = getComponentQuirks(info);</span><br><span class="line"></span><br><span class="line">            ALOGV(<span class="string">"matching '%s' quirks 0x%08x"</span>,</span><br><span class="line">                  entry-&gt;mName.<span class="built_in">string</span>(), entry-&gt;mQuirks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kPreferSoftwareCodecs) &#123;<span class="comment">//如果是优先软解，则需要将软解组件排序到前面</span></span><br><span class="line">        matchingCodecs-&gt;sort(CompareSoftwareCodecsFirst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里主要也是做了两件事：</p>
<ul>
<li>取出获取本地配置的编解码器组件列表</li>
<li>根据视频的mime类型在本地配置的编解码器组件列表中选取所有匹配的解码器</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们依然查看：</p>
<p>&#160; &#160; &#160; &#160;（1） 获取本地配置编解码器列表</p>
<p>&#160; &#160; &#160; &#160;const sp&lt; IMediaCodecList &gt; list = MediaCodecList::getInstance();我们进入MediaCodecList的getInstance()函数看看，位于framework/av/media/libstagefright/MediaCodecList.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getInstance() &#123;</span><br><span class="line">    Mutex::Autolock _l(sRemoteInitMutex);</span><br><span class="line">    <span class="keyword">if</span> (sRemoteList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//获取MediaPlayerService服务</span></span><br><span class="line">        sp&lt;IBinder&gt; binder =</span><br><span class="line">            defaultServiceManager()-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">        sp&lt;IMediaPlayerService&gt; service =</span><br><span class="line">            interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">        <span class="keyword">if</span> (service.get() != <span class="literal">NULL</span>) &#123;<span class="comment">//MediaPlayerService的getCodecList函数</span></span><br><span class="line">            sRemoteList = service-&gt;getCodecList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sRemoteList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// if failed to get remote list, create local list</span></span><br><span class="line">            sRemoteList = getLocalInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sRemoteList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后进入MediaPlayerService查看getCodecList函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IMediaCodecList&gt; MediaPlayerService::getCodecList() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MediaCodecList::getLocalInstance();<span class="comment">//这特么又回去了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这特么又回去了，继续查看MediaCodecList::getLocalInstance()：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MediaCodecList::MediaCodecList()</span><br><span class="line">    : mInitCheck(NO_INIT) &#123;</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs.xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;后续其实就是解析/etc/media_codecs.xml，然后将里面的编解码器相关信息保存起来，每一个编解码器就是一个MediaCodecInfo。<br>&#160; &#160; &#160; &#160;解析xml的函数都在MediaCodecList.cpp中，只不过用C++的函数处理的，看了下先关函数，和java层的SAX解析xml很像。有兴趣的童鞋可以看看，这里限于篇幅就不贴代码了。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;实际上系统中存在的解码器可以很多，但能够被应用使用的解码器是根据配置来的，即/etc/media_codecc.xml。这个文件一般由硬件或者系统的生产厂家在build整个系统的时候提供，一般是保存在代码的device/[company]/[codename]目录下的，例如device/samsung/manta/media_codecs.xml。这个文件配置了系统中有哪些可用的codec以及，这些codec对应的媒体文件类型。在这个文件里面，系统里面提供的软硬codec都需要被列出来。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;我借了同事的nexus 5，刷的是android的原生系统，也是高通的芯片。然后取出media_codecc.xml文件，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MediaCodecs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">"media_codecs_google_audio.xml"</span> /&gt;</span> <span class="comment">&lt;!-- audio codec相关，在另一个xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">"media_codecs_google_telephony.xml"</span> /&gt;</span><span class="comment">&lt;!-- telephony codec相关 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Setting</span> <span class="attr">name</span>=<span class="string">"max-video-encoder-input-buffers"</span> <span class="attr">value</span>=<span class="string">"9"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Encoders</span>&gt;</span><span class="comment">&lt;!-- 一些视频的encoder --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.encoder.mpeg4"</span> <span class="attr">type</span>=<span class="string">"video/mp4v-es"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-loaded-to-idle-after-allocation"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"96x64"</span> <span class="attr">max</span>=<span class="string">"1920x1088"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"block-size"</span> <span class="attr">value</span>=<span class="string">"16x16"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"blocks-per-second"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"489600"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"bitrate"</span> <span class="attr">range</span>=<span class="string">"1-60000000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"13"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.encoder.h263"</span> <span class="attr">type</span>=<span class="string">"video/3gpp"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-loaded-to-idle-after-allocation"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"96x64"</span> <span class="attr">max</span>=<span class="string">"720x576"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"13"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.encoder.avc"</span> <span class="attr">type</span>=<span class="string">"video/avc"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-loaded-to-idle-after-allocation"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"96x64"</span> <span class="attr">max</span>=<span class="string">"3840x2160"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"block-size"</span> <span class="attr">value</span>=<span class="string">"16x16"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"blocks-per-second"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"972000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"bitrate"</span> <span class="attr">range</span>=<span class="string">"1-100000000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"13"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.encoder.vp8"</span> <span class="attr">type</span>=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-loaded-to-idle-after-allocation"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"96x64"</span> <span class="attr">max</span>=<span class="string">"3840x2160"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"block-size"</span> <span class="attr">value</span>=<span class="string">"16x16"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"blocks-per-second"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"777600"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"bitrate"</span> <span class="attr">range</span>=<span class="string">"1-20000000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"13"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Encoders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Decoders</span>&gt;</span><span class="comment">&lt;!-- 一些视频的decoder --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.decoder.avc"</span> <span class="attr">type</span>=<span class="string">"video/avc"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"defers-output-buffer-allocation"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"64x64"</span> <span class="attr">max</span>=<span class="string">"3840x2160"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"block-size"</span> <span class="attr">value</span>=<span class="string">"16x16"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"blocks-per-second"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"972000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"bitrate"</span> <span class="attr">range</span>=<span class="string">"1-100000000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Feature</span> <span class="attr">name</span>=<span class="string">"adaptive-playback"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"13"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> <span class="attr">type</span>=<span class="string">"video/avc"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"defers-output-buffer-allocation"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"64x64"</span> <span class="attr">max</span>=<span class="string">"3840x2160"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"block-size"</span> <span class="attr">value</span>=<span class="string">"16x16"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"blocks-per-second"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"972000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"bitrate"</span> <span class="attr">range</span>=<span class="string">"1-100000000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Feature</span> <span class="attr">name</span>=<span class="string">"adaptive-playback"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Feature</span> <span class="attr">name</span>=<span class="string">"secure-playback"</span> <span class="attr">required</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"6"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> <span class="attr">type</span>=<span class="string">"video/mp4v-es"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"defers-output-buffer-allocation"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"64x64"</span> <span class="attr">max</span>=<span class="string">"1920x1088"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"block-size"</span> <span class="attr">value</span>=<span class="string">"16x16"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"blocks-per-second"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"489600"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"bitrate"</span> <span class="attr">range</span>=<span class="string">"1-60000000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Feature</span> <span class="attr">name</span>=<span class="string">"adaptive-playback"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"13"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.decoder.h263"</span> <span class="attr">type</span>=<span class="string">"video/3gpp"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"defers-output-buffer-allocation"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"64x64"</span> <span class="attr">max</span>=<span class="string">"720x576"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Feature</span> <span class="attr">name</span>=<span class="string">"adaptive-playback"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"13"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.decoder.vp8"</span> <span class="attr">type</span>=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"defers-output-buffer-allocation"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"64x64"</span> <span class="attr">max</span>=<span class="string">"3840x2160"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"block-size"</span> <span class="attr">value</span>=<span class="string">"16x16"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"blocks-per-second"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"777600"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"bitrate"</span> <span class="attr">range</span>=<span class="string">"1-20000000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Feature</span> <span class="attr">name</span>=<span class="string">"adaptive-playback"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"13"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Decoders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MediaCodecs</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>也就是说，如果系统里面实际上包含了某个codec，但是并没有被配置在这个文件里，那么应用程序也无法使用到！</strong><br>&#160; &#160; &#160; &#160;上面获取配置xml中的解码器，因为解析xml和SAX解析很像，是逐行扫描，所以保存的<strong>list也是按照xml中的顺序保存的</strong>。</p>
<p>&#160; &#160; &#160; &#160;（2）取出所有匹配的解码器列表<br>&#160; &#160; &#160; &#160;获取本地配置的编解码器组件列表后，查找匹配的解码器在list中的index。我们查看ssize_t matchIndex = list-&gt;findCodecByType(mime, createEncoder, index) ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// legacy method for non-advanced codecs</span></span><br><span class="line"><span class="keyword">ssize_t</span> MediaCodecList::findCodecByType(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="comment">//视频源mime</span></span><br><span class="line">         <span class="keyword">bool</span> encoder, <span class="comment">//false</span></span><br><span class="line">         <span class="keyword">size_t</span> startIndex <span class="comment">//从编解码器开始遍历的位置</span></span><br><span class="line">         ) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *advancedFeatures[] = &#123;<span class="comment">//高级播放模式</span></span><br><span class="line">        <span class="string">"feature-secure-playback"</span>, <span class="comment">//DRM加密</span></span><br><span class="line">        <span class="string">"feature-tunneled-playback"</span>, <span class="comment">//“隧道”播放模式，为了低功耗</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//mCodecInfos就是我们刚刚解析media_codecs.xml中配置的编解码器信息</span></span><br><span class="line">    <span class="keyword">size_t</span> numCodecs = mCodecInfos.size();</span><br><span class="line">    <span class="comment">//选混遍历所有配置的解码器</span></span><br><span class="line">    <span class="keyword">for</span> (; startIndex &lt; numCodecs; ++startIndex) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> MediaCodecInfo &amp;info = *mCodecInfos.itemAt(startIndex).get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info.isEncoder() != encoder) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这个视频源mime类型，这个遍历的解码器有能力播放，则ok</span></span><br><span class="line">        sp&lt;MediaCodecInfo::Capabilities&gt; capabilities = info.getCapabilitiesFor(type);</span><br><span class="line">        <span class="keyword">if</span> (capabilities == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;details = capabilities-&gt;getDetails();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> required;</span><br><span class="line">        <span class="keyword">bool</span> isAdvanced = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果是高级播放模式，则不能播</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> ix = <span class="number">0</span>; ix &lt; ARRAY_SIZE(advancedFeatures); ix++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (details-&gt;findInt32(advancedFeatures[ix], &amp;required) &amp;&amp;</span><br><span class="line">                    required != <span class="number">0</span>) &#123;</span><br><span class="line">                isAdvanced = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isAdvanced) &#123;<span class="comment">//然后返回有能力播放这个类型视频的解码器index</span></span><br><span class="line">            <span class="keyword">return</span> startIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面内容就是从配置的本地编解码列表中选取支持视频源mime类型的解码器，然后返回它位于列表中的index。<br>&#160; &#160; &#160; &#160;然后回到findMatchingCodecs函数中，就是根据所有匹配的index去一一获取编解码器的MediaCodecInfo，然后再做先关设置，最后加入到matchingCodecs这个Vector当中。</p>
<h3 id="选取并初始化第一个解码器"><a href="#选取并初始化第一个解码器" class="headerlink" title="选取并初始化第一个解码器"></a>选取并初始化第一个解码器</h3><p>&#160; &#160; &#160; &#160;接着会创建OMXCodecObserver 实例，OMXCodecObserver功能后续会详细介绍。创建一个node 并初始化为0。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;OMXCodecObserver&gt; observer = <span class="keyword">new</span> OMXCodecObserver;  </span><br><span class="line">    IOMX::node_id node = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后通过omx入口 依靠binder 机制调用OMX服务中的allocateNode()，这一步把匹配得到的解码器组件名、OMXCodecObserver实例和初始化为0的node一并传入。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> err = omx-&gt;allocateNode(componentName, observer, &amp;node);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个allocateNode 就是文章最开始讲的，在OMX那头创建一个和mVideoSource相匹配的解码实例。用node值作为唯一标识。<br>&#160; &#160; &#160; &#160;让我们来看看真正的omx中allocateNode做了啥，位于framework/av/media/libstagefright/omx/OMX.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> OMX::allocateNode(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer, node_id *node) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    *node = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建一个OMXNodeInstance实例</span></span><br><span class="line">    OMXNodeInstance *instance = <span class="keyword">new</span> OMXNodeInstance(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">    OMX_COMPONENTTYPE *handle;</span><br><span class="line">    <span class="comment">//通过mMaster-&gt;makeComponentInstance创建真正解码器的组件，并通过handle与OMXNodeInstance关联。</span></span><br><span class="line">    OMX_ERRORTYPE err = mMaster-&gt;makeComponentInstance(</span><br><span class="line">            name, &amp;OMXNodeInstance::kCallbacks,</span><br><span class="line">            instance, &amp;handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OMX_ErrorNone) &#123;</span><br><span class="line">        ALOGE(<span class="string">"FAILED to allocate omx component '%s'"</span>, name);</span><br><span class="line"></span><br><span class="line">        instance-&gt;onGetHandleFailed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *node = makeNodeID(instance);</span><br><span class="line">    mDispatchers.add(*node, <span class="keyword">new</span> CallbackDispatcher(instance));</span><br><span class="line"></span><br><span class="line">    instance-&gt;setHandle(*node, handle);</span><br><span class="line"></span><br><span class="line">    mLiveNodes.add(observer-&gt;asBinder(), instance);</span><br><span class="line">    observer-&gt;asBinder()-&gt;linkToDeath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;创建一个OMXNodeInstance实例。<br>&#160; &#160; &#160; &#160;通过mMaster-&gt;makeComponentInstance创建真正解码器的组件，并通过handle与OMXNodeInstance关联。<br>&#160; &#160; &#160; &#160;所以说mMaster-&gt;makeComponentInstance这里是建立解码器组件的核心。会把mVideoSource需要的解码器name一直传递下去。<br>&#160; &#160; &#160; &#160;我们查看OMXMaster的makeComponentInstance函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mPluginByInstance位于OMXMaster.h中</span></span><br><span class="line">KeyedVector&lt;OMX_COMPONENTTYPE *, OMXPluginBase *&gt; mPluginByInstance;</span><br><span class="line"></span><br><span class="line">OMX_ERRORTYPE OMXMaster::makeComponentInstance(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">        <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    *component = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//mPluginByComponentName就是我们第一步准备工作中保存所有编解码组件的map，然后找到匹配解码器组件名在其中的位置</span></span><br><span class="line">    <span class="keyword">ssize_t</span> index = mPluginByComponentName.indexOfKey(String8(name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInvalidComponentName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后根据解码器在其中的位置找到队形的插件，即软解或者硬解插件之一，二选一</span></span><br><span class="line">    OMXPluginBase *plugin = mPluginByComponentName.valueAt(index);</span><br><span class="line">    <span class="comment">//然后调用注册插件的makeComponentInstance函数</span></span><br><span class="line">    OMX_ERRORTYPE err =</span><br><span class="line">        plugin-&gt;makeComponentInstance(name, callbacks, appData, component);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OMX_ErrorNone) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将组件和对应插件加入到这个map中</span></span><br><span class="line">    mPluginByInstance.add(*component, plugin);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mPluginByComponentName就是我们第一步准备工作中保存所有编解码组件的map，然后找到匹配解码器组件名在其中的位置，然后根据解码器在其中的位置找到队形的插件，即软解或者硬解插件之一，二选一，最后调用注册插件的makeComponentInstance函数。</p>
<p>&#160; &#160; &#160; &#160;我们依然以高通平台为例，查看步入hardware/qcom/media/libstagefrighthw/QComOMXPlugin.cpp，查看makeComponentInstance函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">OMX_ERRORTYPE QComOMXPlugin::makeComponentInstance(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">        <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLibHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//会调用mGetHandle函数函数指针，在构造函数中又定义</span></span><br><span class="line">    <span class="keyword">return</span> (*mGetHandle)(</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;OMX_HANDLETYPE *&gt;(component),</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(name),</span><br><span class="line">            appData, <span class="keyword">const_cast</span>&lt;OMX_CALLBACKTYPE *&gt;(callbacks));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QComOMXPlugin::QComOMXPlugin()</span><br><span class="line">    : mLibHandle(dlopen(<span class="string">"libOmxCore.so"</span>, RTLD_NOW)),</span><br><span class="line">      mInit(<span class="literal">NULL</span>),</span><br><span class="line">      mDeinit(<span class="literal">NULL</span>),</span><br><span class="line">      mComponentNameEnum(<span class="literal">NULL</span>),</span><br><span class="line">      mGetHandle(<span class="literal">NULL</span>),</span><br><span class="line">      mFreeHandle(<span class="literal">NULL</span>),</span><br><span class="line">      mGetRolesOfComponentHandle(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLibHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mInit = (InitFunc)dlsym(mLibHandle, <span class="string">"OMX_Init"</span>);</span><br><span class="line">        mDeinit = (DeinitFunc)dlsym(mLibHandle, <span class="string">"OMX_Deinit"</span>);</span><br><span class="line">        </span><br><span class="line">        mComponentNameEnum =</span><br><span class="line">            (ComponentNameEnumFunc)dlsym(mLibHandle, <span class="string">"OMX_ComponentNameEnum"</span>);</span><br><span class="line">        <span class="comment">//重点在这里，会调用hardware/qcom/media/mm-core/omxcore/src/common/qc_omx_core.c的OMX_GetHandle方法</span></span><br><span class="line">        mGetHandle = (GetHandleFunc)dlsym(mLibHandle, <span class="string">"OMX_GetHandle"</span>);</span><br><span class="line">        mFreeHandle = (FreeHandleFunc)dlsym(mLibHandle, <span class="string">"OMX_FreeHandle"</span>);</span><br><span class="line"></span><br><span class="line">        mGetRolesOfComponentHandle =</span><br><span class="line">            (GetRolesOfComponentFunc)dlsym(</span><br><span class="line">                    mLibHandle, <span class="string">"OMX_GetRolesOfComponent"</span>);</span><br><span class="line"></span><br><span class="line">        (*mInit)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后会调用qcom OpenMax IL的核心和公共内容。 其中qc_omx_core为主要文件，位于hardware/qcom/media/mm-core/omxcore/src/common/qc_omx_core.c，调用OMX_GetHandle()函数，用户获取各个组件的句柄。这一部分上一篇已经讲过了，可以查看<a href="http://windrunnerlihuan.com/2016/12/26/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AD-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0-preview/#Qualcomm-高通-OpenMax-IL的硬件实现">Android多媒体开发(六)—-Android中OpenMax的实现(preview)</a> ，看看高通对于这一部分的而实现。<br>&#160; &#160; &#160; &#160;假设是hevc/h265类型编码的视频，OMX解码组件会加载对应的libOmxVdec.so或libOmxVdecHevc.so库。高通芯片确实犀利呀，我在同事的nexus手机上查找视频解码库就一个libOmxVdec.so，而别的一些平台放了一大堆so，比如amlogic或者mstar的，不仅夹了很多私货，其实性能也很差。。。。。。</p>
<p>&#160; &#160; &#160; &#160;经过这一路下来，终于完成了解码器的创建工作。简单总结一下：</p>
<ul>
<li>AwesomePlayer中通过initVideoDecoder 来创建video解码器mVideoSource。</li>
<li>mVideoSource 中通过上部分demux后的视频流 mVideoTrack来获得解码器的类型，通过类型调用omx-&gt;allocateNode 创建omx node实例与自己对应。以后都是通过node实例来操作解码器。</li>
<li>在 omx-&gt;allocateNode中 通过mMaster-&gt;makeComponentInstance 来创建真正对应的解码器组件。这个解码器组件是完成之后解码实际工作的。</li>
<li>在创建mMaster-&gt;makeComponentInstance过程中，也是通过上面mVideoTrack<br>过来的解码器类型名，找到相对应的解码器的库，然后实例化。</li>
</ul>
<h1 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h1><p>&#160; &#160; &#160; &#160;OMXCodec，OMXCodecObserver和OMXNodeInstance是一一对应的，<br>简单的可以理解它们3个构成了OpenMAX IL的一个Component，每一个node就是一个codec在OMX服务端的标识。<br>&#160; &#160; &#160; &#160;当然还有CallbackDispatcher，用于处理codec过来的消息，通过它的post/loop/dispatch来发起接收，最终透过IOMX::onMessage -&gt; OMXNodeInstance::onMessage -&gt; OMXCodecObserver::onMessage -&gt; OMXCodec::on_message一路往上，当然消息的来源是因为我们有向codec注册OMXNodeInstance::kCallbacks，请看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> OMX::allocateNode(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer, node_id *node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    OMX_ERRORTYPE err = mMaster-&gt;makeComponentInstance(</span><br><span class="line">            name, &amp;OMXNodeInstance::kCallbacks,</span><br><span class="line">            instance, &amp;handle);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;kCallbacks包含3种事件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OMX_CALLBACKTYPE OMXNodeInstance::kCallbacks = &#123;</span><br><span class="line">    &amp;OnEvent, &amp;OnEmptyBufferDone, &amp;OnFillBufferDone</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它们分别都会调用到自己owner的OnEvent/OnEmptyBufferDone/OnFillBufferDone<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">OMX_ERRORTYPE OMXNodeInstance::OnEvent(</span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,</span><br><span class="line">        OMX_IN OMX_PTR pAppData,</span><br><span class="line">        OMX_IN OMX_EVENTTYPE eEvent,</span><br><span class="line">        OMX_IN OMX_U32 nData1,</span><br><span class="line">        OMX_IN OMX_U32 nData2,</span><br><span class="line">        OMX_IN OMX_PTR pEventData) &#123;</span><br><span class="line">    OMXNodeInstance *instance = <span class="keyword">static_cast</span>&lt;OMXNodeInstance *&gt;(pAppData);</span><br><span class="line">    <span class="keyword">if</span> (instance-&gt;mDying) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;owner()-&gt;OnEvent(</span><br><span class="line">            instance-&gt;nodeID(), eEvent, nData1, nData2, pEventData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;而owner相应的又会调用自己dispatcher的post方法，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">OMX_ERRORTYPE OMX::OnEvent(</span><br><span class="line">        node_id node,</span><br><span class="line">        OMX_IN OMX_EVENTTYPE eEvent,</span><br><span class="line">        OMX_IN OMX_U32 nData1,</span><br><span class="line">        OMX_IN OMX_U32 nData2,</span><br><span class="line">        OMX_IN OMX_PTR pEventData) &#123;</span><br><span class="line">    ALOGV(<span class="string">"OnEvent(%d, %ld, %ld)"</span>, eEvent, nData1, nData2);</span><br><span class="line"> </span><br><span class="line">    omx_message msg;</span><br><span class="line">    msg.type = omx_message::EVENT;</span><br><span class="line">    msg.node = node;</span><br><span class="line">    msg.u.event_data.event = eEvent;</span><br><span class="line">    msg.u.event_data.data1 = nData1;</span><br><span class="line">    msg.u.event_data.data2 = nData2;</span><br><span class="line"> </span><br><span class="line">    findDispatcher(node)-&gt;post(msg);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样所有的事件都串起来了，消息有来源，有最终的去处！<br>&#160; &#160; &#160; &#160;结合这些信息所以我们就可以认为在这里是创建出了一个Component出来。下面贴个图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%83%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/timeline.jpeg" alt="时序图"></p>
<h1 id="硬解还是软解"><a href="#硬解还是软解" class="headerlink" title="硬解还是软解"></a>硬解还是软解</h1><p>&#160; &#160; &#160; &#160;上面加载解码组件的时候有一段很重要的话，为了加深记忆我要再贴一遍：</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;实际上系统中存在的解码器可以很多，但能够被应用使用的解码器是根据配置来的，即/etc/media_codecc.xml。这个文件一般由硬件或者系统的生产厂家在build整个系统的时候提供，一般是保存在代码的device/[company]/[codename]目录下的，例如device/samsung/manta/media_codecs.xml。这个文件配置了系统中有哪些可用的codec以及，这些codec对应的媒体文件类型。在这个文件里面，系统里面提供的软硬codec都需要被列出来。<br>&#160; &#160; &#160; &#160;<strong>也就是说，如果系统里面实际上包含了某个codec，但是并没有被配置在这个文件里，那么应用程序也无法使用到！</strong></p>
</blockquote>
<p>&#160; &#160; &#160; &#160;在这里配置文件里面，如果出现多个codec对应同样类型的媒体格式的时候，这些codec都会被保留起来。<strong>当系统使用的时候，将后选择第一个匹配的codec</strong>。除非是指明了要软解码还是硬解码，但是Android的framework层为上层提供服务的AwesomePlayer中在处理音频和视频的时候，对到底是选择软解还是硬解的参数没有设置。所以虽然底层是支持选择的，但是对于上层使用MediaPlayer的Java程序来说，还是只能接受默认的codec选取规则。</p>
<p>&#160; &#160; &#160; &#160;一般来说，如果系统里面有对应媒体的硬件解码器的话，系统开发人员应该是会配置在media_codecs.xml中，所以大多数情况下，如果有硬件解码器，那么我们总是会使用到硬件解码器。</p>
<p>&#160; &#160; &#160; &#160;所以对于这种情况，经常听到APP开发人员骂google的MediaPlayer支持格式太少，兼容性太差，然后将锅强行甩给google。。。。。。这事也不能怨google，要怪就怪芯片商或者方案商吧！</p>
<p>&#160; &#160; &#160; &#160;google估计是听到的骂声太多了，所以推出了<a href="https://github.com/google/ExoPlayer" target="_blank" rel="external">ExoPlayer</a>，可以避免这种芯片商这种匹配第一个codec规则的弊端。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;本篇算是对Android中OpenMax的实现做了一个差不多详细的分析。我水平有限，这几天看源码看的也很头疼，如有错误欢迎指正，我会在第一时间修改的。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%83%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(六)----Android中OpenMax的实现(preview)]]></title>
      <url>http://windrunnerlihuan.com/2016/12/26/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AD-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0-preview/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;上一篇对OpenMax有了简单介绍，本篇就讲讲Android上对OpenMax IL层的实现。（可以忽略，下一篇会分析流程）<br><a id="more"></a></p>
<h1 id="OpenMax的接口与实现"><a href="#OpenMax的接口与实现" class="headerlink" title="OpenMax的接口与实现"></a>OpenMax的接口与实现</h1><p>&#160; &#160; &#160; &#160;在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节。</p>
<ul>
<li><strong>编解码驱动程序</strong>：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。</li>
<li><strong>OpenMax IL层</strong>：根据OpenMax IL层的标准头文件实现不同功能的组件。</li>
</ul>
<p>&#160; &#160; &#160; &#160;Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配），它作为Android本地层的接口，可以被Android的多媒体引擎调用。</p>
<h2 id="OpenMax-IL层接口"><a href="#OpenMax-IL层接口" class="headerlink" title="OpenMax IL层接口"></a>OpenMax IL层接口</h2><p>&#160; &#160; &#160; &#160;OpenMax IL层的接口定义由若干个头文件组成，这也是实现它需要实现的内容，位于frameworks/native/include/media/openmax下，它们的基本描述如下所示：</p>
<blockquote>
<p>OMX_Types.h：OpenMax Il的数据类型定义<br>OMX_Core.h：OpenMax IL核心的API<br>OMX_Component.h：OpenMax IL 组件相关的 API<br>OMX_Audio.h：音频相关的常量和数据结构<br>OMX_IVCommon.h：图像和视频公共的常量和数据结构<br>OMX_Image.h：图像相关的常量和数据结构<br>OMX_Video.h：视频相关的常量和数据结构<br>OMX_Other.h：其他数据结构（包括A/V 同步）<br>OMX_Index.h：OpenMax IL定义的数据结构索引<br>OMX_ContentPipe.h：内容的管道定义</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;<strong>提示：OpenMax标准只有头文件，没有标准的库，设置没有定义函数接口。对于实现者，需要实现的主要是包含函数指针的结构体。</strong></p>
<p>&#160; &#160; &#160; &#160;其中，OMX_Component.h中定义的OMX_COMPONENTTYPE结构体是OpenMax IL层的核心内容，表示一个组件，其内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> OMX_COMPONENTTYPE    </span><br><span class="line">&#123;  </span><br><span class="line">    OMX_U32 nSize;                          <span class="comment">/* 这个结构体的大小 */</span>    </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本号 */</span>    </span><br><span class="line">    OMX_PTR pComponentPrivate;          <span class="comment">/* 这个组件的私有数据指针. */</span>    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 调用者（IL client）设置的指针，用于保存它的私有数据，传回给所有的回调函数 */</span>    </span><br><span class="line">    OMX_PTR pApplicationPrivate;    </span><br><span class="line">    <span class="comment">/* 以下的函数指针返回OMX_core.h中的对应内容 */</span>    </span><br><span class="line">    OMX_ERRORTYPE (*GetComponentVersion)(<span class="comment">/* 获得组件的版本*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STRING pComponentName,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pComponentVersion,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pSpecVersion,    </span><br><span class="line">        OMX_OUT OMX_UUIDTYPE* pComponentUUID);    </span><br><span class="line">    OMX_ERRORTYPE (*SendCommand)(<span class="comment">/* 发送命令 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_COMMANDTYPE Cmd,    </span><br><span class="line">        OMX_IN  OMX_U32 nParam1,    </span><br><span class="line">        OMX_IN  OMX_PTR pCmdData);    </span><br><span class="line">    OMX_ERRORTYPE (*GetParameter)(<span class="comment">/* 获得参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nParamIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetParameter)(<span class="comment">/* 设置参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetConfig)(<span class="comment">/* 获得配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetConfig)(<span class="comment">/* 设置配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetExtensionIndex)(<span class="comment">/* 转换成OMX结构的索引 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_STRING cParameterName,    </span><br><span class="line">        OMX_OUT OMX_INDEXTYPE* pIndexType);    </span><br><span class="line">    OMX_ERRORTYPE (*GetState)(<span class="comment">/* 获得组件当前的状态 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STATETYPE* pState);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentTunnelRequest)(<span class="comment">/* 用于连接到另一个组件*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nPort,    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hTunneledComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nTunneledPort,    </span><br><span class="line">        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup);    </span><br><span class="line">    OMX_ERRORTYPE (*UseBuffer)(<span class="comment">/* 为某个端口使用Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes,    </span><br><span class="line">        OMX_IN OMX_U8* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*AllocateBuffer)(<span class="comment">/* 在某个端口分配Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes);    </span><br><span class="line">    OMX_ERRORTYPE (*FreeBuffer)(<span class="comment">/*将某个端口Buffer释放*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*EmptyThisBuffer)(<span class="comment">/* 让组件消耗这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*FillThisBuffer)(<span class="comment">/* 让组件填充这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*SetCallbacks)(<span class="comment">/* 设置回调函数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_CALLBACKTYPE* pCallbacks,    </span><br><span class="line">        OMX_IN  OMX_PTR pAppData);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentDeInit)(<span class="comment">/* 反初始化组件 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent);    </span><br><span class="line">    OMX_ERRORTYPE (*UseEGLImage)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN <span class="keyword">void</span>* eglImage);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentRoleEnum)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_U8 *cRole,    </span><br><span class="line">        OMX_IN OMX_U32 nIndex);    </span><br><span class="line">&#125; OMX_COMPONENTTYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1）EmptyThisBuffer和FillThisBuffer是驱动组件运行的基本的机制，前者表示让组件消耗缓冲区，表示对应组件输入的内容；后者表示让组件填充缓冲区，表示对应组件输出的内容。<br>&#160; &#160; &#160; &#160;2）UseBuffer，AllocateBuffer，FreeBuffer为和端口相关的缓冲区管理函数，对于组件的端口有些可以自己分配缓冲区，有些可以使用外部的缓冲区，因此有不同的接口对其进行操作。<br>&#160; &#160; &#160; &#160;3）SendCommand表示向组件发送控制类的命令。GetParameter，SetParameter，GetConfig，SetConfig几个接口用于辅助的参数和配置的设置和获取。<br>&#160; &#160; &#160; &#160;4）ComponentTunnelRequest用于组件之间的隧道化连接，其中需要制定两个组件及其相连的端口。<br>&#160; &#160; &#160; &#160;5）ComponentDeInit用于组件的反初始化。</p>
<p>&#160; &#160; &#160; &#160;OMX_COMPONENTTYPE结构体实现后，其中的各个函数指针就是调用者可以使用的内容。<strong>各个函数指针和OMX_core.h中定义的内容相对应</strong>。<br>&#160; &#160; &#160; &#160;提示：OpenMax函数的参数中，经常包含OMX_IN和OMX_OUT等宏，它们的实际内容为空，只是为了标记参数的方向是输入还是输出。</p>
<p>&#160; &#160; &#160; &#160;OMX_Component.h中端口类型的定义为OMX_PORTDOMAINTYPE枚举类型，内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_PORTDOMAINTYPE &#123;   </span><br><span class="line">    OMX_PortDomainAudio,        <span class="comment">/* 音频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainVideo,        <span class="comment">/* 视频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainImage,        <span class="comment">/* 图像类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainOther,        <span class="comment">/* 其他类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainKhronosExtensions = <span class="number">0x6F000000</span>,   <span class="comment">//为Khronos标准预留宽展</span></span><br><span class="line">    OMX_PortDomainVendorStartUnused = <span class="number">0x7F000000</span>    <span class="comment">//为厂商预留扩展</span></span><br><span class="line">    OMX_PortDomainMax = <span class="number">0x7ffffff</span>  </span><br><span class="line">&#125; OMX_PORTDOMAINTYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;音频类型，视频类型，图像类型，其他类型是OpenMax IL层此所定义的四种端口的类型。</p>
<p>端口具体内容的定义使用OMX_PARAM_PORTDEFINITIONTYPE类（也在OMX_Component.h中定义）来表示，其内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> OMX_PARAM_PORTDEFINITIONTYPE &#123;   </span><br><span class="line">    OMX_U32 nSize;                      <span class="comment">/* 结构体大小 */</span>   </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本*/</span>   </span><br><span class="line">    OMX_U32 nPortIndex;             <span class="comment">/* 端口号 */</span>   </span><br><span class="line">    OMX_DIRTYPE eDir;                   <span class="comment">/* 端口的方向 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountActual;         <span class="comment">/* 为这个端口实际分配的Buffer的数目 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountMin;            <span class="comment">/* 这个端口最小Buffer的数目*/</span>   </span><br><span class="line">    OMX_U32 nBufferSize;                <span class="comment">/* 缓冲区的字节数 */</span>   </span><br><span class="line">    OMX_BOOL bEnabled;                  <span class="comment">/* 是否使能 */</span>   </span><br><span class="line">    OMX_BOOL bPopulated;                <span class="comment">/* 是否在填充 */</span>   </span><br><span class="line">    OMX_PORTDOMAINTYPE eDomain;         <span class="comment">/* 端口的类型 */</span>   </span><br><span class="line">    <span class="keyword">union</span> &#123;                         <span class="comment">/* 端口实际的内容，由类型确定具体结构 */</span>   </span><br><span class="line">        OMX_AUDIO_PORTDEFINITIONTYPE audio;   </span><br><span class="line">        OMX_VIDEO_PORTDEFINITIONTYPE video;   </span><br><span class="line">        OMX_IMAGE_PORTDEFINITIONTYPE image;   </span><br><span class="line">        OMX_OTHER_PORTDEFINITIONTYPE other;   </span><br><span class="line">    &#125; format;   </span><br><span class="line">    OMX_BOOL bBuffersContiguous;   </span><br><span class="line">    OMX_U32 nBufferAlignment;   </span><br><span class="line">&#125; OMX_PARAM_PORTDEFINITIONTYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;对于一个端口，其重点的内容如下:</p>
<ul>
<li>端口的方向（OMX_DIRTYPE）：包含OMX_DirInput（输入）和OMX_DirOutput（输出）两种</li>
<li>端口分配的缓冲区数目和最小缓冲区数目</li>
<li>端口的类型（OMX_PORTDOMAINTYPE）：可以是四种类型</li>
<li>端口格式的数据结构：使用format联合体来表示，具体由四种不同类型来表示，与端口的类型相对应<br>OMX_AUDIO_PORTDEFINITIONTYPE，OMX_VIDEO_PORTDEFINITIONTYPE，OMX_IMAGE_PORTDEFINITIONTYPE和OMX_OTHER_PORTDEFINITIONTYPE等几个具体的格式类型，分别在OMX_Audio.h，OMX_Video.h，OMX_Image.h和OMX_Other.h这四个头文件中定义。</li>
</ul>
<p>&#160; &#160; &#160; &#160;OMX_Core.h中定义的枚举类型OMX_STATETYPE命令表示OpenMax的状态机，内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_STATETYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_StateInvalid,                   <span class="comment">/* 组件监测到内部的数据结构被破坏 */</span>   </span><br><span class="line">    OMX_StateLoaded,                    <span class="comment">/* 组件被加载但是没有完成初始化 */</span>   </span><br><span class="line">    OMX_StateIdle,                      <span class="comment">/* 组件初始化完成，准备开始 */</span>   </span><br><span class="line">    OMX_StateExecuting,             <span class="comment">/* 组件接受了开始命令，正在树立数据 */</span>   </span><br><span class="line">    OMX_StatePause,                     <span class="comment">/* 组件接受暂停命令*/</span>   </span><br><span class="line">    OMX_StateWaitForResources,      <span class="comment">/* 组件正在等待资源 */</span>   </span><br><span class="line">    OMX_StateKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_StateVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_StateMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_STATETYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OpenMax组件的状态机可以由外部的命令改变，也可以由内部发生的情况改变。OpenMax IL组件的状态机的迁移关系如图所示：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/state.png" alt="状态机"></p>
<p>&#160; &#160; &#160; &#160;OMX_Core.h中定义的枚举类型OMX_COMMANDTYPE表示对组件的命令类型，内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_COMMANDTYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_CommandStateSet,                <span class="comment">/* 改变状态机器 */</span>   </span><br><span class="line">    OMX_CommandFlush,                   <span class="comment">/* 刷新数据队列 */</span>   </span><br><span class="line">    OMX_CommandPortDisable,             <span class="comment">/* 禁止端口 */</span>   </span><br><span class="line">    OMX_CommandPortEnable,              <span class="comment">/* 使能端口 */</span>   </span><br><span class="line">    OMX_CommandMarkBuffer,              <span class="comment">/* 标记组件或Buffer用于观察 */</span>   </span><br><span class="line">    OMX_CommandKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_CommandVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_CommandMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_COMMANDTYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OMX_COMMANDTYPE类型在SendCommand调用中作为参数被使用，其中OMX_CommandStateSet就是改变状态机的命令。</p>
<h2 id="OpenMax-IL实现的内容"><a href="#OpenMax-IL实现的内容" class="headerlink" title="OpenMax IL实现的内容"></a>OpenMax IL实现的内容</h2><p>&#160; &#160; &#160; &#160;对于OpenMax IL层的实现，一般的方式并不调用OpenMax DL层。具体实现的内容就是各个不同的组件。<br>&#160; &#160; &#160; &#160;OpenMax IL组件的实现包含以下两个步骤：</p>
<ul>
<li>组件的初始化函数：硬件和OpenMax数据结构的初始化，一般分成函数指针初始化、私有数据结构的初始化、端口的初始化等几个步骤，使用OMX_Component.h其中的pComponentPrivate成员保留本组件的私有数据为上下文，最后获得填充完成OMX_COMPONENTTYPE类型的结构体。</li>
<li>OMX_COMPONENTTYPE类型结构体的各个指针：实现其中的各个函数指针，需要使用私有数据的时候，从其中的pComponentPrivate得到指针，转化成实际的数据结构使用。</li>
</ul>
<p>&#160; &#160; &#160; &#160;端口的定义是OpenMax IL组件对外部的接口。OpenMax IL常用的组件大都是输入和输出端口各一个。对于最常用的编解码（Codec）组件，通常需要在每个组件的实现过程中，调用硬件的编解码接口来实现。在组件的内部处理中，可以建立线程来处理。OpenMax的组件的端口有默认参数，但也可以在运行时设置，因此一个端口也可以支持不同的编码格式。音频编码组件的输出和音频编码组件的输入通常是原始数据格式（PCM格式），视频编码组件的输出和视频编码组件的输入通常是原始数据格式（YUV格式）。<br>&#160; &#160; &#160; &#160;提示：在一种特定的硬件实现中，编解码部分具有相似性，因此通常可以构建一个OpenMax组件的”基类”或者公共函数，来完成公共性的操作。</p>
<h1 id="Android中OpenMax的适配层"><a href="#Android中OpenMax的适配层" class="headerlink" title="Android中OpenMax的适配层"></a>Android中OpenMax的适配层</h1><p>&#160; &#160; &#160; &#160;Android中的OpenMax适配层的接口在frameworks/av/include/media/IOMX.h文件定义，其内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> IOMX : <span class="keyword">public</span> IInterface &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    DECLARE_META_INTERFACE(OMX);    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *buffer_id;    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *node_id;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">livesLocally</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">struct</span> ComponentInfo &#123;<span class="comment">// 组件的信息    </span></span><br><span class="line">        String8 mName;    </span><br><span class="line">        List&lt;String8&gt; mRoles;    </span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">listNodes</span><span class="params">(List&lt;ComponentInfo&gt; *<span class="built_in">list</span>)</span> </span>= <span class="number">0</span>;  <span class="comment">// 节点列表    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateNode</span><span class="params">(    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer,  <span class="comment">// 分配节点    </span></span><br><span class="line">        node_id *node)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">freeNode</span><span class="params">(node_id node)</span> </span>= <span class="number">0</span>; <span class="comment">// 找到节点    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">sendCommand</span><span class="params">(<span class="comment">// 发送命令    </span></span><br><span class="line">        node_id node, OMX_COMMANDTYPE cmd, OMX_S32 param)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getParameter</span><span class="params">(<span class="comment">// 获得参数    </span></span><br><span class="line">        node_id node, OMX_INDEXTYPE index,    </span><br><span class="line">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setParameter</span><span class="params">(<span class="comment">// 设置参数    </span></span><br><span class="line">        node_id node, OMX_INDEXTYPE index,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getConfig</span><span class="params">(<span class="comment">// 获得配置    </span></span><br><span class="line">        node_id node, OMX_INDEXTYPE index,    </span><br><span class="line">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setConfig</span><span class="params">(<span class="comment">// 设置配置    </span></span><br><span class="line">        node_id node, OMX_INDEXTYPE index,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">useBuffer</span><span class="params">(<span class="comment">// 使用缓冲区    </span></span><br><span class="line">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span><br><span class="line">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateBuffer</span><span class="params">(<span class="comment">// 分配缓冲区    </span></span><br><span class="line">        node_id node, OMX_U32 port_index, <span class="keyword">size_t</span> size,    </span><br><span class="line">        buffer_id *buffer, <span class="keyword">void</span> **buffer_data)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateBufferWithBackup</span><span class="params">(<span class="comment">// 分配带后备缓冲区    </span></span><br><span class="line">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span><br><span class="line">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">freeBuffer</span><span class="params">(<span class="comment">// 释放缓冲区    </span></span><br><span class="line">        node_id node, OMX_U32 port_index, buffer_id buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">fillBuffer</span><span class="params">(node_id node, buffer_id buffer)</span> </span>= <span class="number">0</span>; <span class="comment">// 填充缓冲区    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">emptyBuffer</span><span class="params">(<span class="comment">// 消耗缓冲区    </span></span><br><span class="line">        node_id node,    </span><br><span class="line">        buffer_id buffer,    </span><br><span class="line">        OMX_U32 range_offset, OMX_U32 range_length,    </span><br><span class="line">        OMX_U32 flags, OMX_TICKS timestamp)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getExtensionIndex</span><span class="params">(    </span><br><span class="line">        node_id node,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *parameter_name,    </span><br><span class="line">        OMX_INDEXTYPE *index)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IOMXRenderer&gt; createRenderer(<span class="comment">// 创建渲染器（从ISurface）    </span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;ISurface&gt; &amp;surface,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName,    </span><br><span class="line">        OMX_COLOR_FORMATTYPE colorFormat,    </span><br><span class="line">        <span class="keyword">size_t</span> encodedWidth, <span class="keyword">size_t</span> encodedHeight,    </span><br><span class="line">        <span class="keyword">size_t</span> displayWidth, <span class="keyword">size_t</span> displayHeight) = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    ......   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;IOMX表示的是OpenMax的一个组件，根据Android的Binder IPC机制，<strong>BnOMX继承IOMX，实现者需要继承实现BnOMX</strong>。IOMX类中，有标准的OpenMax的GetParameter，SetParameter，GetConfig，SetConfig，SendCommand，UseBuffer，AllocateBuffer，FreeBuffer，FillThisBuffer和EmptyThisBuffer等接口。<br>&#160; &#160; &#160; &#160;在IOMX.h文件中，另有表示观察器类的IOMXObserver，这个类表示OpenMax的观察者，其中只包含一个onMessage()函数，其参数为omx_message接口体，其中包含Event事件类型、FillThisBuffer完成和EmptyThisBuffer完成几种类型。<br>&#160; &#160; &#160; &#160;提示：Android中OpenMax的适配层是OpenMAX IL层至上的封装层，在Android系统中被StageFright调用，也可以被其他部分调用。</p>
<h1 id="TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现"><a href="#TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现" class="headerlink" title="TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现"></a>TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现</h1><h2 id="TI-OpenMax-IL实现的结构和机制"><a href="#TI-OpenMax-IL实现的结构和机制" class="headerlink" title="TI OpenMax IL实现的结构和机制"></a>TI OpenMax IL实现的结构和机制</h2><p>&#160; &#160; &#160; &#160;Android的开源代码中，已经包含了TI的OpenMax IL层的实现代码，其路径如hardware/ti/omap3/omx下。其中包含的主要目录如下所示：</p>
<ul>
<li>system：OpenMax核心和公共部分</li>
<li>audio：音频处理部分的OpenMax IL组件</li>
<li>video：视频处理部分OpenMax IL组件</li>
<li>image：图像处理部分OpenMax IL组件</li>
</ul>
<p>&#160; &#160; &#160; &#160;TI OpenMax IL实现的结构如图所示:<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/tiopenmaxil.png" alt="TI openmax IL实现"></p>
<p>&#160; &#160; &#160; &#160;在TI OpenMax IL实现中，最上面的内容是OpenMax的管理者用于管理和初始化，中间层是各个编解码单元的OpenMax IL标准组件，下层是LCML层，供各个OpenMax IL标准组件所调用。<br>&#160; &#160; &#160; &#160;（1）TI OpenMax IL实现的公共部分在system/src/openmax_il/目录中，主要的内容如下所示。</p>
<ul>
<li>omx_core/src：OpenMax IL的核心，生成动态库<strong>libOMX_Core.so</strong></li>
<li>lcml/：LCML的工具库，生成动态库libLCML.so</li>
</ul>
<p>&#160; &#160; &#160; &#160;（2）I OpenMax IL的视频（Video）相关的组件在video/src/openmax_il/目录中，主要的内容如下所示。</p>
<ul>
<li>prepost_processor：Video数据的前处理和后处理，生成动态库libOMX.TI.VPP.so</li>
<li>video_decode：Video解码器，生成动态库libOMX.TI.Video.Decoder.so</li>
<li>video_encode：Video编码器，生成动态库libOMX.TI.Video.encoder.so</li>
</ul>
<p>&#160; &#160; &#160; &#160;（3）TI OpenMax IL的音频（Audio）相关的组件在audio/src/openmax_il/目录中，主要的内容如下所示。</p>
<ul>
<li>g711_dec：G711解码器，生成动态库libOMX.TI.G711.decode.so</li>
<li>g711_enc：G711编码器，生成动态库libOMX.TI.G711.encode.so</li>
<li>g722_dec：G722解码器，生成动态库libOMX.TI.G722.decode.so</li>
<li>g722_enc：G722编码器，生成动态库libOMX.TI.G722.encode.so</li>
<li>g726_dec：G726解码器，生成动态库libOMX.TI.G726.decode.so</li>
<li>g726_enc：G726编码器，生成动态库libOMX.TI.G726.encode.so</li>
<li>g729_dec：G729解码器，生成动态库libOMX.TI.G729.decode.so</li>
<li>g729_enc：G720编码器，生成动态库libOMX.TI.G729.encode.so</li>
<li>nbamr_dec：AMR窄带解码器，生成动态库libOMX.TI.AMR.decode.so</li>
<li>nbamr_enc：AMR窄带编码器，生成动态库libOMX.TI.AMR.encode.so</li>
<li>wbamr_dec：AMR宽带解码器，生成动态库libOMX.TI.WBAMR.decode.so</li>
<li>wbamr_enc：AMR宽带编码器，生成动态库libOMX.TI.WBAMR.encode.so</li>
<li>mp3_dec：MP3解码器，生成动态库libOMX.TI.MP3.decode.so</li>
<li>aac_dec：AAC解码器，生成动态库libOMX.TI.AAC.decode.so</li>
<li>aac_enc：AAC编码器，生成动态库libOMX.TI.AAC.encode.so</li>
<li>wma_dec：WMA解码器，生成动态库libOMX.TI.WMA.decode.so</li>
</ul>
<p>&#160; &#160; &#160; &#160;（4）TI OpenMax IL的图像（Image）相关的组件在image/src/openmax_il/目录中，主要的内容如下所示。</p>
<ul>
<li>jpeg_enc：JPEG编码器，生成动态库libOMX.TI.JPEG.Encoder.so</li>
<li>jpeg_dec：JPEG解码器，生成动态库libOMX.TI.JPEG.decoder.so</li>
</ul>
<h2 id="TI-OpenMax-IL的核心和公共内容"><a href="#TI-OpenMax-IL的核心和公共内容" class="headerlink" title="TI OpenMax IL的核心和公共内容"></a>TI OpenMax IL的核心和公共内容</h2><p>&#160; &#160; &#160; &#160;LCML的全称是”<strong>Linux Common Multimedia Layer</strong>“，是TI的Linux公共多媒体层。在OpenMax IL的实现中，这个内容在system/src/openmax_il/lcml/目录中，主要文件是子目录src中的LCML_DspCodec.c文件。通过调用DSPBridge的内容， 让ARM和DSP进行通信，然DSP进行编解码方面的处理。DSP的运行还需要固件的支持。<br>&#160; &#160; &#160; &#160;<strong>TI OpenMax IL的核心实现在system/src/openmax_il/omx_core/目录中，生成TI OpenMax IL的核心库libOMX_Core.so。</strong><br>&#160; &#160; &#160; &#160;其中子目录src中的<strong>OMX_Core.c</strong>为主要文件，其中定义了编解码器的名称等，其片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *tComponentName[MAXCOMP][<span class="number">2</span>] = &#123;    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.JPEG.decoder"</span>, <span class="string">"image_decoder.jpeg"</span>&#125;,<span class="comment">/* 图像和视频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.JPEG.Encoder"</span>, <span class="string">"image_encoder.jpeg"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.avc"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.mpeg4"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.wmv"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.mpeg4"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.h263"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.avc"</span>&#125;,    </span><br><span class="line">     <span class="comment">/* ......省略 ，语音相关组件*/</span>    </span><br><span class="line">#ifdef BUILD_WITH_TI_AUDIO <span class="comment">/* 音频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.MP3.decode"</span>, <span class="string">"audio_decoder.mp3"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AAC.encode"</span>, <span class="string">"audio_encoder.aac"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AAC.decode"</span>, <span class="string">"audio_decoder.aac"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WMA.decode"</span>, <span class="string">"audio_decoder.wma"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WBAMR.decode"</span>, <span class="string">"audio_decoder.amrwb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AMR.decode"</span>, <span class="string">"audio_decoder.amrnb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AMR.encode"</span>, <span class="string">"audio_encoder.amrnb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WBAMR.encode"</span>, <span class="string">"audio_encoder.amrwb"</span>&#125;,    </span><br><span class="line">#endif    </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;tComponentName数组的各个项中，第一个表示<strong>编解码库内容</strong>，第二个表示<strong>库所实现的功能</strong>。<br>&#160; &#160; &#160; &#160;其中，<strong>TIOMX_GetHandle()函数用于获得各个组件的句柄</strong>，其实现的主要片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">TIOMX_GetHandle</span><span class="params">( OMX_HANDLETYPE* pHandle, OMX_STRING cComponentName,    </span><br><span class="line">    OMX_PTR pAppData, OMX_CALLBACKTYPE* pCallBacks)</span>   </span><br><span class="line"></span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> prefix[] = <span class="string">"lib"</span>;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> postfix[] = <span class="string">".so"</span>;    </span><br><span class="line">    OMX_ERRORTYPE (*pComponentInit)(OMX_HANDLETYPE*);    </span><br><span class="line">    OMX_ERRORTYPE err = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *componentType;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pErr = dlerror();    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; COUNTOF(pModules); i++) &#123;       <span class="comment">// 循环查找    </span></span><br><span class="line">        <span class="keyword">if</span>(pModules[i] == <span class="literal">NULL</span>) <span class="keyword">break</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> refIndex = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (refIndex=<span class="number">0</span>; refIndex &lt; MAX_TABLE_SIZE; refIndex++) &#123;    </span><br><span class="line">    <span class="comment">// 循环查找组件列表    </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(componentTable[refIndex].name, cComponentName) == <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (componentTable[refIndex].refCount&gt;= MAX_CONCURRENT_INSTANCES) &#123;    </span><br><span class="line">            <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(prefix) + MAXNAMESIZE+ <span class="keyword">sizeof</span>(postfix)];    </span><br><span class="line">                <span class="built_in">strcpy</span>(buf, prefix);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, cComponentName);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, postfix);    </span><br><span class="line">                pModules[i] = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                <span class="comment">// 动态取出初始化的符号    </span></span><br><span class="line">                pComponentInit = dlsym(pModules[i], <span class="string">"OMX_ComponentInit"</span>);    </span><br><span class="line">                pErr = dlerror();    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                *pHandle = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OMX_COMPONENTTYPE));    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                pComponents[i] = *pHandle;    </span><br><span class="line">                componentType = (OMX_COMPONENTTYPE*) *pHandle;    </span><br><span class="line">                componentType-&gt;nSize = <span class="keyword">sizeof</span>(OMX_COMPONENTTYPE);    </span><br><span class="line">                err = (*pComponentInit)(*pHandle);   <span class="comment">// 执行初始化工作    </span></span><br><span class="line">                <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    err = OMX_ErrorComponentNotFound;    </span><br><span class="line">    <span class="keyword">goto</span> UNLOCK_MUTEX;    </span><br><span class="line">    <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">     <span class="keyword">return</span> (err);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在TIOMX_GetHandle()函数中，根据tComponentName数组中动态库的名称，动态打开各个编解码实现的动态库，取出其中的<strong>OMX_ComponentInit</strong>符号来执行各个组件的初始化。</p>
<h2 id="一个TI-OpenMax-IL组件的实现"><a href="#一个TI-OpenMax-IL组件的实现" class="headerlink" title="一个TI OpenMax IL组件的实现"></a>一个TI OpenMax IL组件的实现</h2><p>&#160; &#160; &#160; &#160;TI OpenMax IL中各个组件都是通过调用LCML来实现的，实现的方式基本类似。主要都是实现了名称为<strong>OMX_ComponentInit</strong>的初始化函数，实现OMX_COMPONENTTYPE类型的结构体中的各个成员。各个组件其目录结构和文件结构也类似。</p>
<p>&#160; &#160; &#160; &#160;以MP3解码器的实现为例，在audio/src/openmax_il/mp3_dec/src目录中，主要包含以下文件：</p>
<ul>
<li>OMX_Mp3Decoder.c：MP3解码器组件实现</li>
<li>OMX_Mp3Dec_CompThread.c：MP3解码器组件的线程循环</li>
<li>OMX_Mp3Dec_Utils.c：MP3解码器的相关工具，调用LCML实现真正的MP3解码的功能</li>
</ul>
<p>&#160; &#160; &#160; &#160;OMX_Mp3Decoder.c中的OMX_ComponentInit()函数负责组件的初始化，返回的内容再从参数中得到，这个函数的主要片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">OMX_ComponentInit</span> <span class="params">(OMX_HANDLETYPE hComp)</span>    </span><br><span class="line"></span>&#123;    </span><br><span class="line">    OMX_ERRORTYPE eError = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *pHandle = (OMX_COMPONENTTYPE*) hComp;    </span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE *pPortDef_ip = <span class="literal">NULL</span>, *pPortDef_op = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFormat = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_MP3TYPE *mp3_ip = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PCMMODETYPE *mp3_op = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3DEC_COMPONENT_PRIVATE *pComponentPrivate = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_AUDIODEC_PORT_TYPE *pCompPort = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_BUFFERLIST *pTemp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;    </span><br><span class="line">  </span><br><span class="line">    MP3D_OMX_CONF_CHECK_CMD(pHandle,<span class="number">1</span>,<span class="number">1</span>);    </span><br><span class="line">    <span class="comment">/* ......省略，初始化OMX_COMPONENTTYPE类型的指针pHandle */</span>    </span><br><span class="line">    OMX_MALLOC_GENERIC(pHandle-&gt;pComponentPrivate, MP3DEC_COMPONENT_PRIVATE);    </span><br><span class="line">    pComponentPrivate = pHandle-&gt;pComponentPrivate; <span class="comment">/* 私有指针互相指向 */</span>    </span><br><span class="line">    pComponentPrivate-&gt;pHandlepHandle = pHandle;    </span><br><span class="line">    <span class="comment">/* ......略，初始化似有数据指针pComponentPrivate */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_ip-&gt;nSize                   = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_ip-&gt;nPortIndex             = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortDef_ip-&gt;eDir                    = OMX_DirInput;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountActual    = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountMin        = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferSize             = MP3D_INPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferAlignment       = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_ip-&gt;bEnabled                 = OMX_TRUE;    </span><br><span class="line">    pPortDef_ip-&gt;bPopulated               = OMX_FALSE;    </span><br><span class="line">    pPortDef_ip-&gt;eDomain                   = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.eEncoding = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.cMIMEType = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.pNativeRender           = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* 设置输出端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_op-&gt;nSize                 = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_op-&gt;nPortIndex           = MP3D_OUTPUT_PORT;    </span><br><span class="line">    pPortDef_op-&gt;eDir                  = OMX_DirOutput;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountMin     = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountActual  = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferSize          = MP3D_OUTPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_op-&gt;nBufferAlignment    = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_op-&gt;bEnabled              = OMX_TRUE;    </span><br><span class="line">    pPortDef_op-&gt;bPopulated            = OMX_FALSE;    </span><br><span class="line">    pPortDef_op-&gt;eDomain               = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.eEncoding      = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.cMIMEType      = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.pNativeRender = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* ......省略，分配端口 */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_INPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">    pPortFormat-&gt;nPortIndex         = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortFormat-&gt;nIndex             = OMX_IndexParamAudioMp3;    </span><br><span class="line">    pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    <span class="comment">/* 设置输出端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_OUTPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">        pPortFormat-&gt;nPortIndex         = MP3D_OUTPUT_PORT;    </span><br><span class="line">        pPortFormat-&gt;nIndex             = OMX_IndexParamAudioPcm;    </span><br><span class="line">        pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    eError = Mp3Dec_StartCompThread(pHandle);   <span class="comment">// 启动MP3解码线程    </span></span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    <span class="keyword">return</span> eError;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个组件是OpenMax的标准实现方式，对外的接口的内容只有一个初始化函数。完成OMX_COMPONENTTYPE类型的初始化。输入端口的编号为MP3D_INPUT_PORT（==0），类型为OMX_PortDomainAudio，格式为OMX_AUDIO_CodingMP3。输出端口的编号是MP3D_OUTPUT_PORT（==1），类型为OMX_PortDomainAudio，格式为OMX<em>AUDIO</em> CodingPCM。</p>
<p>&#160; &#160; &#160; &#160;OMX_Mp3Dec_CompThread.c中定义了MP3DEC_ComponentThread()函数，用于创建MP3解码的线程的执行函数。<br>&#160; &#160; &#160; &#160;OMX_Mp3Dec_Utils.c中的Mp3Dec_StartCompThread()函数，调用了POSIX的线程库建立MP3解码的线程，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nRet = pthread_create (&amp;(pComponentPrivate-&gt;ComponentThread), <span class="literal">NULL</span>,    </span><br><span class="line">    MP3DEC_ComponentThread, pComponentPrivate);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Mp3Dec_StartCompThread()函数就是在组件初始化函数OMX_ComponentInit()最后调用的内容。MP3线程的开始并不表示解码过程开始，线程需要等待通过pipe机制获得命令和数据（cmdPipe和dataPipe），在适当的时候开始工作。这个pipe在MP3解码组件的SendCommand等实现写操作，在线程中读取其内容。</p>
<h1 id="Qualcomm-高通-OpenMax-IL的硬件实现"><a href="#Qualcomm-高通-OpenMax-IL的硬件实现" class="headerlink" title="Qualcomm(高通) OpenMax IL的硬件实现"></a>Qualcomm(高通) OpenMax IL的硬件实现</h1><h2 id="qcom-OpenMax-IL实现的结构和机制"><a href="#qcom-OpenMax-IL实现的结构和机制" class="headerlink" title="qcom OpenMax IL实现的结构和机制"></a>qcom OpenMax IL实现的结构和机制</h2><p>&#160; &#160; &#160; &#160;（1）在AOSP中依然有对高通平台的OpenMax IL层实现代码，位于hardware/qcom/media/mm-core下。这一部分是OpenMax核心和公共部分，主要编译为<strong>libOmxCore.so</strong>。<br>&#160; &#160; &#160; &#160;（2）e.g. 继续在hardware/qcom/media下，选取mm-video-v4l2目录。即Video4linux2（简称V4L2),是linux中关于视频设备的内核驱动。再次进入vidc，（DivxDrmDecrypt为DRM数字版权相关）主要目录如下：</p>
<ul>
<li>vdec：视频解码处理，编译成<strong>libOmxVdec.so/libOmxVdecHevc.so</strong></li>
<li>venc：视频编码处理，编译成<strong>libOmxVenc.so</strong></li>
</ul>
<h2 id="qcom-OpenMax-IL的核心和公共内容"><a href="#qcom-OpenMax-IL的核心和公共内容" class="headerlink" title="qcom OpenMax IL的核心和公共内容"></a>qcom OpenMax IL的核心和公共内容</h2><p>&#160; &#160; &#160; &#160;类似于前面介绍的TI，高通平台在OpenMax IL实现也是大同小异，位于hardware/qcom/media/mm-core，生成libOmxCore.so库。<br>&#160; &#160; &#160; &#160;其中qc_omx_core为主要文件，位于hardware/qcom/media/mm-core/omxcore/src/common/下面。和TI的差不多，<strong>OMX_GetHandle()函数用户获取各个组件的句柄</strong>，其实现的主要片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编解码器组件集合数组</span></span><br><span class="line"><span class="keyword">extern</span> omx_core_cb_type core[];</span><br><span class="line"></span><br><span class="line"> <span class="function">OMX_API OMX_ERRORTYPE OMX_APIENTRY</span><br><span class="line"><span class="title">OMX_GetHandle</span><span class="params">(OMX_OUT OMX_HANDLETYPE*     handle,</span><br><span class="line">              OMX_IN OMX_STRING    componentName,</span><br><span class="line">              OMX_IN OMX_PTR             appData,</span><br><span class="line">              OMX_IN OMX_CALLBACKTYPE* callBacks)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  OMX_ERRORTYPE  eRet = OMX_ErrorNone;</span><br><span class="line">  <span class="keyword">int</span> cmp_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> hnd_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  DEBUG_PRINT(<span class="string">"OMXCORE API :  Get Handle %p %s %p\n"</span>, handle,</span><br><span class="line">                                                     componentName,</span><br><span class="line">                                                     appData);</span><br><span class="line">  pthread_mutex_lock(&amp;lock_core);</span><br><span class="line">  <span class="keyword">if</span>(handle)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> stat sd;</span><br><span class="line">	<span class="comment">//组件句柄</span></span><br><span class="line">    *handle = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//获取根据组件名获取相应index</span></span><br><span class="line">    cmp_index = get_cmp_index(componentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmp_index &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       DEBUG_PRINT(<span class="string">"getting fn pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// dynamically load the so 动态加载组件的so库</span></span><br><span class="line">      core[cmp_index].fn_ptr =</span><br><span class="line">        omx_core_load_cmp_library(core[cmp_index].so_lib_name,</span><br><span class="line">                                  &amp;core[cmp_index].so_lib_handle);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(core[cmp_index].fn_ptr)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Construct the component requested</span></span><br><span class="line">        <span class="comment">// Function returns the opaque handle</span></span><br><span class="line">        <span class="comment">//根据获取的组件句柄初始化它</span></span><br><span class="line">        <span class="keyword">void</span>* pThis = (*(core[cmp_index].fn_ptr))();</span><br><span class="line">        <span class="keyword">if</span>(pThis)</span><br><span class="line">        &#123;</span><br><span class="line">	      <span class="comment">//包装一层，忽略</span></span><br><span class="line">          <span class="keyword">void</span> *hComp = <span class="literal">NULL</span>;</span><br><span class="line">          hComp = qc_omx_create_component_wrapper((OMX_PTR)pThis);</span><br><span class="line">          <span class="keyword">if</span>((eRet = qc_omx_component_init(hComp, core[cmp_index].name)) !=</span><br><span class="line">                           OMX_ErrorNone)</span><br><span class="line">          &#123;</span><br><span class="line">              DEBUG_PRINT(<span class="string">"Component not created succesfully\n"</span>);</span><br><span class="line">              pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">              <span class="keyword">return</span> eRet;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//设置回调</span></span><br><span class="line">          qc_omx_component_set_callbacks(hComp,callBacks,appData);</span><br><span class="line">          hnd_index = get_comp_handle_index(componentName);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span>(hnd_index &gt;= <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//保存这个组件句柄</span></span><br><span class="line">            core[cmp_index].inst[hnd_index]= *handle = (OMX_HANDLETYPE) hComp;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">          <span class="comment">/*-------下面全是错误处理，忽略------*/</span></span><br><span class="line">            DEBUG_PRINT(<span class="string">"OMX_GetHandle:NO free slot available to store Component Handle\n"</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">          &#125;</span><br><span class="line">          DEBUG_PRINT(<span class="string">"Component %p Successfully created\n"</span>,*handle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">          DEBUG_PRINT(<span class="string">"Component Creation failed\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        eRet = OMX_ErrorNotImplemented;</span><br><span class="line">        DEBUG_PRINT(<span class="string">"library couldnt return create instance fn\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      eRet = OMX_ErrorNotImplemented;</span><br><span class="line">      DEBUG_PRINT(<span class="string">"ERROR: Already another instance active  ;rejecting \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    eRet =  OMX_ErrorBadParameter;</span><br><span class="line">    DEBUG_PRINT(<span class="string">"\n OMX_GetHandle: NULL handle \n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">  <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里的有个数组：<strong>extern omx_core_cb_type core[]</strong>，是从别的文件中声明过来的全局变量，其中包含了各种编解码器的名称和一些属性的结构体。结构体定义位于hardware/qcom/media/mm-core/omxcore/src/common/qc_omx_core.h：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _omx_core_cb_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span>*                         name;<span class="comment">// Component name 组件名</span></span><br><span class="line">  create_qc_omx_component     fn_ptr;<span class="comment">// create instance fn ptr 创建实例函数指针</span></span><br><span class="line">  <span class="keyword">void</span>*                         inst[OMX_COMP_MAX_INST];<span class="comment">// Instance handle 实例句柄</span></span><br><span class="line">  <span class="keyword">void</span>*                so_lib_handle;<span class="comment">// So Library handle so库句柄</span></span><br><span class="line">  <span class="keyword">char</span>*                  so_lib_name;<span class="comment">// so directory so名</span></span><br><span class="line">  <span class="keyword">char</span>* roles[OMX_CORE_MAX_CMP_ROLES];<span class="comment">// roles played 组件扮演的角色</span></span><br><span class="line">&#125;omx_core_cb_type;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;但是给<strong>omx_core_cb_type core[]</strong>这个结构体数组复制的地方要根据不同型号进行选取，我们进入hardware/qcom/media/mm-core/src下面，会看到有许多型号，7627A、7630、8084、8226、8610、8660等等。比如这个8974的，位于hardware/qcom/media/mm-core/src/8974/qc_registry_table_android.c中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">omx_core_cb_type core[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//avc/h264解码器</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.avc"</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.avc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//mpeg4解码器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.mpeg4"</span>,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.mpeg4"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//wmv解码器</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.wmv"</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.vc1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//hevc/h265编码器</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.encoder.hevc"</span>,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVencHevc.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_encoder.hevc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  ...太多了，省略...</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面就是对编解码器相关信息的注册。</p>
<p>&#160; &#160; &#160; &#160;在OMX_GetHandle()函数中，根据omx_core_cb_type core[]数组中动态库的名称，动态打开各个编解码实现的动态库,然后进行初始化。</p>
<h2 id="一个qcom-OpenMax-IL组件的实现"><a href="#一个qcom-OpenMax-IL组件的实现" class="headerlink" title="一个qcom OpenMax IL组件的实现"></a>一个qcom OpenMax IL组件的实现</h2><p>&#160; &#160; &#160; &#160;高通平台对于编解码组件的处理都比较集中，不像TI那么分散和细致。一个组件实现都要包含<strong>Qc_omx_component.h</strong>头文件，位于很多地方，如hardware/qcom/media/mm-core/inc，要实现里面相关纯虚函数。当一个组件被创建后要初始化，就要实现<strong>component_init(OMX_IN OMX_STRING componentName)</strong>方法。</p>
<p>&#160; &#160; &#160; &#160;举个例子，依然以Video4linux2平台，进入hardware/qcom/media/mm-video-v4l2/vidc/vdec/src查看视频解码相关组件。比如我们看看解码组件omx_vdec_hevc.cpp，查看component_init方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENUS_HEVC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="string">"/dev/video/venus_dec"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="string">"/dev/video/q6_dec"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ======================================================================</span><br><span class="line">   FUNCTION</span><br><span class="line">   omx_vdec::ComponentInit</span><br><span class="line"></span><br><span class="line">   DESCRIPTION</span><br><span class="line">   Initialize the component.</span><br><span class="line"></span><br><span class="line">   PARAMETERS</span><br><span class="line">   ctxt -- Context information related to the self.</span><br><span class="line">   id   -- Event identifier. This could be any of the following:</span><br><span class="line">   1. Command completion event</span><br><span class="line">   2. Buffer done callback event</span><br><span class="line">   3. Frame done callback event</span><br><span class="line"></span><br><span class="line">   RETURN VALUE</span><br><span class="line">   None.</span><br><span class="line"></span><br><span class="line">   ========================================================================== */</span></span><br><span class="line">OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    OMX_ERRORTYPE eRet = OMX_ErrorNone;</span><br><span class="line">    <span class="keyword">struct</span> v4l2_fmtdesc fdesc;</span><br><span class="line">    <span class="keyword">struct</span> v4l2_format fmt;</span><br><span class="line">    <span class="keyword">struct</span> v4l2_requestbuffers bufreq;</span><br><span class="line">    <span class="keyword">struct</span> v4l2_control control;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   alignment = <span class="number">0</span>,buffer_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> r,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> codec_ambiguous = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//打开设备文件"/dev/video/venus_dec"或"/dev/video/q6_dec"</span></span><br><span class="line">    OMX_STRING device_name = (OMX_STRING)DEVICE_NAME;</span><br><span class="line">    ......</span><br><span class="line">    drv_ctx.video_driver_fd = open(device_name, O_RDWR);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//如果是一个打开成功后，为什么要再次打开？？excuse me ？</span></span><br><span class="line">    <span class="keyword">if</span> (drv_ctx.video_driver_fd == <span class="number">0</span>) &#123;</span><br><span class="line">        drv_ctx.video_driver_fd = open(device_name, O_RDWR);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打开设备文件失败</span></span><br><span class="line">    <span class="keyword">if</span> (drv_ctx.video_driver_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Omx_vdec::Comp Init Returning failure, errno %d"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_ctx.frame_rate.fps_numerator = DEFAULT_FPS;<span class="comment">//帧率分子</span></span><br><span class="line">    drv_ctx.frame_rate.fps_denominator = <span class="number">1</span>;<span class="comment">//帧率分母</span></span><br><span class="line">	<span class="comment">//创建一个异步线程，执行async_message_thread函数，对输入端进行设置</span></span><br><span class="line">    ret = pthread_create(&amp;async_thread_id,<span class="number">0</span>,async_message_thread,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建线程失败，则关闭设备文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(drv_ctx.video_driver_fd);</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Failed to create async_message_thread"</span>);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the role information which provides the decoder kind</span></span><br><span class="line">    <span class="comment">//将组建角色名字copy进设备驱动上下文结构体的kind属性</span></span><br><span class="line">    strlcpy(drv_ctx.kind,role,<span class="number">128</span>);</span><br><span class="line">	<span class="comment">//如果是mpeg4解码组件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind,<span class="string">"OMX.qcom.video.decoder.mpeg4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.mpeg4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.timestamp_adjust = <span class="literal">true</span>;</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG4;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingMPEG4;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_MPEG4;</span><br><span class="line">        <span class="comment">/*Initialize Start Code for MPEG4*/</span></span><br><span class="line">        codec_type_parse = CODEC_TYPE_MPEG4;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//如果是mpeg2解码组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind,<span class="string">"OMX.qcom.video.decoder.mpeg2"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.mpeg2"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG2;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_MPEG2;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingMPEG2;</span><br><span class="line">        <span class="comment">/*Initialize Start Code for MPEG2*/</span></span><br><span class="line">        codec_type_parse = CODEC_TYPE_MPEG2;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//如果是h263解码组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.h263"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.h263"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_LOW(<span class="string">"H263 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_H263;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingH263;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_H263;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_H263;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//如果是divx311...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx311"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_LOW (<span class="string">"DIVX 311 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_3;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX_311;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是divx4...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_ERROR (<span class="string">"DIVX 4 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_4;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        codec_ambiguous = <span class="literal">true</span>;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是divx...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_ERROR (<span class="string">"DIVX 5/6 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_6;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        codec_ambiguous = <span class="literal">true</span>;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果是avc/h264...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.avc"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.avc"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_H264;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_H264;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingAVC;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_H264;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">        m_frame_parser.init_nal_length(nal_length);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//如果是hevc/h265...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.hevc"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.hevc"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_HEVC;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_HEVC;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingHevc;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_HEVC;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">        m_frame_parser.init_nal_length(nal_length);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//如果是vc1...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.vc1"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vc1"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_VC1;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingWMV;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VC1;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_VC1_ANNEX_G;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">	<span class="comment">//如果是wmv...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.wmv"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vc1"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_VC1_RCV;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingWMV;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VC1;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_VC1_ANNEX_L;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">	<span class="comment">//如果是vp8...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.vp8"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vp8"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        output_capability=V4L2_PIX_FMT_VP8;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingVPX;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VP8;</span><br><span class="line">        arbitrary_bytes = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果是不认识的解码组件，则报错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"ERROR:Unknown Component"</span>);</span><br><span class="line">        eRet = OMX_ErrorInvalidComponentName;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果错误</span></span><br><span class="line">    <span class="keyword">if</span> (eRet == OMX_ErrorNone) &#123;</span><br><span class="line">		<span class="comment">//设置视频输出编码格式为YUV的一种</span></span><br><span class="line">        drv_ctx.output_format = VDEC_YUV_FORMAT_NV12;</span><br><span class="line">        <span class="comment">//设置颜色编码</span></span><br><span class="line">        OMX_COLOR_FORMATTYPE dest_color_format = (OMX_COLOR_FORMATTYPE)</span><br><span class="line">            QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;</span><br><span class="line">        <span class="keyword">if</span> (!client_buffers.set_color_format(dest_color_format)) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Setting color format failed"</span>);</span><br><span class="line">            eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//订阅事件</span></span><br><span class="line">        capture_capability= V4L2_PIX_FMT_NV12;</span><br><span class="line">        ret = subscribe_to_events(drv_ctx.video_driver_fd);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Subscribe Event Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">struct</span> v4l2_capability cap;</span><br><span class="line">        <span class="comment">//设置查询能力标志位</span></span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_QUERYCAP, &amp;cap);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to query capabilities"</span>);</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"Capabilities: driver_name = %s, card = %s, bus_info = %s,"</span></span><br><span class="line">                    <span class="string">" version = %d, capabilities = %x"</span>, cap.driver, cap.card,</span><br><span class="line">                    cap.bus_info, cap.version, cap.capabilities);</span><br><span class="line">        &#125;</span><br><span class="line">        ret=<span class="number">0</span>;</span><br><span class="line">        fdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;</span><br><span class="line">        fdesc.index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == <span class="number">0</span>) &#123;</span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"fmt: description: %s, fmt: %x, flags = %x"</span>, fdesc.description,</span><br><span class="line">                    fdesc.pixelformat, fdesc.flags);</span><br><span class="line">            fdesc.index++;</span><br><span class="line">        &#125;</span><br><span class="line">        fdesc.type=V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;</span><br><span class="line">        fdesc.index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"fmt: description: %s, fmt: %x, flags = %x"</span>, fdesc.description,</span><br><span class="line">                    fdesc.pixelformat, fdesc.flags);</span><br><span class="line">            fdesc.index++;</span><br><span class="line">        &#125;</span><br><span class="line">        update_resolution(<span class="number">320</span>, <span class="number">240</span>);</span><br><span class="line">        fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;</span><br><span class="line">        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;</span><br><span class="line">        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;</span><br><span class="line">        fmt.fmt.pix_mp.pixelformat = output_capability;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to set format on output port"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Set Format was successful"</span>);</span><br><span class="line">        <span class="comment">//如果有歧义的解码组件</span></span><br><span class="line">        <span class="keyword">if</span> (codec_ambiguous) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output_capability == V4L2_PIX_FMT_DIVX) &#123;</span><br><span class="line">                <span class="keyword">struct</span> v4l2_control divx_ctrl;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_4) &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_4;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_5) &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_5;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_6;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                divx_ctrl.id = V4L2_CID_MPEG_VIDC_VIDEO_DIVX_FORMAT;</span><br><span class="line">                ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;divx_ctrl);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"Failed to set divx version"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"Codec should not be ambiguous"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//解码相关参数设置</span></span><br><span class="line">        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;</span><br><span class="line">        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;</span><br><span class="line">        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;</span><br><span class="line">        fmt.fmt.pix_mp.pixelformat = capture_capability;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to set format on capture port"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Set Format was successful"</span>);</span><br><span class="line">        <span class="keyword">if</span> (secure_mode) &#123;</span><br><span class="line">            control.id = V4L2_CID_MPEG_VIDC_VIDEO_SECURE;</span><br><span class="line">            control.value = <span class="number">1</span>;</span><br><span class="line">            DEBUG_PRINT_LOW(<span class="string">"Omx_vdec:: calling to open secure device %d"</span>, ret);</span><br><span class="line">            ret=ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL,&amp;control);</span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"Omx_vdec:: Unable to open secure device %d"</span>, ret);</span><br><span class="line">                close(drv_ctx.video_driver_fd);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Get the Buffer requirements for input and output ports*/</span></span><br><span class="line">        <span class="comment">//获得输入和输出的缓冲条件</span></span><br><span class="line">        drv_ctx.ip_buf.buffer_type = VDEC_BUFFER_TYPE_INPUT;</span><br><span class="line">        drv_ctx.op_buf.buffer_type = VDEC_BUFFER_TYPE_OUTPUT;</span><br><span class="line">        <span class="keyword">if</span> (secure_mode) &#123;</span><br><span class="line">            drv_ctx.op_buf.alignment=SZ_1M;</span><br><span class="line">            drv_ctx.ip_buf.alignment=SZ_1M;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drv_ctx.op_buf.alignment=SZ_4K;</span><br><span class="line">            drv_ctx.ip_buf.alignment=SZ_4K;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_ctx.interlace = VDEC_InterlaceFrameProgressive;</span><br><span class="line">        drv_ctx.extradata = <span class="number">0</span>;</span><br><span class="line">        drv_ctx.picture_order = VDEC_ORDER_DISPLAY;</span><br><span class="line">        control.id = V4L2_CID_MPEG_VIDC_VIDEO_OUTPUT_ORDER;</span><br><span class="line">        control.value = V4L2_MPEG_VIDC_VIDEO_OUTPUT_ORDER_DISPLAY;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;control);</span><br><span class="line">        drv_ctx.idr_only_decoding = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_state = OMX_StateLoaded;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEFAULT_EXTRADATA</span></span><br><span class="line">        <span class="keyword">if</span> (eRet == OMX_ErrorNone &amp;&amp; !secure_mode)</span><br><span class="line">            enable_extradata(DEFAULT_EXTRADATA, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        eRet=get_buffer_req(&amp;drv_ctx.ip_buf);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Input Buffer Size =%d"</span>,drv_ctx.ip_buf.buffer_size);</span><br><span class="line">        get_buffer_req(&amp;drv_ctx.op_buf);</span><br><span class="line">        <span class="comment">//如果解码器格式是h264或者hevc/h265</span></span><br><span class="line">        <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||</span><br><span class="line">                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC) &#123;</span><br><span class="line">            h264_scratch.nAllocLen = drv_ctx.ip_buf.buffer_size;</span><br><span class="line">            h264_scratch.pBuffer = (OMX_U8 *)<span class="built_in">malloc</span> (drv_ctx.ip_buf.buffer_size);</span><br><span class="line">            h264_scratch.nFilledLen = <span class="number">0</span>;</span><br><span class="line">            h264_scratch.nOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (h264_scratch.pBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"h264_scratch.pBuffer Allocation failed "</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果解码器格式是h264</span></span><br><span class="line">        <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_frame_parser.mutils == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                m_frame_parser.mutils = <span class="keyword">new</span> H264_Utils();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m_frame_parser.mutils == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"parser utils Allocation failed "</span>);</span><br><span class="line">                    eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    m_frame_parser.mutils-&gt;initialize_frame_checking_environment();</span><br><span class="line">                    m_frame_parser.mutils-&gt;allocate_rbsp_buffer (drv_ctx.ip_buf.buffer_size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//创建一个h264流的解析器</span></span><br><span class="line">            h264_parser = <span class="keyword">new</span> h264_stream_parser();</span><br><span class="line">            <span class="keyword">if</span> (!h264_parser) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"ERROR: H264 parser allocation failed!"</span>);</span><br><span class="line">                eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//打开一个管道，读写端保存进fds数组</span></span><br><span class="line">        <span class="keyword">if</span> (pipe(fds)) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"pipe creation failed"</span>);</span><br><span class="line">            eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (fds[<span class="number">0</span>] == <span class="number">0</span> || fds[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pipe (temp1)) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"pipe creation failed"</span>);</span><br><span class="line">                    <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//close (fds[0]);</span></span><br><span class="line">                <span class="comment">//close (fds[1]);</span></span><br><span class="line">                fds[<span class="number">0</span>] = temp1 [<span class="number">0</span>];</span><br><span class="line">                fds[<span class="number">1</span>] = temp1 [<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输入/读</span></span><br><span class="line">            m_pipe_in = fds[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//输出/写</span></span><br><span class="line">            m_pipe_out = fds[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//创建一个工作线程，调用omx开始处理解码，并进行i/o操作</span></span><br><span class="line">            r = pthread_create(&amp;msg_thread_id,<span class="number">0</span>,message_thread,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"component_init(): message_thread creation failed"</span>);</span><br><span class="line">                eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//没有错误，然后收尾</span></span><br><span class="line">    <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Component Init Failed"</span>);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Calling VDEC_IOCTL_STOP_NEXT_MSG"</span>);</span><br><span class="line">        (<span class="keyword">void</span>)ioctl(drv_ctx.video_driver_fd, VDEC_IOCTL_STOP_NEXT_MSG,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Calling close() on Video Driver"</span>);</span><br><span class="line">        close (drv_ctx.video_driver_fd);</span><br><span class="line">        drv_ctx.video_driver_fd = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"omx_vdec::component_init() success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//memset(&amp;h264_mv_buff,0,sizeof(struct h264_mv_buffer));</span></span><br><span class="line">    <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个是解码组件的初始化实现。我们能够看出和TI的差距挺大的。步骤大概如下（maybe wrong）：</p>
<ul>
<li>打开media相关设备文件</li>
<li>创建一个异步线程，执行async_message_thread函数，对输入端进行设置</li>
<li>根据解码器role名配置相关属性</li>
<li>对视频解码相关基本配置进行设置</li>
<li>创建一个管道，然后再开一个个工作线程，调用omx开始处理解码，并进行i/o操作</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;本篇和上一篇都是科普一下OpenMax和它在android上的实现，可以忽略不用看。下一篇我们将承接上上一篇和上一篇结尾的部分，分析android平台Stagefright和codec的交互。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/meizi.png" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(五)----OpenMax简介]]></title>
      <url>http://windrunnerlihuan.com/2016/12/15/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%BA%94-OpenMax%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;android中的 AwesomePlayer就是用OpenMax来做(codec)编解码的，上一篇最后一步初始化解码器我们只是初窥了一下，以后会仔细分析。本节就主要科普一下OpenMax和它在Android系统中扮演的角色。<br><a id="more"></a></p>
<h1 id="OpenMax系统的结构"><a href="#OpenMax系统的结构" class="headerlink" title="OpenMax系统的结构"></a>OpenMax系统的结构</h1><h2 id="OpenMax总体层次结构"><a href="#OpenMax总体层次结构" class="headerlink" title="OpenMax总体层次结构"></a>OpenMax总体层次结构</h2><p>&#160; &#160; &#160; &#160;OpenMax是一个多媒体应用程序的框架标准，由<strong>NVIDIA</strong>公司和<strong>Khronos</strong>在2006年推出。<br>&#160; &#160; &#160; &#160;OpenMax是无授权费的，跨平台的应用程序接口API，<strong>通过使媒体加速组件能够在开发、集成和编程环节中实现跨多操作系统和处理器硬件平台，提供全面的流媒体编解码器和应用程序便携化</strong>。<br>&#160; &#160; &#160; &#160;OpenMax的官方网站如下所示：<br>&#160; &#160; &#160; &#160;<a href="http://www.khronos.org/openmax/" target="_blank" rel="external">http://www.khronos.org/openmax/</a></p>
<p>&#160; &#160; &#160; &#160;OpenMax实际上分成三个层次，自上而下分别是，OpenMax DL（开发层），OpenMax IL（集成层）和OpenMax AL（应用层）。三个层次的内容分别如下所示：</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;<strong>第一层：OpenMax DL（Development Layer，开发层）</strong><br>&#160; &#160; &#160; &#160; OpenMax DL定义了一个API，它是音频、视频和图像功能的集合。供应商能够在一个新的处理器上实现并优化，然后编解码供应商使用它来编写更广泛的编解码器功能。它包括音频信号的处理功能，如FFT和filter，图像原始处理，如颜色空间转换、视频原始处理，以实现例如MPEG-4、H.264、MP3、AAC和JPEG等编解码器的优化。</p>
<p>&#160; &#160; &#160; &#160;<strong>第二层：OpenMax IL（Integration Layer，集成层）</strong><br>&#160; &#160; &#160; &#160;<em>OpenMax IL作为音频、视频和图像编解码器能与多媒体编解码器交互，并以统一的行为支持组件（例如，资源和皮肤）。</em>这些编解码器或许是软硬件的混合体，对用户是透明的底层接口应用于嵌入式、移动设备。它提供了应用程序和媒体框架，透明的。编解码器供应商必须写私有的或者封闭的接口，集成进移动设备。IL的主要目的是使用特征集合为编解码器提供一个系统抽象，为解决多个不同媒体系统之间轻便性的问题。</p>
<p>&#160; &#160; &#160; &#160;<strong>第三层：OpenMax AL（Appliction Layer，应用层）</strong><br>&#160; &#160; &#160; &#160;OpenMax AL API在应用程序和多媒体中间件之间提供了一个标准化接口，多媒体中间件提供服务以实现被期待的API功能。</p>
</blockquote>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%94%29----OpenMax%E7%AE%80%E4%BB%8B/openmaxsystem.png" alt="OpenMax系统分层"></p>
<p>&#160; &#160; &#160; &#160;OpenMax API将会与处理器一同提供，以<strong>使库和编解码器开发者能够高速有效地利用新器件的完整加速潜能，无须担心其底层的硬件结构</strong>。该标准是针对嵌入式设备和移动设备的多媒体软件架构。在架构底层上为多媒体的编解码和数据处理定义了一套统一的编程接口，对多媒体数据的处理功能进行<code>系统级抽象</code>，为用户屏蔽了底层的细节。因此，<strong>多媒体应用程序和多媒体框架通过OpenMax IL可以以一种统一的方式来使用编解码和其他多媒体数据处理功能，具有了</strong><code>跨越软硬件平台的移植性</code>。</p>
<p>&#160; &#160; &#160; &#160;<font color="red">注：在实际的应用中，OpenMax的三个层次中使用较多的是OpenMax IL集成层，由于操作系统到硬件的差异和多媒体应用的差异，OpenMax的DL和AL层使用相对较少</font>。 </p>
<h2 id="OpenMax-IL简介"><a href="#OpenMax-IL简介" class="headerlink" title="OpenMax IL简介"></a>OpenMax IL简介</h2><p>&#160; &#160; &#160; &#160;OpenMax IL 处在中间层的位置，OpenMAX IL 作为音频，视频和图像编解码器 能与多媒体编解码器交互，并以统一的行为支持组件（例如资源和皮肤）。这些编解码器或许是软硬件的混合体，对用户是 的底层接口应用于嵌入式或 / 和移动设备。它提供了应用程序和媒体框架， 透明的。本质上不存在这种标准化的接口，编解码器供 应商必须写私有的或者封闭的接口，集成进移动设备。 IL 的主要目的 是使用特征集合为编解码器提供一个系统抽象，为解决多个不同媒体系统之间轻便性的问题。<br>&#160; &#160; &#160; &#160;OpenMax IL 的目的就是为硬件平台的图形及音视频提供一个抽象层，可以为上层的应用提供一个可跨平台的支撑。这一点对于跨平台的媒体应用来说十分重要。本人也接触过几家高清解码芯片，这些芯片底层的音视频接口虽然功能上大致相同，但是接口设计及用法上各有不同，而且相差很多。你要想让自己开发的媒体应用完美的运行在不同的硬件厂商平台上，就得适应不同芯片的底层解码接口。这个对于应用开发来说十分繁琐。所以就需要类似于OpenMax IL 这种接口规范。应用假如涉及到音视频相关功能时，只需调用这些标准的接口，而不需要关心接口下方硬件相关的实现。假如换了硬件平台时，只需要把接口层与硬件适配好了就行了。上层应用不需要频繁改动。<br>&#160; &#160; &#160; &#160;你可以把OpenMax IL 看作是中间件中的porting层接口，但是现在中间件大部分都是自家定义自己的。</p>
<p>&#160; &#160; &#160; &#160;OpenMax 想做的就是定义一个这样的行业标准，这样媒体应用、硬件厂商都遵循这种标准。硬件厂商将OpenMax 与处理器一并提供，上层的多媒体框架想要用到硬件音视频加速功能时，只需遵循openmax的接口就可以扩平台运行。<br>&#160; &#160; &#160; &#160;可喜的，现在越来越多的多媒体框架及多媒体应用正在遵循openmax标准，包括各种知名的媒体开源软件。越来越多的芯片厂商也在遵循openmax的标准。对于现在的音视频编解码来说，分辨率越来越高，需要芯片提供硬件加速功能是个大的趋势。我相信 接口的标准化是一定要走的。如下图所示， openmax IL在多媒体框架中的应用：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%94%29----OpenMax%E7%AE%80%E4%BB%8B/openmaxuse.png" alt="openmax use"></p>
<p>&#160; &#160; &#160; &#160;<strong>OpenMax IL目前已经成为了事实上的多媒体框架标准</strong>。嵌入式处理器或者多媒体编解码模块的硬件生产者，通常提供标准的OpenMax IL层的软件接口，这样软件的开发者就可以基于这个层次的标准化接口进行多媒体程序的开发。<br>&#160; &#160; &#160; &#160;OpenMax IL的接口层次结构适中，既不是硬件编解码的接口，也不是应用程序层的接口，因此比较容易实现标准化。OpenMax IL的层次结构如下：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%94%29----OpenMax%E7%AE%80%E4%BB%8B/openmaxIL.png" alt="openmax IL"></p>
<p>&#160; &#160; &#160; &#160;图中的虚线中的内容是OpenMax IL层的内容，其主要实现了OpenMax IL中的各个组件（Component）。<strong>对下层，OpenMax IL可以调用OpenMax DL层的接口，也可以直接调用各种Codec实现。对上层，OpenMax IL可以给OpenMax AL 层等框架层（Middleware）调用，也可以给应用程序直接调用</strong>。</p>
<h2 id="OpenMax-IL结构"><a href="#OpenMax-IL结构" class="headerlink" title="OpenMax IL结构"></a>OpenMax IL结构</h2><p>&#160; &#160; &#160; &#160;OpenMax IL主要内容如下所示。</p>
<ul>
<li><strong>客户端（Client）</strong>：OpenMax IL的调用者</li>
<li><strong>组件（Component）</strong>：OpenMax IL的单元，每一个组件实现一种功能</li>
<li><strong>端口（Port）</strong>：组件的输入输出接口</li>
<li><strong>隧道化（Tunneled）</strong>：让两个组件直接连接的方式</li>
</ul>
<p>&#160; &#160; &#160; &#160;OpenMax IL的基本运作过程如图所示：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%94%29----OpenMax%E7%AE%80%E4%BB%8B/openmaxilbase.png" alt="基本运作"></p>
<p>&#160; &#160; &#160; &#160;OpenMAL IL的客户端，通过调用四个OpenMAL IL组件，实现了一个功能。四个组件分别是Source组件、Host组件、Accelerator组件和Sink组件。Source组件只有一个输出端口；而Host组件有一个输入端口和一个输出端口；Accelerator组件具有一个输入端口，调用了硬件的编解码器，加速主要体现在这个环节上。Accelerator组件和Sink组件通过私有通讯方式在内部进行连接，没有经过明确的组件端口。<br>&#160; &#160; &#160; &#160;OpenMAL IL在使用的时候，其数据流也有不同的处理方式：既可以经由客户端，也可以不经由客户端。图中Source组件到Host组件的数据流就是经过客户端的；而Host组件到Accelerator组件的数据流就没有经过客户端，使用了隧道化的方式；Accelerator组件和Sink组件甚至可以使用私有的通讯方式。</p>
<p>&#160; &#160; &#160; &#160;OpenMax Core是辅助各个组件运行的部分，它通常需要完成各个组件的初始化等工作，在真正运行过程中，重点是各个OpenMax IL的组件，OpenMax Core不是重点，也不是标准。</p>
<p>&#160; &#160; &#160; &#160;OpenMAL IL的组件是OpenMax IL实现的核心内容，一个组件以输入、输出端口为接口，端口可以被连接到另一个组件上。外部对组件可以发送命令，还进行设置/获取参数、配置等内容。组件的端口可以包含缓冲区（Buffer）的队列。<br>&#160; &#160; &#160; &#160;组件的处理的核心内容是：通过输入端口消耗Buffer，通过输出端口填充Buffer，由此多组件相联接可以构成流式的处理。OpenMAL IL中一个组件的结构如下图所示：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%94%29----OpenMax%E7%AE%80%E4%BB%8B/openilinternal.JPG" alt="openmax IL组件"></p>
<p>&#160; &#160; &#160; &#160;组件的功能和其定义的端口类型密切相关，通常情况下：只有一个输出端口的，为<strong>Source</strong>组件；只有一个输入端口的，为<strong>Sink组件</strong>；有多个输入端口，一个输出端口的为<strong>Mux组件</strong>；有一个输入端口，多个输出端口的为<strong>DeMux组件</strong>；输入输出端口各一个组件的为<strong>中间处理环节</strong>，这是最常见的组件。</p>
<p>&#160; &#160; &#160; &#160;端口具体支持的数据也有不同的类型。例如，对于一个输入、输出端口各一个组件，其输入端口使用MP3格式的数据，输出端口使用PCM格式的数据，那么这个组件就是一个MP3解码组件。</p>
<p>&#160; &#160; &#160; &#160;隧道化（Tunneled）是一个关于组件连接方式的概念。通过隧道化可以将不同的组件的一个输入端口和一个输出端口连接到一起，在这种情况下，两个组件的处理过程合并，共同处理。尤其对于单输入和单输出的组件，两个组件将作为类似一个使用。</p>
<h1 id="Android中的OpenMax"><a href="#Android中的OpenMax" class="headerlink" title="Android中的OpenMax"></a>Android中的OpenMax</h1><h2 id="OpenMax在Android中的使用情况"><a href="#OpenMax在Android中的使用情况" class="headerlink" title="OpenMax在Android中的使用情况"></a>OpenMax在Android中的使用情况</h2><p>&#160; &#160; &#160; &#160;在Android中，OpenMax IL层，通常可以用于<strong>多媒体引擎的插件</strong>，Android的多媒体引擎OpenCore和StageFright都可以使用OpenMax作为插件，主要用于<strong>编解码（Codec）</strong>处理。<br>&#160; &#160; &#160; &#160;在Android的框架层，也定义了由Android封装的OpenMax接口，和标准的接口概念基本相同，但是使用C++类型的接口，并且使用了Android的Binder IPC机制。Android封装OpenMax的接口被StageFright使用，OpenCore没有使用这个接口，而是使用其他形式对OpenMax IL层接口进行封装。Android OpenMax的基本层次结构如图：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%94%29----OpenMax%E7%AE%80%E4%BB%8B/openmaxinandroid.jpg" alt="openmax in android"></p>
<p>&#160; &#160; &#160; &#160;Android系统的一些部分对OpenMax IL层进行使用，基本使用的是标准OpenMax IL层的接口，只是进行了简单的封装。标准的OpenMax IL实现很容易以插件的形式加入到Android系统中。<br>&#160; &#160; &#160; &#160;Android的多媒体引擎OpenCore和StageFright都可以使用OpenMax作为多媒体编解码的插件，只是<strong>没有直接使用OpenMax IL层提供的纯C接口，而是对其进行了一定的封装(C++封装)</strong>。<br>&#160; &#160; &#160; &#160;在Android2.x版本之后，Android的框架层也对OpenMax IL层的接口进行了封装定义，甚至使用Android中的Binder IPC机制。Stagefright使用了这个层次的接口，OpenCore没有使用。<br>&#160; &#160; &#160; &#160;注：OpenCore使用OpenMax IL层作为编解码插件在前，Android框架层封装OpenMax接口在后面的版本中才引入。</p>
<h2 id="Android-OpenMax实现的内容"><a href="#Android-OpenMax实现的内容" class="headerlink" title="Android OpenMax实现的内容"></a>Android OpenMax实现的内容</h2><p>&#160; &#160; &#160; &#160;android中的 AwesomePlayer就是用openmax来做(Codec)编解码,其实在openmax接口设计中，他不光能用来当编解码。通过他的组件可以组成一个完整的播放器，包括sourc、demux、decode、output。但是为什么android只用他来做code呢？应该有如下方面：</p>
<ul>
<li>1.在整个播放器中，解码器不得不说是最重要的一部分，而且也是最耗资源的一块。如果全靠软解，直接通过cpu来运算，特别是高清视频。别的事你就可以啥都不干了。所以解码器是最需要硬件提供加速的部分。现在的高清解码芯片都是主芯片+DSP结构，解码的工作都是通过DSP来做，不会在过多的占用主芯片。所有将芯片中DSP硬件编解码的能力通过openmax标准接口呈现出来，提供上层播放器来用。我认为这块是openmax最重要的意义。</li>
<li>2.source 主要是和协议打交道，demux 分解容器部分，大多数的容器格式的分解是不需要通过硬件来支持。只是ts流这种格式最可能用到硬件的支持。因为ts格式比较特殊，单包的大小太小了，只有188字节。所以也是为什么现在常见的解码芯片都会提供硬件ts demux 的支持。</li>
<li>3.音视频输出部分video\audio output 这块和操作系统关系十分紧密。可以看看著名开源播放器vlc。vlc 在mac、linux、Windows都有，功能上差别也不大。所以说他是跨平台的，他跨平台跨在哪？主要的工作量还是在音视频解码完之后的输出模块。因为各个系统的图像渲染和音频输出实现方法不同，所以vlc需要针对每个平台实现不同的output。这部分内容放在openmax来显然不合适。</li>
</ul>
<p>&#160; &#160; &#160; &#160;Android中使用的主要是OpenMax的编解码功能。虽然OpenMax也可以生成输入、输出、文件解析-构建等组件，但是在各个系统（不仅是Android）中使用的最多的还是编解码组件。<strong>媒体的输入、输出环节和系统的关系很大，引入OpenMax标准比较麻烦；文件解析-构建环节一般不需要使用硬件加速</strong>。编解码组件也是最能体现硬件加速的环节，因此最常使用。</p>
<h1 id="初窥适配层接口"><a href="#初窥适配层接口" class="headerlink" title="初窥适配层接口"></a>初窥适配层接口</h1><p>&#160; &#160; &#160; &#160;在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节：</p>
<ul>
<li>编解码驱动程序：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。</li>
<li>OpenMax IL层：根据OpenMax IL层的标准头文件实现不同功能的组件。</li>
</ul>
<p>&#160; &#160; &#160; &#160;<strong>Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配）</strong>，它作为Android本地层的接口，可以被Android的多媒体引擎调用。<a href="http://windrunnerlihuan.com/2016/12/12/Android多媒体开发-四-AwesomePlayer数据源处理/">上一篇文章</a>末尾，初始化解码器核心调用的两个方法就是适配层的接口。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%94%29----OpenMax%E7%AE%80%E4%BB%8B/openmaxsult.jpg" alt="适配层"></p>
<ul>
<li>1.上面已经说过了，android系统中只用openmax来做Codec，所以android向上抽象了一层OMXCodec，提供给上层播放器用。播放器中音视频解码器mVideosource、mAudiosource都是OMXCodec的实例。</li>
<li>2.OMXCodec通过IOMX 依赖binder机制 获得 OMX服务，OMX服务 才是openmax 在android中 实现。</li>
<li>3.OMX把软编解码和硬件编解码统一看作插件的形式管理起来。</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;本届基本上是对OpenMax的介绍，科普一下知识。下一节我们承接上一节末尾，详细分析适配层代码的调用流程。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%94%29----OpenMax%E7%AE%80%E4%BB%8B/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(四)----AwesomePlayer数据源处理]]></title>
      <url>http://windrunnerlihuan.com/2016/12/12/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%9B%9B-AwesomePlayer%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;我们追着setDataSource都能挖出这么多内容，这次我们分析AwesomePlayer的setDataSource流程。<br><a id="more"></a></p>
<h1 id="设置数据源"><a href="#设置数据源" class="headerlink" title="设置数据源"></a>设置数据源</h1><p>&#160; &#160; &#160; &#160;通过前几篇的了解，我们知道StageFright框架在整个playback的位置：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%9B%9B%29----AwesomePlayer%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%84%E7%90%86/stagefrightrole.jpg" alt="StageFright角色"></p>
<p>&#160; &#160; &#160; &#160;前一个章节我们了解了播放器的大概流程。如果要分析数据源设置，就要在前一章节的图上稍作改动。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%9B%9B%29----AwesomePlayer%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%84%E7%90%86/setdatasource.jpg" alt="数据源设置改动"></p>
<p>&#160; &#160; &#160; &#160;通过setDataSource 指定播放器的数据源。可以是URI或者fd.可以是http:// 、rtsp://、本地地址或者本地文件描述符fd。其最终调用是将上层传递来的参数转化为<strong>DataSource</strong>，为下一步的demux提供数据支持。</p>
<p>&#160; &#160; &#160; &#160;继续跟进AwesomePlayer的setDataSource，我们依然选取Fd类型，方便分析。位于framework/av/media/libstagefright/AwesomePlayer.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::setDataSource(</span><br><span class="line">        <span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    reset_l();</span><br><span class="line">    <span class="comment">//创建了一个FileSource的类对象，主要提供一些文件操作的方法</span></span><br><span class="line">    sp&lt;DataSource&gt; dataSource = <span class="keyword">new</span> FileSource(fd, offset, length);</span><br><span class="line">    <span class="comment">//检查文件是否ok</span></span><br><span class="line">    <span class="keyword">status_t</span> err = dataSource-&gt;initCheck();</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋给全局变量</span></span><br><span class="line">    mFileSource = dataSource;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">        mStats.mFd = fd;</span><br><span class="line">        mStats.mURI = String8();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后会调用setDataSource_l(dataSource)方法</span></span><br><span class="line">    <span class="keyword">return</span> setDataSource_l(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里主要讲外部传入的fd封装了一个FileSource的对象，FileSource.cpp主要实现了一些对文件的操作方法，位于framework/av/media/libstagefright/FileSource.cpp，有兴趣的可以看看。我们继续查看setDataSource_l(dataSource)方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::setDataSource_l(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DataSource&gt; &amp;dataSource) &#123;</span><br><span class="line">    <span class="comment">//这里根据文件类型创建不同的MediaExtractor对象</span></span><br><span class="line">    sp&lt;MediaExtractor&gt; extractor = MediaExtractor::Create(dataSource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extractor == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否是DRM加密文件</span></span><br><span class="line">    <span class="keyword">if</span> (extractor-&gt;getDrmFlag()) &#123;</span><br><span class="line">        checkDrmStatus(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后会调用到这里</span></span><br><span class="line">    <span class="keyword">return</span> setDataSource_l(extractor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;方法中又根据文件类型创建不同的MediaExtractor对象，我们看看它是怎么对文件类型进行分类的，位于framework/av/media/libstagefright/MediaExtractor.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="comment">//这个Create方法第二个参数mime是缺省参数，缺省为NULL</span></span><br><span class="line">sp&lt;MediaExtractor&gt; MediaExtractor::Create(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> <span class="keyword">char</span> *mime) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; meta;</span><br><span class="line"></span><br><span class="line">    String8 tmp;</span><br><span class="line">    <span class="keyword">if</span> (mime == <span class="literal">NULL</span>) &#123;<span class="comment">//如果外部没有传入文件的mime类型(缺省为NULL)</span></span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        <span class="comment">//从FileSource中读取文件的mime类型</span></span><br><span class="line">        <span class="keyword">if</span> (!source-&gt;sniff(&amp;tmp, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            ALOGV(<span class="string">"FAILED to autodetect media content."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将读取到的mime复制给局部变量</span></span><br><span class="line">        mime = tmp.<span class="built_in">string</span>();</span><br><span class="line">        ALOGV(<span class="string">"Autodetected media content as '%s' with confidence %.2f"</span>,</span><br><span class="line">             mime, confidence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否为DRM加密文件</span></span><br><span class="line">    <span class="keyword">bool</span> isDrm = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// DRM MIME type syntax is "drm+type+original" where</span></span><br><span class="line">    <span class="comment">// type is "es_based" or "container_based" and</span></span><br><span class="line">    <span class="comment">// original is the content's cleartext MIME type</span></span><br><span class="line">    <span class="comment">//如果是DRM加密文件，则mime字符串有些不同，这里检查是否为"drm+type+original"这种格式</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(mime, <span class="string">"drm+"</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *originalMime = <span class="built_in">strchr</span>(mime+<span class="number">4</span>, <span class="string">'+'</span>);</span><br><span class="line">        <span class="keyword">if</span> (originalMime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// second + not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++originalMime;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(mime, <span class="string">"drm+es_based+"</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">            <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DRMExtractor(source, originalMime);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(mime, <span class="string">"drm+container_based+"</span>, <span class="number">20</span>)) &#123;</span><br><span class="line">            mime = originalMime;</span><br><span class="line">            isDrm = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面逻辑就是根据mime对文件类型的判断了，比如audio/wav wav,video/x-msvideo avi,然后选择创建哪一种Extractor数据解析器</span></span><br><span class="line">    MediaExtractor *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)</span><br><span class="line">            || !strcasecmp(mime, <span class="string">"audio/mp4"</span>)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> MPEG4Extractor(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> MP3Extractor(source, meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)</span><br><span class="line">            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> AMRExtractor(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> FLACExtractor(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> WAVExtractor(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> OggExtractor(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> MatroskaExtractor(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> MPEG2TSExtractor(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">        <span class="comment">// Return now.  WVExtractor should not have the DrmFlag set in the block below.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WVMExtractor(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> AACExtractor(source, meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> MPEG2PSExtractor(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果文件经过DRM处理，则设置一下标签</span></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (isDrm) &#123;</span><br><span class="line">           ret-&gt;setDrmFlag(<span class="literal">true</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ret-&gt;setDrmFlag(<span class="literal">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面逻辑只要先获取文件的mime，然后根绝mime的类型去创造不同的文件解析器Extractor。MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型，这个应该都很熟悉了吧。列一些常见的比如：(类型/子类型     扩展名)</p>
<ul>
<li>image/jpeg        jpg</li>
<li>application/msword        doc</li>
<li>audio/mpeg        mp3</li>
<li>application/octet-stream        flv //特殊处理</li>
<li>video/x-ms-wmv        wmv</li>
<li>video/mp4        mp4 //特殊处理</li>
</ul>
<p>&#160; &#160; &#160; &#160;<strong>(如果不知道MIME类型 可以写通用的: application/octet-stream；还有一些规律是平台工具直接打开类型的，比如文本：text/扩展名，音频：audio/扩展名，视频：video/扩展名)</strong><br>&#160; &#160; &#160; &#160;常见的mime可以上<strong>w3school</strong>查询，可以点<a href="http://www.w3school.com.cn/media/media_mimeref.asp" target="_blank" rel="external">这里</a>。</p>
<p>&#160; &#160; &#160; &#160;创建好了数据解析器，比如MPEG4Extractor，位于framework/av/media/libstagefright/MPEG4Extractor.cpp。<br>&#160; &#160; &#160; &#160;然后我们继续往下看，进入setDataSource_l(extractor)方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::setDataSource_l(<span class="keyword">const</span> sp&lt;MediaExtractor&gt; &amp;extractor) &#123;</span><br><span class="line">    <span class="comment">// Attempt to approximate overall stream bitrate by summing all</span></span><br><span class="line">    <span class="comment">// tracks' individual bitrates, if not all of them advertise bitrate,</span></span><br><span class="line">    <span class="comment">// we have to fail.</span></span><br><span class="line">    <span class="comment">//比特率为每一路音频/视频/字幕流各自比特率的累加，如果又哪一路数据流没有拿到它单个的比特率，则数据解析失败</span></span><br><span class="line">    <span class="keyword">int64_t</span> totalBitRate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mExtractor = extractor;</span><br><span class="line">    <span class="comment">//遍历每一路数据流</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; extractor-&gt;countTracks(); ++i) &#123;</span><br><span class="line">        <span class="comment">//读取数据流的元数据，比如MPEG4Extractor中的获取方法，对文件头部信息的读取(也有一些类型文件元数据在尾部)</span></span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line">        <span class="comment">//单独数据流的比特率</span></span><br><span class="line">        <span class="keyword">int32_t</span> bitrate;</span><br><span class="line">        <span class="keyword">if</span> (!meta-&gt;findInt32(kKeyBitRate, &amp;bitrate)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">            CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">            ALOGV(<span class="string">"track of type '%s' does not publish bitrate"</span>, mime);</span><br><span class="line"></span><br><span class="line">            totalBitRate = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将单个数据流比特率累加，比特率越大，码率越高，片子质量越清晰越好</span></span><br><span class="line">        totalBitRate += bitrate;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;MetaData&gt; fileMeta = mExtractor-&gt;getMetaData();</span><br><span class="line">    <span class="keyword">if</span> (fileMeta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> duration;</span><br><span class="line">        <span class="keyword">if</span> (fileMeta-&gt;findInt64(kKeyDuration, &amp;duration)) &#123;</span><br><span class="line">            mDurationUs = duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBitrate = totalBitRate;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"mBitrate = %lld bits/sec"</span>, mBitrate);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">        mStats.mBitrate = mBitrate;</span><br><span class="line">        mStats.mTracks.clear();</span><br><span class="line">        mStats.mAudioTrackIndex = <span class="number">-1</span>;</span><br><span class="line">        mStats.mVideoTrackIndex = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否有音频流</span></span><br><span class="line">    <span class="keyword">bool</span> haveAudio = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//是否有视频流</span></span><br><span class="line">    <span class="keyword">bool</span> haveVideo = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//开始遍历文件的每一路数据流</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; extractor-&gt;countTracks(); ++i) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *_mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;_mime));</span><br><span class="line"></span><br><span class="line">        String8 mime = String8(_mime);</span><br><span class="line">        <span class="comment">//根据每一路数据流的mime判断是音频还是视频，然后做轨道分离</span></span><br><span class="line">        <span class="keyword">if</span> (!haveVideo &amp;&amp; !strncasecmp(mime.<span class="built_in">string</span>(), <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;<span class="comment">//是否是视频流</span></span><br><span class="line">            <span class="comment">//将视频流分离，生成mVideoTrack这个MediaSource，比如MPEG4Source：MediaSource</span></span><br><span class="line">            setVideoSource(extractor-&gt;getTrack(i));</span><br><span class="line">            <span class="comment">//有视频流标签置为true</span></span><br><span class="line">            haveVideo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the presentation/display size</span></span><br><span class="line">            <span class="comment">//显示宽高</span></span><br><span class="line">            <span class="keyword">int32_t</span> displayWidth, displayHeight;</span><br><span class="line">            <span class="keyword">bool</span> success = meta-&gt;findInt32(kKeyDisplayWidth, &amp;displayWidth);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success = meta-&gt;findInt32(kKeyDisplayHeight, &amp;displayHeight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                mDisplayWidth = displayWidth;</span><br><span class="line">                mDisplayHeight = displayHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">                mStats.mVideoTrackIndex = mStats.mTracks.size();</span><br><span class="line">                mStats.mTracks.push();</span><br><span class="line">                TrackStat *stat =</span><br><span class="line">                    &amp;mStats.mTracks.editItemAt(mStats.mVideoTrackIndex);</span><br><span class="line">                stat-&gt;mMIME = mime.<span class="built_in">string</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!haveAudio &amp;&amp; !strncasecmp(mime.<span class="built_in">string</span>(), <span class="string">"audio/"</span>, <span class="number">6</span>)) &#123;<span class="comment">//音频流分离</span></span><br><span class="line">            <span class="comment">//将视频流分离，生成mAudioTrack</span></span><br><span class="line">            setAudioSource(extractor-&gt;getTrack(i));</span><br><span class="line">            <span class="comment">//重置有音频流标签</span></span><br><span class="line">            haveAudio = <span class="literal">true</span>;</span><br><span class="line">            mActiveAudioTrackIndex = i;</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">                mStats.mAudioTrackIndex = mStats.mTracks.size();</span><br><span class="line">                mStats.mTracks.push();</span><br><span class="line">                TrackStat *stat =</span><br><span class="line">                    &amp;mStats.mTracks.editItemAt(mStats.mAudioTrackIndex);</span><br><span class="line">                stat-&gt;mMIME = mime.<span class="built_in">string</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对ogg类型音频的额外处理</span></span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(mime.<span class="built_in">string</span>(), MEDIA_MIMETYPE_AUDIO_VORBIS)) &#123;</span><br><span class="line">                <span class="comment">// Only do this for vorbis audio, none of the other audio</span></span><br><span class="line">                <span class="comment">// formats even support this ringtone specific hack and</span></span><br><span class="line">                <span class="comment">// retrieving the metadata on some extractors may turn out</span></span><br><span class="line">                <span class="comment">// to be very expensive.</span></span><br><span class="line">                sp&lt;MetaData&gt; fileMeta = extractor-&gt;getMetaData();</span><br><span class="line">                <span class="keyword">int32_t</span> loop;</span><br><span class="line">                <span class="keyword">if</span> (fileMeta != <span class="literal">NULL</span></span><br><span class="line">                        &amp;&amp; fileMeta-&gt;findInt32(kKeyAutoLoop, &amp;loop) &amp;&amp; loop != <span class="number">0</span>) &#123;</span><br><span class="line">                    modifyFlags(AUTO_LOOPING, SET);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime.<span class="built_in">string</span>(), MEDIA_MIMETYPE_TEXT_3GPP)) &#123;<span class="comment">//分离字幕</span></span><br><span class="line">            <span class="comment">//对字幕流分离</span></span><br><span class="line">            addTextSource_l(i, extractor-&gt;getTrack(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果既没有视频也没有音频，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (!haveAudio &amp;&amp; !haveVideo) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mWVMExtractor != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mWVMExtractor-&gt;getError();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mExtractorFlags = extractor-&gt;flags();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述方法比较长，总结如下：</p>
<ul>
<li>根据MediaExtractor，读取数据源文件的元数据信息，将每一路数据流的比特率进行累加；</li>
<li>分离数据流，音频/视频/字幕分离：设置视频源mVideoTrack ；设置音频源mAudioTrack；分离字幕。mVideoTrack和mAudioTrack的做为创建的AwesomePlayer的成员函数，举个例子，比如其类型为MPEG4Source，继承了MediaSource。</li>
</ul>
<p>&#160; &#160; &#160; &#160;注释已经写得比较清楚了。到这里文件类型的setDataSource就分析完了，这个自己挖的大坑也算填的差不多了。</p>
<h1 id="网络类型数据源"><a href="#网络类型数据源" class="headerlink" title="网络类型数据源"></a>网络类型数据源</h1><p>&#160; &#160; &#160; &#160;如果我们给MediaPlayer里面setDataSource设置的路径是网络路径，比如 <a href="http://xxxxxx......xx.mp4" target="_blank" rel="external">http://xxxxxx......xx.mp4</a> ,那么在setDataSource时候是不能直接获取数据流的，要到prepareAsync才能得到数据信息。所以我们继续顺着思路，看看网络类型数据信息怎么获取。</p>
<p>&#160; &#160; &#160; &#160;其实这里涉及另一个知识点：MediaHTTPService ，这里给出模块图，具体细节有兴趣的同学可以自己研究，限于篇幅就不详细赘述。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%9B%9B%29----AwesomePlayer%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%84%E7%90%86/netmodule.jpg" alt="网络模型"></p>
<p><strong>java：</strong><br>\frameworks2\media\java\android\media<br>IMediaHTTPService.aidl<br>IMediaHTTPConnection.aidl</p>
<p><strong>jni：</strong><br>android_media_MediaHTTPConnection.cpp (.\framework\media\jni)<br>android_media_MediaHTTPConnection.h (.\framework\media\jni)</p>
<p><strong>native：</strong><br>Lib: libstagefright_http_support.so<br>frameworks2\av\media\libstagefright\http<br>IMediaHTTPConnection.aidl (.\framework\media\java\android\media)<br>IMediaHTTPService.aidl (.\framework\media\java\android\media)<br>MediaHTTPConnection.java (.\framework\media\java\android\media)<br>MediaHTTPService.java (.\framework\media\java\android\media)<br>IMediaHTTPConnection.h (.\framework\av\include\media)<br>IMediaHTTPService.h (.\framework\av\include\media)<br>IMediaHTTPConnection.aidl (.\framework\av\media\libstagefright)<br>IMediaHTTPService.aidl (.\framework\av\media\libstagefright)<br>MediaHTTP.cpp (.\framework\av\media\libstagefright\http)<br>MediaHTTP.h (.\framework\av\include\media\stagefright)<br>IMediaHTTPConnection.cpp (.\framework\av\media\libmedia)<br>IMediaHTTPService.cpp (.\framework\av\media\libmedia)</p>
<p>&#160; &#160; &#160; &#160;依然先看AwesomePlayer的另一个重载方法setDataSource：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::setDataSource(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *uri,</span><br><span class="line">        <span class="keyword">const</span> KeyedVector&lt;String8, String8&gt; *headers) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">//会调用下一个方法</span></span><br><span class="line">    <span class="keyword">return</span> setDataSource_l(httpService, uri, headers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AwesomePlayer::setDataSource_l(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *uri,</span><br><span class="line">        <span class="keyword">const</span> KeyedVector&lt;String8, String8&gt; *headers) &#123;</span><br><span class="line">    reset_l();</span><br><span class="line">    <span class="comment">//仅仅将httpservice保存到全局变量而已</span></span><br><span class="line">    mHTTPService = httpService;</span><br><span class="line">    <span class="comment">//保存了上层传入的uri</span></span><br><span class="line">    mUri = uri;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (headers) &#123;</span><br><span class="line">        mUriHeaders = *headers;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> index = mUriHeaders.indexOfKey(String8(<span class="string">"x-hide-urls-from-log"</span>));</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Browser is in "incognito" mode, suppress logging URLs.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// This isn't something that should be passed to the server.</span></span><br><span class="line">            mUriHeaders.removeItemsAt(index);</span><br><span class="line"></span><br><span class="line">            modifyFlags(INCOGNITO, SET);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"setDataSource_l(%s)"</span>, uriDebugString(mUri, mFlags &amp; INCOGNITO).c_str());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The actual work will be done during preparation in the call to</span></span><br><span class="line">    <span class="comment">// ::finishSetDataSource_l to avoid blocking the calling thread in</span></span><br><span class="line">    <span class="comment">// setDataSource for any significant time.</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">        mStats.mFd = <span class="number">-1</span>;</span><br><span class="line">        mStats.mURI = mUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面代码仅仅保存了httpService变量，这个用于请求网络；还有上层传入的uri。那么获取数据应该在prepareAsync中。我们知道prepare和prepareAsync不同在于一个是同步操作，一个是异步回调。那么我们先看看prepare：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::prepare() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">//会调用prepare_l方法</span></span><br><span class="line">    <span class="keyword">return</span> prepare_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AwesomePlayer::prepare_l() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARED) &#123;<span class="comment">//已经prepare完成了，则返回</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARING) &#123;<span class="comment">//如果正在preparing，则返回错误</span></span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsAsyncPrepare = <span class="literal">false</span>;<span class="comment">//将异步标签置为false</span></span><br><span class="line">    <span class="comment">//最终还是会调用prepareAsync_l，只不过在同一线程</span></span><br><span class="line">    <span class="keyword">status_t</span> err = prepareAsync_l();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因此prepare会等待在同步线程</span></span><br><span class="line">    <span class="keyword">while</span> (mFlags &amp; PREPARING) &#123;</span><br><span class="line">        mPreparedCondition.wait(mLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mPrepareResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;同步prepare很简单，执行方法最终还是会调用prepareAsync_l方法，只不过在同一线程等待。<br>&#160; &#160; &#160; &#160;那么我们看看异步prepareAsync：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::prepareAsync() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">//如果正在preparing，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARING) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;  <span class="comment">// async prepare already pending</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsAsyncPrepare = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//调用prepareAsync_l方法</span></span><br><span class="line">    <span class="keyword">return</span> prepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AwesomePlayer::prepareAsync_l() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARING) &#123;<span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;  <span class="comment">// async prepare already pending</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这一步就是我们上一节分析的事件调度线程启动，可以参考上一节</span></span><br><span class="line">    <span class="keyword">if</span> (!mQueueStarted) &#123;</span><br><span class="line">        mQueue.start();</span><br><span class="line">        mQueueStarted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改标志位，加上PREPARING标志</span></span><br><span class="line">    modifyFlags(PREPARING, SET);</span><br><span class="line">    <span class="comment">//将封装onPrepareAsyncEvent方法的时间加入事件队列中</span></span><br><span class="line">    mAsyncPrepareEvent = <span class="keyword">new</span> AwesomeEvent(</span><br><span class="line">            <span class="keyword">this</span>, &amp;AwesomePlayer::onPrepareAsyncEvent);</span><br><span class="line"></span><br><span class="line">    mQueue.postEvent(mAsyncPrepareEvent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里我们可以看到它启动了事件调度队列，这个我们上一节分析过了，如果不太明白可以回去看看：<a href="http://windrunnerlihuan.com/2016/12/21/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%89-%E4%BB%8EStageFright%E5%88%B0AwesomePlayer/#">Android多媒体开发(三)—-从StageFright到AwesomePlayer</a> 。<br>&#160; &#160; &#160; &#160;然后给事件队列加入封装onPrepareAsyncEvent方法的事件，我们接着看这个方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::onPrepareAsyncEvent() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">//调用beginPrepareAsync_l</span></span><br><span class="line">    beginPrepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AwesomePlayer::beginPrepareAsync_l() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARE_CANCELLED) &#123;</span><br><span class="line">        ALOGI(<span class="string">"prepare was cancelled before doing anything"</span>);</span><br><span class="line">        abortPrepare(UNKNOWN_ERROR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主要在这一步，设置网络数据源</span></span><br><span class="line">    <span class="keyword">if</span> (mUri.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = finishSetDataSource_l();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abortPrepare(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化视频解码器</span></span><br><span class="line">    <span class="keyword">if</span> (mVideoTrack != <span class="literal">NULL</span> &amp;&amp; mVideoSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = initVideoDecoder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abortPrepare(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化音频解码器</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioTrack != <span class="literal">NULL</span> &amp;&amp; mAudioSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = initAudioDecoder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abortPrepare(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifyFlags(PREPARING_CONNECTED, SET);</span><br><span class="line">    <span class="comment">//是否是http的网络数据流</span></span><br><span class="line">    <span class="keyword">if</span> (isStreamingHTTP()) &#123;</span><br><span class="line">        postBufferingEvent_l();<span class="comment">//开始onBufferingUpdate回调，开始缓冲视频</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishAsyncPrepare_l();<span class="comment">//完成prepare</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> AwesomePlayer::isStreamingHTTP() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mCachedSource != <span class="literal">NULL</span> || mWVMExtractor != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们这一步的重点是在设置网络数据源，调用finishSetDataSource_l方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::finishSetDataSource_l() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    sp&lt;DataSource&gt; dataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> isWidevineStreaming = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//Widevine是google在ICS版本上新推出的一种DRM数字版权管理功能，有这个功能的话，就能从google指定的服务器上，下载经过google加密的版权文件，例如视频、应用等等。</span></span><br><span class="line">    <span class="keyword">if</span> (!strncasecmp(<span class="string">"widevine://"</span>, mUri.<span class="built_in">string</span>(), <span class="number">11</span>)) &#123;</span><br><span class="line">        isWidevineStreaming = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果是google自家的私货，就要在uri加上http://的前缀</span></span><br><span class="line">        String8 newURI = String8(<span class="string">"http://"</span>);</span><br><span class="line">        newURI.append(mUri.<span class="built_in">string</span>() + <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        mUri = newURI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mime</span></span><br><span class="line">    AString sniffedMIME;</span><br><span class="line">    <span class="comment">//如果是http、https的网络数据流，或者是谷歌自家的私货widevine</span></span><br><span class="line">    <span class="keyword">if</span> (!strncasecmp(<span class="string">"http://"</span>, mUri.<span class="built_in">string</span>(), <span class="number">7</span>)</span><br><span class="line">            || !strncasecmp(<span class="string">"https://"</span>, mUri.<span class="built_in">string</span>(), <span class="number">8</span>)</span><br><span class="line">            || isWidevineStreaming) &#123;</span><br><span class="line">        <span class="comment">//这个就是我们在setDataSource里面取到的httpservice，用于发送http请求    </span></span><br><span class="line">        <span class="keyword">if</span> (mHTTPService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Attempt to play media from http URI without HTTP service."</span>);</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立http链接</span></span><br><span class="line">        sp&lt;IMediaHTTPConnection&gt; conn = mHTTPService-&gt;makeHTTPConnection();</span><br><span class="line">        mConnectingDataSource = <span class="keyword">new</span> MediaHTTP(conn);</span><br><span class="line"></span><br><span class="line">        String8 cacheConfig;</span><br><span class="line">        <span class="keyword">bool</span> disconnectAtHighwatermark;</span><br><span class="line">        NuCachedSource2::RemoveCacheSpecificHeaders(</span><br><span class="line">                &amp;mUriHeaders, &amp;cacheConfig, &amp;disconnectAtHighwatermark);</span><br><span class="line"></span><br><span class="line">        mLock.unlock();</span><br><span class="line">        <span class="comment">//开始链接网络</span></span><br><span class="line">        <span class="keyword">status_t</span> err = mConnectingDataSource-&gt;connect(mUri, &amp;mUriHeaders);</span><br><span class="line">        <span class="comment">// force connection at this point, to avoid a race condition between getMIMEType and the</span></span><br><span class="line">        <span class="comment">// caching datasource constructed below, which could result in multiple requests to the</span></span><br><span class="line">        <span class="comment">// server, and/or failed connections.</span></span><br><span class="line">        String8 contentType = mConnectingDataSource-&gt;getMIMEType();</span><br><span class="line">        mLock.lock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            mConnectingDataSource.clear();</span><br><span class="line"></span><br><span class="line">            ALOGI(<span class="string">"mConnectingDataSource-&gt;connect() returned %d"</span>, err);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isWidevineStreaming) &#123;<span class="comment">//非google的私货，正常的http网络请求读取数据</span></span><br><span class="line">            <span class="comment">// The widevine extractor does its own caching.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            mCachedSource = <span class="keyword">new</span> NuCachedSource2(</span><br><span class="line">                    <span class="keyword">new</span> ThrottledSource(</span><br><span class="line">                        mConnectingDataSource, <span class="number">50</span> * <span class="number">1024</span> <span class="comment">/* bytes/sec */</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>       </span></span><br><span class="line">            <span class="comment">// NuCachedSource2，带缓存的DataSource，不包含媒体信息，只管理缓存以及调用底层的DataSource读取和缓存数据。可以获取缓存的信息以及操作缓存。</span></span><br><span class="line">            mCachedSource = <span class="keyword">new</span> NuCachedSource2(</span><br><span class="line">                    mConnectingDataSource,</span><br><span class="line">                    cacheConfig.isEmpty() ? <span class="literal">NULL</span> : cacheConfig.<span class="built_in">string</span>(),</span><br><span class="line">                    disconnectAtHighwatermark);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">//获取缓存数据源</span></span><br><span class="line">            dataSource = mCachedSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//是google的私货</span></span><br><span class="line">            dataSource = mConnectingDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mConnectingDataSource.clear();</span><br><span class="line">        <span class="comment">//如果不是纯音频的文件类型</span></span><br><span class="line">        <span class="keyword">if</span> (strncasecmp(contentType.<span class="built_in">string</span>(), <span class="string">"audio/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="comment">// We're not doing this for streams that appear to be audio-only</span></span><br><span class="line">            <span class="comment">// streams to ensure that even low bandwidth streams start</span></span><br><span class="line">            <span class="comment">// playing back fairly instantly.</span></span><br><span class="line">            </span><br><span class="line">                ...省略一些代码...</span><br><span class="line">                        <span class="keyword">if</span> (!dataSource-&gt;sniff(&amp;tmp, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">                            mLock.lock();</span><br><span class="line">                            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// We successfully identified the file's extractor to</span></span><br><span class="line">                        <span class="comment">// be, remember this mime type so we don't have to</span></span><br><span class="line">                        <span class="comment">// sniff it again when we call MediaExtractor::Create()</span></span><br><span class="line">                        <span class="comment">// below.</span></span><br><span class="line">                        <span class="comment">//获取mime</span></span><br><span class="line">                        sniffedMIME = tmp.<span class="built_in">string</span>();</span><br><span class="line">                        </span><br><span class="line">                ...省略一些代码...</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是不http、https的网络数据流、谷歌自家的私货widevine</span></span><br><span class="line">        <span class="comment">//请求网络数据</span></span><br><span class="line">        dataSource = DataSource::CreateFromURI(</span><br><span class="line">                mHTTPService, mUri.<span class="built_in">string</span>(), &amp;mUriHeaders);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sp&lt;MediaExtractor&gt; extractor;</span><br><span class="line">    <span class="comment">//是google的私货</span></span><br><span class="line">    <span class="keyword">if</span> (isWidevineStreaming) &#123;</span><br><span class="line">        String8 mimeType;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        sp&lt;AMessage&gt; dummy;</span><br><span class="line">        <span class="keyword">bool</span> success;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SniffWVM is potentially blocking since it may require network access.</span></span><br><span class="line">        <span class="comment">// Do not call it with mLock held.</span></span><br><span class="line">        mLock.unlock();</span><br><span class="line">        <span class="comment">//嗅探wvm类型资源</span></span><br><span class="line">        success = SniffWVM(dataSource, &amp;mimeType, &amp;confidence, &amp;dummy);</span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success</span><br><span class="line">                || strcasecmp(</span><br><span class="line">                    mimeType.<span class="built_in">string</span>(), MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_UNSUPPORTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建wvm的数据解析器</span></span><br><span class="line">        mWVMExtractor = <span class="keyword">new</span> WVMExtractor(dataSource);</span><br><span class="line">        mWVMExtractor-&gt;setAdaptiveStreamingMode(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (mUIDValid)</span><br><span class="line">            mWVMExtractor-&gt;setUID(mUID);</span><br><span class="line">        extractor = mWVMExtractor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是google的私货，则根据MIME创建相应的数据解析器</span></span><br><span class="line">        extractor = MediaExtractor::Create(</span><br><span class="line">                dataSource, sniffedMIME.empty() ? <span class="literal">NULL</span> : sniffedMIME.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extractor == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否有DRM处理</span></span><br><span class="line">    <span class="keyword">if</span> (extractor-&gt;getDrmFlag()) &#123;</span><br><span class="line">        checkDrmStatus(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setDataSource_l(extractor)我们本节分析，主要是分流音频/视频/字幕</span></span><br><span class="line">    <span class="keyword">status_t</span> err = setDataSource_l(extractor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        mWVMExtractor.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述就是网络获取数据源的过程：1）setDataSource获取一个网络连接服务；2）prepareAsync中请求网络，读取缓存，然后得到文件类型mime；3）根据mime创建MediaExtractor，然后分离音频/视频/字幕流数据。</p>
<h1 id="初窥解码器"><a href="#初窥解码器" class="headerlink" title="初窥解码器"></a>初窥解码器</h1><p>&#160; &#160; &#160; &#160;上一步我们分析完了setDataSource，并且进入了prepare环节。走完了finishSetDataSource_l，但是beginPrepareAsync_l方法还没有走完。接下来应该是初始化音/视频解码器了。</p>
<h2 id="视频解码器入口"><a href="#视频解码器入口" class="headerlink" title="视频解码器入口"></a>视频解码器入口</h2><p>&#160; &#160; &#160; &#160;进入beginPrepareAsync_l方法，执行到initVideoDecoder方法位置，我们继续查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::initVideoDecoder(<span class="keyword">uint32_t</span> flags) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Either the application or the DRM system can independently say</span></span><br><span class="line">    <span class="comment">// that there must be a hardware-protected path to an external video sink.</span></span><br><span class="line">    <span class="comment">// For now we always require a hardware-protected path to external video sink</span></span><br><span class="line">    <span class="comment">// if content is DRMed, but eventually this could be optional per DRM agent.</span></span><br><span class="line">    <span class="comment">// When the application wants protection, then</span></span><br><span class="line">    <span class="comment">//   (USE_SURFACE_ALLOC &amp;&amp; (mSurface != 0) &amp;&amp;</span></span><br><span class="line">    <span class="comment">//   (mSurface-&gt;getFlags() &amp; ISurfaceComposer::eProtectedByApp))</span></span><br><span class="line">    <span class="comment">// will be true, but that part is already handled by SurfaceFlinger.</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mDecryptHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        flags |= OMXCodec::kEnableGrallocUsageProtected;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    ALOGV(<span class="string">"initVideoDecoder flags=0x%x"</span>, flags);</span><br><span class="line">    <span class="comment">//和视频解码关，视频解码器</span></span><br><span class="line">    mVideoSource = OMXCodec::Create(</span><br><span class="line">            mClient.interface(), mVideoTrack-&gt;getFormat(),</span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// createEncoder</span></span><br><span class="line">            mVideoTrack,</span><br><span class="line">            <span class="literal">NULL</span>, flags, USE_SURFACE_ALLOC ? mNativeWindow : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">        <span class="comment">//获取视频轨道格式，然后读取时长</span></span><br><span class="line">        <span class="keyword">if</span> (mVideoTrack-&gt;getFormat()-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mMiscStateLock)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (mDurationUs &lt; <span class="number">0</span> || durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取原始视频数据</span></span><br><span class="line">        <span class="keyword">status_t</span> err = mVideoSource-&gt;start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"failed to start video source"</span>);</span><br><span class="line">            mVideoSource.clear();</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一些检查逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (mVideoSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName;</span><br><span class="line">        CHECK(mVideoSource-&gt;getFormat()</span><br><span class="line">                -&gt;findCString(kKeyDecoderComponent, &amp;componentName));</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">            TrackStat *stat = &amp;mStats.mTracks.editItemAt(mStats.mVideoTrackIndex);</span><br><span class="line"></span><br><span class="line">            stat-&gt;mDecoderName = componentName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *kPrefix = <span class="string">"OMX.Nvidia."</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *kSuffix = <span class="string">".decode"</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kSuffixLength = <span class="built_in">strlen</span>(kSuffix);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> componentNameLength = <span class="built_in">strlen</span>(componentName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(componentName, kPrefix, <span class="built_in">strlen</span>(kPrefix))</span><br><span class="line">                &amp;&amp; componentNameLength &gt;= kSuffixLength</span><br><span class="line">                &amp;&amp; !<span class="built_in">strcmp</span>(&amp;componentName[</span><br><span class="line">                    componentNameLength - kSuffixLength], kSuffix)) &#123;</span><br><span class="line">            modifyFlags(SLOW_DECODER_HACK, SET);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mVideoSource != <span class="literal">NULL</span> ? OK : UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;视频解码器的入口，核心是OMXCodec::Create()方法，创建解码器。这个我们下一节会自信分析，本节只是入口。</p>
<h2 id="音频解码器入口"><a href="#音频解码器入口" class="headerlink" title="音频解码器入口"></a>音频解码器入口</h2><p>&#160; &#160; &#160; &#160;然后我们看看音频解码器：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::initAudioDecoder() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">//获取音频轨道跟踪格式</span></span><br><span class="line">    sp&lt;MetaData&gt; meta = mAudioTrack-&gt;getFormat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">    <span class="comment">// Check whether there is a hardware codec for this stream</span></span><br><span class="line">    <span class="comment">// This doesn't guarantee that the hardware has a free stream</span></span><br><span class="line">    <span class="comment">// but it avoids us attempting to open (and re-open) an offload</span></span><br><span class="line">    <span class="comment">// stream to hardware that doesn't have the necessary codec</span></span><br><span class="line">    <span class="keyword">audio_stream_type_t</span> streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//得到音频流类型</span></span><br><span class="line">        streamType = mAudioSink-&gt;getAudioStreamType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffloadAudio = canOffloadStream(meta, (mVideoSource != <span class="literal">NULL</span>),</span><br><span class="line">                                     isStreamingHTTP(), streamType);</span><br><span class="line">    <span class="comment">//如果是原始数据不用解码</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) &#123;</span><br><span class="line">        ALOGV(<span class="string">"createAudioPlayer: bypass OMX (raw)"</span>);</span><br><span class="line">        mAudioSource = mAudioTrack;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If offloading we still create a OMX decoder as a fall-back</span></span><br><span class="line">        <span class="comment">// but we don't start it</span></span><br><span class="line">        <span class="comment">//创建音频解码器。和上面的视频解码器一样，只不过参数由mVideoTrack变为mAudioTrack</span></span><br><span class="line">        mOmxSource = OMXCodec::Create(</span><br><span class="line">                mClient.interface(), mAudioTrack-&gt;getFormat(),</span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// createEncoder</span></span><br><span class="line">                mAudioTrack);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            ALOGV(<span class="string">"createAudioPlayer: bypass OMX (offload)"</span>);</span><br><span class="line">            mAudioSource = mAudioTrack;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mAudioSource = mOmxSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">        <span class="keyword">if</span> (mAudioTrack-&gt;getFormat()-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mMiscStateLock)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (mDurationUs &lt; <span class="number">0</span> || durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取音频原始数据</span></span><br><span class="line">        <span class="keyword">status_t</span> err = mAudioSource-&gt;start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            mAudioSource.clear();</span><br><span class="line">            mOmxSource.clear();</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_QCELP)) &#123;</span><br><span class="line">        <span class="comment">// For legacy reasons we're simply going to ignore the absence</span></span><br><span class="line">        <span class="comment">// of an audio decoder for QCELP instead of aborting playback</span></span><br><span class="line">        <span class="comment">// altogether.</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">        TrackStat *stat = &amp;mStats.mTracks.editItemAt(mStats.mAudioTrackIndex);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *component;</span><br><span class="line">        <span class="keyword">if</span> (!mAudioSource-&gt;getFormat()</span><br><span class="line">                -&gt;findCString(kKeyDecoderComponent, &amp;component)) &#123;</span><br><span class="line">            component = <span class="string">"none"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stat-&gt;mDecoderName = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mAudioSource != <span class="literal">NULL</span> ? OK : UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;初始化音频解码和视频解码器代码部分大同小异，核心还是OMXCodec::Create()方法，只是参数不用。</p>
<p>&#160; &#160; &#160; &#160;总结一下上述流程：</p>
<ul>
<li>通过setDataSource 指定播放器的数据源。可以是URI或者fd.可以是http:// 、rtsp://、本地地址或者本地文件描述符fd。其最终调用是将上层传递来的参数转化为DataSource，为下一步的demux提供数据支持。</li>
<li>在真正Prepare功能函数onPrepareAsyncEvent()会调用finishSetDataSource_l。通过第一步产生的DataSource来生成extractor，因为封装的格式很多，所以需要通过DataSource的信息，去创建不同的extractor。</li>
<li>得到extractor之后，通过setVideoSource() setAudioSource()产生独立的mVideoTrack(视频)、mAudioTrack(音频)数据流，分别为音视频解码器提供有各自需要的数据流。</li>
<li>接下来就是initVideoDecoder() initAudioDecoder().依赖上面产生的mVideoTrack(视频)、mAudioTrack(音频)数据流。生成了mVideoSource和mAudioSource这两个音视频解码器。</li>
</ul>
<p>&#160; &#160; &#160; &#160;最后一步创建解码器都是调用同样的接口：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mVideoSource = OMXCodec::Create(  </span><br><span class="line">            mClient.interface(), mVideoTrack-&gt;getFormat(),  </span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// createEncoder  </span></span><br><span class="line">            mVideoTrack,  </span><br><span class="line">            <span class="literal">NULL</span>, flags, USE_SURFACE_ALLOC ? mNativeWindow : <span class="literal">NULL</span>);  </span><br><span class="line"> mAudioSource = OMXCodec::Create(  </span><br><span class="line">                mClient.interface(), mAudioTrack-&gt;getFormat(),  </span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// createEncoder  </span></span><br><span class="line">                mAudioTrack);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mVideoSource、mAudioSource组成了播放器模型中的decoder部分。</p>
<p>&#160; &#160; &#160; &#160;Android系统中的编解码器部分用的是openmax，以后会深入了解。openma x是一套标准接口，各家硬件厂商都可以遵循这个标准来做自己的实现，发挥自己芯片特性。然后提供给android系统来用。因为大部分的机顶盒芯片产品硬件的编解码是它的优势，可以把这种优势完全融入到android平台中。以后手机高清视频硬解码也会是个趋势。</p>
<p>&#160; &#160; &#160; &#160;解码完之后的数据就要输出了。AwesomePlayer分别用了mVideoRenderer做视频输出、mAudioPlayer做音频输出。他们分别调用android图像和音频的相关服务。mVideoRenderer和mAudioPlayer就组成了播放器中output的部分。这俩部分是android平台中十分重要的2块，以后会深入了解。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;综上AwesomePlayer的整体框架和流程就清晰了，其实也脱离不了DataSource、demux、decoder、output这4大部分。接下来会分别了解每个部分是怎么实现的。<br>&#160; &#160; &#160; &#160;下一节我们就从openmax开始。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%9B%9B%29----AwesomePlayer%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%84%E7%90%86/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(三)----从StageFright到AwesomePlayer]]></title>
      <url>http://windrunnerlihuan.com/2016/12/11/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%89-%E4%BB%8EStageFright%E5%88%B0AwesomePlayer/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;上一节我们分析到了MediaPlayer的C/S架构最下层的StagefrightPlayer，今天我们继续往下挖，看看这个东西到底是个什么鬼。<br><a id="more"></a></p>
<h1 id="皮包公司StagefrightPlayer"><a href="#皮包公司StagefrightPlayer" class="headerlink" title="皮包公司StagefrightPlayer"></a>皮包公司StagefrightPlayer</h1><p>&#160; &#160; &#160; &#160;上一节我们再次止步于C++层的setDateSource，但是我们初窥了StatefrightPlayer，简要了解android高版本对opencore的舍弃，和采用了Stagefright框架。所以我们来看看这个StagefrightPlayer是怎么实现的。位于framework/av/media/libmediaplayerservice/StagefrightPlayer.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">StagefrightPlayer::StagefrightPlayer()</span><br><span class="line">    : mPlayer(<span class="keyword">new</span> AwesomePlayer) &#123; <span class="comment">//StagefrightPlayer构造方法默认创建了AwesomePlayer代替他完成职能</span></span><br><span class="line">    ALOGV(<span class="string">"StagefrightPlayer"</span>);</span><br><span class="line"></span><br><span class="line">    mPlayer-&gt;setListener(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StagefrightPlayer::~StagefrightPlayer() &#123;</span><br><span class="line">    ALOGV(<span class="string">"~StagefrightPlayer"</span>);</span><br><span class="line">    reset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> mPlayer;</span><br><span class="line">    mPlayer = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning: The filedescriptor passed into this method will only be valid until</span></span><br><span class="line"><span class="comment">// the method returns, if you want to keep it, dup it!</span></span><br><span class="line"><span class="keyword">status_t</span> StagefrightPlayer::setDataSource(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length) &#123;</span><br><span class="line">    ALOGV(<span class="string">"setDataSource(%d, %lld, %lld)"</span>, fd, offset, length);</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;setDataSource(dup(fd), offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> StagefrightPlayer::setVideoSurfaceTexture(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    ALOGV(<span class="string">"setVideoSurfaceTexture"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;setSurfaceTexture(bufferProducer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> StagefrightPlayer::prepare() &#123;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;prepare();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...省略诸多AwesomePlayer代替他完成职能的方法</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们看到这个StagefrightPlayer其实是个皮包公司，对MediaPlayerInterface接口的实现方法都是由<strong>AwesomePlayer</strong>这个播放器来实现的。(听着名字都应该是装饰模式关系，StageFright叫舞台恐怖者，Awesome是令人畏惧者，一个前台耍花腔散播恐惧，一个后台实际操控恐怖主义)。<br>&#160; &#160; &#160; &#160;前面一篇中，分析到mediaplayerservice会调到Stagefright中，进行编码解码操作<br>在libsstagefright中,预设的多媒体解码是openCore，由于其过于庞大和复杂，需要成本较高，开始引进了另一个框架，也就是stagefright框架，以后默认情况Android选择stagefright，但是并没有完全抛弃opencore，做了一个OMX层，仅仅是对 opencore的omx-component部分做了引用。stagefright是和opencore是并列的。Stagefright在 Android中是以shared library的形式存在(libstagefright.so)，其中的module – AwesomePlayer可用来播放video/audio。 AwesomePlayer提供许多API，可以让上层的应用程序(Java/JNI)来调用。</p>
<h1 id="播放器基本模型"><a href="#播放器基本模型" class="headerlink" title="播放器基本模型"></a>播放器基本模型</h1><p>&#160; &#160; &#160; &#160;AwesomePlayer不管有多么神秘，说到底还是个播放器。在播放器的基本模型上，他与VCL、mplayer、ffmpeg等开源的结构是一致的。只是组织实现的方式不同。<br>&#160; &#160; &#160; &#160;深入了解AwesomePlayer 之前，把播放器的基本模型总结一下，然后按照模型的各个部分来深入研究AwesomePlayer 的实现方式。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%89%29----%E4%BB%8EStageFright%E5%88%B0AwesomePlayer/playermodule.jpg" alt="播放器模型"></p>
<p>&#160; &#160; &#160; &#160;播放器大致分为4大部分：source、demux、decoder、output。</p>
<ul>
<li><strong>source数据源</strong>：数据源，数据的来源不一定都是本地file，也有可能是网路上的各种协议例如：http、rtsp、HLS等。source的任务就是把数据源抽象出来，为下一个demux模块提供它需要的稳定的数据流。demux不用关信数据到底是从什么地方来的。</li>
<li><strong>demux解复用</strong>：视频文件一般情况下都是把音视频的ES流交织的通过某种规则放在一起。这种规则就是容器规则。现在有很多不同的容器格式。如ts、mp4、flv、mkv、avi、rmvb等等。demux的功能就是把音视频的ES流从容器中剥离出来，然后分别送到不同的解码器中。其实音频和视频本身就是2个独立的系统。容器把它们包在了一起。但是他们都是独立解码的，所以解码之前，需要把它分别 独立出来。demux就是干这活的，他为下一步decoder解码提供了数据流。</li>
<li><strong>decoder解码</strong>：解码器—-播放器的核心模块。分为音频和视频解码器。影像在录制后, 原始的音视频都是占用大量空间, 而且是冗余度较高的数据. 因此, 通常会在制作的时候就会进行某种压缩 ( 压缩技术就是将数据中的冗余信息去除数据之间的相关性 ). 这就是我们熟知的音视频编码格式, 包括MPEG1（VCD）\ MPEG2（DVD）\ MPEG4 \ H.264 等等. 音视频解码器的作用就是把这些压缩了的数据还原成原始的音视频数据. 当然, 编码解码过程基本上都是有损的 .解码器的作用就是把编码后的数据还原成原始数据。</li>
<li><strong>output输出</strong>：输出部分分为音频和视频输出。解码后的音频（pcm）和视频（yuv）的原始数据需要得到音视频的output模块的支持才能真正的让人的感官系统（眼和耳）辨识到。</li>
</ul>
<p>&#160; &#160; &#160; &#160;所以，播放器大致分成上述4部分。怎么抽象的实现这4大部分、以及找到一种合理的方式将这几部分组织并运动起来。是每个播放器不同的实现方式而已。接下来就围绕这4大部分做深入学习，看看AwesomePlayer 是怎么玩的吧。</p>
<h1 id="AwesomePlayer基础"><a href="#AwesomePlayer基础" class="headerlink" title="AwesomePlayer基础"></a>AwesomePlayer基础</h1><h2 id="AwesomePlayer事件调度器————TimedEventQueue-event"><a href="#AwesomePlayer事件调度器————TimedEventQueue-event" class="headerlink" title="AwesomePlayer事件调度器————TimedEventQueue-event"></a>AwesomePlayer事件调度器————TimedEventQueue-event</h2><p>&#160; &#160; &#160; &#160;在分析AwesomePlayer的主要流程前，我们先了解一下它的时间调度机制，为以后分析主流程打好基础。<br>&#160; &#160; &#160; &#160;视频处理过程中有很多都是十分耗时的，如果都放在一个大的线程空间中。用户体验的效果可想而知。所以通常都是做异步操作。</p>
<p>&#160; &#160; &#160; &#160;AwesomePlayer是通过event事件调度来实现这些功能之间的驱动和调用的，类似于上层的Handler-Looper。AwesomePlayer中的内部变量TimedEventQueue mQueue；位于framework/av/media/libstagefright/include/AwesomePlayer.h中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimedEventQueue mQueue;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个mQueue就是AwesomePlayer的事件队列，也是事件调度器。从他类型的名字上就能很清楚的看出他是以时间为基础事件队列。接下来看看它是怎么玩转的。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%89%29----%E4%BB%8EStageFright%E5%88%B0AwesomePlayer/timedeventqueue.jpg" alt="事件调度器"></p>
<p>&#160; &#160; &#160; &#160;1. 我们看看TimedEventQueue的内部结构，位于framework/av/media/libstagefright/include/TimedEventQueue.h中。TimedEventQueue内部有一个<strong>List&lt; QueueItem &gt;</strong>，每个<strong>QueueItem</strong>包含enent和触发事件时间，还有一个是否持有唤醒锁的标志位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">List&lt;QueueItem&gt; mQueue;<span class="comment">//触发事件队列</span></span><br><span class="line"><span class="keyword">pthread_t</span> mThread;<span class="comment">//独立调度线程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> event_id;<span class="comment">//这里是个typedef，下面Event结构体的事件id会用到</span></span><br><span class="line">event_id mEventID;</span><br><span class="line">    <span class="comment">//事件队列单项结构体</span></span><br><span class="line">    <span class="keyword">struct</span> QueueItem &#123;</span><br><span class="line">        sp&lt;Event&gt; event;<span class="comment">//事件</span></span><br><span class="line">        <span class="keyword">int64_t</span> realtime_us;<span class="comment">//触发时间</span></span><br><span class="line">        <span class="keyword">bool</span> has_wakelock;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//封装事件结构体</span></span><br><span class="line">    <span class="keyword">struct</span> Event : <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">        Event()</span><br><span class="line">            : mEventID(<span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~Event() &#123;&#125;</span><br><span class="line">        <span class="function">event_id <span class="title">eventID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mEventID;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="comment">//发射事件，即执行事件</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">(TimedEventQueue *<span class="built_in">queue</span>, <span class="keyword">int64_t</span> now_us)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> TimedEventQueue;</span><br><span class="line">        event_id mEventID;<span class="comment">//每个事件自动分配的id，初始值为1，每多一个事件id会+1</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setEventID</span><span class="params">(event_id id)</span> </span>&#123;</span><br><span class="line">            mEventID = id;</span><br><span class="line">        &#125;</span><br><span class="line">        Event(<span class="keyword">const</span> Event &amp;);</span><br><span class="line">        Event &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Event &amp;);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里有一个独立线程mThread，它主要负责事件调度。是在TimedEventQueue::start被创建，TimedEventQueue::stop被销毁的。位于framework/av/media/libstagefright/TimedEventQueue.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TimedEventQueue::start() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRunning) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStopped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">    <span class="comment">//创建调度线程，同时调用ThreadWrapper方法</span></span><br><span class="line">    pthread_create(&amp;mThread, &amp;attr, ThreadWrapper, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    mRunning = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TimedEventQueue::stop(<span class="keyword">bool</span> flush) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRunning) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">        postEventToBack(<span class="keyword">new</span> StopEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postTimedEvent(<span class="keyword">new</span> StopEvent, INT64_MIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *dummy;</span><br><span class="line">    pthread_join(mThread, &amp;dummy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some events may be left in the queue if we did not flush and the wake lock</span></span><br><span class="line">    <span class="comment">// must be released.</span></span><br><span class="line">    releaseWakeLock_l(<span class="literal">true</span> <span class="comment">/*force*/</span>);</span><br><span class="line">    mQueue.clear();</span><br><span class="line"></span><br><span class="line">    mRunning = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2. 这里创建了调度线程，然后执行了ThreadWrapper方法，我们继续看看这个方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="keyword">void</span> *TimedEventQueue::ThreadWrapper(<span class="keyword">void</span> *me) &#123;    </span><br><span class="line">    androidSetThreadPriority(<span class="number">0</span>, ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">    <span class="comment">//调用了threadEntry方法</span></span><br><span class="line">    <span class="keyword">static_cast</span>&lt;TimedEventQueue *&gt;(me)-&gt;threadEntry();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TimedEventQueue::threadEntry() &#123;</span><br><span class="line">    prctl(PR_SET_NAME, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="string">"TimedEventQueue"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> now_us = <span class="number">0</span>;</span><br><span class="line">        sp&lt;Event&gt; event;</span><br><span class="line">        <span class="keyword">bool</span> wakeLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">            <span class="comment">//如果停止标志则退出轮询</span></span><br><span class="line">            <span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//事件队列为空，则线程等待</span></span><br><span class="line">            <span class="keyword">while</span> (mQueue.empty()) &#123;</span><br><span class="line">                mQueueNotEmptyCondition.wait(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            event_id eventID = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//如果时间对垒为空，跳出内循环，进入外循环等待</span></span><br><span class="line">                <span class="keyword">if</span> (mQueue.empty()) &#123;</span><br><span class="line">                    <span class="comment">// The only event in the queue could have been cancelled</span></span><br><span class="line">                    <span class="comment">// while we were waiting for its scheduled time.</span></span><br><span class="line">                    <span class="comment">//当我们等着这个事件被执行，但是它被取消了，则跳出这次轮询</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历队列中的所有事件</span></span><br><span class="line">                List&lt;QueueItem&gt;::iterator it = mQueue.begin();</span><br><span class="line">                eventID = (*it).event-&gt;eventID();</span><br><span class="line">                <span class="comment">//获取当前的系统时间(毫秒)</span></span><br><span class="line">                now_us = ALooper::GetNowUs();</span><br><span class="line">                <span class="comment">//事件触发的事件</span></span><br><span class="line">                <span class="keyword">int64_t</span> when_us = (*it).realtime_us;</span><br><span class="line">                <span class="comment">//等待延时执行的时间</span></span><br><span class="line">                <span class="keyword">int64_t</span> delay_us;</span><br><span class="line">                <span class="keyword">if</span> (when_us &lt; <span class="number">0</span> || when_us == INT64_MAX) &#123;<span class="comment">//如果等待时间小于0或者是int_64最大值，则将等待时间置为0</span></span><br><span class="line">                    delay_us = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常等待</span></span><br><span class="line">                    delay_us = when_us - now_us;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待时间小于等于0，则跳出这次事件轮询</span></span><br><span class="line">                <span class="keyword">if</span> (delay_us &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//等待的最大超时时间为10秒</span></span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">int64_t</span> kMaxTimeoutUs = <span class="number">10000000l</span>l;  <span class="comment">// 10 secs</span></span><br><span class="line">                <span class="keyword">bool</span> timeoutCapped = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (delay_us &gt; kMaxTimeoutUs) &#123;</span><br><span class="line">                    ALOGW(<span class="string">"delay_us exceeds max timeout: %"</span> PRId64 <span class="string">" us"</span>, delay_us);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// We'll never block for more than 10 secs, instead</span></span><br><span class="line">                    <span class="comment">// we will split up the full timeout into chunks of</span></span><br><span class="line">                    <span class="comment">// 10 secs at a time. This will also avoid overflow</span></span><br><span class="line">                    <span class="comment">// when converting from us to ns.</span></span><br><span class="line">                    <span class="comment">//如果等待时长大于10秒，则强制让它10秒后执行。</span></span><br><span class="line">                    <span class="comment">//上面注释说这样避免了从毫秒到纳秒转化后的值溢出int_64最大范围。</span></span><br><span class="line">                    <span class="comment">//然后将超时标签置为true</span></span><br><span class="line">                    delay_us = kMaxTimeoutUs;</span><br><span class="line">                    timeoutCapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//线程开始等待</span></span><br><span class="line">                <span class="keyword">status_t</span> err = mQueueHeadChangedCondition.waitRelative(</span><br><span class="line">                        mLock, delay_us * <span class="number">1000l</span>l);</span><br><span class="line">                <span class="comment">//时间到了，调出内循环，到外层循环去执行事件</span></span><br><span class="line">                <span class="keyword">if</span> (!timeoutCapped &amp;&amp; err == -ETIMEDOUT) &#123;</span><br><span class="line">                    <span class="comment">// We finally hit the time this event is supposed to</span></span><br><span class="line">                    <span class="comment">// trigger.</span></span><br><span class="line">                    now_us = ALooper::GetNowUs();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The event w/ this id may have been cancelled while we're</span></span><br><span class="line">            <span class="comment">// waiting for its trigger-time, in that case</span></span><br><span class="line">            <span class="comment">// removeEventFromQueue_l will return NULL.</span></span><br><span class="line">            <span class="comment">// Otherwise, the QueueItem will be removed</span></span><br><span class="line">            <span class="comment">// from the queue and the referenced event returned.</span></span><br><span class="line">            <span class="comment">//如果在等待时间过程中，事件被移除了，则返回NULL</span></span><br><span class="line">            <span class="comment">//如果正常情况，则返回这个事件，同时从队列中移除这个事件</span></span><br><span class="line">            event = removeEventFromQueue_l(eventID, &amp;wakeLocked);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// Fire event with the lock NOT held.</span></span><br><span class="line">            <span class="comment">//发射事件，执行事件方法</span></span><br><span class="line">            event-&gt;fire(<span class="keyword">this</span>, now_us);</span><br><span class="line">            <span class="keyword">if</span> (wakeLocked) &#123;</span><br><span class="line">                Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">                releaseWakeLock_l();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//如果在等待时间过程中，事件被移除了，则返回NULL</span></span><br><span class="line">            <span class="comment">//如果正常情况，则返回这个事件，同时从队列中移除这个事件</span></span><br><span class="line">sp&lt;TimedEventQueue::Event&gt; TimedEventQueue::removeEventFromQueue_l(</span><br><span class="line">        event_id id, <span class="keyword">bool</span> *wakeLocked) &#123;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;QueueItem&gt;::iterator it = mQueue.begin();</span><br><span class="line">         it != mQueue.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*it).event-&gt;eventID() == id) &#123;</span><br><span class="line">            sp&lt;Event&gt; event = (*it).event;</span><br><span class="line">            event-&gt;setEventID(<span class="number">0</span>);</span><br><span class="line">            *wakeLocked = (*it).has_wakelock;</span><br><span class="line">            mQueue.erase(it);</span><br><span class="line">            <span class="keyword">return</span> event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGW(<span class="string">"Event %d was not found in the queue, already cancelled?"</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一段代码比较长，其实就是讲List<queueitem>目的就是按照延时时间维护一个event事件队列，threadEntry线程就是不断的从队列的头取出一个event，然后通过  event-&gt;fire(this, now_us); 回调到这个event事件提前注册好的相对应功能函数。这一部分和Handler-Looper很像，应该不难理解。<br>发射执行事件比较简单，我们看看AwesomeEvent这个继承TimedEventQueue::Event的实现类，位于framework/av/media/libstagefright/AwesomePlayer.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> AwesomeEvent : <span class="keyword">public</span> TimedEventQueue::Event &#123;</span><br><span class="line">    AwesomeEvent(</span><br><span class="line">            AwesomePlayer *player,</span><br><span class="line">            <span class="keyword">void</span> (AwesomePlayer::*method)())</span><br><span class="line">        : mPlayer(player),</span><br><span class="line">          mMethod(method) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AwesomeEvent() &#123;&#125;</span><br><span class="line">    <span class="comment">//发射事件，调用AwesomePlayer的相关方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">(TimedEventQueue * <span class="comment">/* queue */</span>, <span class="keyword">int64_t</span> <span class="comment">/* now_us */</span>)</span> </span>&#123;</span><br><span class="line">        (mPlayer-&gt;*mMethod)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AwesomePlayer *mPlayer;</span><br><span class="line">    <span class="keyword">void</span> (AwesomePlayer::*mMethod)();</span><br><span class="line"></span><br><span class="line">    AwesomeEvent(<span class="keyword">const</span> AwesomeEvent &amp;);</span><br><span class="line">    AwesomeEvent &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> AwesomeEvent &amp;);</span><br></pre></td></tr></table></figure></queueitem></p>
<p>&#160; &#160; &#160; &#160;3. 然后看看AwesomePlayer是怎么用TimedEventQueue，AwesomePlayer会定义很多类型的event事件，并把和这些事件相关的功能函数一定绑定起来。比如AwesomePlayer的构造方法里有这么几个，位于framework/av/media/libstagefright/AwesomePlayer.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">mVideoEvent = <span class="keyword">new</span> AwesomeEvent(<span class="keyword">this</span>, &amp;AwesomePlayer::onVideoEvent);</span><br><span class="line">mVideoEventPending = <span class="literal">false</span>;</span><br><span class="line">mStreamDoneEvent = <span class="keyword">new</span> AwesomeEvent(<span class="keyword">this</span>, &amp;AwesomePlayer::onStreamDone);</span><br><span class="line">mStreamDoneEventPending = <span class="literal">false</span>;</span><br><span class="line">mBufferingEvent = <span class="keyword">new</span> AwesomeEvent(<span class="keyword">this</span>, &amp;AwesomePlayer::onBufferingUpdate);</span><br><span class="line">mBufferingEventPending = <span class="literal">false</span>;</span><br><span class="line">mVideoLagEvent = <span class="keyword">new</span> AwesomeEvent(<span class="keyword">this</span>, &amp;AwesomePlayer::onVideoLagUpdate);</span><br><span class="line">mVideoLagEventPending = <span class="literal">false</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;当然还有一些Event是在方法内部构造的。</p>
<p>&#160; &#160; &#160; &#160;原因之前也说了，因为好多音视频处理的功能是十分耗时间的，假如AwesomePlayer 想用某个功能，他并不是直线去调用它，而是抽象成一种AwesomeEvent，将想要调用的功能函数与事件捆绑。通过TimedEventQueue::postTimedEvent(),按照延时的优先顺序把它放到TimedEventQueue的队列之中。然后AwesomePlayer就不管了。TimedEventQueue start之后，自己内部的线程会从队列中依次取出这些事件，然后通过event-&gt;fire回调事件的功能函数。这样就达到了AwesomePlayer的目的。</p>
<p>&#160; &#160; &#160; &#160;4. 我们举个栗子，比如prepareAsync过程，我们看看AwesomePlayer的prepareAsync过程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> AwesomePlayer::prepareAsync() &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> prepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AwesomePlayer::prepareAsync_l() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARING) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;  <span class="comment">// async prepare already pending</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mQueueStarted) &#123;</span><br><span class="line">        mQueue.start();</span><br><span class="line">        mQueueStarted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifyFlags(PREPARING, SET);</span><br><span class="line">    <span class="comment">//在这里new了一个AwesomeEvent给onPrepareAsyncEvent事件回调</span></span><br><span class="line">    mAsyncPrepareEvent = <span class="keyword">new</span> AwesomeEvent(</span><br><span class="line">            <span class="keyword">this</span>, &amp;AwesomePlayer::onPrepareAsyncEvent);</span><br><span class="line"></span><br><span class="line">    mQueue.postEvent(mAsyncPrepareEvent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;他并没有实际的调用onPrepareAsyncEvent（）真正的功能函数，他只是把mQueue start之后，然后创建个mAsyncPrepareEvent事件，把它插入到mQueue之中就不管了，具体调用是由mQueue中的threadEntry线程来做。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;本节我们只是做一个铺垫，在分析AwesomePlayer基本框架及播放流程之前的预备知识。这里我们依然止步于AwesomePlayer的setDataSource（这个setDataSource都可以贯穿这么篇幅了，果然不简单），所以下一节将仔细分析这些过程。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%89%29----%E4%BB%8EStageFright%E5%88%B0AwesomePlayer/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(二)----MediaPlayer的C/S架构以及C++层调用步骤]]></title>
      <url>http://windrunnerlihuan.com/2016/11/30/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%BA%8C-MediaPlayer%E7%9A%84C-S%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8AC-%E5%B1%82%E8%B0%83%E7%94%A8%E6%AD%A5%E9%AA%A4/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;上一节主要分析了MediaPlayer从java层到jni层做的一些工作，并且setDataSource和后续流程还没有往下分析。这一节先介绍MediaPlayer的C/S架构，然后顺着架构往下深究，我们的思路会更清晰。<br><a id="more"></a></p>
<h1 id="MediaPlayer的C-S架构"><a href="#MediaPlayer的C-S架构" class="headerlink" title="MediaPlayer的C/S架构"></a>MediaPlayer的C/S架构</h1><p>&#160; &#160; &#160; &#160;整个MediaPlayer在运行的时候，可以分成Client和Server两个部分，它们分别在两个进程中运行，它们之间使用Binder机制实现IPC通信。架构图如下，我的viso用的不太好，但是还是能看清。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%8C%29----MediaPlayer%E7%9A%84C/S%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8AC++%E5%B1%82%E8%B0%83%E7%94%A8%E6%AD%A5%E9%AA%A4/jiagou.jpg" alt="架构图"></p>
<p>&#160; &#160; &#160; &#160;1）如果从功能从上往下看，最上层是java层MediaPlayer的API，然后是jni层到C++层之间的IPC通信，最下边就是player的具体实现了（如StageFrightPlayer、MstarPlayer）。<br>&#160; &#160; &#160; &#160;2）C++层是比较重要的环节，这一块也是C/S架构的核心。主要围绕C++层MediaPlayer通过BpMediaPlayerService这个本地proxy对象，经过IPC与远程服务MediaPlayerService(BnMediaPlayerService)通信，完成C/S架构。（其实Android有很多模块设计都是C/S架构，都是通过BpXXX这个代理皮包和拥有干货的BnXXX通信。这里的p指的是proxy，n就是native）<br>&#160; &#160; &#160; &#160;3）当Server端收到Client端的请求，MediaPlayerService会为每一个Client进程创建一个会话，这里就是new一个MediaPlayerService:Client对象和其交互。然后这个对象再根据Client端请求的资源类型去判断创建什么类型的Player，就是最下边那些。（其实这些Player有些是芯片商自己做的，每家做的都不一样）</p>
<h1 id="C-层MediaPlayer实现"><a href="#C-层MediaPlayer实现" class="headerlink" title="C++层MediaPlayer实现"></a>C++层MediaPlayer实现</h1><p>&#160; &#160; &#160; &#160;上一节我们只是分析了从java层到jni层的一些步骤，应该算是准备工作，正好我们入门。这次我们从jni层入手，应该位于架构图中客户端进程部分，C++层MediaPlayer往上，jni层往下的部分。继续往下，还得从setDataSource入手。</p>
<h2 id="setDataSource-C-实现"><a href="#setDataSource-C-实现" class="headerlink" title="setDataSource C++实现"></a>setDataSource C++实现</h2><p>&#160; &#160; &#160; &#160;通过JNI方式调用到framework层 android_media_MediaPlayer.cpp(\frameworks\base\media\jni\android_media_MediaPlayer.cpp)，继而调用mediaplayer.cpp(frameworks\av\media\libmedia\MediaPlayer.cpp)。我们找到setDataSource方法，上次我们分析的而是获取文件描述符的重载方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MediaPlayer::setDataSource(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"setDataSource(%d, %"</span> PRId64 <span class="string">", %"</span> PRId64 <span class="string">")"</span>, fd, offset, length);</span><br><span class="line">    <span class="keyword">status_t</span> err = UNKNOWN_ERROR;</span><br><span class="line">    <span class="comment">//获取BpMediaPlayerService这个代理MediaPlayerService的proxy对象</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService());</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//从service manager中获得MediaPlayerService 服务，然后通过服务来创建player,这个player就是架构图最下层那些拥有真正干活本领的player</span></span><br><span class="line">        sp&lt;IMediaPlayer&gt; player(service-&gt;create(<span class="keyword">this</span>, mAudioSessionId));</span><br><span class="line">        <span class="keyword">if</span> ((NO_ERROR != doSetRetransmitEndpoint(player)) ||</span><br><span class="line">            <span class="comment">//会走到这里，调用那些能够干活的player的setDataSource方法</span></span><br><span class="line">            (NO_ERROR != player-&gt;setDataSource(fd, offset, length))) &#123;</span><br><span class="line">            player.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        err = attachNewPlayer(player);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在整个应用程序的进程中，Mediaplayer.cpp 中 setDataSource会从service manager中获得<strong>MediaPlayerService</strong> 服务，然后通过服务来创建<strong>player</strong>,这个<strong>player</strong>就是播放器的真实实例。</p>
<p>&#160; &#160; &#160; &#160;分工步骤如下：</p>
<h3 id="通过Binder获取远程服务"><a href="#通过Binder获取远程服务" class="headerlink" title="通过Binder获取远程服务"></a>通过Binder获取远程服务</h3><p>&#160; &#160; &#160; &#160;通过 getMediaPlayerService 得到的service其实是 BpMediaPlayerService，这是和<strong>MediaPlayerService</strong>进程中的BnMediaPlayerService 相对应负责binder通讯。BpMediaPlayerService中的create其实通过binder机制将CREATE消息发送出去。位于framework/av/media/libmedia/IMediaPlayerService.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> sp&lt;IMediaPlayer&gt; create(</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IMediaPlayerClient&gt;&amp; client, <span class="keyword">int</span> audioSessionId) &#123;</span><br><span class="line">        <span class="comment">//发送数据data，相应数据reply    </span></span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());</span><br><span class="line">        data.writeStrongBinder(client-&gt;asBinder());</span><br><span class="line">        data.writeInt32(audioSessionId);</span><br><span class="line">        <span class="comment">//通过binder将CTEATE消息发送出去</span></span><br><span class="line">        remote()-&gt;transact(CREATE, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在对面的BnMediaPlayerService中，通过onTransact()接受这些消息。并把结果返回。同样位于framework/av/media/libmedia/IMediaPlayerService.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BnMediaPlayerService::onTransact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE: &#123;</span><br><span class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">            sp&lt;IMediaPlayerClient&gt; client =</span><br><span class="line">                interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder());</span><br><span class="line">            <span class="keyword">int</span> audioSessionId = data.readInt32();</span><br><span class="line">            <span class="comment">//BnMediaPlayerService的子类是MediaPlayerService，因此会调用MediaPlayerService的create方法</span></span><br><span class="line">            sp&lt;IMediaPlayer&gt; player = create(client, audioSessionId);</span><br><span class="line">            <span class="comment">//将create创建的player回执给客户端</span></span><br><span class="line">            reply-&gt;writeStrongBinder(player-&gt;asBinder());</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DECODE_URL:</span><br><span class="line">        ...... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="服务端创建会话"><a href="#服务端创建会话" class="headerlink" title="服务端创建会话"></a>服务端创建会话</h3><p>&#160; &#160; &#160; &#160;当发现是CREATE才真正调用了MediaPlayerService 中的create函数，位于framework/av/media/libmediaplayerservice/MediaPlayerService.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IMediaPlayer&gt; MediaPlayerService::create(<span class="keyword">const</span> sp&lt;IMediaPlayerClient&gt;&amp; client,</span><br><span class="line">        <span class="keyword">int</span> audioSessionId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = IPCThreadState::self()-&gt;getCallingPid();</span><br><span class="line">    <span class="keyword">int32_t</span> connId = android_atomic_inc(&amp;mNextConnId);</span><br><span class="line">    <span class="comment">//在create函数中其实是创建了一个MediaPlayerService::Client的实例，也就是</span></span><br><span class="line">    <span class="comment">//说MediaPlayerService会为每个client应用进程创建一个相应的MediaPlayerService::Client的实例，来提供服务</span></span><br><span class="line">    sp&lt;Client&gt; c = <span class="keyword">new</span> Client(</span><br><span class="line">            <span class="keyword">this</span>, pid, connId, client, audioSessionId,</span><br><span class="line">            IPCThreadState::self()-&gt;getCallingUid());</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Create new client(%d) from pid %d, uid %d, "</span>, connId, pid,</span><br><span class="line">         IPCThreadState::self()-&gt;getCallingUid());</span><br><span class="line"></span><br><span class="line">    wp&lt;Client&gt; w = c;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mClients.add(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在create函数中其实是创建了一个MediaPlayerService::Client的实例，也就是 说MediaPlayerService会为每个client应用进程创建一个相应的MediaPlayerService::Client的实例，来提供服务。<br>&#160; &#160; &#160; &#160;这样Mediaplayer.cpp就得到了一个player的实例，对他来说这个实例和本地的其他类的实例没什么用法上的区别，殊不知其实这个实例是运行在另外一个进程中。实现这种假象的就是binder机制。<br>&#160; &#160; &#160; &#160;如果对Binder机制不是很了解，可以看看<a href="http://windrunnerlihuan.com/2016/06/12/Binder简要分析/">这篇文章</a>。</p>
<h3 id="回执后setDataSource流程"><a href="#回执后setDataSource流程" class="headerlink" title="回执后setDataSource流程"></a>回执后setDataSource流程</h3><p>&#160; &#160; &#160; &#160;获得这个实例后继续player-&gt;setDataSource().在MediaPlayerService的进程中他的实际函数中，才会真正的创建框架图最下面那些具有干活能力的播放器具体实例。<br>&#160; &#160; &#160; &#160;我们继续查看MediaPlayerService::Client::setDataSource方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MediaPlayerService::Client::setDataSource(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取播放器类型</span></span><br><span class="line">    player_type playerType = MediaPlayerFactory::getPlayerType(<span class="keyword">this</span>,</span><br><span class="line">                                                               fd,</span><br><span class="line">                                                               offset,</span><br><span class="line">                                                               length);</span><br><span class="line">    <span class="comment">//这里会根据上面选择的播放器类型去创建相应的播放器                                                               </span></span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p = setDataSource_pre(playerType);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now set data source</span></span><br><span class="line">    <span class="comment">//最后在这里在将数据源设置给播放器</span></span><br><span class="line">    setDataSource_post(p, p-&gt;setDataSource(fd, offset, length));</span><br><span class="line">    <span class="keyword">return</span> mStatus;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这也也要分步骤执行，我们一步一步去看，然后才能弄清楚每一步的职责。<br>&#160; &#160; &#160; &#160;1）先是获取播放器的类型，我们进入MediaPlayerFactory类看看getPlayerType方法，位于framework/av/media/libmediaplayerservice/MediaPlayerFactory.cpp中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">player_type MediaPlayerFactory::getPlayerType(const sp&lt;IMediaPlayer&gt;&amp; client,</span><br><span class="line">                                              int fd,</span><br><span class="line">                                              int64_t offset,</span><br><span class="line">                                              int64_t length) &#123;</span><br><span class="line">    //这是一个宏，我们看看它的宏定义                                              </span><br><span class="line">    GET_PLAYER_TYPE_IMPL(client, fd, offset, length);</span><br><span class="line">&#125;</span><br><span class="line">//注册不同播放器的map</span><br><span class="line">MediaPlayerFactory::tFactoryMap MediaPlayerFactory::sFactoryMap;</span><br><span class="line"></span><br><span class="line">//这就是它的宏定义</span><br><span class="line">#define GET_PLAYER_TYPE_IMPL(a...)                      \</span><br><span class="line">    Mutex::Autolock lock_(&amp;sLock);                      \</span><br><span class="line">                                                        \</span><br><span class="line">    player_type ret = STAGEFRIGHT_PLAYER;               \</span><br><span class="line">    float bestScore = 0.0;                              \</span><br><span class="line">                                                        \</span><br><span class="line">    for (size_t i = 0; i &lt; sFactoryMap.size(); ++i) &#123;   \</span><br><span class="line">                                                        \</span><br><span class="line">        IFactory* v = sFactoryMap.valueAt(i);           \</span><br><span class="line">        float thisScore;                                \</span><br><span class="line">        CHECK(v != NULL);                               \</span><br><span class="line">        thisScore = v-&gt;scoreFactory(a, bestScore);      \</span><br><span class="line">        if (thisScore &gt; bestScore) &#123;                    \</span><br><span class="line">            ret = sFactoryMap.keyAt(i);                 \</span><br><span class="line">            bestScore = thisScore;                      \</span><br><span class="line">        &#125;                                               \</span><br><span class="line">    &#125;                                                   \</span><br><span class="line">                                                        \</span><br><span class="line">    if (0.0 == bestScore) &#123;                             \</span><br><span class="line">        ret = getDefaultPlayerType();                   \</span><br><span class="line">    &#125;                                                   \</span><br><span class="line">                                                        \</span><br><span class="line">    return ret;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里定义一个宏来选择播放器类型。里面的for循环也很简单，就是查询注册进来的播放器map中的score得分，谁的得分最高，就返回这个播放器。<br>&#160; &#160; &#160; &#160;这里默认返回的是StageFright，舞台恐惧者，Google总喜欢用一些稀奇古怪的名字命名它的模块组件。</p>
<p>&#160; &#160; &#160; &#160;我看可以查看MediaPlayerFactory.cpp这个文件，这个文件里面有许多种类型的播放器工厂，可以创建出不同的播放器，如StagefrightPlayer、NuPlayerDriver、MidiFile等等。如果厂商要定制自己的播放器，就可以在这里做文章。比如Mstar或者海思自己的播放器，MstarPlayer、HisiPlayer。创建自己的工厂类，实现createPlayer方法，然后修改scoreFactory返回得分值为一个较大的数值，再注册进sFactoryMap变量。或者直接修改GET_PLAYER_TYPE_IMPL宏和getDefaultPlayerType方法的规则。</p>
<p>&#160; &#160; &#160; &#160;这里我们就选取默认值STAGEFRIGHT_PLAYER，位于framework/av/media/libmediaplayerservice/MediaPlayerFactory.h：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> player_type &#123;</span><br><span class="line">    PV_PLAYER = <span class="number">1</span>,</span><br><span class="line">    SONIVOX_PLAYER = <span class="number">2</span>,</span><br><span class="line">    STAGEFRIGHT_PLAYER = <span class="number">3</span>,<span class="comment">//这个是默认值</span></span><br><span class="line">    NU_PLAYER = <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// Test players are available only in the 'test' and 'eng' builds.</span></span><br><span class="line">    <span class="comment">// The shared library with the test player is passed passed as an</span></span><br><span class="line">    <span class="comment">// argument to the 'test:' url in the setDataSource call.</span></span><br><span class="line">    TEST_PLAYER = <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2）根据上述选取的STAGEFRIGHT_PLAYER 创建播放器。回到上面继续查看setDataSource_pre方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::setDataSource_pre(</span><br><span class="line">        player_type playerType)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"player type = %d"</span>, playerType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the right type of player</span></span><br><span class="line">    <span class="comment">//调用createPlayer方法，这一步继续跟进</span></span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p = createPlayer(playerType);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置音频输出</span></span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;hardwareOutput()) &#123;</span><br><span class="line">        mAudioOutput = <span class="keyword">new</span> AudioOutput(mAudioSessionId, IPCThreadState::self()-&gt;getCallingUid(),</span><br><span class="line">                mPid, mAudioAttributes);</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;MediaPlayerInterface*&gt;(p.get())-&gt;setAudioSink(mAudioOutput);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::createPlayer(player_type playerType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// determine if we have the right player type</span></span><br><span class="line">    <span class="comment">//确定正确的播放器类型，如果不对，则删除旧的</span></span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p = mPlayer;</span><br><span class="line">    <span class="keyword">if</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;playerType() != playerType)) &#123;</span><br><span class="line">        ALOGV(<span class="string">"delete player"</span>);</span><br><span class="line">        p.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//根据工厂类创建播放器实例</span></span><br><span class="line">        p = MediaPlayerFactory::createPlayer(playerType, <span class="keyword">this</span>, notify);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;setUID(mUID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后会调用MediaPlayerFactory::createPlayer静态方法，我们进去看看怎么实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;MediaPlayerBase&gt; MediaPlayerFactory::createPlayer(</span><br><span class="line">        player_type playerType,</span><br><span class="line">        <span class="keyword">void</span>* cookie,</span><br><span class="line">        notify_callback_f notifyFunc) &#123;</span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p;</span><br><span class="line">    IFactory* factory;</span><br><span class="line">    <span class="keyword">status_t</span> init_result;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock_</span><span class="params">(&amp;sLock)</span></span>;</span><br><span class="line">    <span class="comment">//查询检测</span></span><br><span class="line">    <span class="keyword">if</span> (sFactoryMap.indexOfKey(playerType) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to create player object of type %d, no registered"</span></span><br><span class="line">              <span class="string">" factory"</span>, playerType);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出播放器工厂类</span></span><br><span class="line">    factory = sFactoryMap.valueFor(playerType);</span><br><span class="line">    CHECK(<span class="literal">NULL</span> != factory);</span><br><span class="line">    <span class="comment">//这句才是创建播放器</span></span><br><span class="line">    p = factory-&gt;createPlayer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to create player object of type %d, create failed"</span>,</span><br><span class="line">               playerType);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通知回调</span></span><br><span class="line">    init_result = p-&gt;initCheck();</span><br><span class="line">    <span class="keyword">if</span> (init_result == NO_ERROR) &#123;</span><br><span class="line">        p-&gt;setNotifyCallback(cookie, notifyFunc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to create player object of type %d, initCheck failed"</span></span><br><span class="line">              <span class="string">" (res = %d)"</span>, playerType, init_result);</span><br><span class="line">        p.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因为我们的播放器类型为STAGEFRIGHT_PLAYER ，所以对应的工厂类为StagefrightPlayerFactory，继续进入MediaPlayerFactory.cpp中查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> StagefrightPlayerFactory :</span><br><span class="line">    <span class="keyword">public</span> MediaPlayerFactory::IFactory &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">scoreFactory</span><span class="params">(<span class="keyword">const</span> sp&lt;IMediaPlayer&gt;&amp; <span class="comment">/*client*/</span>,</span><br><span class="line">                               <span class="keyword">int</span> fd,</span><br><span class="line">                               <span class="keyword">int64_t</span> offset,</span><br><span class="line">                               <span class="keyword">int64_t</span> <span class="comment">/*length*/</span>,</span><br><span class="line">                               <span class="keyword">float</span> <span class="comment">/*curScore*/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getDefaultPlayerType()</span><br><span class="line">                == STAGEFRIGHT_PLAYER) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">            lseek(fd, offset, SEEK_SET);</span><br><span class="line">            read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            lseek(fd, offset, SEEK_SET);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> ident = *((<span class="keyword">uint32_t</span>*)buf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ogg vorbis?</span></span><br><span class="line">            <span class="keyword">if</span> (ident == <span class="number">0x5367674f</span>) <span class="comment">// 'OggS'</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;MediaPlayerBase&gt; createPlayer() &#123;</span><br><span class="line">        ALOGV(<span class="string">" create StagefrightPlayer"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StagefrightPlayer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里他就创建了StagefrightPlayer这个播放器对象了。在这里已经看不到openCore的影子了，android高版本已经舍弃了openCore了。</p>
<p>&#160; &#160; &#160; &#160;3）最后一部就是用上面创建的StagefrightPlayer对象设置数据源了。这一步下一节讲Stagefright框架时会讲的。</p>
<h2 id="StageFright-与openCore"><a href="#StageFright-与openCore" class="headerlink" title="StageFright 与openCore"></a>StageFright 与openCore</h2><p>&#160; &#160; &#160; &#160;Android froyo版本多媒体引擎做了变动，新添加了stagefright框架，并且默认情况android选择stagefright，并没有完全抛弃opencore，主要是做了一个OMX层，仅仅是对 opencore的omx-component部分做了引用。stagefright是在MediaPlayerService这一层加入的，和opencore是并列的。Stagefright在 Android中是以shared library的形式存在(libstagefright.so)，其中的module – AwesomePlayer可用来播放video/audio。 AwesomePlayer提供许多API，可以让上层的应用程序(Java/JNI)来调用。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;以上就是本节分析的内容，承接上一节jni层setDataSource，一直到本届C++层setDataSource。步骤如下：</p>
<ul>
<li>jni层调用C++层MediaPlayer的setDataSource；</li>
<li>通过IPC获取MediaPlayerService服务，为客户端进程分配一个回话；</li>
<li>服务端setDataSource过程中创建指定类型的播放器；</li>
<li>播放器设置setDataSource。</li>
</ul>
<p>&#160; &#160; &#160; &#160;本届内容就这么多，依然止于setDataSource，不过是StageFright的setDataSource，我们在这里做个标记。<br>&#160; &#160; &#160; &#160;下一节我们将详细分析StageFright框架。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%BA%8C%29----MediaPlayer%E7%9A%84C/S%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8AC++%E5%B1%82%E8%B0%83%E7%94%A8%E6%AD%A5%E9%AA%A4/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android多媒体开发(一)----MediaPlayer框架开始]]></title>
      <url>http://windrunnerlihuan.com/2016/11/28/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%80-MediaPlayer%E6%A1%86%E6%9E%B6%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;The Android multimedia framework includes support for playing variety of common mediatypes, so that you can easily integrate audio, video and images into your applications. You can play audio or video from media files stored in your application’s resources (raw resources), from standalone files in the filesystem, or from a data stream arriving over a network connection, all using MediaPlayer APIs.<br><a id="more"></a></p>
<h1 id="前言-忽略"><a href="#前言-忽略" class="headerlink" title="前言(忽略)"></a>前言(忽略)</h1><p>&#160; &#160; &#160; &#160;做多媒体开发都离不开<strong>MediaPlayer</strong>这个类，现在android市场已经趋于饱和，在API调用方面人人基本上已是轻车熟路。<br>&#160; &#160; &#160; &#160;这里不详细赘述MediaPlayer的使用，毕竟网上例子一搜一大堆，逛网也给出了详细介绍和用法。<br>&#160; &#160; &#160; &#160;官网介绍：<a href="https://developer.android.com/reference/android/media/MediaPlayer.html" target="_blank" rel="external">https://developer.android.com/reference/android/media/MediaPlayer.html</a><br>&#160; &#160; &#160; &#160;官网用法：<a href="https://developer.android.com/guide/topics/media/mediaplayer.html" target="_blank" rel="external">https://developer.android.com/guide/topics/media/mediaplayer.html</a>  (这里官网已经把<em>ExoPlayer</em>贴在导航页了，关于ExoPlayer可以点<a href="https://github.com/google/ExoPlayer" target="_blank" rel="external">这里</a>看Github)</p>
<p>&#160; &#160; &#160; &#160;一个很简单的demo如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer mediaPlayer = <span class="keyword">new</span> MediaPlayer();  </span><br><span class="line">mediaPlayer.setDataSource(path);  </span><br><span class="line">mediaPlayer.setDisplay(surfaceView.getHolder());  </span><br><span class="line">mediaPlayer.prepare();  </span><br><span class="line">mediaPlayer.start();</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<br>我们就从这个很简单的例子着手，一步一步分析整个播放流程。</p>
<h1 id="mediaserver-启动"><a href="#mediaserver-启动" class="headerlink" title="mediaserver 启动"></a>mediaserver 启动</h1><p>&#160; &#160; &#160; &#160;我们知道，Android系统是基于Linux内核的，而在Linux系统中，所有的进程都是init进程的子孙进程，也就是说，所有的进程都是直接或者间接地由init进程fork出来的。Zygote进程也不例外，它是在系统启动的过程，由init进程创建的。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%80%29----MediaPlayer%E6%A1%86%E6%9E%B6%E5%BC%80%E5%A7%8B/qidong.png" alt="启动流程"></p>
<p>&#160; &#160; &#160; &#160;在系统启动脚本system/core/rootdir/init.rc文件中，我们可以看到启动<strong>mediaserver</strong>进程的脚本命令：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service media /system/bin/mediaserver</span><br><span class="line">    <span class="keyword">class</span> main</span><br><span class="line">    user media</span><br><span class="line">    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm</span><br><span class="line">    ioprio rt <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>mediaserver</strong>启动后会把media相关一些服务添加到servicemanager中，其中就有<strong>MediaPlayerService</strong>。这样应用启动前，系统就有了MediaPlayerService这个服务程序。位于frameworks/av/media/mediaserver/Main_mediaserver.cpp的main函数中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	......</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());  </span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();  </span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());  </span><br><span class="line">    AudioFlinger::instantiate();</span><br><span class="line">    <span class="comment">//初始化MediaPlayerService  </span></span><br><span class="line">    MediaPlayerService::instantiate();  </span><br><span class="line">    CameraService::instantiate();  </span><br><span class="line">    AudioPolicyService::instantiate();  </span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();  </span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后我们看看MediaPlayerService的初始化，位于frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instantiate() &#123;  </span><br><span class="line">    defaultServiceManager()-&gt;addService(  </span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;MediaPlayerService 初始化函数，向ServiceManager注册了一个实名Binder(media.player)，可以dumpsys -l查看启动了哪些实名service。</p>
<h1 id="MediaPlayer-创建"><a href="#MediaPlayer-创建" class="headerlink" title="MediaPlayer 创建"></a>MediaPlayer 创建</h1><p>&#160; &#160; &#160; &#160;接着我们进入应用层，看看MediaPlayer创建时做了那些事情。</p>
<h2 id="MediaPlayer构造"><a href="#MediaPlayer构造" class="headerlink" title="MediaPlayer构造"></a>MediaPlayer构造</h2><p>&#160; &#160; &#160; &#160;应用层MediaPlayer mediaPlayer = new MediaPlayer()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MediaPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里会构建一个EventHandler的Handler对象，用于处理一些消息回调</span></span><br><span class="line">      Looper looper;</span><br><span class="line">      <span class="keyword">if</span> ((looper = Looper.myLooper()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          mEventHandler = <span class="keyword">new</span> EventHandler(<span class="keyword">this</span>, looper);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((looper = Looper.getMainLooper()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          mEventHandler = <span class="keyword">new</span> EventHandler(<span class="keyword">this</span>, looper);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mEventHandler = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Native setup requires a weak reference to our object.</span><br><span class="line">       * It's easier to create it here than in C++.</span><br><span class="line">       */</span></span><br><span class="line">       <span class="comment">//这个才是重点，jni层创建MediaPlayer，将java层弱引用传递给jni层。</span></span><br><span class="line">      native_setup(<span class="keyword">new</span> WeakReference&lt;MediaPlayer&gt;(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造之前MediaPlayer类有一段静态代码块，加载了media_jni.so库，用于初始jni相关，早于构造方法，在加载类时就执行。一般是全局性的数据，变量，可以放在这。frameworks\base\media\java\android\media\MediaPlayer.java。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"media_jni"</span>);</span><br><span class="line">        native_init();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里会先加载libmedia_jni的so库，需要在这里做个标记，下一节会介绍。</p>
<p>&#160; &#160; &#160; &#160;调用本地方法native_init，我们找到它的jni实现，位于frameworks/base/media/jni/android_media_MediaPlayer.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// This function gets some field IDs, which in turn causes class initialization.</span></span><br><span class="line"><span class="comment">// It is called from a static block in MediaPlayer, which won't run until the</span></span><br><span class="line"><span class="comment">// first time an instance of this class is used.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaPlayer_native_init</span><span class="params">(JNIEnv *env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">	<span class="comment">//通过native层调用java层，获取MediaPlayer类</span></span><br><span class="line">    clazz = env-&gt;FindClass(<span class="string">"android/media/MediaPlayer"</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取java层mNativeContext变量，是个long型变量，JNI调用经常这么搞，把jni返回结果通过强转为java层long型变量，供上层保存调用</span></span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, <span class="string">"mNativeContext"</span>, <span class="string">"J"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fields.context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//找到java层postEventFromNative方法</span></span><br><span class="line">    fields.post_event = env-&gt;GetStaticMethodID(clazz, <span class="string">"postEventFromNative"</span>,</span><br><span class="line">                                               <span class="string">"(Ljava/lang/Object;IIILjava/lang/Object;)V"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fields.post_event == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//找到java层mNativeSurfaceTexture变量</span></span><br><span class="line">    fields.surface_texture = env-&gt;GetFieldID(clazz, <span class="string">"mNativeSurfaceTexture"</span>, <span class="string">"J"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fields.surface_texture == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里我们可以看到jni层设置了java层的postEventFromNative方法，从字面意思可以看出就是被native层调用，通过这样反向调用，仅被使用EventHandler post事件回到主线程中。post开头都是post到主线程，用软引用指向java层的MediaPlayer，以便native代码是线程安全的。postEventFromNative实现如下，不难理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postEventFromNative</span><span class="params">(Object mediaplayer_ref,</span><br><span class="line">                                          <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">   <span class="comment">//这就是传入到native层java层MediaPlayer弱引用</span></span><br><span class="line">      MediaPlayer mp = (MediaPlayer)((WeakReference)mediaplayer_ref).get();</span><br><span class="line">      <span class="keyword">if</span> (mp == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">      <span class="comment">//用EventHandler发送native的消息</span></span><br><span class="line">      <span class="keyword">if</span> (mp.mEventHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Message m = mp.mEventHandler.obtainMessage(what, arg1, arg2, obj);</span><br><span class="line">          mp.mEventHandler.sendMessage(m);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里native_init的准备工作就做完了，然后就是jni层的native_setup方法的执行了。对应本地方法依然位于frameworks/base/media/jni/android_media_MediaPlayer.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaPlayer_native_setup</span><span class="params">(JNIEnv *env, jobject thiz, jobject weak_this)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ALOGV(<span class="string">"native_setup"</span>);</span><br><span class="line">    <span class="comment">//创建一个C++层的MediaPlayer</span></span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/RuntimeException"</span>, <span class="string">"Out of memory"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new listener and give it to MediaPlayer</span></span><br><span class="line">    <span class="comment">//创建一个listener给MediaPlayer，以便java层MediaPlayer设置一些监听能产生回调，如setPrepareListener、setOnCompleteListener等等。</span></span><br><span class="line">    sp&lt;JNIMediaPlayerListener&gt; listener = <span class="keyword">new</span> JNIMediaPlayerListener(env, thiz, weak_this);</span><br><span class="line">    mp-&gt;setListener(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stow our new C++ MediaPlayer in an opaque field in the Java object.</span></span><br><span class="line">    <span class="comment">//C++层的MediaPlayer对于java层的是不透明的，大家互不关心</span></span><br><span class="line">    setMediaPlayer(env, thiz, mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里创建了一个C++层的MediaPlayer，还有一些Listener回调。这个模式和Android的Looper差不多，也是java层一个Looper，C++层也有一个Looper。关于Android消息机制原理，可以看看<a href="http://windrunnerlihuan.com/2016/07/31/Android消息机制零散分析/">这里</a>。</p>
<h2 id="setDataSource过程"><a href="#setDataSource过程" class="headerlink" title="setDataSource过程"></a>setDataSource过程</h2><p>&#160; &#160; &#160; &#160;构造完MediaPlayer之后，就要设置数据源了。setDataSource有许多重载方法，我们这里就挑一个文件类型处理的方法，也方便分析。文件类型数据源上层java代码会调用本地方法，还是位于frameworks/base/media/jni/android_media_MediaPlayer.cpp中。不过这次根据名字找不到对应方法了，因为它用如下一个结构体数组做了明值映射：（这个也是jni层常用的技巧，如果看过Log系统源码的应该都了解，毕竟学习jni都是从Log系统开始的）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"nativeSetDataSource"</span>,</span><br><span class="line">        <span class="string">"(Landroid/os/IBinder;Ljava/lang/String;[Ljava/lang/String;"</span></span><br><span class="line">        <span class="string">"[Ljava/lang/String;)V"</span>,</span><br><span class="line">        (<span class="keyword">void</span> *)android_media_MediaPlayer_setDataSourceAndHeaders</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"_setDataSource"</span>,       <span class="string">"(Ljava/io/FileDescriptor;JJ)V"</span>,    (<span class="keyword">void</span> *)android_media_MediaPlayer_setDataSourceFD&#125;,</span><br><span class="line">	<span class="comment">//省略许多方法映射</span></span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个结构体数组几乎映射了所有MediaPlayer方法处理，我们这里只关心setDataSource，所以照上面找到文件中的android_media_MediaPlayer_setDataSourceFD方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaPlayer_setDataSourceFD</span><span class="params">(JNIEnv *env, jobject thiz, jobject fileDescriptor, jlong offset, jlong length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//获取C++层的MediaPlayer</span></span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileDescriptor == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取数据源的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</span><br><span class="line">    ALOGV(<span class="string">"setDataSourceFD: fd %d"</span>, fd);</span><br><span class="line">    <span class="comment">//这一步其实重点在mp-&gt;setDataSource(fd, offset, length)</span></span><br><span class="line">    process_media_player_call( env, thiz, mp-&gt;setDataSource(fd, offset, length), <span class="string">"java/io/IOException"</span>, <span class="string">"setDataSourceFD failed."</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一步先获取C++层的MediaPlayer，然后获取数据源文件描述符，最后调用process_media_player_call检查返回状态，在参数里已经让C++层的MediaPlayer调用了setDataSource方法。我们先看看process_media_player_call的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If exception is NULL and opStatus is not OK, this method sends an error</span></span><br><span class="line"><span class="comment">// event to the client application; otherwise, if exception is not NULL and</span></span><br><span class="line"><span class="comment">// opStatus is not OK, this method throws the given exception to the client</span></span><br><span class="line"><span class="comment">// application.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_media_player_call</span><span class="params">(JNIEnv *env, jobject thiz, <span class="keyword">status_t</span> opStatus, <span class="keyword">const</span> <span class="keyword">char</span>* exception, <span class="keyword">const</span> <span class="keyword">char</span> *message)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exception == <span class="literal">NULL</span>) &#123;  <span class="comment">// Don't throw exception. Instead, send an event.</span></span><br><span class="line">	    <span class="comment">//如果setDataSource过程返回状态不OK，则notify MEDIA_ERROR状态</span></span><br><span class="line">        <span class="keyword">if</span> (opStatus != (<span class="keyword">status_t</span>) OK) &#123;</span><br><span class="line">            sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">            <span class="keyword">if</span> (mp != <span class="number">0</span>) mp-&gt;notify(MEDIA_ERROR, opStatus, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// Throw exception!</span></span><br><span class="line">        <span class="keyword">if</span> ( opStatus == (<span class="keyword">status_t</span>) INVALID_OPERATION ) &#123;<span class="comment">//不合法操作</span></span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( opStatus == (<span class="keyword">status_t</span>) PERMISSION_DENIED ) &#123;<span class="comment">//权限拒绝</span></span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/SecurityException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( opStatus != (<span class="keyword">status_t</span>) OK ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(message) &gt; <span class="number">230</span>) &#123;</span><br><span class="line">               <span class="comment">// if the message is too long, don't bother displaying the status code</span></span><br><span class="line">               jniThrowException( env, exception, message);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">char</span> msg[<span class="number">256</span>];</span><br><span class="line">                <span class="comment">// append the status code to the message</span></span><br><span class="line">               <span class="built_in">sprintf</span>(msg, <span class="string">"%s: status=0x%X"</span>, message, opStatus);</span><br><span class="line">               jniThrowException( env, exception, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;看代码和注释能看出process_media_player_call主要是做错误和异常检测工作，然后notify出去相应错误状态。</p>
<p>&#160; &#160; &#160; &#160;接着就是调用C++层MediaPlayer的setData方法，这个我们下一节详细分析，本节我们知道setDataSource最后调用了C++层MediaPlayer的setData方法。</p>
<h2 id="setDisplay过程"><a href="#setDisplay过程" class="headerlink" title="setDisplay过程"></a>setDisplay过程</h2><p>&#160; &#160; &#160; &#160;下一步就是java层的setDisplay，依然查看java层MediaPlayer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(SurfaceHolder sh)</span> </span>&#123;</span><br><span class="line">        mSurfaceHolder = sh;<span class="comment">//保存SurfaceHolder</span></span><br><span class="line">        Surface surface;</span><br><span class="line">        <span class="keyword">if</span> (sh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            surface = sh.getSurface();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            surface = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _setVideoSurface(surface);<span class="comment">//给视频设置surface</span></span><br><span class="line">        updateSurfaceScreenOn();<span class="comment">//更新surface到屏幕上</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">_setVideoSurface</span><span class="params">(Surface surface)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后会调用本地方法_setVideoSurface，我们继续找到它的jni实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaPlayer_setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    setVideoSurface(env, thiz, jsurface, <span class="literal">true</span> <span class="comment">/* mediaPlayerMustBeAlive */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);<span class="comment">//获取C++的MediaPlayer</span></span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaPlayerMustBeAlive) &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line">    decVideoSurfaceRef(env, thiz);</span><br><span class="line">	<span class="comment">//IGraphicBufferProducer图层缓冲区合成器</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; new_st;</span><br><span class="line">    <span class="keyword">if</span> (jsurface) &#123;</span><br><span class="line">	    <span class="comment">//得到java层的surface</span></span><br><span class="line">        sp&lt;Surface&gt; surface(android_view_Surface_getSurface(env, jsurface));</span><br><span class="line">        <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	        <span class="comment">//获取IGraphicBufferProducer</span></span><br><span class="line">            new_st = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">            <span class="keyword">if</span> (new_st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface does not have a binding SurfaceTexture!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加IGraphicBufferProducer的强引用+1</span></span><br><span class="line">            new_st-&gt;incStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface has been released"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//上面我们在native_init方法中将java层mNativeSurfaceTexture查找给了jni层，正好，在这里将IGraphicBufferProducer赋给它</span></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.surface_texture, (jlong)new_st.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will fail if the media player has not been initialized yet. This</span></span><br><span class="line">    <span class="comment">// can be the case if setDisplay() on MediaPlayer.java has been called</span></span><br><span class="line">    <span class="comment">// before setDataSource(). The redundant call to setVideoSurfaceTexture()</span></span><br><span class="line">    <span class="comment">// in prepare/prepareAsync covers for this case.</span></span><br><span class="line">    <span class="comment">//如果MediaPlayer没有初始化，这一步会失败。原因可能是setDisplay在setDataSource之前。如果在prepare/prepareAsync 时想规避这个错误而去调用setVideoSurfaceTexture是多余的。</span></span><br><span class="line">    <span class="comment">//最终会调用C++层的setVideoSurfaceTexture方法，下一节在分析</span></span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(new_st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decVideoSurfaceRef</span><span class="params">(JNIEnv *env, jobject thiz)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; old_st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (old_st != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old_st-&gt;decStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一步主要是对图像显示的surface的保存，然后将旧的IGraphicBufferProducer强引用减一，再获得新的IGraphicBufferProducer，最后会调用C++的MediaPlayer的setVideoSurfaceTexture将它折纸进去。</p>
<p>&#160; &#160; &#160; &#160;IGraphicBufferProducer是SurfaceFlinger的内容，一个UI完全显示到diplay的过程，SurfaceFlinger扮演着重要的角色但是它的职责是“Flinger”，即把系统中所有应用程序的最终的“绘图结果”进行“混合”，然后统一显示到物理屏幕上，而其他方面比如各个程序的绘画过程，就由其他东西来担任了。这个光荣的任务自然而然地落在了BufferQueue的肩膀上，它是每个应用程序“一对一”的辅导老师，指导着UI程序的“画板申请”、“作画流程”等一系列细节。下面的图描述了这三者的关系：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%80%29----MediaPlayer%E6%A1%86%E6%9E%B6%E5%BC%80%E5%A7%8B/IGraphicBufferProducer.png" alt="IGraphicBufferProducer"></p>
<p>&#160; &#160; &#160; &#160;虽说是三者的关系，但是他们所属的层却只有两个，app属于Java层，BufferQueue/SurfaceFlinger属于native层。也就是说BufferQueue也是隶属SurfaceFlinger，所有工作围绕SurfaceFlinger展开。<br>&#160; &#160; &#160; &#160;这里IGraphicBufferProducer就是app和BufferQueue重要桥梁，GraphicBufferProducer承担着单个应用进程中的UI显示需求，与BufferQueue打交道的就是它。</p>
<p>&#160; &#160; &#160; &#160;后面的prepare和start直接和C++层MediaPlayer相关，因此我们再下一节分析，这里就简单到此。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;本节只是简单分析上层MediaPlayer调用的一些工作，下一节开始将详细分析后续流程，包括对不同数据源创建不同DataSource，prepare过程中对于系统播放器的选择，底层解码和厂商对OpenMax接口的实现，当然还有整个多媒体框架的C/S架构分析。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E4%B8%80%29----MediaPlayer%E6%A1%86%E6%9E%B6%E5%BC%80%E5%A7%8B/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA线程池简单分析]]></title>
      <url>http://windrunnerlihuan.com/2016/10/31/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;java 1.5引入了<strong>java.util.concurrent</strong>包，作者是<a href="http://ifeve.com/doug-lea/" target="_blank" rel="external">Doug Lea</a>这位史诗级别的老爷子。今天我们只挑选并发包下线程池的部分内容分析。<br><a id="more"></a></p>
<h1 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h1><p>&#160; &#160; &#160; &#160;对于线程池的使用开发者都已经得心应手了。如果查看源码，都和<strong>ThreadPoolExecutor </strong>这个类相关。</p>
<h2 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h2><p>&#160; &#160; &#160; &#160;ThreadPoolExecutor 提供了四种构造方法实现(这里只介绍一种)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                             <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                             <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                             TimeUnit unit,</span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                             ThreadFactory threadFactory,</span><br><span class="line">                             RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;参数大概意思如下：</p>
<ul>
<li><strong>corePoolSize</strong>：核心运行的poolSize，也就是当超过这个范围的时候，就需要将新的Runnable放入到等待队列workQueue中了，我们把这些Runnable就叫做要去执行的任务吧。</li>
<li><strong>maximumPoolSize</strong>：一般你用不到，当大于了这个值就会将任务由一个丢弃处理机制来处理，但是当你发生：newFixedThreadPool的时候，corePoolSize和maximumPoolSize是一样的，而corePoolSize是先执行的，所以他会先被放入等待队列，而不会执行到下面的丢弃处理中，看了后面的代码你就知道了。</li>
<li><strong>workQueue</strong>：等待队列，当达到corePoolSize的时候，就向该等待队列放入线程信息（默认为一个LinkedBlockingQueue），运行中的线程属性为：workers，为一个HashSet；我们的Runnable内部被包装了一层，后面会看到这部分代码；这个队列默认是一个无界队列（你也可以设定一个有界队列），所以在生产者疯狂生产的时候，考虑如何控制的问题。</li>
<li><strong>keepAliveTime</strong>：默认都是0，当线程没有任务处理后，保持多长时间，当你使用：newCachedThreadPool()，它将是60s的时间。这个参数在运行中的线程从workQueue获取任务时，当(poolSize &gt;corePoolSize || allowCoreThreadTimeOut)会用到，当然allowCoreThreadTimeOut要设置为true，也会先判定keepAliveTime是大于0的。</li>
<li><strong>threadFactory</strong>：是构造Thread的方法，你可以自己去包装和传递，主要实现newThread方法即可。</li>
<li><strong>handler</strong>：也就是参数maximumPoolSize达到后丢弃处理的方法，java提供了5种丢弃处理的方法，当然你也可以自己根据实际情况去重写，主要是要实现接口：RejectedExecutionHandler中的方法： public void rejectedExecution(Runnabler, ThreadPoolExecutor e) java默认的是使用：AbortPolicy，他的作用是当出现这中情况的时候会抛出一个异常。</li>
</ul>
<p>其余的handler还包括：<br>1、CallerRunsPolicy：如果发现线程池还在运行，就直接运行这个线程。<br>2、DiscardOldestPolicy：在线程池的等待队列中，将头取出一个抛弃，然后将当前线程放进去。<br>3、DiscardPolicy：什么也不做。<br>4、AbortPolicy：java默认，抛出一个异常：RejectedExecutionException。<br>你可以自己写一个，例如我们想在这个处理中，既不是完全丢弃，也不是完全启动，也不是抛异常，而是控制生产者的线程，那么你就可以尝试某种方式将生产者的线程blocking住，其实就有点类似提到的Semaphor的功能了。</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>&#160; &#160; &#160; &#160;ThreadPoolExecutor 类中将线程状态（ runState）分为了以下五种：</p>
<blockquote>
<p>RUNNING：可以接受新任务并且处理进入队列中的任务<br>SHUTDOWN：不接受新任务，但是仍然执行队列中的任务<br>STOP：不接受新任务也不执行队列中的任务<br>TIDYING：所有任务中止，队列为空，进入该状态下的任务会执行 terminated()方法<br>TERMINATED： terminated()方法执行完成后进入该状态</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;状态之间的转换如下：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用了 shutdown()方法，可能是在 finalize()方法中被隐式调用</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：调用 shutdownNow()</li>
<li>SHUTDOWN -&gt; TIDYING：当队列和线程池都为空时</li>
<li>STOP -&gt; TIDYING：线程池为空时</li>
<li>TIDYING -&gt; TERMINATED：terminated()方法执行完成</li>
</ul>
<p>&#160; &#160; &#160; &#160;这几个变量的定义代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面的原子变量ctl 是整个类的核心，AtomicInteger保证了对这个变量的操作是原子的，通过巧妙的操作，ThreadPoolExecutor用这一个变量保存了两个内容：</p>
<ul>
<li>所有有效线程的数量（workerCount）</li>
<li>各个线程的状态（runState）</li>
</ul>
<p>&#160; &#160; &#160; &#160;低29位存线程数workerCount，高3位存runState。</p>
<p>&#160; &#160; &#160; &#160;所以将上述六个常量打印出来如下：</p>
<ul>
<li>00011111111111111111111111111111    ——    CAPACITY</li>
<li>11100000000000000000000000000000    ——    RUNNING</li>
<li>00000000000000000000000000000000    ——    SHUTDOWN</li>
<li>00100000000000000000000000000000    ——    STOP</li>
<li>01000000000000000000000000000000    ——    TIDYING</li>
<li>01100000000000000000000000000000    ——    TERMINATED</li>
</ul>
<p>&#160; &#160; &#160; &#160;第一行代表线程容量，后面5行提取高3位得到：</p>
<ul>
<li>111 - RUNNING</li>
<li>000 - SHUTDOWN</li>
<li>001 - STOP</li>
<li>010 - TIDYING</li>
<li>011 - TERMINATED</li>
</ul>
<p>&#160; &#160; &#160; &#160;分别对应5种状态，可以看到这样定义之后，只需要通过简单的移位操作就可以进行状态的转换。<br>&#160; &#160; &#160; &#160;围绕ctl变量有一些操作，了解这些方法是看懂后面一些晦涩代码的基础：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 这个方法用于取出runState的值 因为CAPACITY值为：00011111111111111111111111111111</span><br><span class="line"> * ~为按位取反操作，则~CAPACITY值为：11100000000000000000000000000000</span><br><span class="line"> * 再同参数做&amp;操作，就将低29位置0了，而高3位还是保持原先的值，也就是runState的值</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> c</span><br><span class="line"> *            该参数为存储runState和workerCount的int值</span><br><span class="line"> * <span class="doctag">@return</span> runState的值</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 这个方法用于取出workerCount的值</span><br><span class="line"> * 因为CAPACITY值为：00011111111111111111111111111111，所以&amp;操作将参数的高3位置0了</span><br><span class="line"> * 保留参数的低29位，也就是workerCount的值</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> c</span><br><span class="line"> *            ctl, 存储runState和workerCount的int值</span><br><span class="line"> * <span class="doctag">@return</span> workerCount的值</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将runState和workerCount存到同一个int中</span><br><span class="line"> * “|”运算的意思是，假设rs的值是101000，wc的值是000111，则他们位或运算的值为101111</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> rs</span><br><span class="line"> *            runState移位过后的值，负责填充返回值的高3位</span><br><span class="line"> * <span class="doctag">@param</span> wc</span><br><span class="line"> *            workerCount移位过后的值，负责填充返回值的低29位</span><br><span class="line"> * <span class="doctag">@return</span> 两者或运算过后的值</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs | wc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有RUNNING状态会小于0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><h2 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h2><p>&#160; &#160; &#160; &#160;给线程池加入任务的方法为execute方法，该方法策略大概分三步：<br>&#160; &#160; &#160; &#160;1）活动线程小于corePoolSize的时候创建新的线程；<br>&#160; &#160; &#160; &#160;2）活动线程大于corePoolSize时都是先加入到任务队列当中；<br>&#160; &#160; &#160; &#160;3）任务队列满了再去启动新的线程，如果线程数达到最大值就拒绝任务。<br>&#160; &#160; &#160; &#160;代码及注释如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 活动线程数 &lt; corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新的线程。第二个参数true:addWorker中会重新检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="comment">// 添加成功返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 活动线程数 &gt;= corePoolSize</span></span><br><span class="line">    <span class="comment">// runState为RUNNING &amp;&amp; 队列未满</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// double check</span></span><br><span class="line">        <span class="comment">// 非RUNNING状态 则从workQueue中移除任务并拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);<span class="comment">// 采用线程池指定的策略拒绝任务</span></span><br><span class="line">        <span class="comment">// 线程池处于RUNNING状态 || 线程池处于非RUNNING状态但是任务移除失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 这行代码是为了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">            <span class="comment">// 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两种情况：</span></span><br><span class="line">        <span class="comment">// 1.非RUNNING状态拒绝新的任务</span></span><br><span class="line">        <span class="comment">// 2.队列满了启动新的线程失败（workCount &gt; maximumPoolSize）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;注释比较清楚了就不再解释了，其中比较难理解的应该是addWorker(null, false);这一行，这要结合addWorker一起来看。 主要目的是防止HUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</p>
<h2 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h2><p>&#160; &#160; &#160; &#160;addWorker即创建新线程。检查在当前线程池状态和限制下能否创建一个新线程，如果可以，会相应改变workerCount，每个worker都会运行他们的firstTask。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">// 当前线程池状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="comment">// 这条语句等价：rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null ||</span></span><br><span class="line">            <span class="comment">// workQueue.isEmpty())</span></span><br><span class="line">            <span class="comment">// 满足下列调价则直接返回false，线程创建失败:</span></span><br><span class="line">            <span class="comment">// rs &gt; SHUTDOWN:STOP || TIDYING || TERMINATED 此时不再接受新的任务，且所有任务执行结束</span></span><br><span class="line">            <span class="comment">// rs = SHUTDOWN:firtTask != null 此时不再接受任务，但是仍然会执行队列中的任务</span></span><br><span class="line">            <span class="comment">// rs = SHUTDOWN:firtTask == null见execute方法的addWorker(null,</span></span><br><span class="line">            <span class="comment">// false)，任务为null &amp;&amp; 队列为空</span></span><br><span class="line">            <span class="comment">// 最后一种情况也就是说SHUTDONW状态下，如果队列不为空还得接着往下执行，为什么？add一个null任务目的到底是什么？</span></span><br><span class="line">            <span class="comment">// 看execute方法只有workCount==0的时候firstTask才会为null结合这里的条件就是线程池SHUTDOWN了不再接受新任务</span></span><br><span class="line">            <span class="comment">// 但是此时队列不为空，那么还得创建线程把任务给执行完才行。</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 走到这的情形：</span></span><br><span class="line">            <span class="comment">// 1.线程池状态为RUNNING</span></span><br><span class="line">            <span class="comment">// 2.SHUTDOWN状态，但队列中还有任务需要执行</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))<span class="comment">// 原子操作递增workCount</span></span><br><span class="line">                    <span class="keyword">break</span> retry;<span class="comment">// 操作成功跳出的重试的循环</span></span><br><span class="line">                c = ctl.get(); <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)<span class="comment">// 如果线程池的状态发生变化则重试</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wokerCount递增成功</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 并发的访问线程池workers对象必须加锁</span></span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// RUNNING状态 || SHUTDONW状态下清理队列中剩余的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">// 将新启动的线程添加到线程池中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="comment">// 更新largestPoolSize</span></span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</span></span><br><span class="line">                <span class="comment">// 当等待keepAlieTime还没有任务执行则该线程结束。见runWoker和getTask方法的代码。</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();<span class="comment">// 最终执行的是ThreadPoolExecutor的runWoker方法</span></span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程启动失败，则从wokers中移除w并递减wokerCount</span></span><br><span class="line">            <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">                <span class="comment">// 递减wokerCount会触发tryTerminate方法</span></span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;内部类Worker是对任务的封装，所有submit的Runnable都被封装成了Worker，它本身也是一个Runnable， 然后利用<strong>AQS</strong>框架实现了一个简单的非重入的互斥锁， 实现互斥锁主要目的是为了中断的时候判断线程是在空闲还是运行，可以看后面shutdown和shutdownNow方法的分析。Worker中获取和释放锁相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state只有0和1，互斥</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 成功获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程进入等待队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;之所以不用ReentrantLock是为了避免任务执行的代码中修改线程池的变量，如<strong>setCorePoolSize</strong>，因为ReentrantLock是可重入的。</p>
<h2 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h2><p>&#160; &#160; &#160; &#160;任务添加成功后实际执行的是runWorker这个方法，这个方法非常重要，简单来说它做的就是：<br>&#160; &#160; &#160; &#160;1）第一次启动会执行初始化传进来的任务firstTask；<br>&#160; &#160; &#160; &#160;2）然后会从workQueue中取任务执行，如果队列为空则等待keepAliveTime这么长时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Worker的构造函数中抑制了线程中断setState(-1)，所以这里需要unlock从而允许中断</span></span><br><span class="line">        w.unlock();</span><br><span class="line">        <span class="comment">// 用于标识是否异常终止，finally中processWorkerExit的方法会有不同逻辑</span></span><br><span class="line">        <span class="comment">// 为true的情况：1.执行任务抛出异常；2.被中断。</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果getTask返回null那么getTask中会将workerCount递减，如果异常了这个递减操作会在processWorkerExit中处理</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted. This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)))</span><br><span class="line">                        &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务执行前可以插入一些处理，子类重载该方法</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();<span class="comment">// 执行用户任务</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x;</span><br><span class="line">                        <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x;</span><br><span class="line">                        <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 和beforeExecute一样，留给子类去重载</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 结束线程的一些清理工作</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h2><p>&#160; &#160; &#160; &#160;runWorker方法里有一段会调用getTask判断，主要用来取出队列中的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        retry: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="comment">// 1.rs &gt; SHUTDOWN 所以rs至少等于STOP,这时不再处理队列中的任务</span></span><br><span class="line">            <span class="comment">// 2.rs = SHUTDOWN 所以rs&gt;=STOP肯定不成立，这时还需要处理队列中的任务除非队列为空</span></span><br><span class="line">            <span class="comment">// 这两种情况都会返回null让runWoker退出while循环也就是当前线程结束了，所以必须要decrement</span></span><br><span class="line">            <span class="comment">// wokerCount</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">// 递减workerCount值</span></span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记从队列中取任务时是否设置超时时间</span></span><br><span class="line">            <span class="keyword">boolean</span> timed; <span class="comment">// Are workers subject to culling?</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.RUNING状态</span></span><br><span class="line">            <span class="comment">// 2.SHUTDOWN状态，但队列中还有任务需要执行</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1.core thread允许被超时，那么超过corePoolSize的的线程必定有超时</span></span><br><span class="line">                <span class="comment">// 2.allowCoreThreadTimeOut == false &amp;&amp; wc &gt;</span></span><br><span class="line">                <span class="comment">// corePoolSize时，一般都是这种情况，core thread即使空闲也不会被回收，只要超过的线程才会</span></span><br><span class="line">                timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从addWorker可以看到一般wc不会大于maximumPoolSize，所以更关心后面半句的情形：</span></span><br><span class="line">                <span class="comment">// 1. timedOut == false 第一次执行循环， 从队列中取出任务不为null方法返回 或者</span></span><br><span class="line">                <span class="comment">// poll出异常了重试</span></span><br><span class="line">                <span class="comment">// 2.timeOut == true &amp;&amp; timed ==</span></span><br><span class="line">                <span class="comment">// false:看后面的代码workerQueue.poll超时时timeOut才为true，</span></span><br><span class="line">                <span class="comment">// 并且timed要为false，这两个条件相悖不可能同时成立（既然有超时那么timed肯定为true）</span></span><br><span class="line">                <span class="comment">// 所以超时不会继续执行而是return null结束线程。（重点：线程是如何超时的？？？）</span></span><br><span class="line">                <span class="keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; !(timedOut &amp;&amp; timed))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// workerCount递减，结束当前thread</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                c = ctl.get(); <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="comment">// 需要重新检查线程池状态，因为上述操作过程中线程池可能被SHUTDOWN</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1.以指定的超时时间从队列中取任务</span></span><br><span class="line">                <span class="comment">// 2.core thread没有超时</span></span><br><span class="line">                Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;<span class="comment">// 超时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;<span class="comment">// 线程被中断重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h2><p>&#160; &#160; &#160; &#160;线程退出会执行这个方法做一些清理工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 正常的话再runWorker的getTask方法workerCount已经被减一了</span></span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 累加线程的completedTasks</span></span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            <span class="comment">// 从线程池中移除超时或者出现异常的线程</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试停止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// runState为RUNNING或SHUTDOWN</span></span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            <span class="comment">// 线程不是异常结束</span></span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="comment">// 线程池最小空闲数，允许core thread超时就是0，否则就是corePoolSize</span></span><br><span class="line">                <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="comment">// 如果min == 0但是队列不为空要保证有1个线程来执行队列中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 线程池还不为空那就不用担心了</span></span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.线程异常退出</span></span><br><span class="line">            <span class="comment">// 2.线程池为空，但是队列中还有任务没执行，看addWoker方法对这种情况的处理</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h2><p>&#160; &#160; &#160; &#160;processWorkerExit方法中会尝试调用tryTerminate来终止线程池。这个方法在任何可能导致线程池终止的动作后执行：比如减少wokerCount或SHUTDOWN状态下从队列中移除任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">// 以下状态直接返回：</span></span><br><span class="line">            <span class="comment">// 1.线程池还处于RUNNING状态</span></span><br><span class="line">            <span class="comment">// 2.SHUTDOWN状态但是任务队列非空</span></span><br><span class="line">            <span class="comment">// 3.runState &gt;= TIDYING 线程池已经停止了或在停止了</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只能是以下情形会继续下面的逻辑：结束线程池。</span></span><br><span class="line">            <span class="comment">// 1.SHUTDOWN状态，这时不再接受新任务而且任务队列也空了</span></span><br><span class="line">            <span class="comment">// 2.STOP状态，当调用了shutdownNow方法</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// workerCount不为0则还不能停止线程池,而且这时线程都处于空闲等待的状态</span></span><br><span class="line">            <span class="comment">// 需要中断让线程“醒”过来，醒过来的线程才能继续处理shutdown的信号。</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">                <span class="comment">// runWoker方法中w.unlock就是为了可以被中断,getTask方法也处理了中断。</span></span><br><span class="line">                <span class="comment">// ONLY_ONE:这里只需要中断1个线程去处理shutdown信号就可以了。</span></span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 进入TIDYING状态</span></span><br><span class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 子类重载：一些资源清理工作</span></span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// TERMINATED状态</span></span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                        <span class="comment">// 继续awaitTermination</span></span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="shutdown和shutdownNow"><a href="#shutdown和shutdownNow" class="headerlink" title="shutdown和shutdownNow"></a>shutdown和shutdownNow</h2><p>&#160; &#160; &#160; &#160;shutdown这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">// 线程池状态设为SHUTDOWN，如果已经至少是这个状态那么则直接返回</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">// 注意这里是中断所有空闲的线程：runWorker中等待的线程被中断 → 进入processWorkerExit →</span></span><br><span class="line">            <span class="comment">// tryTerminate方法中会保证队列中剩余的任务得到执行。</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;shutdownNow方法将runState置为STOP。和shutdown方法的区别，这个方法会终止所有的线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// STOP状态：不再接受新任务且不再执行队列中的任务。</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 返回队列中还没有被执行的任务。</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;主要区别在于shutdown调用的是interruptIdleWorkers这个方法，而shutdownNow实际调用的是Worker类的interruptIfStarted方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// w.tryLock能获取到锁，说明该线程没有在运行，因为runWorker中执行任务会先lock，</span></span><br><span class="line">            <span class="comment">// 因此保证了中断的肯定是空闲的线程。</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// 初始化时state == -1</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这就是前面提到的Woker类实现AQS的主要作用。AQS这个类在并发包下的地位还是举足轻重的，大家可以在<code>并发编程网</code>找找相关资料，或者<a href="http://ifeve.com/abstractqueuedsynchronizer-use/" target="_blank" rel="external">这篇</a>。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;因为注释比较多，所以看起来比较无聊。核心方法就那么些，实现细节就是那些double check的部分。还有状态和数量的计算。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg" alt="结语"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android壁纸开发流程分析]]></title>
      <url>http://windrunnerlihuan.com/2016/10/08/Android%E5%A3%81%E7%BA%B8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;起因是产品汪的一个奇葩需求，要求播放视频使用背景播放，前台还可以随意操作其他东西，就像PS4那样的。所以不得不研究一下动态壁纸了，中途也是遇到了无数坑，但终于还是做出来了。这里就简单介绍一下Android对壁纸的管理流程。<br><a id="more"></a></p>
<h1 id="壁纸设置"><a href="#壁纸设置" class="headerlink" title="壁纸设置"></a>壁纸设置</h1><p>&#160; &#160; &#160; &#160;Android为我们提供了壁纸服务，让我们的桌面看起来更加绚丽。打开设置我们都会发现，壁纸有动态和静态之分。静态壁纸就是一张图片，可以选择系统预留的也可以设置自己的照片；动态壁纸就比较复杂了，内容在不停地变换，系统也给我们提供了许多种选择。接下来我们先说说这两种壁纸如何设置。</p>
<h2 id="静态壁纸"><a href="#静态壁纸" class="headerlink" title="静态壁纸"></a>静态壁纸</h2><p>&#160; &#160; &#160; &#160;设置静态壁纸有很多途径，但归根结底都是一下三种方法：</p>
<ul>
<li>使用WallpaperManager的setResource(int ResourceID)方法</li>
<li>使用WallpaperManager的setBitmap(Bitmap bitmap)方法</li>
<li>使用WallpaperManager的setStream(InputStream data)方法</li>
</ul>
<p>&#160; &#160; &#160; &#160;举个栗子，就选第一个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WallpaperManager wallpaperManager = WallpaperManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	wallpaperManager.setResource(R.drawable.picture);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其他两个和第一个一样，只不过将要设为壁纸的图片参数换成了Bitmap和InputStream。然后就是不要忘了加上以下权限：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span> = <span class="string">"android.permission.SET_WALLPAPER"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态壁纸"><a href="#动态壁纸" class="headerlink" title="动态壁纸"></a>动态壁纸</h2><p>&#160; &#160; &#160; &#160;首先动态壁纸的动态体现出这个组件是实时变化的，也就是说有一个后台在不停的刷新这个组件。联想到后台组件首先想到的就是service，从代码角度看，果然如此。每一个动态壁纸都继承自WallpaperService，其中必须实现的抽象方法onCreateEngine，返回一个Engine对象，实际上所有的绘图与刷新都是由engine完成，service正是提供engine的部分。<br>&#160; &#160; &#160; &#160;打个比方说，在我们设置一个动态壁纸时有预览，这时启动了一个预览的engine来绘制与刷新，当我们设置了壁纸以后又启动了一个填充整个桌面的engine在实时的绘制与刷新。所以动态壁纸的重点在engine里，有几个重要的方法：</p>
<p><strong>public void onCreate(SurfaceHolder surfaceHolder)</strong><br>有了surfaceholder我们可以获得canvas对象，有了canvas我们就可以绘图 </p>
<p><strong>public void onOffsetsChanged(float xOffset, float yOffset, float xOffsetStep, float yOffsetStep, int xPixelsOffset, int yPixelsOffset)</strong><br>屏幕滑动的时候触发此方法<br>xOffset可以用来判断屏幕序号 百分比的形式，举例说如果你手机上有5个分屏，第一屏这里是0.000，第二屏是0.2000 第三屏是0.4000以此类推<br>xOffsetStep从字面意义就能理解是步进 同样和你的分屏数有关 如果你的分屏数为5 则每次步进xOffsetStep都是0.20000<br>xPixelsOffset就是实际上像素的移动距离，也就是说移动了多少像素，奇怪的是这里左右移动像素点的offset都为负数</p>
<p><strong>public void onVisibilityChanged(boolean visible)</strong><br>当动态壁纸的可见性发生变化时触发此方法，举例说在桌面上时，动态壁纸的visibility为true，当你运行某个程序的时候动态壁纸的visibility变为false，这里很好理解 </p>
<p><strong>public Bundle onCommand(String action, int x, int y, int z, Bundle extras, boolean resultRequested)</strong><br>可以监听点击事件，点击时触发此方法，action为 android.wallpaper.tap，x记录了横坐标，y记录了纵坐标，z的作用未知，可能是为3d桌面预留下的？ 没有试验过，z一般为0</p>
<p>还有一些重要的生命周期方法，和activity类似，就不多说了。 </p>
<p>&#160; &#160; &#160; &#160;因为动态壁纸是一个Service，还必须在清单文件中进行一些配置，比如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置动态壁纸Service --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span><br><span class="line">	<span class="attr">android:name</span>=<span class="string">".LiveWallpaper"</span></span><br><span class="line">	<span class="attr">android:permission</span>=<span class="string">"android.permission.BIND_WALLPAPER"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 为动态壁纸配置intent-filter --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span>	<span class="attr">android:name</span>=<span class="string">"android.service.wallpaper.WallpaperService"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 为动态壁纸配置meta-data --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"android.service.wallpaper"</span></span><br><span class="line">		<span class="attr">android:resource</span>=<span class="string">"@xml/livewallpaper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;比较重要的部分首先是权限android:permission=”android.permission.BIND_WALLPAPER”；<br>&#160; &#160; &#160; &#160;其次service需要响应action：android:name=”android.service.wallpaper.WallpaperService；<br>&#160; &#160; &#160; &#160;再就是配置文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">"android.service.wallpaper"</span></span><br><span class="line">	<span class="attr">android:resource</span>=<span class="string">"@xml/livewallpaper"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来接收配置文件。首先在res文件夹下建立一个xml目录，和写appwidget一样。在目录下我们创建一个xml文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">wallpaper</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span><br><span class="line">    <span class="attr">android:settingsActivity</span>=<span class="string">"LiveWallPreference"</span>  </span><br><span class="line">    <span class="attr">android:thumbnail</span>=<span class="string">"@drawable/ic_launcher"</span>  </span><br><span class="line">    <span class="attr">android:description</span>=<span class="string">"@string/wallpaper_description"</span>  </span><br><span class="line">    /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中含义如下：</p>
<p><strong>android:settingsActivity=”LiveWallPreference” </strong><br>指定配置动态壁纸的PreferenceActivity，这个PreferenceActivity同样需要在AndroidManifest.xml中注册，不过和一般的activity一样。当我们点击动态壁纸的设置按钮时，导向这个activity。不可缺少，否则点击设置会报错。</p>
<p><strong>android:thumbnail=”@drawable/ic_launcher” </strong><br><strong>android:description=”@string/wallpaper_description” </strong><br>第一个图标对应动态壁纸列表中的图标，第二条description则是图标右边你创建的动态壁纸的名字。</p>
<p>&#160; &#160; &#160; &#160;至此动态壁纸的框架就算完成了。接下来只需要在wallpaperservice类中加入刷新机制，加入动态内容，一个动态桌面就完成了。</p>
<p>&#160; &#160; &#160; &#160;这里我贴一个魔方的动态壁纸：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A wallpaper service is responsible for showing a live wallpaper behind</span><br><span class="line"> * applications that would like to sit on top of it. This service object itself</span><br><span class="line"> * does very little -- its only purpose is to generate instances of</span><br><span class="line"> * WallpaperService.Engine as needed. Implementing a wallpaper thus involves</span><br><span class="line"> * subclassing from this, subclassing an Engine implementation, and implementing</span><br><span class="line"> * onCreateEngine() to return a new instance of your engine</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CubeWallpaper1</span> <span class="keyword">extends</span> <span class="title">WallpaperService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*常用的都是这样的，用一个handler来动态的去刷新UI，对吧？猜的，看下面代码到底是不是*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 这个方法与Activity里面的一样，当这个类的服务被第一次创建时</span><br><span class="line">	 * 调用，也就是说，这个方法只调用一次..</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 与上面反的，销毁时调用，这个猜下，</span><br><span class="line">	 * 不懂了查文档</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 这个方法在类注释中写明了</span><br><span class="line">	 * implementing onCreateEngine() to return a new instance of your engine</span><br><span class="line">	 * 必须实现这个方法来返回我们自己定义引擎的一个实例</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Engine <span class="title">onCreateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CubeEngine();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * </span><br><span class="line">	* <span class="doctag">@Title</span>: CubeWallpaper1.java</span><br><span class="line">	* <span class="doctag">@Package</span> cube1</span><br><span class="line">	* <span class="doctag">@Description</span>: 自定义引擎类</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">CubeEngine</span> <span class="keyword">extends</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Paint mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">float</span> mOffset;</span><br><span class="line">		<span class="comment">/*用户触摸位置*/</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">float</span> mTouchX = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">float</span> mTouchY = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">long</span> mStartTime;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*屏幕中心坐标，记下，是中心不是原心（0，0）*/</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">float</span> mCenterX;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">float</span> mCenterY;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Runnable mDrawCube = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				drawFrame();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> mVisible;</span><br><span class="line"></span><br><span class="line">		CubeEngine() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/*下面这几行就为了在屏幕中画立方体的线条而做准备*/</span></span><br><span class="line">			<span class="keyword">final</span> Paint paint = mPaint;</span><br><span class="line">			paint.setColor(<span class="number">0xffffffff</span>);<span class="comment">//画笔颜色</span></span><br><span class="line">			paint.setAntiAlias(<span class="keyword">true</span>);<span class="comment">//抗锯齿</span></span><br><span class="line">			paint.setStrokeWidth(<span class="number">2</span>);<span class="comment">//线条粗细，猜的，不知道对不对</span></span><br><span class="line">			paint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">			paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">			<span class="comment">//系统启动完之后，开始绘制壁纸的时间，这个时间里面包含有系统睡眠时间</span></span><br><span class="line">			mStartTime = SystemClock.elapsedRealtime();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * 大家发现这个onCreate与Activity的方法有什么不同了吧？</span><br><span class="line">		 * 老规矩的，还是在初始化壁纸引擎的时候调用这个方法，并设置触</span><br><span class="line">		 * 屏事件为可用</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SurfaceHolder surfaceHolder)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.onCreate(surfaceHolder);</span><br><span class="line">			setTouchEventsEnabled(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.onDestroy();</span><br><span class="line">			mHandler.removeCallbacks(mDrawCube);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * 系统壁纸状态改变时会调用这个方法，如：</span><br><span class="line">		 * 壁纸由隐藏转换为显示状态时会调用这个方法</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVisibilityChanged</span><span class="params">(<span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">			mVisible = visible;</span><br><span class="line">			<span class="comment">/*下面这个判断好玩，就是说，如果屏幕壁纸状态转为显式时重新绘制壁纸，否则黑屏幕，隐藏就可以*/</span></span><br><span class="line">			<span class="keyword">if</span> (visible) &#123;</span><br><span class="line">				drawFrame();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				mHandler.removeCallbacks(mDrawCube);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format,</span><br><span class="line">				<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.onSurfaceChanged(holder, format, width, height);</span><br><span class="line">			<span class="comment">//下面是来保存屏幕显示立方体的，也就是你能看到的正面图的中心位置</span></span><br><span class="line">			mCenterX = width / <span class="number">2.0f</span>;</span><br><span class="line">			mCenterY = height / <span class="number">2.0f</span>;</span><br><span class="line">			drawFrame();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * 下面两个方法是为了方便调用SurfaceHolder交互来重写的</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.onSurfaceCreated(holder);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.onSurfaceDestroyed(holder);</span><br><span class="line">			mVisible = <span class="keyword">false</span>;</span><br><span class="line">			mHandler.removeCallbacks(mDrawCube);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * 当手动壁纸时根据偏移量重绘壁纸</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOffsetsChanged</span><span class="params">(<span class="keyword">float</span> xOffset, <span class="keyword">float</span> yOffset, <span class="keyword">float</span> xStep,</span><br><span class="line">				<span class="keyword">float</span> yStep, <span class="keyword">int</span> xPixels, <span class="keyword">int</span> yPixels)</span> </span>&#123;</span><br><span class="line">			mOffset = xOffset;</span><br><span class="line">			drawFrame();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 在这个地方保存触摸的位置，我们会在绘制壁纸的时候使用触摸值</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">				mTouchX = event.getX();</span><br><span class="line">				mTouchY = event.getY();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				mTouchX = -<span class="number">1</span>;</span><br><span class="line">				mTouchY = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 绘制立方体方法实现</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">final</span> SurfaceHolder holder = getSurfaceHolder();</span><br><span class="line"></span><br><span class="line">			Canvas c = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				c = holder.lockCanvas();</span><br><span class="line">				<span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">					drawCube(c);</span><br><span class="line">					drawTouchPoint(c);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (c != <span class="keyword">null</span>)</span><br><span class="line">					holder.unlockCanvasAndPost(c);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 在指定时间里重绘制，这个地方大家可以看效果图，如果你拖动过快的话，立方体</span></span><br><span class="line">			<span class="comment">//每个顶点之间会有一个短暂的未连接延迟，就是在这个地方使用了延迟来绘制的</span></span><br><span class="line">			mHandler.removeCallbacks(mDrawCube);</span><br><span class="line">			<span class="keyword">if</span> (mVisible) &#123;</span><br><span class="line">				mHandler.postDelayed(mDrawCube, <span class="number">1000</span> / <span class="number">25</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 *  这个地方是以立方体某个顶点为起始端，绘制三条线</span><br><span class="line">		 *  一堆数字，看着好晕  </span><br><span class="line">		 *  在这小马顺便贴在这个DEMO里面用到的基本的绘制，如下：</span><br><span class="line">		 *  graphics.Canvas有四种画矩形的方法。</span><br><span class="line">			canvas.drawRect(new RectF(10, 10, 300, 100), paint);</span><br><span class="line">			canvas.drawRect(10, 150, 300, 200, paint);</span><br><span class="line">			canvas.drawRect(new Rect(10, 250, 300, 300), paint);</span><br><span class="line">			第四种：画圆角的矩形</span><br><span class="line">			canvas.drawRoundRect(new RectF(10, 350, 300, 450), 10, 10, paint);</span><br><span class="line">			第二个和第三个参数为圆角的宽高。</span><br><span class="line">			有兴趣的朋友可以改下下面这些东西 </span><br><span class="line">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">drawCube</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">			c.save();</span><br><span class="line">			c.translate(mCenterX, mCenterY);</span><br><span class="line">			c.drawColor(<span class="number">0xff000000</span>);</span><br><span class="line">			drawLine(c, -<span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>);</span><br><span class="line">			drawLine(c, <span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>);</span><br><span class="line">			drawLine(c, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>);</span><br><span class="line">			drawLine(c, -<span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">			drawLine(c, -<span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">			drawLine(c, <span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">			drawLine(c, <span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">			drawLine(c, -<span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">			drawLine(c, -<span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>);</span><br><span class="line">			drawLine(c, <span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, -<span class="number">400</span>);</span><br><span class="line">			drawLine(c, <span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>);</span><br><span class="line">			drawLine(c, -<span class="number">400</span>, <span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>, <span class="number">400</span>, -<span class="number">400</span>);</span><br><span class="line">			c.restore();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 在屏幕中绘制三维空间的线</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Canvas c, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> z1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> z2)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 *因为大家都知道，壁纸是手机启动完成之后就已经开始绘制的，一般取时间什么的</span><br><span class="line">			 *我们都用Timer System.currentTimeMillis() Calendar来取</span><br><span class="line">			 *这个地方取系统级启动时间等的，记住这个类，SystemClock，方法自己查</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">long</span> now = SystemClock.elapsedRealtime();</span><br><span class="line">			<span class="comment">/*取得三维坐标轴的旋转值*/</span></span><br><span class="line">			<span class="keyword">float</span> xrot = ((<span class="keyword">float</span>) (now - mStartTime)) / <span class="number">1000</span>;</span><br><span class="line">			<span class="keyword">float</span> yrot = (<span class="number">0.5f</span> - mOffset) * <span class="number">2.0f</span>;</span><br><span class="line">			<span class="keyword">float</span> zrot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">// rotation around X-axis  ？？？</span></span><br><span class="line">			<span class="keyword">float</span> newy1 = (<span class="keyword">float</span>) (Math.sin(xrot) * z1 + Math.cos(xrot) * y1);</span><br><span class="line">			<span class="keyword">float</span> newy2 = (<span class="keyword">float</span>) (Math.sin(xrot) * z2 + Math.cos(xrot) * y2);</span><br><span class="line">			<span class="keyword">float</span> newz1 = (<span class="keyword">float</span>) (Math.cos(xrot) * z1 - Math.sin(xrot) * y1);</span><br><span class="line">			<span class="keyword">float</span> newz2 = (<span class="keyword">float</span>) (Math.cos(xrot) * z2 - Math.sin(xrot) * y2);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// rotation around Y-axis  ？？？</span></span><br><span class="line">			<span class="keyword">float</span> newx1 = (<span class="keyword">float</span>) (Math.sin(yrot) * newz1 + Math.cos(yrot) * x1);</span><br><span class="line">			<span class="keyword">float</span> newx2 = (<span class="keyword">float</span>) (Math.sin(yrot) * newz2 + Math.cos(yrot) * x2);</span><br><span class="line">			newz1 = (<span class="keyword">float</span>) (Math.cos(yrot) * newz1 - Math.sin(yrot) * x1);</span><br><span class="line">			newz2 = (<span class="keyword">float</span>) (Math.cos(yrot) * newz2 - Math.sin(yrot) * x2);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3D-to-2D projection  ？？？</span></span><br><span class="line">			<span class="keyword">float</span> startX = newx1 / (<span class="number">4</span> - newz1 / <span class="number">400</span>);</span><br><span class="line">			<span class="keyword">float</span> startY = newy1 / (<span class="number">4</span> - newz1 / <span class="number">400</span>);</span><br><span class="line">			<span class="keyword">float</span> stopX = newx2 / (<span class="number">4</span> - newz2 / <span class="number">400</span>);</span><br><span class="line">			<span class="keyword">float</span> stopY = newy2 / (<span class="number">4</span> - newz2 / <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">			c.drawLine(startX, startY, stopX, stopY, mPaint);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 按位屏幕手动时绘制一个白色的圈</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">drawTouchPoint</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (mTouchX &gt;= <span class="number">0</span> &amp;&amp; mTouchY &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				c.drawCircle(mTouchX, mTouchY, <span class="number">80</span>, mPaint);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160;上面都是一些设置壁纸的方法，但这实现不了产品汪的需求啊。产品汪想要Launcher一直用背景播放视频，设计喵出了许多应用的效果图，要求这些应用都可以和背景进行交互……唉，坑爹的需求，继续看源码吧。</p>
<h2 id="静态壁纸流程"><a href="#静态壁纸流程" class="headerlink" title="静态壁纸流程"></a>静态壁纸流程</h2><p>&#160; &#160; &#160; &#160;三种设置静态壁纸的方法，其实原理都大同小异。我们只看看WallpaperManager的setBitmap(Bitmap bitmap)方法，其他两种有兴趣的同学也可以自己看看位于framework/base/core/java/android/app/WallpaperManager.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBitmap</span><span class="params">(Bitmap bitmap)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sGlobals.mService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"WallpaperService not running"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//sGlobals.mService声明在WallpaperManager的内部类Globals里，对应系统服务WallpaperManagerService;</span></span><br><span class="line">            ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (fd == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">	            <span class="comment">//获得WallpaperManagerService返回的一个壁纸相关的文件描述符，然后将新壁纸内容写入</span></span><br><span class="line">                fos = <span class="keyword">new</span> ParcelFileDescriptor.AutoCloseOutputStream(fd);</span><br><span class="line">                bitmap.compress(Bitmap.CompressFormat.PNG, <span class="number">90</span>, fos);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Globals</span> <span class="keyword">extends</span> <span class="title">IWallpaperManagerCallback</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> IWallpaperManager mService;</span><br><span class="line">		......</span><br><span class="line">        </span><br><span class="line">        Globals(Looper looper) &#123;</span><br><span class="line">	        <span class="comment">//对应系统服务WallpaperManagerService</span></span><br><span class="line">            IBinder b = ServiceManager.getService(Context.WALLPAPER_SERVICE);</span><br><span class="line">            mService = IWallpaperManager.Stub.asInterface(b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;setBitmap方法内部有一段ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null)，这里sGlobals.mService声明在WallpaperManager的内部类Globals里，这个mService对应系统服务的WallpaperManagerService。它的setWallpaper方法返回的是一个文件描述符，我们猜测这个就是壁纸内容存放的fd，往下的代码就是将我们指定的bitmap写入这个fd。所以我们看看WallpaperManagerService的setWallpaper方法,位于frameworks/base/services/core/java/com/android/server/wallpaper/WallpaperManagerService.java中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParcelFileDescriptor <span class="title">setWallpaper</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    checkPermission(android.Manifest.permission.SET_WALLPAPER);</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">"setWallpaper"</span>);</span><br><span class="line">        <span class="comment">//先获取用户的userId</span></span><br><span class="line">        <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">        <span class="comment">//根据userId这个键去取WallpaperData这个壁纸包装类的值</span></span><br><span class="line">        WallpaperData wallpaper = mWallpaperMap.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (wallpaper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Wallpaper not yet initialized for user "</span> + userId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//获得壁纸文件的fd</span></span><br><span class="line">            ParcelFileDescriptor pfd = updateWallpaperBitmapLocked(name, wallpaper);</span><br><span class="line">            <span class="keyword">if</span> (pfd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wallpaper.imageWallpaperPending = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pfd;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里分三步：<br>&#160; &#160; &#160; &#160;1）先获取用户的userId，看看UserHandle.的getCallingUserId()方法，位于framework/base/core/java/android/os/UserHandle.java中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span><br><span class="line">  * <span class="doctag">@hide</span> Range of uids allocated for a user.</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PER_USER_RANGE = <span class="number">100000</span>;</span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * <span class="doctag">@hide</span> Enable multi-user related side effects. Set this to false if</span><br><span class="line">  * there are problems with single user use-cases.</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> MU_ENABLED = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getCallingUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getUserId(Binder.getCallingUid());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * Returns the user id for a given uid.</span><br><span class="line">  * <span class="doctag">@hide</span></span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getUserId</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (MU_ENABLED) &#123;</span><br><span class="line">         <span class="keyword">return</span> uid / PER_USER_RANGE;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因为Android从4.2之后支持了多用户，所以MU_ENABLED 的值为true。<br>&#160; &#160; &#160; &#160;这里Binder.getCallingUid()获得应用的uid，我们知道系统的uid是1000，之后应用都是从1000往后的。一些重要的system app，比如com.android.phone电话是1001，com.android.bluetooth蓝牙是1002等等；第三方应用则是从10000开始的，多装一个应用分配的uid就会+1，比如我装了个com.bilibili.tv 这个哔哩哔哩动画的uid是10019，之后又装了个tv.danmaku.bilixl哔哩哔哩动画经典版的uid就变为10020了；但是如果应用在清单文件中配置了android:sharedUserId=”android.uid.system”属性，那么这个应用的uid也是1000，不过一般需要打系统签名。<br>&#160; &#160; &#160; &#160;如果要查看应用的uid，可以查看android机器的/data/system/packages.list文件，上面都罗列了每个应用的包名和对应uid。</p>
<p>&#160; &#160; &#160; &#160;回到上面代码，返回值是用应用的uid除以100000，所以这里返回的是0。</p>
<p>&#160; &#160; &#160; &#160;2）根据userId这个键去取WallpaperData这个壁纸包装类的值。<br>&#160; &#160; &#160; &#160;这里userId是0，因为系统崩溃，所以下面那个异常不会抛出，这里mWallpaperMap.get(userId)获得的WallpaperData 对象wallpaper 不为空。<br>&#160; &#160; &#160; &#160;所以我们就得找这个WallpaperData 被存入mWallpaperMap的时机。在浏览WallpaperManagerService的构造方法是发现了存入时机，调用WallpaperManagerService构造方法是在SystemServer启动时调用的。因为android系统开机会启动framework，framework会启动它的SystemServer，代码实现如下，位于framework/base/services/java/com/android/server/SystemServer.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * The main entry point from zygote.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    ......</span><br><span class="line">	    startOtherServices();</span><br><span class="line">	    ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Starts a miscellaneous grab bag of stuff that has yet to be refactored</span><br><span class="line">     * and organized.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    ......</span><br><span class="line">	    WallpaperManagerService wallpaper = <span class="keyword">null</span>;</span><br><span class="line">	    ......</span><br><span class="line">	     <span class="keyword">if</span> (!disableNonCoreServices &amp;&amp; context.getResources().getBoolean(</span><br><span class="line">                        R.bool.config_enableWallpaperService)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">"Wallpaper Service"</span>);</span><br><span class="line">                    <span class="comment">//这里启动了WallpaperManagerService系统服务，加入ServiceManager中管理</span></span><br><span class="line">                    wallpaper = <span class="keyword">new</span> WallpaperManagerService(context);</span><br><span class="line">                    ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    reportWtf(<span class="string">"starting Wallpaper Service"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里启动了WallpaperManagerService后，然后我们继续分析他的构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WallpaperManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="comment">//生成壁纸相关目录/data/system/users/0</span></span><br><span class="line">    getWallpaperDir(UserHandle.USER_OWNER).mkdirs();</span><br><span class="line">    <span class="comment">//载入系统保存的配置，UserHandle.USER_OWNER为0</span></span><br><span class="line">    loadSettingsLocked(UserHandle.USER_OWNER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回 /data/system/users/&#123;userId&#125;</span><br><span class="line"> * <span class="doctag">@param</span> userId</span><br><span class="line"> * <span class="doctag">@return</span> /data/system/users/&#123;userId&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getWallpaperDir</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Environment.getUserSystemDirectory(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里先生成壁纸相关目录，/data/system/users/0这个目录。然后就是载入系统保存的配置，我们接着看loadSettingsLocked(UserHandle.USER_OWNER)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadSettingsLocked</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;<span class="comment">//0</span></span><br><span class="line">       </span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">//封装/data/system/users/0/wallpaper_info.xml文件的方法</span></span><br><span class="line">       JournaledFile journal = makeJournaledFile(userId);</span><br><span class="line">       FileInputStream stream = <span class="keyword">null</span>;</span><br><span class="line">       File file = journal.chooseForRead();</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//此时mWallpaperMap.get(0)为null</span></span><br><span class="line">       WallpaperData wallpaper = mWallpaperMap.get(userId);</span><br><span class="line">       <span class="keyword">if</span> (wallpaper == <span class="keyword">null</span>) &#123;<span class="comment">//会进入这里</span></span><br><span class="line">           wallpaper = <span class="keyword">new</span> WallpaperData(userId);</span><br><span class="line">           mWallpaperMap.put(userId, wallpaper);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//--------------解析/data/system/users/0/wallpaper_info.xml  START----------------</span></span><br><span class="line">           stream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">           XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">           parser.setInput(stream, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">int</span> type;</span><br><span class="line">           do &#123;</span><br><span class="line">               type = parser.next();</span><br><span class="line">               <span class="keyword">if</span> (type == XmlPullParser.START_TAG) &#123;</span><br><span class="line">                   String tag = parser.getName();</span><br><span class="line">                   <span class="keyword">if</span> (<span class="string">"wp"</span>.equals(tag)) &#123;</span><br><span class="line">                       wallpaper.width = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"width"</span>));</span><br><span class="line">                       wallpaper.height = Integer.parseInt(parser</span><br><span class="line">                               .getAttributeValue(<span class="keyword">null</span>, <span class="string">"height"</span>));</span><br><span class="line">                       wallpaper.padding.left = getAttributeInt(parser, <span class="string">"paddingLeft"</span>, <span class="number">0</span>);</span><br><span class="line">                       wallpaper.padding.top = getAttributeInt(parser, <span class="string">"paddingTop"</span>, <span class="number">0</span>);</span><br><span class="line">                       wallpaper.padding.right = getAttributeInt(parser, <span class="string">"paddingRight"</span>, <span class="number">0</span>);</span><br><span class="line">                       wallpaper.padding.bottom = getAttributeInt(parser, <span class="string">"paddingBottom"</span>, <span class="number">0</span>);</span><br><span class="line">                       wallpaper.name = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"name"</span>);</span><br><span class="line">                       String comp = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"component"</span>);</span><br><span class="line">                       wallpaper.nextWallpaperComponent = comp != <span class="keyword">null</span></span><br><span class="line">                               ? ComponentName.unflattenFromString(comp)</span><br><span class="line">                               : <span class="keyword">null</span>;</span><br><span class="line">                       <span class="keyword">if</span> (wallpaper.nextWallpaperComponent == <span class="keyword">null</span></span><br><span class="line">                               || <span class="string">"android"</span>.equals(wallpaper.nextWallpaperComponent</span><br><span class="line">                                       .getPackageName())) &#123;</span><br><span class="line">                           wallpaper.nextWallpaperComponent = mImageWallpaper;</span><br><span class="line">                       &#125;    </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">while</span> (type != XmlPullParser.END_DOCUMENT);</span><br><span class="line">	<span class="comment">//--------------解析/data/system/users/0/wallpaper_info.xml  END----------------</span></span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String WALLPAPER_INFO = <span class="string">"wallpaper_info.xml"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装/data/system/users/0/wallpaper_info.xml文件的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JournaledFile <span class="title">makeJournaledFile</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> String base = <span class="keyword">new</span> File(getWallpaperDir(userId), WALLPAPER_INFO).getAbsolutePath();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> JournaledFile(<span class="keyword">new</span> File(base), <span class="keyword">new</span> File(base + <span class="string">".tmp"</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入系统保存的配置，这里也是分三步：<br>&#160; &#160; &#160; &#160;1. 封装一下/data/system/users/0/wallpaper_info.xml文件，用JournaledFile这个工具类，这个工具类会包装两个文件，一个是wallpaper_info.xml正式文件，另一个是wallpaper_info.xml.tmp临时文件。如果正式文件存在就选出正式文件，并删除临时文件；如果正式文件不存在就将临时文件重名为正式文件。<br>&#160; &#160; &#160; &#160;2. 创建一个WallpaperData并存入WallpaperData ，我们可以看看WallpaperData 的构造，这是一个内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String WALLPAPER = <span class="string">"wallpaper"</span>;</span><br><span class="line">      WallpaperData(<span class="keyword">int</span> userId) &#123;<span class="comment">//0</span></span><br><span class="line">          <span class="keyword">this</span>.userId = userId;</span><br><span class="line">          <span class="comment">//位于/data/system/users/0/wallpaper，是存放壁纸的文件</span></span><br><span class="line">          wallpaperFile = <span class="keyword">new</span> File(getWallpaperDir(userId), WALLPAPER);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>WallpaperData 的构造方法主要是创建了一个/data/system/users/0/wallpaper的File对象。<br>&#160; &#160; &#160; &#160;3. 最后就是解析/data/system/users/0/wallpaper_info.xml文件，用pull解析器简单解析，这个xml也很简单，这里我举个测试栗子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">wp</span> <span class="attr">width</span>=<span class="string">"1920"</span> <span class="attr">height</span>=<span class="string">"1920"</span> <span class="attr">name</span>=<span class="string">"res:com.example.aaaandroid:drawable/ic_launcher"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里获取WallpaperData的流程就分析完了，然后继续往下走。</p>
<p>&#160; &#160; &#160; &#160;3）获得壁纸文件的fd，查看updateWallpaperBitmapLocked(name, wallpaper)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ParcelFileDescriptor <span class="title">updateWallpaperBitmapLocked</span><span class="params">(String name, WallpaperData wallpaper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) name = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File dir = getWallpaperDir(wallpaper.userId);</span><br><span class="line">        <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">            dir.mkdir();</span><br><span class="line">            FileUtils.setPermissions(</span><br><span class="line">                    dir.getPath(),</span><br><span class="line">                    FileUtils.S_IRWXU|FileUtils.S_IRWXG|FileUtils.S_IXOTH,</span><br><span class="line">                    -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  /data/system/users/0/wallpaper文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(dir, WALLPAPER);</span><br><span class="line">        <span class="comment">//返回这个文件的fd</span></span><br><span class="line">        ParcelFileDescriptor fd = ParcelFileDescriptor.open(file,</span><br><span class="line">                MODE_CREATE|MODE_READ_WRITE|MODE_TRUNCATE);</span><br><span class="line">        <span class="keyword">if</span> (!SELinux.restorecon(file)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wallpaper.name = name;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Error setting wallpaper"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到，这个方法最终返回了/data/system/users/0/wallpaper文件的fd。</p>
<p>&#160; &#160; &#160; &#160;到这里三步走就完了，千万不能晕了。赶紧回到刚才WallpaperManager的setBitmap方法中。接着就是将我们指定的Bitmap写入到这个fd当中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBitmap</span><span class="params">(Bitmap bitmap)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//sGlobals.mService声明在WallpaperManager的内部类Globals里，对应系统服务WallpaperManagerService;</span></span><br><span class="line">           ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(<span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (fd == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得WallpaperManagerService返回的一个壁纸相关的文件描述符，然后将新壁纸内容写入</span></span><br><span class="line">               fos = <span class="keyword">new</span> ParcelFileDescriptor.AutoCloseOutputStream(fd);</span><br><span class="line">               bitmap.compress(Bitmap.CompressFormat.PNG, <span class="number">90</span>, fos);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   fos.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           <span class="comment">// Ignore</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后我们的设置静态壁纸就完了。<br>&#160; &#160; &#160; &#160;我们的设置静态壁纸就完了。<br>&#160; &#160; &#160; &#160;设置静态壁纸就完了。<br>&#160; &#160; &#160; &#160;静态壁纸就完了。<br>&#160; &#160; &#160; &#160;就完了。<br>&#160; &#160; &#160; &#160;。。。。。。。。。<br>&#160; &#160; &#160; &#160;总感觉不对啊<del>~</del>~我们只是把一个图片的内容写入到了一个目录的文件中而已，怎么就会改变壁纸呢，这不合常理啊！<br>&#160; &#160; &#160; &#160;当时我也是一脸懵逼啊！。。。。。。。<br>&#160; &#160; &#160; &#160;然后我就想：嗯。。。这个fd指向的文件一定另有玄机，然后翻阅WallpaperManagerService时发现了WallpaperObserver这个类，这个类继承FileObserver，这是一个监听文件改变的类，看来八九不离十。<br>&#160; &#160; &#160; &#160;接着查找调用它构造方法的地方，最后顺藤摸瓜还是到了SystemServer里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line">	<span class="comment">//调用startOtherServices</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//wallpaper就是刚才启动的WallpaperManagerService </span></span><br><span class="line">		<span class="keyword">final</span> WallpaperManagerService wallpaperF = wallpaper;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// We now tell the activity manager it is okay to run third party</span></span><br><span class="line">        <span class="comment">// code.  It will call back into us once it has gotten to the state</span></span><br><span class="line">        <span class="comment">// where third party code can really run (but before it has actually</span></span><br><span class="line">        <span class="comment">// started launching the initial applications), for us to complete our</span></span><br><span class="line">        <span class="comment">// initialization.</span></span><br><span class="line">        <span class="comment">//当可以启动Launcher之前会回调</span></span><br><span class="line">		mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			......</span><br><span class="line"></span><br><span class="line">			 <span class="keyword">try</span> &#123;</span><br><span class="line">					 <span class="comment">//调用WallpaperManagerService 的systemRunning方法</span></span><br><span class="line">                    <span class="keyword">if</span> (wallpaperF != <span class="keyword">null</span>) wallpaperF.systemRunning();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    reportWtf(<span class="string">"Notifying WallpaperService running"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这是startOtherServices的部分代码，设置了一下监听，ActivityManagerService准备工作完成后可以启动Launcher之前触发回调。我们接着看WallpaperManagerService 的systemRunning方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">       WallpaperData wallpaper = mWallpaperMap.get(UserHandle.USER_OWNER);</span><br><span class="line">       ......</span><br><span class="line">       wallpaper.wallpaperObserver = <span class="keyword">new</span> WallpaperObserver(wallpaper);</span><br><span class="line">       wallpaper.wallpaperObserver.startWatching();</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//WallpaperObserver的构造方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">WallpaperObserver</span><span class="params">(WallpaperData wallpaper)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//已经对/data/system/users/0目录进行监听</span></span><br><span class="line">           <span class="keyword">super</span>(getWallpaperDir(wallpaper.userId).getAbsolutePath(),</span><br><span class="line">                   CLOSE_WRITE | MOVED_TO | DELETE | DELETE_SELF);</span><br><span class="line">           mWallpaperDir = getWallpaperDir(wallpaper.userId);</span><br><span class="line">           mWallpaper = wallpaper;</span><br><span class="line">           <span class="comment">//这个就是/data/system/users/0/wallpaper这个壁纸文件</span></span><br><span class="line">           mWallpaperFile = <span class="keyword">new</span> File(mWallpaperDir, WALLPAPER);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里已经开始了壁纸文件的改动监听，我们可以看看它的回调方法，即WallpaperObserver的onEvent方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">int</span> event, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">           </span><br><span class="line">......</span><br><span class="line"><span class="comment">//改动的文件</span></span><br><span class="line">            File changedFile = <span class="keyword">new</span> File(mWallpaperDir, path);</span><br><span class="line">            <span class="comment">//如果改动的文件是/data/system/users/0/wallpaper</span></span><br><span class="line">            <span class="keyword">if</span> (mWallpaperFile.equals(changedFile)) &#123;</span><br><span class="line">                 ......</span><br><span class="line">                 <span class="comment">//绑定壁纸组件，请注意mImageWallpaper这个参数</span></span><br><span class="line">                    bindWallpaperComponentLocked(mImageWallpaper, <span class="keyword">true</span>,</span><br><span class="line">                            <span class="keyword">false</span>, mWallpaper, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//保存壁纸信息，和上面的loadSettingsLocked正好相反，一个保存，一个取出        </span></span><br><span class="line">                    saveSettingsLocked(mWallpaper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果改动的文件是/data/system/users/0/wallpaper，则就要绑定壁纸组件，调用bindWallpaperComponentLocked方法。我们这里需要注意第一个参数mImageWallpaper，我们可以看看它是在哪里初始化的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span><br><span class="line">   * Name of the component used to display bitmap wallpapers from either the gallery or</span><br><span class="line">   * built-in wallpapers.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">final</span> ComponentName mImageWallpaper;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WallpaperManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mImageWallpaper = ComponentName.unflattenFromString(</span><br><span class="line">              context.getResources().getString(R.string.image_wallpaper_component));</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它也是在WallpaperManagerService的构造方法中初始化的，R.string.image_wallpaper_component这个资源是个string类型，位于framework/base/core/res/res/values/config.xml中：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Component name of the built in wallpaper used to display bitmap wallpapers. This must not be null. --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"image_wallpaper_component"</span> <span class="attr">translatable</span>=<span class="string">"false"</span>&gt;</span>com.android.systemui/com.android.systemui.ImageWallpaper<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个mImageWallpaper是个ComponentName，指向SystemUI中的ImageWallpaper。这个类是SystemUI app中的一个类，位于framework/base/packages/SystemUI/src/com/android/systemui/ImageWallpaper.java中。</p>
<p>&#160; &#160; &#160; &#160;我们继续，分析bindWallpaperComponentLocked方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">bindWallpaperComponentLocked</span><span class="params">(ComponentName componentName, <span class="keyword">boolean</span> force,</span><br><span class="line">         <span class="keyword">boolean</span> fromUser, WallpaperData wallpaper, IRemoteCallback reply)</span> </span>&#123;<span class="comment">//mImageWallpaper, true, false, mWallpaper, null</span></span><br><span class="line">     </span><br><span class="line">     ......</span><br><span class="line">     <span class="comment">// Has the component changed?</span></span><br><span class="line">     <span class="keyword">if</span> (!force) &#123;<span class="comment">//force为true，所以不进入这段逻辑</span></span><br><span class="line">         <span class="keyword">if</span> (wallpaper.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (wallpaper.wallpaperComponent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (componentName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                     <span class="comment">// Still using default wallpaper.</span></span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wallpaper.wallpaperComponent.equals(componentName)) &#123;</span><br><span class="line">                 <span class="comment">// Changing to same wallpaper.</span></span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (componentName == <span class="keyword">null</span>) &#123;<span class="comment">//componentName 不为null，所以不进入下面逻辑</span></span><br><span class="line">             componentName = WallpaperManager.getDefaultWallpaperComponent(mContext);</span><br><span class="line">             <span class="keyword">if</span> (componentName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// Fall back to static image wallpaper</span></span><br><span class="line">                 componentName = mImageWallpaper;</span><br><span class="line">                 <span class="comment">//clearWallpaperComponentLocked();</span></span><br><span class="line">                 <span class="comment">//return;</span></span><br><span class="line">                 </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">         </span><br><span class="line">         WallpaperInfo wi = <span class="keyword">null</span>;</span><br><span class="line">         </span><br><span class="line">         Intent intent = <span class="keyword">new</span> Intent(WallpaperService.SERVICE_INTERFACE);</span><br><span class="line">         <span class="keyword">if</span> (componentName != <span class="keyword">null</span> &amp;&amp; !componentName.equals(mImageWallpaper)) &#123; <span class="comment">// true &amp;&amp; false ,因此不进入下面逻辑</span></span><br><span class="line">             <span class="comment">// Make sure the selected service is actually a wallpaper service.</span></span><br><span class="line">             List&lt;ResolveInfo&gt; ris =</span><br><span class="line">                     mIPackageManager.queryIntentServices(intent,</span><br><span class="line">                             intent.resolveTypeIfNeeded(mContext.getContentResolver()),</span><br><span class="line">                             PackageManager.GET_META_DATA, serviceUserId);</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ris.size(); i++) &#123;</span><br><span class="line">                 ServiceInfo rsi = ris.get(i).serviceInfo;</span><br><span class="line">                 <span class="keyword">if</span> (rsi.name.equals(si.name) &amp;&amp;</span><br><span class="line">                         rsi.packageName.equals(si.packageName)) &#123;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         wi = <span class="keyword">new</span> WallpaperInfo(mContext, ris.get(i));</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (fromUser) &#123;</span><br><span class="line">                             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">                         &#125;</span><br><span class="line">                         Slog.w(TAG, e);</span><br><span class="line">                         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (fromUser) &#123;</span><br><span class="line">                             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">                         &#125;</span><br><span class="line">                         Slog.w(TAG, e);</span><br><span class="line">                         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (wi == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 String msg = <span class="string">"Selected service is not a wallpaper: "</span></span><br><span class="line">                         + componentName;</span><br><span class="line">                 <span class="keyword">if</span> (fromUser) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">                 &#125;</span><br><span class="line">                 Slog.w(TAG, msg);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// Bind the service!</span></span><br><span class="line">      <span class="comment">//WallpaperConnection实现了ServiceConnection接口，绑定服务时和解绑时回调两个接口</span></span><br><span class="line">         WallpaperConnection newConn = <span class="keyword">new</span> WallpaperConnection(wi, wallpaper);</span><br><span class="line">      <span class="comment">//com.android.systemui/.ImageWallpaper</span></span><br><span class="line">         intent.setComponent(componentName);</span><br><span class="line">         intent.putExtra(Intent.EXTRA_CLIENT_LABEL,</span><br><span class="line">                 com.android.internal.R.string.wallpaper_binding_label);</span><br><span class="line">         intent.putExtra(Intent.EXTRA_CLIENT_INTENT, PendingIntent.getActivityAsUser(</span><br><span class="line">                 mContext, <span class="number">0</span>,</span><br><span class="line">                 Intent.createChooser(<span class="keyword">new</span> Intent(Intent.ACTION_SET_WALLPAPER),</span><br><span class="line">                         mContext.getText(com.android.internal.R.string.chooser_wallpaper)),</span><br><span class="line">                 <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">new</span> UserHandle(serviceUserId)));</span><br><span class="line">         <span class="comment">//绑定com.android.systemui/.ImageWallpaper这个服务        </span></span><br><span class="line">         <span class="keyword">if</span> (!mContext.bindServiceAsUser(intent, newConn,</span><br><span class="line">                 Context.BIND_AUTO_CREATE | Context.BIND_SHOWING_UI,</span><br><span class="line">                 <span class="keyword">new</span> UserHandle(serviceUserId))) &#123;</span><br><span class="line">             String msg = <span class="string">"Unable to bind service: "</span></span><br><span class="line">                     + componentName;</span><br><span class="line">             <span class="keyword">if</span> (fromUser) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(msg);</span><br><span class="line">             &#125;</span><br><span class="line">             Slog.w(TAG, msg);</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//移除原先壁纸和窗口的管理</span></span><br><span class="line">         <span class="keyword">if</span> (wallpaper.userId == mCurrentUserId &amp;&amp; mLastWallpaper != <span class="keyword">null</span>) &#123;</span><br><span class="line">             detachWallpaperLocked(mLastWallpaper);</span><br><span class="line">         &#125;</span><br><span class="line">         wallpaper.wallpaperComponent = componentName;</span><br><span class="line">         wallpaper.connection = newConn;</span><br><span class="line">         newConn.mReply = reply;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (wallpaper.userId == mCurrentUserId) &#123;</span><br><span class="line">                 <span class="comment">//给壁纸窗口加入TYPE_WALLPAPER类型</span></span><br><span class="line">                 mIWindowManager.addWindowToken(newConn.mToken,</span><br><span class="line">                         WindowManager.LayoutParams.TYPE_WALLPAPER);</span><br><span class="line">                 mLastWallpaper = wallpaper;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">         String msg = <span class="string">"Remote exception for "</span> + componentName + <span class="string">"\n"</span> + e;</span><br><span class="line">         <span class="keyword">if</span> (fromUser) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(msg);</span><br><span class="line">         &#125;</span><br><span class="line">         Slog.w(TAG, msg);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个方法虽然复杂，然是很多逻辑不会进入，少了干扰项。因为我们是设置静态壁纸，所以核心步骤也不多，大概如下：</p>
<ul>
<li>绑定com.android.systemui/.ImageWallpaper这个服务  </li>
<li>移除原先壁纸和窗口的管理，给壁纸窗口加入TYPE_WALLPAPER类型</li>
</ul>
<h3 id="绑定壁纸服务"><a href="#绑定壁纸服务" class="headerlink" title="绑定壁纸服务"></a>绑定壁纸服务</h3><p>&#160; &#160; &#160; &#160;核心就在绑定com.android.systemui/.ImageWallpaper这个服务。<br>&#160; &#160; &#160; &#160;ImageWallpaper继承于WallpaperService，并且我们看一下它的写法，和上述的动态壁纸的模式一模一样啊：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageWallpaper</span> <span class="keyword">extends</span> <span class="title">WallpaperService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mWallpaperManager = (WallpaperManager) getSystemService(WALLPAPER_SERVICE);</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">onCreateEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mEngine = <span class="keyword">new</span> DrawableEngine();</span><br><span class="line">        <span class="keyword">return</span> mEngine;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">DrawableEngine</span> <span class="keyword">extends</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">		......一些Engine的方法,和上面的魔方那个例子几乎一样.....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;但是我们分析还是按着步骤一步一来，就回到绑定服务那一步。<br>&#160; &#160; &#160; &#160;绑定ImageWallpaper这个服务，会回调ServiceConnection接口的onServiceConnected方法。所以我们看看这个WallpaperConnection类的onServiceConnected方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ImageWallpaper的onBind方法返回值就是这个mService </span></span><br><span class="line">IWallpaperService mService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">              <span class="keyword">if</span> (mWallpaper.connection == <span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="comment">//ImageWallpaper的onBind方法返回值就是这个mService </span></span><br><span class="line">                  mService = IWallpaperService.Stub.asInterface(service);</span><br><span class="line">                  <span class="comment">//接下来会调用的</span></span><br><span class="line">                  attachServiceLocked(<span class="keyword">this</span>, mWallpaper);</span><br><span class="line">                  <span class="comment">// XXX should probably do saveSettingsLocked() later</span></span><br><span class="line">                  <span class="comment">// when we have an engine, but I'm not sure about</span></span><br><span class="line">                  <span class="comment">// locking there and anyway we always need to be able to</span></span><br><span class="line">                  <span class="comment">// recover if there is something wrong.</span></span><br><span class="line">                  <span class="comment">//保存壁纸信息，这个方法上面说过的，和loadSettingsLocked方法正好相对</span></span><br><span class="line">                  saveSettingsLocked(mWallpaper);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;ImageWallpaper的onBind方法返回值就是这个mService ，这个得从ImageWallpaper的父类WallpaperService中查找：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Implement to return the implementation of the internal accessibility</span><br><span class="line">    * service interface.  Subclasses should not override.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IWallpaperServiceWrapper(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Implements the internal &#123;<span class="doctag">@link</span> IWallpaperService&#125; interface to convert</span><br><span class="line">    * incoming calls to it back to calls on an &#123;<span class="doctag">@link</span> WallpaperService&#125;.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">IWallpaperServiceWrapper</span> <span class="keyword">extends</span> <span class="title">IWallpaperService</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> WallpaperService mTarget;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">IWallpaperServiceWrapper</span><span class="params">(WallpaperService context)</span> </span>&#123;</span><br><span class="line">           mTarget = context;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(IWallpaperConnection conn, IBinder windowToken,</span><br><span class="line">               <span class="keyword">int</span> windowType, <span class="keyword">boolean</span> isPreview, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight, Rect padding)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">new</span> IWallpaperEngineWrapper(mTarget, conn, windowToken,</span><br><span class="line">                   windowType, isPreview, reqWidth, reqHeight, padding);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里给这个类型为IWallpaperService 的mService变量赋值的是IWallpaperServiceWrapper这个类的一个实例。</p>
<p>&#160; &#160; &#160; &#160;然后我们回到上面，接着调用attachServiceLocked(this, mWallpaper)，我们再跟进去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">attachServiceLocked</span><span class="params">(WallpaperConnection conn, WallpaperData wallpaper)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这里会调用IWallpaperServiceWrapper 的attach方法</span></span><br><span class="line">         conn.mService.attach(conn, conn.mToken,</span><br><span class="line">                 WindowManager.LayoutParams.TYPE_WALLPAPER, <span class="keyword">false</span>,</span><br><span class="line">                 wallpaper.width, wallpaper.height, wallpaper.padding);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">......</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;内部有调用了IWallpaperServiceWrapper 的attach方法，上面代码已经贴出。可以看到，attach方法内部又创建了一个IWallpaperEngineWrapper对象，所以我们还得看看IWallpaperEngineWrapper的构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IWallpaperEngineWrapper(WallpaperService context,</span><br><span class="line">        IWallpaperConnection conn, IBinder windowToken,</span><br><span class="line">        <span class="keyword">int</span> windowType, <span class="keyword">boolean</span> isPreview, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight, Rect padding) &#123;</span><br><span class="line">    <span class="comment">//这个HandlerCaller就是对Handler的一个封装类，大家以后可以参考它    </span></span><br><span class="line">    mCaller = <span class="keyword">new</span> HandlerCaller(context, context.getMainLooper(), <span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">    mConnection = conn;<span class="comment">//WallpaperManagerService中的WallpaperConnection类的对象</span></span><br><span class="line">    mWindowToken = windowToken;<span class="comment">//final Binder mToken = new Binder();</span></span><br><span class="line">    mWindowType = windowType;<span class="comment">//WindowManager.LayoutParams.TYPE_WALLPAPER</span></span><br><span class="line">    mIsPreview = isPreview;<span class="comment">//false</span></span><br><span class="line">    mReqWidth = reqWidth;<span class="comment">//wallpaper_info.xml中读取的width</span></span><br><span class="line">    mReqHeight = reqHeight;<span class="comment">//wallpaper_info.xml中读取的height</span></span><br><span class="line">    mDisplayPadding.set(padding);<span class="comment">//new Rect（0，0，0，0）；</span></span><br><span class="line">    <span class="comment">//发送DO_ATTACH消息</span></span><br><span class="line">    Message msg = mCaller.obtainMessage(DO_ATTACH);</span><br><span class="line">    mCaller.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里的HandlerCaller就是对Handler的一个封装类，大家以后可以参考它 ，位于framework/base/core/java/com/android/internal/os/HandlerCaller.java，这里不做详细分析。</p>
<p>&#160; &#160; &#160; &#160;IWallpaperEngineWrapper的构造方法最后发送了DO_ATTACH消息，处理消息在IWallpaperEngineWrapper类的executeMessage方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> DO_ATTACH: &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">	                    <span class="comment">//调用WallpaperConnection的attachEngine方法</span></span><br><span class="line">                        mConnection.attachEngine(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        Log.w(TAG, <span class="string">"Wallpaper host disappeared"</span>, e);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//调用重写的onCreateEngine返回一个Engine类型的对象</span></span><br><span class="line">                    Engine engine = onCreateEngine();</span><br><span class="line">                    mEngine = engine;</span><br><span class="line">                    mActiveEngines.add(engine);</span><br><span class="line">                    <span class="comment">//在调用Engine的attach方法</span></span><br><span class="line">                    engine.attach(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">				.......</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;处理DO_ATTACH消息会先调用WallpaperConnection的attachEngine方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachEngine</span><span class="params">(IWallpaperEngine engine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">     <span class="comment">//用IWallpaperEngineWrapper类对象赋值</span></span><br><span class="line">        mEngine = engine;</span><br><span class="line">        <span class="keyword">if</span> (mDimensionsChanged) &#123;<span class="comment">//false</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mEngine.setDesiredSize(mWallpaper.width, mWallpaper.height);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failed to set wallpaper dimensions"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            mDimensionsChanged = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mPaddingChanged) &#123;<span class="comment">//false</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mEngine.setDisplayPadding(mWallpaper.padding);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failed to set wallpaper padding"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            mPaddingChanged = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个方法就是用IWallpaperEngineWrapper类对象赋值，然后如果尺寸或者缩进改变了，就调整一下大小。</p>
<p>&#160; &#160; &#160; &#160;处理DO_ATTACH消息接着调用重写的onCreateEngine返回一个Engine类型的对象，并将它存入这个mActiveEngines的ArrayList中；</p>
<p>&#160; &#160; &#160; &#160;处理DO_ATTACH消息最后会调用Engine的attach方法，我们进入WallpaperService的内部类Engine的attach方法中看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(IWallpaperEngineWrapper wrapper)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"attach: "</span> + <span class="keyword">this</span> + <span class="string">" wrapper="</span> + wrapper);</span><br><span class="line">           <span class="keyword">if</span> (mDestroyed) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           mIWallpaperEngine = wrapper;</span><br><span class="line">           mCaller = wrapper.mCaller;</span><br><span class="line">           mConnection = wrapper.mConnection;</span><br><span class="line">           <span class="comment">//一个binder对象</span></span><br><span class="line">           mWindowToken = wrapper.mWindowToken;</span><br><span class="line">           <span class="comment">//mSurfaceHolder是BaseSurfaceHolder类对象，继承与SurfaceHolder，用于控制绘制图层</span></span><br><span class="line">           mSurfaceHolder.setSizeFromLayout();</span><br><span class="line">           mInitializing = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//申请一个window需要一个WindowSession</span></span><br><span class="line">           mSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">           <span class="comment">//一个BaseIWindow类型的对象，继承于IWindow.Stub</span></span><br><span class="line">           mWindow.setSession(mSession);</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//Engine的初始化工作</span></span><br><span class="line">           onCreate(mSurfaceHolder);</span><br><span class="line">           </span><br><span class="line">           mInitializing = <span class="keyword">false</span>;</span><br><span class="line">           mReportedVisible = <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//开始往window上的surface里绘制壁纸</span></span><br><span class="line">           updateSurface(<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个attach方法也做了两件事：<br>&#160; &#160; &#160; &#160;1. 初始化壁纸窗口和绘制图层相关工作<br>&#160; &#160; &#160; &#160;2. 开始往window上的surface里绘制壁纸</p>
<p>&#160; &#160; &#160; &#160;关于初始化窗口相关内容比较复杂，下面篇幅我会给出参考资料，这一部分原理也很复杂，有兴趣的同学可以自行研究（我也没研究过，以后再补上= 。=）</p>
<p>&#160; &#160; &#160; &#160;绘制壁纸就是在updateSurface方法里，不过这个方法也是很复杂的，可以看出，这个方法会被很多种情况不停触发。我们简单分析一下触发条件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSurface</span><span class="params">(<span class="keyword">boolean</span> forceRelayout, <span class="keyword">boolean</span> forceReport, <span class="keyword">boolean</span> redrawNeeded)</span> </span>&#123;</span><br><span class="line">	...省略一些逻辑,条件<span class="number">1</span>...</span><br><span class="line">	onVisibilityChanged(<span class="keyword">true</span>);</span><br><span class="line">	...省略一些逻辑,条件<span class="number">2</span>...</span><br><span class="line">	onSurfaceRedrawNeeded(mSurfaceHolder);</span><br><span class="line">	...省略一些逻辑,条件<span class="number">3</span>...</span><br><span class="line">    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);</span><br><span class="line">	...省略一些逻辑...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;以上三个条件均会触发绘制，即调用了ImageWallpaper的drawFrame方法。drawFrame方法内部对壁纸的大小和位置都做了很多调整，这里我们不作详细分析，我们只care它的绘制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	...省略大部分调整壁纸大小和窗口位置的逻辑...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (mIsHwAccelerated) &#123;<span class="comment">//如果机器支持硬件加速，就用OpenGL绘制</span></span><br><span class="line">                <span class="keyword">if</span> (!drawWallpaperWithOpenGL(sh, availw, availh, xPixels, yPixels)) &#123;</span><br><span class="line">                    drawWallpaperWithCanvas(sh, availw, availh, xPixels, yPixels);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则就用Skia绘制</span></span><br><span class="line">                drawWallpaperWithCanvas(sh, availw, availh, xPixels, yPixels);</span><br><span class="line">				......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;关于OpenGL的绘制其实我看不懂，但是我们知道这是往窗口那一层Layer绘制壁纸图像。所以看看使用Canvas开绘制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawWallpaperWithCanvas</span><span class="params">(SurfaceHolder sh, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> left, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">    Canvas c = sh.lockCanvas();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Redrawing: left="</span> + left + <span class="string">", top="</span> + top);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> right = left + mBackground.getWidth() * mScale;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> bottom = top + mBackground.getHeight() * mScale;</span><br><span class="line">            <span class="keyword">if</span> (w &lt; <span class="number">0</span> || h &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                c.save(Canvas.CLIP_SAVE_FLAG);</span><br><span class="line">                c.clipRect(left, top, right, bottom,</span><br><span class="line">                        Op.DIFFERENCE);</span><br><span class="line">                c.drawColor(<span class="number">0xff000000</span>);</span><br><span class="line">                c.restore();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mBackground != <span class="keyword">null</span>) &#123;</span><br><span class="line">                RectF dest = <span class="keyword">new</span> RectF(left, top, right, bottom);</span><br><span class="line">                <span class="comment">// add a filter bitmap?</span></span><br><span class="line">                c.drawBitmap(mBackground, <span class="keyword">null</span>, dest, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sh.unlockCanvasAndPost(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个没啥难度吧，就是往Canvas画图。</p>
<p>&#160; &#160; &#160; &#160;到这里绑定壁纸服务的流程就分析完了，唉，也是绕来绕去，绕的头晕。。。。。</p>
<h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><p>&#160; &#160; &#160; &#160;窗口管理这一块其实流程也很复杂，要涉及WindowManagerService等一系列逻辑。上面绑定壁纸服务，在绘制前会申请一个窗口专门用来绘制壁纸。</p>
<p>&#160; &#160; &#160; &#160; 在Android系统中，壁纸窗口和输入法窗口一样，都是一种特殊类型的窗口，而且它们都是喜欢和一个普通的Activity窗口缠绵在一起。大家可以充分地想象这样的一个3W场景：输入法窗口在上面，壁纸窗口在下面，Activity窗口夹在它们的中间。</p>
<p>&#160; &#160; &#160; &#160; 一个Activity窗口如果需要显示壁纸，那么它必须满足以下两个条件：</p>
<p>&#160; &#160; &#160; &#160;1. 背景是半透明的，例如，它在AndroidManifest.xml文件中的android:theme属性设置为Theme.Translucent：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".WallpaperActivity"</span></span><br><span class="line">    <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent"</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2. 窗口属性中的WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER位设置为1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WallpaperActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">            </span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果想详细了解Android窗口管理服务WindowManagerService对壁纸窗口（Wallpaper Window）的管理分析 ，可以看看<strong>老罗</strong>的<a href="http://blog.csdn.net/luoshengyang/article/details/8550820#" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="动态壁纸流程分析"><a href="#动态壁纸流程分析" class="headerlink" title="动态壁纸流程分析"></a>动态壁纸流程分析</h2><p>&#160; &#160; &#160; &#160;为了应付产品汪的奇葩需求，就得研究一下动态壁纸是如何设置的。</p>
<p>&#160; &#160; &#160; &#160;所以呢：打开模拟器——打开设置——显示——壁纸——动态壁纸——随便选一个——设置壁纸按钮。用IED工具发现这个界面是这样的：<strong>com.android.wallpaper.livepicker/.LiveWallpaperPreview</strong>。这就随意多了，果断翻源码。位于packages/wallpapers/LivePicker/src/com/android/wallpaper/livepicker/LiveWallpaperPreview.java中，并找到了设置动态壁纸按钮的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveWallpaperPreview</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> WallpaperManager mWallpaperManager;</span><br><span class="line">    <span class="keyword">private</span> WallpaperConnection mWallpaperConnection;</span><br><span class="line">    	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        </span><br><span class="line">		......</span><br><span class="line">        mWallpaperManager = WallpaperManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mWallpaperConnection = <span class="keyword">new</span> WallpaperConnection(mWallpaperIntent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置壁纸</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLiveWallpaper</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//这句话是设置动态壁纸的核心</span></span><br><span class="line">            mWallpaperManager.getIWallpaperManager().setWallpaperComponent(</span><br><span class="line">                    mWallpaperIntent.getComponent());</span><br><span class="line">            mWallpaperManager.setWallpaperOffsetSteps(<span class="number">0.5f</span>, <span class="number">0.0f</span>);</span><br><span class="line">            mWallpaperManager.setWallpaperOffsets(v.getRootView().getWindowToken(), <span class="number">0.5f</span>, <span class="number">0.0f</span>);</span><br><span class="line">            setResult(RESULT_OK);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Log.w(LOG_TAG, <span class="string">"Failure setting wallpaper"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;设置动态壁纸就一句核心代码：<br>&#160; &#160; &#160; &#160;<strong>mWallpaperManager.getIWallpaperManager().setWallpaperComponent(mWallpaperIntent.getComponent());</strong></p>
<p>&#160; &#160; &#160; &#160;因为动态壁纸都是Service，所以上述代码中的参数mWallpaperIntent.getComponent()就是每一个Service的ComponentName。</p>
<p>&#160; &#160; &#160; &#160;为了分析流程，我们继续跟进去。最终是调用WallpaperManagerService的setWallpaperComponent方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWallpaperComponent</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">    checkPermission(android.Manifest.permission.SET_WALLPAPER_COMPONENT);</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">"setWallpaperComponent name="</span> + name);</span><br><span class="line">        <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">        WallpaperData wallpaper = mWallpaperMap.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (wallpaper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Wallpaper not yet initialized for user "</span> + userId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wallpaper.imageWallpaperPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//最终还是调用了bindWallpaperComponentLocked方法，这个我们上面分析静态壁纸分析过了</span></span><br><span class="line">            bindWallpaperComponentLocked(name, <span class="keyword">false</span>, <span class="keyword">true</span>, wallpaper, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以发现，最终还是调用了bindWallpaperComponentLocked方法，只不过第一个参数ComponentName 换了。静态壁纸都是ImageWallpaper这个类，动态壁纸都是自己的类。这个方法我们上面已经分析过了，流程就那么些。</p>
<p>&#160; &#160; &#160; &#160;如果我们想自己绑定自己的壁纸，只要调用mWallpaperManager.getIWallpaperManager().setWallpaperComponent(mWallpaperIntent.getComponent());这句话就行了，只不过需要系统权限，必须在清单文件中配置android:sharedUserId=”android.uid.system”属性，还要打系统签名。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;到此Android的壁纸服务就分析完了。<br>&#160; &#160; &#160; &#160;动态壁纸和静态壁纸设置流程本质都是一样的，只不过静态壁纸是ImageWallpaper这个服务，动态壁纸是自己的。<br>&#160; &#160; &#160; &#160;设置静态壁纸可以直接使用WallpaperManager提供的三种方法，setResource(int resId)，setBitmap(Bitmap bm)和setStream(InputStream is)。<br>&#160; &#160; &#160; &#160;设置动态壁纸可以调用：<br>WallpaperManager.getInstance(context).getIWallpaperManager().setWallpaperComponent(componentName)。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A3%81%E7%BA%B8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何实现1080P延迟低于500ms的实时超清直播传输技术]]></title>
      <url>http://windrunnerlihuan.com/2016/09/18/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;再来当一次技术搬运工，内容来自<code>高可用框架</code>，学霸君工程师袁荣喜的<code>如何实现1080P延迟低于500ms的实时超清直播传输技术</code>。<br><a id="more"></a></p>
<p>&#160; &#160; &#160; &#160;<em>导语：视频直播是很多技术团队及架构师关注的问题，在实时性方面，大部分直播是准实时的，存在 1-3 秒延迟。本文由袁荣喜向「高可用架构」投稿，介绍其将直播延迟控制在 500ms 的背后的实现</em>。</p>
<blockquote>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/touxiang.jpg" title="袁荣喜"></div><br>&#160; &#160; &#160; &#160;袁荣喜，学霸君工程师，2015 年加入学霸君，负责学霸君的网络实时传输和分布式系统的架构设计和实现，专注于基础技术领域，在网络传输、数据库内核、分布式系统和并发编程方面有一定了解。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;最近由于公司业务关系，需要一个在公网上能实时互动超清视频的架构和技术方案。众所周知，视频直播用 CDN + RTMP 就可以满足绝大部分视频直播业务，我们也接触了和测试了几家 CDN 提供的方案，单人直播没有问题，一旦涉及到多人互动延迟非常大，无法进行正常的互动交谈。对于我们做在线教育的企业来说没有互动的直播是毫无意义的，所以我们决定自己来构建一个超清晰（1080P）实时视频的传输方案。</p>
<p>&#160; &#160; &#160; &#160;先来解释下什么是实时视频，实时视频就是视频图像从产生到消费完成整个过程人感觉不到延迟，只要符合这个要求的视频业务都可以称为实时视频。关于视频的实时性归纳为三个等级：</p>
<ul>
<li><strong>伪实时</strong>：视频消费延迟超过 3 秒，单向观看实时，通用架构是 CDN + RTMP + HLS，现在基本上所有的直播都是这类技术。</li>
<li><strong>准实时</strong>： 视频消费延迟 1 ~ 3 秒，能进行双方互动但互动有障碍。有些直播网站通过 TCP/UDP + FLV 已经实现了这类技术，YY 直播属于这类技术。</li>
<li><strong>真实时</strong>：视频消费延迟 &lt; 1秒，平均 500 毫秒。这类技术是真正的实时技术，人和人交谈没有明显延迟感。QQ、微信、Skype 和 WebRTC 等都已经实现了这类技术。</li>
</ul>
<p>&#160; &#160; &#160; &#160;市面上大部分真实时视频都是 480P 或者 480P 以下的实时传输方案，用于在线教育和线上教学有一定困难，而且有时候流畅度是个很大的问题。在实现超清晰实时视频我们做了大量尝试性的研究和探索，在这里会把大部分细节分享出来。</p>
<p>&#160; &#160; &#160; &#160;要实时就要缩短延迟，要缩短延迟就要知道延迟是怎么产生的，视频从产生、编码、传输到最后播放消费，各个环节都会产生延迟，总体归纳为下图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/kaitou.jpg" alt="延时原因"><br>&#160; &#160; &#160; &#160;成像延迟，一般的技术是毫无为力的，涉及到 CCD 相关的硬件，现在市面上最好的 CCD，一秒钟 50 帧，成像延迟也在 20 毫秒左右，一般的 CCD 只有 20 ~ 25 帧左右，成像延迟 40 ~ 50 毫秒。</p>
<p>&#160; &#160; &#160; &#160;编码延迟，和编码器有关系，在接下来的小结介绍，一般优化的空间比较小。</p>
<p>&#160; &#160; &#160; &#160;我们着重针对网络延迟和播放缓冲延迟来进行设计，在介绍整个技术细节之前先来了解下视频编码和网络传输相关的知识和特点。</p>
<h1 id="一、视频编码那些事"><a href="#一、视频编码那些事" class="headerlink" title="一、视频编码那些事"></a>一、视频编码那些事</h1><p>&#160; &#160; &#160; &#160;我们知道从 CCD 采集到的图像格式一般的 RGB 格式的（BMP），这种格式的存储空间非常大，它是用三个字节描述一个像素的颜色值，如果是 1080P 分辨率的图像空间：1920 x 1080 x 3 = 6MB，就算转换成 JPG 也有近 200KB，如果是每秒 12 帧用 JPG 也需要近 2.4MB/S 的带宽，这带宽在公网上传输是无法接受的。</p>
<p>&#160; &#160; &#160; &#160;视频编码器就是为了解决这个问题的，它会根据前后图像的变化做运动检测，通过各种压缩把变化的发送到对方，1080P 进行过  H.264 编码后带宽也就在 200KB/S ~ 300KB/S 左右。在我们的技术方案里面我们采用 H.264 作为默认编码器（也在研究 H.265）。</p>
<h2 id="1-1-H-264-编码"><a href="#1-1-H-264-编码" class="headerlink" title="1.1 H.264 编码"></a>1.1 H.264 编码</h2><p>&#160; &#160; &#160; &#160;前面提到视频编码器会根据图像的前后变化进行选择性压缩，因为刚开始接收端是没有收到任何图像，那么编码器在开始压缩的视频时需要做个全量压缩，这个全量压缩在 H.264 中 I 帧，后面的视频图像根据这个I帧来做增量压缩，这些增量压缩帧叫做 P 帧，H.264 为了防止丢包和减小带宽还引入一种双向预测编码的 B 帧，B 帧以前面的 I 或 P 帧和后面的 P 帧为参考帧。H.264 为了防止中间 P 帧丢失视频图像会一直错误它引入分组序列（GOP）编码，也就是隔一段时间发一个全量 I 帧，上一个 I 帧与下一个 I 帧之间为一个分组 GOP。它们之间的关系如下图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/gop.jpg" alt="GOP"><br>&#160; &#160; &#160; &#160;<em>PS：在实时视频当中最好不要加入 B 帧，因为 B 帧是双向预测，需要根据后面的视频帧来编码，这会增大编解码延迟</em>。</p>
<h2 id="1-2-马赛克、卡顿和秒开"><a href="#1-2-马赛克、卡顿和秒开" class="headerlink" title="1.2 马赛克、卡顿和秒开"></a>1.2 马赛克、卡顿和秒开</h2><p>&#160; &#160; &#160; &#160;前面提到如果 GOP 分组中的P帧丢失会造成解码端的图像发生错误,其实这个错误表现出来的就是马赛克。因为中间连续的运动信息丢失了，H.264 在解码的时候会根据前面的参考帧来补齐，但是补齐的并不是真正的运动变化后的数据，这样就会出现颜色色差的问题，这就是所谓的<strong>马赛克现象</strong>，如图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/masaike.jpg" alt="马赛克"><br>&#160; &#160; &#160; &#160;这种现象不是我们想看到的。为了避免这类问题的发生，一般如果发现 P 帧或者 I 帧丢失，就不显示本 GOP 内的所有帧，直到下一个 I 帧来后重新刷新图像。但是 I 帧是按照帧周期来的，需要一个比较长的时间周期，如果在下一个 I 帧来之前不显示后来的图像，那么视频就静止不动了，这就是出现了所谓的<strong>卡顿现象</strong>。如果连续丢失的视频帧太多造成解码器无帧可解，也会造成严重的卡顿现象。视频解码端的卡顿现象和马赛克现象都是因为丢帧引起的，最好的办法就是<strong>让帧尽量不丢</strong>。</p>
<p>&#160; &#160; &#160; &#160;知道 H.264 的原理和分组编码技术后所谓的秒开技术就比较简单了，<strong>只要发送方从最近一个 GOP 的 I 帧开发发送给接收方，接收方就可以正常解码完成的图像并立即显示</strong>。但这会在视频连接开始的时候多发一些帧数据造成播放延迟，只要在接收端播放的时候尽量让过期的帧数据只解码不显示，直到当前视频帧在播放时间范围之内即可。</p>
<h2 id="1-3-编码延迟与码率"><a href="#1-3-编码延迟与码率" class="headerlink" title="1.3 编码延迟与码率"></a>1.3 编码延迟与码率</h2><p>&#160; &#160; &#160; &#160;前面四个延迟里面我们提到了编码延迟，编码延迟就是从 CCD 出来的 RGB 数据经过 H.264 编码器编码后出来的帧数据过程的时间。我们在一个 8 核 CPU 的普通客户机测试了最新版本 X.264 的各个分辨率的延迟，数据如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/fenbianlv.jpg" alt="分辨率延迟"><br>&#160; &#160; &#160; &#160;从上面可以看出，超清视频的编码延迟会达到 50ms，解决编码延迟的问题只能去优化编码器内核让编码的运算更快，我们也正在进行方面的工作。</p>
<p>&#160; &#160; &#160; &#160;<strong>在 1080P 分辨率下，视频编码码率会达到 300KB/S，单个 I 帧数据大小达到 80KB，单个 P 帧可以达到 30KB，这对网络实时传输造成严峻的挑战</strong>。</p>
<h1 id="二、网络传输质量因素"><a href="#二、网络传输质量因素" class="headerlink" title="二、网络传输质量因素"></a>二、网络传输质量因素</h1><p>&#160; &#160; &#160; &#160;实时互动视频一个关键的环节就是网络传输技术,不管是早期 VoIP，还是现阶段流行的视频直播，其主要手段是通过 TCP/IP 协议来进行通信。但是 IP 网络本来就是不可靠的传输网络，在这样的网络传输视频很容易造成卡顿现象和延迟。先来看看 IP 网络传输的几个影响网络传输质量关键因素。</p>
<h2 id="2-1-TCP-和-UDP"><a href="#2-1-TCP-和-UDP" class="headerlink" title="2.1 TCP 和 UDP"></a>2.1 TCP 和 UDP</h2><p>&#160; &#160; &#160; &#160;对直播有过了解的人都会认为做视频传输首选的就是 TCP + RTMP，其实这是比较片面的。在大规模实时多媒体传输网络中，TCP 和 RTMP 都不占优势。TCP 是个拥塞公平传输的协议，它的拥塞控制都是为了保证网络的公平性而不是快速到达，我们知道，TCP 层只有顺序到对应的报文才会提示应用层读数据，如果中间有报文乱序或者丢包都会在 TCP 做等待，所以 TCP 的发送窗口缓冲和重发机制在网络不稳定的情况下会造成延迟不可控，而且传输链路层级越多延迟会越大。</p>
<p>关于 TCP 的原理：<br><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">http://coolshell.cn/articles/11564.html</a><br>关于 TCP 重发延迟：<br><a href="http://weibo.com/p/1001603821691477346388" target="_blank" rel="external">http://weibo.com/p/1001603821691477346388</a></p>
<p>&#160; &#160; &#160; &#160;<strong>在实时传输中使用 UDP 更加合理</strong>，UDP 避免了 TCP 繁重的三次握手、四次挥手和各种繁杂的传输特性，只需要在 UDP 上做一层简单的链路 QoS 监测和报文重发机制，实时性会比 TCP 好，这一点从 RTP 和 DDCP 协议可以证明这一点，我们正式参考了这两个协议来设计自己的通信协议。</p>
<h2 id="2-2-延迟"><a href="#2-2-延迟" class="headerlink" title="2.2 延迟"></a>2.2 延迟</h2><p>&#160; &#160; &#160; &#160;要评估一个网络通信质量的好坏和延迟一个重要的因素就是 Round-Trip Time（网络往返延迟）,也就是 RTT。评估两端之间的 RTT 方法很简单，大致如下：</p>
<ul>
<li>发送端方一个带本地时间戳 T1 的 ping 报文到接收端；</li>
<li>接收端收到 ping 报文，以 ping 中的时间戳 T1 构建一个携带 T1 的 pong 报文发往发送端；</li>
<li>发送端接收到接收端发了的 pong 时，获取本地的时间戳 T2，用 T2 – T1 就是本次评测的 RTT。</li>
</ul>
<p>示意图如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/pingpong.jpg" alt="pingpong"><br>&#160; &#160; &#160; &#160;上面步骤的探测周期可以设为 1 秒一次。为了防止网络突发延迟增大，我们采用了借鉴了 TCP 的 RTT 遗忘衰减的算法来计算，假设原来的 RTT 值为 rtt，本次探测的 RTT 值为 keep_rtt。那么新的 RTT 为：</p>
<p>&#160; &#160; &#160; &#160;<strong>new_rtt = (7 * rtt + keep_rtt) / 8</strong></p>
<p>&#160; &#160; &#160; &#160;可能每次探测出来的 keep_rtt 会不一样，我们需要会计算一个 RTT 的修正值 rtt_var，算法如下：</p>
<p>&#160; &#160; &#160; &#160;<strong>new_rtt_var = (rtt_var * 3 + abs(rtt – keep_rtt)) / 4</strong></p>
<p>&#160; &#160; &#160; &#160;<strong>rtt_var 其实就是网络抖动的时间差值</strong>。 </p>
<p>&#160; &#160; &#160; &#160;如果 RTT 太大，表示网络延迟很大。<strong>我们在端到端之间的网络路径同时保持多条并且实时探测其网络状态，如果 RTT 超出延迟范围会进行传输路径切换</strong>（本地网络拥塞除外）。</p>
<h2 id="2-3-抖动和乱序"><a href="#2-3-抖动和乱序" class="headerlink" title="2.3 抖动和乱序"></a>2.3 抖动和乱序</h2><p>&#160; &#160; &#160; &#160;UDP 除了延迟外，还会出现网络抖动。什么是抖动呢？举个例子，假如我们每秒发送 10 帧视频帧，发送方与接收方的延迟为 50MS，每帧数据用一个 UDP 报文来承载，那么发送方发送数据的频率是 100ms 一个数据报文，表示第一个报文发送时刻 0ms， T2 表示第二个报文发送时刻 100ms . . .，如果是理想状态下接收方接收到的报文的时刻依次是（50ms, 150ms, 250ms, 350ms….），但由于传输的原因接收方收到的报文的相对时刻可能是（50ms, 120ms, 240ms, 360ms ….），接收方实际接收报文的时刻和理想状态时刻的差值就是抖动。如下示意图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/doudong.jpg" alt="抖动"><br>&#160; &#160; &#160; &#160;我们知道视频必须按照严格是时间戳来播放，否则的就会出现视频动作加快或者放慢的现象，如果我们按照接收到视频数据就立即播放，那么这种加快和放慢的现象会非常频繁和明显。也就是说网络抖动会严重影响视频播放的质量，一般为了解决这个问题会<strong>设计一个视频播放缓冲区</strong>，通过缓冲接收到的视频帧，再按视频帧内部的时间戳来播放既可以了。</p>
<p>&#160; &#160; &#160; &#160;UDP 除了小范围的抖动以外，还是出现大范围的乱序现象，就是后发的报文先于先发的报文到达接收方。乱序会造成视频帧顺序错乱，一般解决的这个问题会在视频<strong>播放缓冲区里做一个先后排序功能</strong>让先发送的报文先进行播放。</p>
<p>&#160; &#160; &#160; &#160;播放缓冲区的设计非常讲究，如果缓冲过多帧数据会造成不必要的延迟，如果缓冲帧数据过少，会因为抖动和乱序问题造成播放无数据可以播的情况发生，会引起一定程度的卡顿。关于播放缓冲区内部的设计细节我们在后面的小节中详细介绍。</p>
<h2 id="2-4-丢包"><a href="#2-4-丢包" class="headerlink" title="2.4 丢包"></a>2.4 丢包</h2><p>&#160; &#160; &#160; &#160;UDP 在传输过程还会出现丢包，丢失的原因有多种，例如：网络出口不足、中间网络路由拥堵、socket 收发缓冲区太小、硬件问题、传输损耗问题等等。在基于 UDP 视频传输过程中，丢包是非常频繁发生的事情，丢包会造成视频解码器丢帧，从而引起视频播放卡顿。这也是大部分视频直播用 TCP 和 RTMP 的原因，因为 TCP 底层有自己的重传机制，可以保证在网络正常的情况下视频在传输过程不丢。基于 UDP 丢包补偿方式一般有以下几种：</p>
<h3 id="报文冗余"><a href="#报文冗余" class="headerlink" title="报文冗余"></a>报文冗余</h3><p>&#160; &#160; &#160; &#160;报文冗余很好理解，就是一个报文在发送的时候发送 2 次或者多次。这个做的好处是简单而且延迟小，坏处就是需要额外 N 倍（N 取决于发送的次数）的带宽。</p>
<h3 id="FEC"><a href="#FEC" class="headerlink" title="FEC"></a>FEC</h3><p>&#160; &#160; &#160; &#160; Forward Error Correction，即向前纠错算法，常用的算法有纠删码技术（EC），在分布式存储系统中比较常见。最简单的就是 A B 两个报文进行 XOR（与或操作）得到 C，同时把这三个报文发往接收端，如果接收端只收到 AC,通过 A 和 C 的 XOR 操作就可以得到 B 操作。这种方法相对增加的额外带宽比较小，也能防止一定的丢包，延迟也比较小，通常用于实时语音传输上。对于  1080P 300KB/S 码率的超清晰视频，哪怕是增加 20% 的额外带宽都是不可接受的，所以视频传输不太建议采用 FEC 机制。</p>
<h3 id="丢包重传"><a href="#丢包重传" class="headerlink" title="丢包重传"></a>丢包重传</h3><p>&#160; &#160; &#160; &#160;丢包重传有两种方式，一种是 push 方式，一种是 pull 方式。Push 方式是发送方没有收到接收方的收包确认进行周期性重传，TCP 用的是 push 方式。pull 方式是接收方发现报文丢失后发送一个重传请求给发送方，让发送方重传丢失的报文。丢包重传是按需重传，比较适合视频传输的应用场景，不会增加太对额外的带宽，但一旦丢包会引来至少一个 RTT 的延迟。</p>
<h2 id="2-5-MTU-和最大-UDP"><a href="#2-5-MTU-和最大-UDP" class="headerlink" title="2.5 MTU 和最大 UDP"></a>2.5 MTU 和最大 UDP</h2><p>&#160; &#160; &#160; &#160;IP 网定义单个 IP 报文最大的大小，常用 MTU 情况如下：</p>
<p>&#160; &#160; &#160; &#160;超通道 65535<br>&#160; &#160; &#160; &#160;16Mb/s 令牌环 179144<br>&#160; &#160; &#160; &#160;Mb/s 令牌环 4464<br>&#160; &#160; &#160; &#160;FDDI 4352<br>&#160; &#160; &#160; &#160;<font color="#ff0000">以太网 1500</font><br>&#160; &#160; &#160; &#160;<font color="#ff0000">IEEE 802.3/802.2 1492</font><br>&#160; &#160; &#160; &#160;<font color="#ff0000">X.25 576</font><br>&#160; &#160; &#160; &#160;点对点（低时延）296</p>
<p>&#160; &#160; &#160; &#160;红色的是 Internet 使用的上网方式，其中 X.25 是个比较老的上网方式，主要是利用 ISDN 或者电话线上网的设备，也不排除有些家用路由器沿用 X.25 标准来设计。所以我们必须清晰知道每个用户端的 MTU 多大，简单的办法就是在初始化阶段用各种大小的 UDP 报文来探测 MTU 的大小。MTU 的大小会影响到我们视频帧分片的大小，视频帧分片的大小其实就是单个 UDP 报文最大承载的数据大小。</p>
<p>&#160; &#160; &#160; &#160;<strong>分片大小 = MTU – IP 头大小 – UDP 头大小 – 协议头大小</strong>;<br>&#160; &#160; &#160; &#160;<strong>IP 头大小 = 20 字节， UDP 头大小 = 8 字节</strong>。</p>
<p>&#160; &#160; &#160; &#160;为了适应网络路由器小包优先的特性，我们如果得到的分片大小超过 800 时，会直接默认成 800 大小的分片。</p>
<h1 id="三、传输模型"><a href="#三、传输模型" class="headerlink" title="三、传输模型"></a>三、传输模型</h1><p>&#160; &#160; &#160; &#160;我们根据视频编码和网络传输得到特性对 1080P 超清视频的实时传输设计了一个自己的传输模型，这个模型包括一个根据网络状态自动码率的编解码器对象、一个网络发送模块、一个网络接收模块和一个 UDP 可靠到达的协议模型。各个模块的关系示意图如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/chuanshumoxing.jpg" alt="传输模型"></p>
<h2 id="3-1-通信协议"><a href="#3-1-通信协议" class="headerlink" title="3.1 通信协议"></a>3.1 通信协议</h2><p>&#160; &#160; &#160; &#160;先来看通信协议，我们定义的通信协议分为三个阶段：接入协商阶段、传输阶段、断开阶段。</p>
<h3 id="接入协商阶段"><a href="#接入协商阶段" class="headerlink" title="接入协商阶段"></a>接入协商阶段</h3><p>&#160; &#160; &#160; &#160;主要是发送端发起一个视频传输接入请求，携带本地的视频的当前状态、起始帧序号、时间戳和 MTU 大小等，接收方在收到这个请求后，根据请求中视频信息初始化本地的接收通道，并对本地 MTU 和发送端 MTU 进行比较取两者中较小的回送给发送方， 让发送方按协商后的 MTU 来分片。示意图如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/jieru.jpg" alt="接入协商"></p>
<h3 id="传输阶段"><a href="#传输阶段" class="headerlink" title="传输阶段"></a>传输阶段</h3><p>&#160; &#160; &#160; &#160;传输阶段有几个协议，一个测试量 RTT 的 PING/PONG 协议、携带视频帧分片的数据协议、数据反馈协议和发送端同步纠正协议。其中数据反馈协议是由接收反馈给发送方的，携带接收方已经接收到连续帧的报文 ID、帧 ID 和请求重传的报文 ID 序列。同步纠正协议是由发送端主动丢弃发送窗口缓冲区中的报文后要求接收方同步到当前发送窗口位置，防止在发送主动丢弃帧数据后接收方一直要求发送方重发丢弃的数据。示意图如下:<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/chuanshu.jpg" alt="传输"></p>
<h3 id="断开阶段"><a href="#断开阶段" class="headerlink" title="断开阶段"></a>断开阶段</h3><p>&#160; &#160; &#160; &#160;就一个断开请求和一个断开确认，发送方和接收方都可以发起断开请求。</p>
<h2 id="3-2-发送"><a href="#3-2-发送" class="headerlink" title="3.2 发送"></a>3.2 发送</h2><p>&#160; &#160; &#160; &#160;发送主要包括视频帧分片算法、发送窗口缓冲区、拥塞判断算法、过期帧丢弃算法和重传。先一个个来介绍。</p>
<h3 id="帧分片"><a href="#帧分片" class="headerlink" title="帧分片"></a>帧分片</h3><p>&#160; &#160; &#160; &#160;前面我们提到 MTU 和视频帧大小，在 1080P 下大部分视频帧的大小都大于 UDP 的 MTU 大小，那么就需要对帧进行分片，分片的方法很简单，按照先连接过程协商后的 MTU 大小来确定分片大小（<strong>确定分片大小的算法在 MTU 小节已经介绍过</strong>），然后将 帧数据按照分片大小切分成若干份，每一份分片以 segment 报文形式发往接收方。</p>
<h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><p>&#160; &#160; &#160; &#160;重传比较简单，我们采用 pull 方式来实现重传，当接收方发生丢包，如果丢包的时刻 T1 + rtt_var&lt; 接收方当前的时刻 T2，就认为是丢包了，这个时候就会把所有满足这个条件丢失的报文 ID 构建一个 segment ack 反馈给发送方，发送方收到这个反馈根据 ID 到重发窗口缓冲区中查找对应的报文重发即可。</p>
<p>&#160; &#160; &#160; &#160;<strong>为什么要间隔一个 rtt_var 才认为是丢包了</strong>？因为报文是有可能乱序到达，所有要等待一个抖动周期后认为丢失的报文还没有来才确认是报文丢失了，如果检测到丢包立即发送反馈要求重传，有可能会让发送端多发数据，造成带宽让费和网络拥塞。</p>
<h3 id="发送窗口缓冲区"><a href="#发送窗口缓冲区" class="headerlink" title="发送窗口缓冲区"></a>发送窗口缓冲区</h3><p>&#160; &#160; &#160; &#160;发送窗口缓冲区保存这所有正在发送且没有得到发送方连续 ID 确认的报文。当接收方反馈最新的连续报文 ID，发送窗口缓冲就会删除所有小于最新反馈连续的报文 ID，<strong>发送窗口缓冲区缓冲的报文都是为了重发而存在</strong>。这里解释下接收方反馈的连续的报文 ID，举个例子，假如发送方发送了 1. 2. 3. 4. 5，接收方收到 1.2. 4. 5。这个时候最小连续 ID = 2，如果后面又来了 3，那么接收方最小连续 ID = 5。</p>
<h3 id="拥塞判断"><a href="#拥塞判断" class="headerlink" title="拥塞判断"></a>拥塞判断</h3><p>&#160; &#160; &#160; &#160;我们把当前时间戳记为 curr_T，把发送窗口缓冲区中最老的报文的时间戳记为 oldest_T，它们之间的间隔记为 delay，那么</p>
<p>&#160; &#160; &#160; &#160;<strong>delay = curr_T - oldest_T</strong></p>
<p>&#160; &#160; &#160; &#160;在编码器请求发送模块发送新的视频帧时，如果 delay &gt; 拥塞阈值 Tn，我们就认为网络拥塞了，这个时候会根据最近 20 秒接收端确认收到的数据大小计算一个带宽值，并把这个带宽值反馈给编码器，编码器收到反馈后，会根据带宽调整编码码率。如果多次发生要求降低码率的反馈，我们会缩小图像的分辨率来保证视频的流畅性和实时性。Tn 的值可以通过 rtt 和 rtt_var 来确定。</p>
<p>&#160; &#160; &#160; &#160;但是网络可能阶段性拥塞，过后却恢复正常，我们设计了一个定时器来定时检查发送方的重发报文数量和 delay，如果发现恢复正常，会逐步增大编码器编码码率，让视频恢复到指定的分辨率和清晰度。</p>
<h3 id="过期帧丢弃"><a href="#过期帧丢弃" class="headerlink" title="过期帧丢弃"></a>过期帧丢弃</h3><p>&#160; &#160; &#160; &#160;在网络拥塞时可能发送窗口缓冲区中有很多报文正在发送，为了缓解拥塞和减少延迟我们会对整个缓冲区做检查，如果有超过一定阈值时间的 H.264 GOP 分组存在，我们会将这个 GOP 所有帧的报文从窗口缓冲区移除。并将它下一个 GOP 分组的 I 的帧 ID 和报文 ID 通过 wnd sync 协议同步到接收端上，接收端接收到这个协议，会将最新连续 ID 设置成同步过来的 ID。这里必须要说明的是如果频繁出现过期帧丢弃的动作会造成卡顿，说明当前网络不适合传输高分辨率视频，可以直接将视频设成更小的分辨率。</p>
<h2 id="3-3-接收"><a href="#3-3-接收" class="headerlink" title="3.3 接收"></a>3.3 接收</h2><p>&#160; &#160; &#160; &#160;接收主要包括丢包管理、播放缓冲区、缓冲时间评估和播放控制，都是围绕播放缓冲区来实现的，一个个来介绍。</p>
<h3 id="丢包管理"><a href="#丢包管理" class="headerlink" title="丢包管理"></a>丢包管理</h3><p>&#160; &#160; &#160; &#160;丢包管理包括丢包检测和丢失报文 ID 管理两部分。丢包检测过程大致是这样的，假设播放缓冲区的最大报文 ID 为 max_id，网络上新收到的报文 ID 为 new_id，如果 max_id + 1 &lt; new_id，那么可能发生丢包，就会将 [max_id + 1, new_id -1] 区间中所有的 ID 和当前时刻作为 K/V 对加入到丢包管理器当中。如果 new_id &lt; max_id，那么就将丢包管理中的 new_id 对应的 K/V 对删除，表示丢失的报文已经收到。当收包反馈条件满足时，会扫描整个丢包管理，将达到请求重传的丢包 ID 加入到 segment ack 反馈消息中并发往发送方请求重传，如果 ID 被请求了重传，会将当前时刻设置为 K/V 对中，增加对应报文的重传计数器 count，这个扫描过程会统计对包管理器中单个重发最多报文的重发次数 resend_count。</p>
<h3 id="缓冲时间评估"><a href="#缓冲时间评估" class="headerlink" title="缓冲时间评估"></a>缓冲时间评估</h3><p>&#160; &#160; &#160; &#160;在前面的抖动与乱序小节中我们提到播放端有个缓冲区，这个缓冲区过大时延迟就大，缓冲区过小时又会出现卡顿现象，我们针对这个问题设计了一个缓冲时间评估的算法。缓冲区评估先会算出一个 cache timer，cache timer 是通过扫描对包管理得到的 resend count 和 rtt 得到的，我们知道从请求重传报文到接收方收到重传的报文的时间间隔是一个 RTT 周期，所以 cache timer 的计算方式如下。</p>
<p>&#160; &#160; &#160; &#160;<strong>cache timer = (2 <em> resend_count+ 1) </em> (rtt + rtt_var) / 2</strong></p>
<p>&#160; &#160; &#160; &#160;有可能 cache timer 计算出来很小（小于视频帧之间间隔时间 frame timer），那么 cache timer = frame timer，也就是说网络再好，缓冲区缓冲区至少 1 帧视频的数据，否则缓冲区是毫无意义的。</p>
<p>&#160; &#160; &#160; &#160;如果单位时间内没有丢包重传发生，那么 cache timer 会做适当的缩小，这样做的好处是当网络间歇性波动造成 cache timer 很大，恢复正常后 cache timer 也能恢复到相对小位置，缩减不必要的缓冲区延迟。</p>
<h3 id="播放缓冲区"><a href="#播放缓冲区" class="headerlink" title="播放缓冲区"></a>播放缓冲区</h3><p>&#160; &#160; &#160; &#160;我们设计的播放缓冲区是按帧 ID 为索引的有序循环数组，数组内部的单元是视频帧的具体信息：帧 ID、分片数、帧类型等。缓冲区有两个状态：waiting 和 playing，waiting 状态表示缓冲区处于缓冲状态，不能进行视频播放直到缓冲区中的帧数据达到一定的阈值。Playing 状态表示缓冲区进入播放状态，播放模块可以从中取出帧进行解码播放。我们来介绍下这两个状态的切换关系：</p>
<ul>
<li>当缓冲区创建时会被初始化成 waiting 状态。</li>
<li>当缓冲区中缓冲的最新帧与最老帧的时间戳间隔 &gt; cache timer 时，进入 playing 状态并更当前时刻设成播放绝对时间戳 play ts。</li>
<li>当缓冲区处于 playing 状态且缓冲区是没有任何帧数据，进入 waiting 状态直到触发第 2 步。</li>
</ul>
<p>&#160; &#160; &#160; &#160;<strong>播放缓冲区的目的就是防止抖动和应对丢包重传，让视频流能按照采集时的频率进行播放，播放缓冲区的设计极其复杂，需要考虑的因素很多，实现的时候需要慎重</strong>。</p>
<h3 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h3><p>&#160; &#160; &#160; &#160;接收端最后一个环节就是播放控制，播放控制就是从缓冲区中拿出有效的视频帧进行解码播放。但是怎么拿？什么时候拿？我们知道视频是按照视频帧从发送端携带过来的相对时间戳来做播放，我们每一帧视频都有一个相对时间戳 TS，根据帧与帧之间的 TS 的差值就可以知道上一帧和下一帧播放的时间间隔，假如上一帧播放的绝对时间戳为 prev_play_ts，相对时间戳为 prev_ts，当前系统时间戳为 curr_play_ts，当前缓冲区中最小序号帧的相对时间戳为  frame_ts，只要满足：</p>
<p>&#160; &#160; &#160; &#160;Prev_play_ts + (frame_ts – prev_ts) &lt; curr_play_ts <strong>且这一帧数据是所有的报文都收齐了</strong></p>
<p>&#160; &#160; &#160; &#160;这两个条件就可以进行解码播放，取出帧数据后将 Prev_play_ts = cur_play_ts，但更新 prev_ts 有些讲究，为了防止缓冲延迟问题我们做了特殊处理。</p>
<p>&#160; &#160; &#160; &#160;如果 frame_ts + cache timer &lt; 缓冲区中最大帧的 ts，表明缓冲的时延太长，则 prev_ts = 缓冲区中最大帧的 ts - cache timer。 否则 prev_ts = frame_ts。</p>
<h1 id="四、测量"><a href="#四、测量" class="headerlink" title="四、测量"></a>四、测量</h1><p>&#160; &#160; &#160; &#160;再好的模型也需要有合理的测量方式来验证，在多媒体这种具有时效性的传输领域尤其如此。一般在实验室环境我们采用 netem 来进行模拟公网的各种情况进行测试，如果在模拟环境已经达到一个比较理想的状态后会组织相关人员在公网上进行测试。下面来介绍怎么来测试我们整个传输模型的。</p>
<h2 id="4-1-netem-模拟测试"><a href="#4-1-netem-模拟测试" class="headerlink" title="4.1 netem 模拟测试"></a>4.1 netem 模拟测试</h2><p>&#160; &#160; &#160; &#160;Netem 是 Linux 内核提供的一个网络模拟工具，可以设置延迟、丢包、抖动、乱序和包损坏等，基本能模拟公网大部分网络情况。</p>
<p>关于 netem 可以访问它的官网：<br><a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank" rel="external">https://wiki.linuxfoundation.org/networking/netem</a></p>
<p>&#160; &#160; &#160; &#160;我们在实验环境搭建了一个基于服务器和客户端模式的测试环境，下面是测试环境的拓扑关系图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/tuopu.png" alt="拓扑关系"></p>
<p>&#160; &#160; &#160; &#160;我们利用 Linux 来做一个路由器，服务器和收发端都连接到这个路由器上，服务器负责客户端的登记、数据转发、数据缓冲等，相当于一个简易的流媒体服务器。Sender 负责媒体编码和发送，receiver 负责接收和媒体播放。为了测试延迟，我们把 sender 和 receiver 运行在同一个 PC 机器上，在 sender 从 CCD 获取到 RGB 图像时打一个时间戳，并把这个时间戳记录在这一帧数据的报文发往 server 和 receiver，receiver 收到并解码显示这帧数据时，通过记录的时间戳可以得到整个过程的延迟。我们的测试用例是用 1080P 码率为 300KB/S 视频流，在 router 用 netem 上模拟了以下几种网络状态：</p>
<ul>
<li>环路延迟 10m，无丢包，无抖动，无乱序</li>
<li>环路延迟 30ms，丢包 0.5%，抖动 5ms, 2% 乱序</li>
<li>环路延迟 60ms，丢包 1%，抖动 20ms, 3% 乱序，0.1% 包损坏</li>
<li>环路延迟 100ms，丢包 4%，抖动 50ms, 4% 乱序，0.1% 包损坏</li>
<li>环路延迟 200ms，丢包 10%，抖动 70ms, 5% 乱序，0.1% 包损坏</li>
<li>环路延迟 300ms，丢包 15%，抖动 100ms, 5% 乱序，0.1% 包损坏</li>
</ul>
<p>&#160; &#160; &#160; &#160;因为传输机制采用的是可靠到达，那么检验传输机制有效的参数就是视频延迟，我们统计 2 分钟周期内最大延迟，以下是各种情况的延迟曲线图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B01080P%E5%BB%B6%E8%BF%9F%E4%BD%8E%E4%BA%8E500ms%E7%9A%84%E5%AE%9E%E6%97%B6%E8%B6%85%E6%B8%85%E7%9B%B4%E6%92%AD%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/yanshiquxian.jpg" alt="延时曲线"><br>&#160; &#160; &#160; &#160;从上图可以看出，<strong>如果网络控制在环路延迟在 200ms 丢包在 10% 以下，可以让视频延迟在 500ms 毫秒以下</strong>，这并不是一个对网络质量要求很苛刻的条件。所以我们在后台的媒体服务部署时，尽量让客户端到媒体服务器之间的网络满足这个条件，如果网路环路延迟在 300ms 丢包 15% 时，依然可以做到小于 1 秒的延迟，基本能满足双向互动交流。</p>
<h2 id="4-2-公网测试"><a href="#4-2-公网测试" class="headerlink" title="4.2 公网测试"></a>4.2 公网测试</h2><p>&#160; &#160; &#160; &#160;公网测试相对比较简单，我们将 Server 部署到 UCloud 云上，发送端用的是上海电信 100M 公司宽带，接收端用的是河北联通 20M 小区宽带，环路延迟在 60ms 左右。总体测试下来 1080P 在接收端观看视频流畅自然，无抖动，无卡顿，延迟统计平均在 180ms 左右。</p>
<h1 id="五、坑"><a href="#五、坑" class="headerlink" title="五、坑"></a>五、坑</h1><p>&#160; &#160; &#160; &#160;在整个 1080P 超清视频的传输技术实现过程中，我们遇到过比较多的坑。大致如下：</p>
<h3 id="Socket-缓冲区问题"><a href="#Socket-缓冲区问题" class="headerlink" title="Socket 缓冲区问题"></a>Socket 缓冲区问题</h3><p>&#160; &#160; &#160; &#160;我们前期开发阶段都是使用 socket 默认的缓冲区大小，由于 1080P 图像帧的数据非常巨大（关键帧超过 80KB），我们发现在在内网测试没有设置丢包的网络环境发现接收端有严重的丢包，经查证是 socket 收发缓冲区太小造成丢包的，后来我们把 socket 缓冲区设置到 128KB 大小，问题解决了。</p>
<h3 id="H-264-B-帧延迟问题"><a href="#H-264-B-帧延迟问题" class="headerlink" title="H.264 B 帧延迟问题"></a>H.264 B 帧延迟问题</h3><p>&#160; &#160; &#160; &#160;前期我们为了节省传输带宽和防丢包开了 B 帧编码，由于 B 帧是前后双向预测编码的，会在编码期滞后几个帧间隔时间，引起了超过 100ms 的编码延时，后来我们为了实时性干脆把 B 帧编码选项去掉。</p>
<h3 id="Push-方式丢包重传"><a href="#Push-方式丢包重传" class="headerlink" title="Push 方式丢包重传"></a>Push 方式丢包重传</h3><p>&#160; &#160; &#160; &#160;在设计阶段我们曾经使用发送端主动 push 方式来解决丢包重传问题，在测试过程发现在丢包频繁发生的情况下至少增加了 20% 的带宽消耗，而且容易带来延迟和网络拥塞。后来几经论证用现在的 pull 模式来进行丢包重传。</p>
<h3 id="Segment-内存问题"><a href="#Segment-内存问题" class="headerlink" title="Segment 内存问题"></a>Segment 内存问题</h3><p>&#160; &#160; &#160; &#160;在设计阶段我们对每个视频缓冲区中的帧信息都是动态分配内存对象的，由于 1080P 在传输过程中每秒会发送 400 - 500 个 UDP 报文，在 PC 端长时间运行容易出现内存碎片，在服务器端出现莫名其妙的 clib 假内存泄露和并发问题。我们实现了一个 memory slab 管理频繁申请和释放内存的问题。</p>
<h3 id="音频和视频数据传输问题"><a href="#音频和视频数据传输问题" class="headerlink" title="音频和视频数据传输问题"></a>音频和视频数据传输问题</h3><p>&#160; &#160; &#160; &#160;在早期的设计之中我们借鉴了 FLV 的方式将音频和视频数据用同一套传输算法传输，好处就是容易实现，但在网络波动的情况下容易引起声音卡顿，也无法根据音频的特性优化传输。后来我们把音频独立出来，针对音频的特性设计了一套低延迟高质量的音频传输体系，定点对音频进行传输优化。</p>
<p>&#160; &#160; &#160; &#160;后续的工作是重点放在媒体器多点分布、多点并发传输、P2P 分发算法的探索上，尽量减少延迟和服务带宽成本,让传输变的更高效和更低廉。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>提问：在优化到 500ms 方案中，哪一块是最关键的</strong>？<br>袁荣喜：主要是丢包重传 拥塞和播放缓冲这三者之间的协调工作最为关键，要兼顾延迟控制和视频流畅性。</p>
<p><strong>提问：多方视频和单方有哪些区别，用到了 CDN 推流吗</strong>？<br>袁荣喜：我们公司是做在线教育的，很多场景需要老师和学生交谈，用 CDN 推流方式延迟很大，我们这个视频主要是解决多方通信之间交谈延迟的问题。我们现在观看放也有用 CDN 推流，但只是单纯的观看。我们也在研发基于 UDP 的观看端分发协议，目前这部分工作还没有完成。</p>
<h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><ul>
<li><a href="http://windrunnerlihuan.com/2016/06/06/移动直播技术秒开优化经验/">移动直播技术秒开优化经验（含PPT）</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547390&amp;idx=1&amp;sn=c241c46b7c9eba70cd0324117835270a&amp;scene=21#wechat_redirect" target="_blank" rel="external">揭秘百万人围观的Facebook视频直播</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[插件开发中的资源问题分析及填坑处理]]></title>
      <url>http://windrunnerlihuan.com/2016/09/05/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;做插件开发有两个问题需要解决，一个是资源文件加载，另一个是关于四大组件生命周期的管理。这里我们就简单分析会遇到那些坑，和一些简单的处理方法或者思路。<br><a id="more"></a><br>&#160; &#160; &#160; &#160;插件开发目前已经不是什么最新技术了，目前市面上已有很多成熟的方案和开源工程，比如<code>任玉刚</code>的<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a>、阿里的<a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a>和<a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">dexposed</a>、360的<a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">DroidPlugin</a>、QQ空间的<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">nuwa</a>。各家实现方案也是各有不同，这些开源库大多已经广泛应用于很多市面上的软件。<br>&#160; &#160; &#160; &#160;说到未来，不得不提一下<strong>ReactNative</strong>，移动应用web化一定是一个必然的趋势，就好像曾经的桌面应用由C/S到B/S的转变。而怎么web化才是关键之处。但目前<strong>RN</strong>在IOS开发中优势很明显，在Android中却是挖坑不断。</p>
<h1 id="普通插件开发"><a href="#普通插件开发" class="headerlink" title="普通插件开发"></a>普通插件开发</h1><h2 id="开发前提"><a href="#开发前提" class="headerlink" title="开发前提"></a>开发前提</h2><p>&#160; &#160; &#160; &#160;Android为我们从ClassLoader派生出了两个类：<strong>DexClassLoader</strong>和<strong>PathClassLoader</strong>。在加载类的时候，是执行父类ClassLoader的loadClass方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Don't want to see this.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因此DexClassLoader和PathClassLoader都属于符合双亲委派模型的类加载器（因为它们没有重载loadClass方法）。也就是说，它们在加载一个类之前，回去检查自己以及自己以上的类加载器是否已经加载了这个类。如果已经加载过了，就会直接将之返回，而不会重复加载。<br>&#160; &#160; &#160; &#160;这两者的区别在于DexClassLoader需要提供一个可写的outpath路径，用来释放.apk包或者.jar包中的dex文件。换个说法来说，就是PathClassLoader不能主动从zip包中释放出dex，因此只支持直接操作dex格式文件，或者已经安装的apk（因为已经安装的apk在cache中存在缓存的dex文件）。而DexClassLoader可以支持.apk、.jar和.dex文件，并且会在指定的outpath路径释放出dex文件。<br>&#160; &#160; &#160; &#160;因此，我们要实现插件开发，需要用DexClassLoader。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>&#160; &#160; &#160; &#160;如果只需要加载插件apk中一个普通的类，只要构造一个DexClassLoader，它的构造方法对每个参数已经说明的很清楚了，我们可以试验一下。<br>&#160; &#160; &#160; &#160;新建一个插件工程TestPlugin，里面放一个类Plugin.java，再放一个简单的方法，即TestPlugin/src/com/example/plugin/Plugin.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCommonStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"COMMON"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后新建一个宿主工程TestHost，在MainActivity里面写一个加载插件的方法，即TestHost/src/com/example/host/MainActivity.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">		loadPluginClass();		</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//定义DexClassLoader  </span></span><br><span class="line">    <span class="comment">//第一个参数：是dex压缩文件的路径  </span></span><br><span class="line">    <span class="comment">//第二个参数：是dex解压缩后存放的目录  </span></span><br><span class="line">    <span class="comment">//第三个参数：是C/C++依赖的本地库文件目录,可以为null  </span></span><br><span class="line">    <span class="comment">//第四个参数：是上一级的类加载器  </span></span><br><span class="line">	DexClassLoader dexClassLoader = <span class="keyword">new</span> DexClassLoader(<span class="keyword">this</span>.getCacheDir().getAbsolutePath() + File.separator + <span class="string">"TestPlugin.apk"</span>,</span><br><span class="line">	<span class="keyword">this</span>.getCacheDir().getAbsolutePath(), <span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = dexClassLoader .loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	<span class="keyword">if</span>(pluginClass == <span class="keyword">null</span>)&#123;</span><br><span class="line">		Log.e(TAG, <span class="string">"plugin class cann't be found"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line"></span><br><span class="line">	Method pluginMethod = pluginClass.getMethod(<span class="string">"getCommonStr"</span>);</span><br><span class="line">	<span class="keyword">if</span>(pluginMethod == <span class="keyword">null</span>)&#123;</span><br><span class="line">		Log.e(TAG, <span class="string">"plugin method cann't be found"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	String methodStr = (String) pluginMethod .invoke(pluginObject);</span><br><span class="line">	Log.e(TAG, <span class="string">"Print Method str = "</span> + methodStr);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先安装宿主程序TestHost.apk，然后将插件TestPlugin.apk放到/data/data/com.example.host/cache/下面，再次运行宿主程序，会打印如下log：<br>&#160; &#160; &#160; &#160;Print Method str = COMMON<br>&#160; &#160; &#160; &#160;这个应该比较随意了，会使用DexClassLoader这个类的开发者都是轻车熟路。</p>
<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><h3 id="普通资源"><a href="#普通资源" class="headerlink" title="普通资源"></a>普通资源</h3><p>&#160; &#160; &#160; &#160;我们知道插件apk中的资源文件是无法直接加载的，因为插件apk并没有安装，所以没有给每个资源生成特定的资源id，所以我们没法使用R.XXX去引用。<br>&#160; &#160; &#160; &#160;不过我们通过android系统安装apk时对资源文件的处理流程中发现可以通过AssetManager这个类完成对插件中资源的引用。Java的源码中发现，它有一个私有方法addAssetPath，只需要将apk的路径作为参数传入，我们就可以获得对应的AssetsManager对象，然后我们就可以使用AssetsManager对象，创建一个Resources对象，然后就可以从Resource对象中访问apk中的资源了。总结如下：</p>
<ul>
<li>新建一个AssetManager对象</li>
<li>通过反射调用addAssetPath方法</li>
<li>以AssetsManager对象为参数，创建Resources对象即可</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们测试demo可以写一个工具类，省略了一部分，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginBaseImpl</span> <span class="keyword">extends</span> <span class="title">PluginBase</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Resources <span class="title">loadResource</span><span class="params">(Context parentContext, String apkPath)</span> </span>&#123;</span><br><span class="line">		Resources ret = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">			Method method = assetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">			method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			method.invoke(assetManager, apkPath);</span><br><span class="line">			ret = <span class="keyword">new</span> Resources(assetManager, parentContext.getResources().getDisplayMetrics(), parentContext.getResources().getConfiguration());</span><br><span class="line">			Log.e(TAG, <span class="string">"loadResources succeed"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			Log.e(TAG, <span class="string">"loadResources faided"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后我们再插件工程里面再添加一个方法，再放入一个简单的资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getContextStr</span><span class="params">(Resources resources)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> resources.getString(R.string.plugin_str);<span class="comment">//&lt;string name="plugin_str"&gt;PLUGIN&lt;/string&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;测试如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	...省略一些初始化代码...</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//构造一个DexClassLoader</span></span><br><span class="line">	DexClassLoader  dexClassLoader = mPluginBase.makeDexClassLoader(APK_PATH, DEX_PATH,</span><br><span class="line">	<span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = mDexClassLoader.loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	......</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line">	<span class="comment">//加载插件apk资源</span></span><br><span class="line">	Resources pluginResources = mPluginBase.loadResource(<span class="keyword">this</span>, APK_PATH);</span><br><span class="line">	</span><br><span class="line">	Method m2 = pluginClass.getMethod(<span class="string">"getContextStr"</span>, Resources.class);</span><br><span class="line">	String methodStr2 = (String) m2.invoke(pluginObject, pluginResources);</span><br><span class="line">	Log.e(TAG, <span class="string">"Print Resource str = "</span> + methodStr2);</span><br><span class="line">	......		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;运行之后，打印log如下：<br>&#160; &#160; &#160; &#160;Print Resource str = PLUGIN</p>
<h3 id="Layout资源"><a href="#Layout资源" class="headerlink" title="Layout资源"></a>Layout资源</h3><p>&#160; &#160; &#160; &#160;如果要使用插件apk里面的layout资源，比如引用某个布局文件TestPlugin/res/layout/plugin.xml，就需要做一做处理。<br>&#160; &#160; &#160; &#160;一般从layout转换成view需要用到LayoutInflate，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View view = LayoutInflater.from(context).inflate(R.layout.plugin, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;但是这个context不能直接传宿主程序的context，否则回报一个资源id没有找到异常。我们跟着LayoutInflate的源码进去看看，问题出在哪儿：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Inflate时会调用到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//这句返回的resource是宿主程序ContextImpl里的resource，即宿主程序的resource</span></span><br><span class="line">        <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">        </span><br><span class="line">		......</span><br><span class="line">		<span class="comment">//所以这里在宿主resource里当然找不到插件资源id了，这个里面抛出了异常</span></span><br><span class="line">        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parser.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们看到inflate时还是在宿主程序的资源里查找了插件资源，因此回报异常。不过我们可以投机取巧一下，重写一个LayoutInflate的Inflate第二个重载方法。在插件工程里可以做如下测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">		<span class="function"><span class="keyword">public</span> LinearLayout <span class="title">getLinearLayout</span><span class="params">(Context context, <span class="keyword">final</span> Resources resources)</span></span>&#123;</span><br><span class="line">		LayoutInflater inflater = <span class="keyword">new</span> LayoutInflater(context) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root,</span><br><span class="line">					<span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		        final Resources res = getContext().getResources(); //注释掉这行</span></span><br><span class="line">		        <span class="keyword">final</span> Resources res = resources; <span class="comment">//替换为插件apk资源</span></span><br><span class="line"></span><br><span class="line">		        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">		        <span class="keyword">try</span> &#123;</span><br><span class="line">		            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">		        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		            parser.close();</span><br><span class="line">		        &#125;</span><br><span class="line">			&#125;    </span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> (LinearLayout) inflater.inflate(R.layout.plugin_layout, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后在宿主程序里写上测试demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	...省略一些初始化代码...</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//构造一个DexClassLoader</span></span><br><span class="line">	DexClassLoader  dexClassLoader = mPluginBase.makeDexClassLoader(APK_PATH, DEX_PATH,</span><br><span class="line">	<span class="keyword">null</span>, getApplicationContext().getClassLoader());</span><br><span class="line">	Class&lt;?&gt; pluginClass = mDexClassLoader.loadClass(<span class="string">"com.example.plugin.Plugin"</span>);</span><br><span class="line">	......</span><br><span class="line">	Object pluginObject = pluginClass.newInstance();</span><br><span class="line">	<span class="comment">//加载插件apk资源</span></span><br><span class="line">	Resources pluginResources = mPluginBase.loadResource(<span class="keyword">this</span>, APK_PATH);</span><br><span class="line">	<span class="comment">//测试插件layout文件</span></span><br><span class="line">	Method m3 = pluginClass.getMethod(<span class="string">"getLinearLayout"</span>, Context.class, Resources.class);</span><br><span class="line">	LinearLayout pluginView = (LinearLayout) m3.invoke(pluginObject, <span class="keyword">this</span>, pluginResources );</span><br><span class="line">	<span class="keyword">this</span>.addContentView(pluginView, <span class="keyword">new</span> RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));</span><br><span class="line">	......		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过测试，插件的layout布局被加入到了宿主界面上，图片就不贴了。</p>
<h3 id="另外三种方式"><a href="#另外三种方式" class="headerlink" title="另外三种方式"></a>另外三种方式</h3><p>&#160; &#160; &#160; &#160;上面的方法其实还是有些繁琐，如果要封装的完善一些可以尝试下面三种方案：</p>
<ul>
<li>创建一个自己的ContextImpl，Override其方法</li>
<li>通过反射，直接替换当前context的mResources私有成员变量</li>
<li>反射替换ActivityThread里的Instrumentation，将插件资源和宿主资源整合</li>
</ul>
<p>(1) 创建自己的Context：<br>&#160; &#160; &#160; &#160;要构建自己的Context，就得继承ContextWrapper类，（Context类和它的一些子类大家应该都清楚）然后重写里面的一些重要方法。实例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginContext</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"PluginContext"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DexClassLoader mClassLoader ;</span><br><span class="line">    <span class="keyword">private</span> Resources mResources;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line"></span><br><span class="line">    PluginContext(Context context, String pluginPath, String optimizedDirectory, String libraryPath) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context.getApplicationContext());</span><br><span class="line">        </span><br><span class="line">        Resources resc = context.getResources();</span><br><span class="line">        <span class="comment">//隐藏API是这样的</span></span><br><span class="line">        <span class="comment">//AssetManager assets = new AssetManager();</span></span><br><span class="line">        AssetManager assets = AssetManager.class.newInstance();</span><br><span class="line">        assets.addAssetPath(pluginPath);</span><br><span class="line"></span><br><span class="line">		mClassLoader = <span class="keyword">new</span> DexClassLoader(pluginPath, optimizedDirectory, libraryPath, context.getClassLoader());</span><br><span class="line">        mResources = <span class="keyword">new</span> Resources(assets, resc.getDisplayMetrics(), </span><br><span class="line">                resc.getConfiguration(), resc.getCompatibilityInfo(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//隐藏API是这样的</span></span><br><span class="line">        <span class="comment">//mInflater = PolicyManager.makeNewLayoutInflater(this);</span></span><br><span class="line">        mInflater = <span class="keyword">new</span> LayoutInflater(context) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root,</span><br><span class="line">					<span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		        final Resources res = getContext().getResources();</span></span><br><span class="line">		        <span class="keyword">final</span> Resources res = mResources;</span><br><span class="line"></span><br><span class="line">		        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">		        <span class="keyword">try</span> &#123;</span><br><span class="line">		            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">		        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		            parser.close();</span><br><span class="line">		        &#125;</span><br><span class="line">			&#125;    </span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources.getAssets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == Context.LAYOUT_INFLATER_SERVICE)</span><br><span class="line">            <span class="keyword">return</span> mInflater;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSystemService(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Theme mTheme;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mTheme == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> resid = Resources.selectDefaultTheme(<span class="number">0</span>,</span><br><span class="line">                        getBaseContext().getApplicationInfo().targetSdkVersion);</span><br><span class="line">                mTheme = mResources.newTheme();</span><br><span class="line">                mTheme.applyStyle(resid, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mTheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样我们插件的Context就构造完成了，以后就可以使用这个Context加载插件中的资源文件了。</p>
<p>(2) 替换当前context的mResources私有成员变量：<br>&#160; &#160; &#160; &#160;这个需要在Activity的attachBaseContext方法中替换它的Context，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">		replaceContextResources(newBase);</span><br><span class="line">		<span class="keyword">super</span>.attachBaseContext(newBase);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">     * 使用反射的方式，使用mPluginResources对象，替换Context的mResources对象</span><br><span class="line">     * <span class="doctag">@param</span> context</span><br><span class="line">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceContextResources</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Field field = context.getClass().getDeclaredField(<span class="string">"mResources"</span>);</span><br><span class="line">			field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			field.set(context, mPluginResources);</span><br><span class="line">			Log.e(TAG, <span class="string">"replace resources succeed"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			Log.e(TAG, <span class="string">"replace resources failed"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3) 反射替换ActivityThread里的Instrumentation，将插件资源和宿主资源整合:<br>&#160; &#160; &#160; &#160;AssetManager的addAssetPath()法调用native层AssetManager对象的addAssetPath()法，通过查看c++代码可以知道，该方法可以被调用多次，每次调用都会把对应资源添加起来，而后来添加的在使用资源是会被首先搜索到。可以怎么理解，C++层的AssetManager有一个存放资源的栈，每次调用addAssetPath()法都会把资源对象压如栈，而在读取搜索资源时是从栈顶开始搜索，找不到就往下查。所以我们可以这样来处理AssetManager并得到Resources。<br>&#160; &#160; &#160; &#160;使用到资源的地方归纳起来有两处，一处是在Java代码中通过Context.getResources获取，一处是在xml文件（如布局文件）里指定资源，其实xml文件里最终也是通过Context来获取资源的只不过是他一般获取的是Resources里的AssetManager。所以，我们可以在Context对象被创建后且还未使用时把它里面的Resources（mResources）替换掉。整个应用的Context数目等于Application+Activity+Service的数目，Context会在这几个类创建对象的时候创建并添加进去。而这些行为都是在ActivityTHread和Instrumentation里做的。<br>&#160; &#160; &#160; &#160;以Activity为例，步骤如下：<br>&#160; &#160; &#160; &#160;1. Activity对象的创建是在ActivityThread里调用Instrumentation的newActivity方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//Instrumentation类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span><br><span class="line">            Intent intent)</span></span><br><span class="line">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">            ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2.Context对象的创建是在ActivityThread里调用createBaseContextForActivity方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;3.Activity绑定Context是在ActivityThread里调用Activity对象的attach方法，其中appContext就是上面创建的Context对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.voiceInteractor);</span><br><span class="line">        ......            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;替换掉Activity里Context里的Resources最好要早，基于上面的观察，我们可以在调用Instrumentation的callActivityOnCreate（）方法时把Resources替换掉。那么问题又来了，我们如何控制callActivityOnCreate（）方法的执行，这里又得使用hook的思想了，即把ActivityThread里面的Instrumentation对象（mInstrumentation）给替换掉，同样得使用反射。步骤如下:<br>&#160; &#160; &#160; &#160;1. 获取ActivityThread对象:<br>&#160; &#160; &#160; &#160;ActivityThread里面有一个静态方法，该方法返回的是ActivityThread对象本身，所以我们可以调用该方法来获取ActivityTHread对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">currentActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sCurrentActivityThread;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然而ActivityThread是被hide的，所以得通过反射来处理，处理如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ActivityThread类</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line"><span class="comment">//获取currentActivityThread方法</span></span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//获取ActivityThread对象</span></span><br><span class="line">Object CurrentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2. 获取ActivityThread里的Instrumentation对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(CurrentActivityThread);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;3. 构建我们自己的Instrumentation对象，并从写callActivityOnCreate方法<br>在callActivityOnCreate方法里要先获取当前Activity对象里的Context（mBase），再获取Context对象里的Resources（mResources）变量，在把mResources变量指向我们构造的Resources对象，做到移花接木。构建我们的MyInstrumentation类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Instrumentation mInstrumentationParent;</span><br><span class="line">	<span class="keyword">private</span> Context mContextParent;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyInstrumentation</span><span class="params">(Instrumentation instrumentation, Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		mInstrumentationParent = instrumentation;</span><br><span class="line">		mContextParent = context;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Field mBaseField = Activity.class.getSuperclass().getSuperclass().getDeclaredField(<span class="string">"mBase"</span>);</span><br><span class="line">			mBaseField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			Context mBase = (Context) mBaseField.get(activity);</span><br><span class="line">			</span><br><span class="line">			Class&lt;?&gt; contextImplClazz = Class.forName(<span class="string">"android.app.ContextImpl"</span>);</span><br><span class="line">			Field mResourcesField = contextImplClazz.getDeclaredField(<span class="string">"mResources"</span>);</span><br><span class="line">			mResourcesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			</span><br><span class="line">			String dexPath = activity.getCacheDir() + File.separator + <span class="string">"TestPlugin.apk"</span>;</span><br><span class="line">			String dexPath2 = mContextParent.getApplicationContext().getPackageCodePath();</span><br><span class="line">			</span><br><span class="line">			AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">			Method addAssetPath = assetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">			addAssetPath.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			</span><br><span class="line">			addAssetPath.invoke(assetManager, dexPath);</span><br><span class="line">			addAssetPath.invoke(assetManager, dexPath2);</span><br><span class="line">			</span><br><span class="line">			Method ensureStringBlocksMethod = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</span><br><span class="line">			ensureStringBlocksMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">			ensureStringBlocksMethod.invoke(assetManager);</span><br><span class="line">			</span><br><span class="line">			Resources superRes = mContextParent.getResources();</span><br><span class="line">			Resources resources = <span class="keyword">new</span> Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());</span><br><span class="line">			</span><br><span class="line">			mResourcesField.set(mBase, resources);</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">super</span>.callActivityOnCreate(activity, icicle);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;4. 最后，使ActivityThread里面的mInstrumentation变量指向我们构建的MyInstrumentation对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookResources</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">	 <span class="comment">//获取ActivityThread类</span></span><br><span class="line">       Class&lt;?&gt; activityThreadClass;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">		<span class="comment">//获取currentActivityThread方法</span></span><br><span class="line">		Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">		currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//获取ActivityThread对象</span></span><br><span class="line">		Object CurrentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//获取Instrumentation变量</span></span><br><span class="line">		Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">        mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(CurrentActivityThread);</span><br><span class="line">		<span class="comment">//构建自己的Instrumentation对象</span></span><br><span class="line">        Instrumentation proxy = <span class="keyword">new</span> MyInstrumentation(mInstrumentation, context);</span><br><span class="line">        <span class="comment">//移花接木</span></span><br><span class="line">        mInstrumentationField.set(CurrentActivityThread, proxy);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="加载SO库流程分析和填坑"><a href="#加载SO库流程分析和填坑" class="headerlink" title="加载SO库流程分析和填坑"></a>加载SO库流程分析和填坑</h2><p>&#160; &#160; &#160; &#160;插件加载带有动态库的apk时，会报UnsatisfiedLinkError找不到动态库的错误原因是我们没有动态指定so库的路径。<br>&#160; &#160; &#160; &#160;解决方法是在DexClassLoader中第三个参数书指定so库的目录路径，因此我们需要把动态库给解压出来放到data/data/xx（package）目录下。<br>&#160; &#160; &#160; &#160;这个，我把so文件放到了/data/data/com.example.host/cache/下面，然后给我们的DexClassLoader第三个参数指定了这个目录，然后在插件工程里调用System.loadLibrary方法就不会报错了。</p>
<p>&#160; &#160; &#160; &#160;关于解压so文件和获取手机CPU的ABI类型这里就不在赘述，网上也是大把的代码。我们主要分析一下Android找寻so和加载的流程：</p>
<h3 id="SO库加载过程"><a href="#SO库加载过程" class="headerlink" title="SO库加载过程"></a>SO库加载过程</h3><p>&#160; &#160; &#160; &#160;在Android中如果想使用so的话，首先得先加载，加载现在主要有两种方法，一种是直接System.loadLibrary方法加载工程中的libs目录下的默认so文件，这里的加载文件名是xxx，而整个so的文件名为：libxxx.so。还有一种是加载指定目录下的so文件，使用System.load方法，这里需要加载的文件名是全路径，比如：xxx/xxx/libxxx.so。<br>&#160; &#160; &#160; &#160;我们可以看看System类的这两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String pathName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libName)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这两个方法都会进入到Runtime类的不同方法中，我们继续跟进去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//load方法比较简单</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(String absolutePath, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (absolutePath == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"absolutePath == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//都会调用doLoad方法</span></span><br><span class="line">       String error = doLoad(absolutePath, loader);</span><br><span class="line">       <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//loadLibrary比较复杂</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libraryName, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;<span class="comment">//这个loader就是加载目标类的ClassLoader，宿主工程为系统指定的PathClassLoader，插件工程为我们构造的DexClassLoader</span></span><br><span class="line">        <span class="comment">//首先会从一些指定目录中查找指定名字的so文件</span></span><br><span class="line">           String filename = loader.findLibrary(libraryName);</span><br><span class="line">           <span class="comment">//如果没有找到就会抛异常</span></span><br><span class="line">           <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;<span class="comment">//这个异常就是我们没有指定DexClassLoader第三个参数时报的异常</span></span><br><span class="line">               <span class="comment">// It's not necessarily true that the ClassLoader used</span></span><br><span class="line">               <span class="comment">// System.mapLibraryName, but the default setup does, and it's</span></span><br><span class="line">               <span class="comment">// misleading to say we didn't find "libMyLibrary.so" when we</span></span><br><span class="line">               <span class="comment">// actually searched for "liblibMyLibrary.so.so".</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(loader + <span class="string">" couldn't find \""</span> +</span><br><span class="line">                                              System.mapLibraryName(libraryName) + <span class="string">"\""</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//都会调用doLoad方法</span></span><br><span class="line">           String error = doLoad(filename, loader);</span><br><span class="line">           <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(error);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//下面逻辑是当指定ClassLoader为null时，就在一些系统so库目录中查找</span></span><br><span class="line">       String filename = System.mapLibraryName(libraryName);</span><br><span class="line">       List&lt;String&gt; candidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       String lastError = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (String directory : mLibPaths) &#123;</span><br><span class="line">           String candidate = directory + filename;</span><br><span class="line">           candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">               String error = doLoad(candidate, loader);</span><br><span class="line">               <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">               &#125;</span><br><span class="line">               lastError = error;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (lastError != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(lastError);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedLinkError(<span class="string">"Library "</span> + libraryName + <span class="string">" not found; tried "</span> + candidates);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们这里详细分析一下loadLibrary方法。首先会判断指定的ClassLoader是否为空，这里传入的值为VMStack.getCallingClassLoader()，就是加载目标类的ClassLoader，宿主工程为系统指定的PathClassLoader，插件工程为我们构造的DexClassLoader。</p>
<p>&#160; &#160; &#160; &#160;然后执行：String filename = loader.findLibrary(libraryName);<br>这一步其实是调用PathClassLoader和DexClassLoader共同父类BaseDexClassLoader的findLibrary方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span><br><span class="line">           String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(parent);</span><br><span class="line">       <span class="comment">//pathList在构造方法中赋值</span></span><br><span class="line">       <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">   &#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//BaseDexClassLoader的findLibrary方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;BaseDexClassLoader的findLibrary方法内部又调用了DexPathList的findLibrary方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DexPathList的findLibrary方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转换指定libraryName为so库文件名，例如turn "MyLibrary" into "libMyLibrary.so".</span></span><br><span class="line">       String fileName = System.mapLibraryName(libraryName);</span><br><span class="line">       <span class="comment">//在nativeLibraryDirectories中遍历目标so库是否存在</span></span><br><span class="line">       <span class="keyword">for</span> (File directory : nativeLibraryDirectories) &#123;</span><br><span class="line">           String path = <span class="keyword">new</span> File(directory, fileName).getPath();</span><br><span class="line">           <span class="keyword">if</span> (IoUtils.canOpenReadOnly(path)) &#123;</span><br><span class="line">               <span class="keyword">return</span> path;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File[] nativeLibraryDirectories;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span><br><span class="line">           String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//也是在构造方法中给nativeLibraryDirectories 赋值；</span></span><br><span class="line">	<span class="comment">//libraryPath就是我们在DexClassLoader中指定的第三个参数,系统的PathClassLoader指定为/data/app-lib/xxx(包名)</span></span><br><span class="line">       <span class="keyword">this</span>.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//GO ON 继续跟踪</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> File[] splitLibraryPath(String path) &#123;</span><br><span class="line">       <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">       <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">//   1. this class loader's library path for application libraries</span></span><br><span class="line">       <span class="comment">//   2. the VM's library path from the system property for system libraries</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//System.getProperty("java.library.path")返回的是/vendor/lib:/system/lib</span></span><br><span class="line">       ArrayList&lt;File&gt; result = splitPaths(path, System.getProperty(<span class="string">"java.library.path"</span>), <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> File[result.size()]);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//NEXT  path1为我们在DexClassLoader中指定的第三个参数,系统的PathClassLoader指定为/data/app-lib/xxx(包名)；path2为/vendor/lib:/system/lib；wantDirectories为true</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;File&gt; <span class="title">splitPaths</span><span class="params">(String path1, String path2,</span><br><span class="line">           <span class="keyword">boolean</span> wantDirectories)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">       ArrayList&lt;File&gt; result = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">       splitAndAdd(path1, wantDirectories, result);</span><br><span class="line">       splitAndAdd(path2, wantDirectories, result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//FINALLY 用“:”分割路径字符串，并且将这些路径都放入到一个ArrayList中</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitAndAdd</span><span class="params">(String searchPath, <span class="keyword">boolean</span> directoriesOnly,</span><br><span class="line">           ArrayList&lt;File&gt; resultList)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (searchPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (String path : searchPath.split(<span class="string">":"</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               StructStat sb = Libcore.os.stat(path);</span><br><span class="line">               <span class="keyword">if</span> (!directoriesOnly || S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">                   resultList.add(<span class="keyword">new</span> File(path));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述代码就是查找so库文件的逻辑了，会分别在/vendor/lib、/system/lib、/data/app-lib/xxx(包名)、和指定目录下查找，如果找不到，就会报UnsatisfiedLinkError异常。</p>
<p>&#160; &#160; &#160; &#160;查找逻辑就先到这里，继续回到Runtime类中。接着就会调用doLoad方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">doLoad</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">       String ldLibraryPath = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (loader != <span class="keyword">null</span> &amp;&amp; loader <span class="keyword">instanceof</span> BaseDexClassLoader) &#123;</span><br><span class="line">        <span class="comment">//ldLibraryPath就是上面提到的vendor/lib、/system/lib、/data/app-lib/xxx(包名)、和指定目录用“:”连接的字符串</span></span><br><span class="line">           ldLibraryPath = ((BaseDexClassLoader) loader).getLdLibraryPath();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//最后会调用nativeLoad方法</span></span><br><span class="line">           <span class="keyword">return</span> nativeLoad(name, loader, ldLibraryPath);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, String ldLibraryPath)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里调用了本地方法，不过悲催的是，我的ART版本代码没有找到，所以只能看 Dalvik版本的。 Runtime类的成员函数nativeLoad在C++层对应的函数为Dalvik_java_lang_Runtime_nativeLoad，这个函数定义在文件dalvik/vm/native/java_lang_Runtime.c中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dalvik_java_lang_Runtime_nativeLoad</span><span class="params">(<span class="keyword">const</span> u4* args,  </span><br><span class="line">    JValue* pResult)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    StringObject* fileNameObj = (StringObject*) args[<span class="number">0</span>]; <span class="comment">//so库名</span></span><br><span class="line">    Object* classLoader = (Object*) args[<span class="number">1</span>];  <span class="comment">//类加载器</span></span><br><span class="line">    <span class="keyword">char</span>* fileName = <span class="literal">NULL</span>;  </span><br><span class="line">    StringObject* result = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">char</span>* reason = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">bool</span> success;  </span><br><span class="line">  </span><br><span class="line">    assert(fileNameObj != <span class="literal">NULL</span>); </span><br><span class="line">    <span class="comment">//将 fileNameObj 转化为C++层字符串</span></span><br><span class="line">    fileName = dvmCreateCstrFromString(fileNameObj);  </span><br><span class="line">    <span class="comment">//调用dvmLoadNativeCode方法</span></span><br><span class="line">    success = dvmLoadNativeCode(fileName, classLoader, &amp;reason);  </span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* msg = (reason != <span class="literal">NULL</span>) ? reason : <span class="string">"unknown failure"</span>;  </span><br><span class="line">        result = dvmCreateStringFromCstr(msg);  </span><br><span class="line">        dvmReleaseTrackedAlloc((Object*) result, <span class="literal">NULL</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">free</span>(reason);  </span><br><span class="line">    <span class="built_in">free</span>(fileName);  </span><br><span class="line">    RETURN_PTR(result);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 参数args[0]保存的是一个Java层的String对象，这个String对象描述的就是要加载的so文件，函数Dalvik_java_lang_Runtime_nativeLoad首先是调用函数dvmCreateCstrFromString来将它转换成一个C++层的字符串fileName，然后再调用函数dvmLoadNativeCode来执行加载so文件的操作。</p>
<p>&#160; &#160; &#160; &#160;接下来，我们就继续分析函数dvmLoadNativeCode的实现，这个函数定义在文件dalvik/vm/Native.c中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmLoadNativeCode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathName, Object* classLoader,  </span><br><span class="line">        <span class="keyword">char</span>** detail)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    SharedLib* pEntry;  </span><br><span class="line">    <span class="keyword">void</span>* handle;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    pEntry = findSharedLibEntry(pathName);  </span><br><span class="line">    <span class="keyword">if</span> (pEntry != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (pEntry-&gt;classLoader != classLoader) &#123;  </span><br><span class="line">            ......  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!checkOnLoadResult(pEntry))  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    handle = dlopen(pathName, RTLD_LAZY);  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* create a new entry */</span>  </span><br><span class="line">    SharedLib* pNewEntry;  </span><br><span class="line">    pNewEntry = (SharedLib*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(SharedLib));  </span><br><span class="line">    pNewEntry-&gt;pathName = strdup(pathName);  </span><br><span class="line">    pNewEntry-&gt;handle = handle;  </span><br><span class="line">    pNewEntry-&gt;classLoader = classLoader;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* try to add it to the list */</span>  </span><br><span class="line">    SharedLib* pActualEntry = addSharedLibEntry(pNewEntry);  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (pNewEntry != pActualEntry) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">        freeSharedLibEntry(pNewEntry);  </span><br><span class="line">        <span class="keyword">return</span> checkOnLoadResult(pActualEntry);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">void</span>* vonLoad;  </span><br><span class="line">        <span class="keyword">int</span> version;  </span><br><span class="line">  </span><br><span class="line">        vonLoad = dlsym(handle, <span class="string">"JNI_OnLoad"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (vonLoad == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            LOGD(<span class="string">"No JNI_OnLoad found in %s %p, skipping init\n"</span>,  </span><br><span class="line">                pathName, classLoader);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            OnLoadFunc func = vonLoad;  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            version = (*func)(gDvm.vmList, <span class="literal">NULL</span>);  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (version != JNI_VERSION_1_2 &amp;&amp; version != JNI_VERSION_1_4 &amp;&amp;  </span><br><span class="line">                version != JNI_VERSION_1_6)  </span><br><span class="line">            &#123;  </span><br><span class="line">                .......  </span><br><span class="line">                result = <span class="literal">false</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                LOGV(<span class="string">"+++ finished JNI_OnLoad %s\n"</span>, pathName);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (result)  </span><br><span class="line">            pNewEntry-&gt;onLoadResult = kOnLoadOkay;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            pNewEntry-&gt;onLoadResult = kOnLoadFailed;  </span><br><span class="line">  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;函数dvmLoadNativeCode首先是检查参数pathName所指定的so文件是否已经加载过了，这是通过调用函数findSharedLibEntry来实现的。如果已经加载过，那么就可以获得一个SharedLib对象pEntry。这个SharedLib对象pEntry描述了有关参数pathName所指定的so文件的加载信息，例如，上次用来加载它的类加载器和上次的加载结果。如果上次用来加载它的类加载器不等于当前所使用的类加载器，或者上次没有加载成功，那么函数dvmLoadNativeCode就回直接返回false给调用者，表示不能在当前进程中加载参数pathName所描述的so文件。</p>
<blockquote>
<p>这里有一个检测异常的代码，而这个错误，是我们在使用插件开发加载so的时候可能会遇到的错误，比如现在我们使用DexClassLoader类去加载插件，但是因为我们为了插件能够实时更新，所以每次都会赋值新的DexClassLoader对象，但是第一次加载so文件到内存中了，这时候退出程序，但是没有真正意义上的退出，只是关闭了Activity了，这时候再次启动又会赋值新的加载器对象，那么原先so已经加载到内存中了，但是这时候是新的类加载器那么就报错了，解决办法其实很简单，主要有两种方式：<br>第一种方式：在退出程序的时候采用真正意义上的退出，比如调用System.exit(0)方法，这时候进程被杀了，加载到内存的so也就被释放了，那么下次赋值新的类加载就在此加载so到内存了，<br>第二种方式：就是全局定义一个static类型的类加载DexClassLoader也是可以的，因为static类型是保存在当前进程中，如果进程没有被杀就一直存在这个对象，下次进入程序的时候判断当前类加载器是否为null，如果不为null就不要赋值了，但是这个方法有一个弊端就是类加载器没有从新赋值，如果插件这时候更新了，但是还是使用之前的加载器，那么新插件将不会进行加载。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;我们假设参数pathName所指定的so文件还没有被加载过，这时候函数dvmLoadNativeCode就会先调用dlopen来在当前进程中加载它，并且将获得的句柄保存在变量handle中，接着再创建一个SharedLib对象pNewEntry来描述它的加载信息。这个SharedLib对象pNewEntry还会通过函数addSharedLibEntry被缓存起来，以便可以知道当前进程都加载了哪些so文件。</p>
<p>&#160; &#160; &#160; &#160; 注意，在调用函数addSharedLibEntry来缓存新创建的SharedLib对象pNewEntry的时候，如果得到的返回值pActualEntry指向的不是SharedLib对象pNewEntry，那么就表示另外一个线程也正在加载参数pathName所指定的so文件，并且比当前线程提前加载完成。在这种情况下，函数addSharedLibEntry就什么也不用做而直接返回了。否则的话，函数addSharedLibEntry就要继续负责调用前面所加载的so文件中的一个指定的函数来注册它里面的JNI方法。</p>
<p>&#160; &#160; &#160; &#160; 这个指定的函数的名称为“JNI_OnLoad”，也就是说，每一个用来实现JNI方法的so文件都应该定义有一个名称为“JNI_OnLoad”的函数，并且这个函数的原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 函数dvmLoadNativeCode通过调用函数dlsym就可以获得在前面加载的so中名称为“JNI_OnLoad”的函数的地址，最终保存在函数指针func中。有了这个函数指针之后，我们就可以直接调用它来执行注册JNI方法的操作了。注意，在调用该JNI_OnLoad函数时，第一个要传递进行的参数是一个JavaVM对象，这个JavaVM对象描述的是在当前进程中运行的Dalvik虚拟机，第二个要传递的参数可以设置为NULL，这是保留给以后使用的。</p>
<p>&#160; &#160; &#160; &#160;到这里我们就总结一下Android中加载so的流程：</p>
<ul>
<li>调用System.loadLibrary和System.load方法进行加载so文件</li>
<li>通过Runtime.java类的nativeLoad方法进行最终调用，这里需要通过类加载器获取到nativeLib路径</li>
<li>到底层之后，就开始使用dlopen方法加载so文件，然后使用dlsym方法调用JNI_OnLoad方法，最终开始了so的执行</li>
</ul>
<h3 id="释放SO库文件"><a href="#释放SO库文件" class="headerlink" title="释放SO库文件"></a>释放SO库文件</h3><p>&#160; &#160; &#160; &#160;我们在使用System.loadLibrary加载so的时候，传递的是so文件的libxxx.so中的xxx部分，那么系统是如何找到这个so文件然后进行加载的呢？这个就要先从apk文件安装时机说起。</p>
<p> &#160; &#160; &#160; &#160;Android系统在启动的过程中，会启动一个应用程序管理服务PackageManagerService，这个服务负责扫描系统中特定的目录，找到里面的应用程序文件，即以Apk为后缀的文件，然后对这些文件进解析，得到应用程序的相关信息，完成应用程序的安装过程。<br>&#160; &#160; &#160; &#160;应用程序管理服务PackageManagerService安装应用程序的过程，其实就是解析析应用程序配置文件AndroidManifest.xml的过程，并从里面得到得到应用程序的相关信息，例如得到应用程序的组件Activity、Service、Broadcast Receiver和Content Provider等信息，有了这些信息后，通过ActivityManagerService这个服务，我们就可以在系统中正常地使用这些应用程序了。</p>
<p> &#160; &#160; &#160; &#160;下面我们一步一步分析：<br>  &#160; &#160; &#160; &#160;我们知道Android系统系统启动时会启动Zygote进程，Zygote进程又会启动SystemServer组件，启动的时候就会调用它的main函数，然后会初始化一系列服务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> PackageManagerService mPackageManagerService;</span><br><span class="line">	</span><br><span class="line">	......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	startBootstrapServices();</span><br><span class="line">	......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">	&#125;	</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;中间会启动PackageManagerService，这个函数定义在frameworks/base/services/java/com/android/server/PackageManagerService.java文件中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageManagerService</span> <span class="keyword">extends</span> <span class="title">IPackageManager</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer,</span><br><span class="line">            <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">        PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer,</span><br><span class="line">                factoryTest, onlyCore);</span><br><span class="line">        ServiceManager.addService(<span class="string">"package"</span>, m);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数创建了一个PackageManagerService服务实例，然后把这个服务添加到ServiceManager中去， 在创建这个PackageManagerService服务实例时，会在PackageManagerService类的构造函数中开始执行安装应用程序的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span><br><span class="line">           <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">scanPackageLI(scanFile, reparseFlags, scanFlags, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;PackageManagerService的构造方法中就完成了对apk文件的解包，还有对xm文件的解析等等，感兴趣的可以自己分析。这里我们限于篇幅，就只分析so文件的解包过程。<br>&#160; &#160; &#160; &#160;这里会调用scanPackageLI方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags,</span><br><span class="line">        <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......    </span><br><span class="line"> <span class="comment">// Note that we invoke the following method only if we are about to unpack an application</span></span><br><span class="line"> PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags</span><br><span class="line">            | SCAN_UPDATE_SIGNATURE, currentTime, user);</span><br><span class="line">            </span><br><span class="line">    ......                    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> parseFlags,</span><br><span class="line">        <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......    </span><br><span class="line"> <span class="keyword">final</span> PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags,</span><br><span class="line">                currentTime, user);</span><br><span class="line">                </span><br><span class="line">    ......                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过一系列重载方法调用，最终会调用scanPackageDirtyLI方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageDirtyLI</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> parseFlags,</span><br><span class="line">         <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//初始化so库放置的目录，并赋值给pkg</span></span><br><span class="line">setNativeLibraryPaths(pkg);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> isAsec = isForwardLocked(pkg) || isExternal(pkg);</span><br><span class="line">         <span class="comment">//nativeLibraryRootStr 指定为/data/app-lib/xxx(包名)</span></span><br><span class="line">         <span class="keyword">final</span> String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;</span><br><span class="line">         <span class="comment">//false</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;</span><br><span class="line"></span><br><span class="line">         NativeLibraryHelper.Handle handle = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//标记打开apk</span></span><br><span class="line">             handle = NativeLibraryHelper.Handle.create(scanFile);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">final</span> File nativeLibraryRoot = <span class="keyword">new</span> File(nativeLibraryRootStr);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Null out the abis so that they can be recalculated.</span></span><br><span class="line">             pkg.applicationInfo.primaryCpuAbi = <span class="keyword">null</span>;</span><br><span class="line">             pkg.applicationInfo.secondaryCpuAbi = <span class="keyword">null</span>;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">                 String[] abiList = (cpuAbiOverride != <span class="keyword">null</span>) ?</span><br><span class="line">                         <span class="keyword">new</span> String[] &#123; cpuAbiOverride &#125; : Build.SUPPORTED_ABIS;</span><br><span class="line"></span><br><span class="line">	    ......</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> copyRet;</span><br><span class="line">                 <span class="keyword">if</span> (isAsec) &#123;</span><br><span class="line">                     copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//解压对应ABI的so文件到指定目录</span></span><br><span class="line">                     copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,</span><br><span class="line">                             nativeLibraryRoot, abiList, useIsaSpecificSubdirs);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">         ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;scanPackageDirtyLI首先调用setNativeLibraryPaths方法，这个方法主要是指定一下so库释放路径：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNativeLibraryPaths</span><span class="params">(PackageParser.Package pkg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ApplicationInfo info = pkg.applicationInfo;</span><br><span class="line">       <span class="keyword">final</span> String codePath = pkg.codePath;</span><br><span class="line">       <span class="keyword">final</span> File codeFile = <span class="keyword">new</span> File(codePath);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> bundledApp = isSystemApp(info) &amp;&amp; !isUpdatedSystemApp(info);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> asecApp = isForwardLocked(info) || isExternal(info);</span><br><span class="line"></span><br><span class="line">       info.nativeLibraryRootDir = <span class="keyword">null</span>;</span><br><span class="line">       info.nativeLibraryRootRequiresIsa = <span class="keyword">false</span>;</span><br><span class="line">       info.nativeLibraryDir = <span class="keyword">null</span>;</span><br><span class="line">       info.secondaryNativeLibraryDir = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (isApkFile(codeFile)) &#123;</span><br><span class="line">           <span class="comment">// Monolithic install</span></span><br><span class="line">           <span class="keyword">if</span> (bundledApp) &#123;</span><br><span class="line">		......</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (asecApp) &#123;</span><br><span class="line">		......</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> String apkName = deriveCodePathName(codePath);</span><br><span class="line">               <span class="comment">//mAppLib32InstallDir为/data/app-lib/</span></span><br><span class="line">               info.nativeLibraryRootDir = <span class="keyword">new</span> File(mAppLib32InstallDir, apkName)</span><br><span class="line">                       .getAbsolutePath();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           info.nativeLibraryRootRequiresIsa = <span class="keyword">false</span>;</span><br><span class="line">           info.nativeLibraryDir = info.nativeLibraryRootDir;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ......</span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后调用NativeLibraryHelper.Handle.create(scanFile)标记打开apk文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		......</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span>[] apkHandles;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> multiArch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(File packageFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> PackageLite lite = PackageParser.parsePackageLite(packageFile, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> create(lite);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageParserException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to parse package: "</span> + packageFile, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(Package pkg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> create(pkg.getAllCodePaths(),</span><br><span class="line">                    (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_MULTIARCH) != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(PackageLite lite)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> create(lite.getAllCodePaths(), lite.multiArch);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//最后调用到这里</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handle <span class="title">create</span><span class="params">(List&lt;String&gt; codePaths, <span class="keyword">boolean</span> multiArch)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = codePaths.size();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span>[] apkHandles = <span class="keyword">new</span> <span class="keyword">long</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> String path = codePaths.get(i);</span><br><span class="line">                <span class="comment">//调用这个native方法，打开apk，并将JNI层返回的句柄保留到java层</span></span><br><span class="line">                apkHandles[i] = nativeOpenApk(path);</span><br><span class="line">                </span><br><span class="line">				......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Handle(apkHandles, multiArch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Handle(<span class="keyword">long</span>[] apkHandles, <span class="keyword">boolean</span> multiArch) &#123;</span><br><span class="line">            <span class="keyword">this</span>.apkHandles = apkHandles;</span><br><span class="line">            <span class="keyword">this</span>.multiArch = multiArch;</span><br><span class="line">            mGuard.open(<span class="string">"close"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//NativeLibraryHelper的nativeOpenApk方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeOpenApk</span><span class="params">(String path)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;经过一系列重载方法调用，最后会调用NativeLibraryHelper的nativeOpenApk方法，打开apk，并将JNI层返回的句柄保留到java层。这个方法的实现位于frameworks/base/core/jni/com_android_internal_content_NativeLibraryHelper.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_openApk</span><span class="params">(JNIEnv *env, jclass, jstring apkPath)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">filePath</span><span class="params">(env, apkPath)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ZipFileRO* zipFile = ZipFileRO::open(filePath.c_str());</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(zipFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述代码调用了ZipFileRO的open方法，并返回一个ZipFileRO类型的指针，然后强转为java层的long型对象返回给java层。open方法实现位于frameworks/base/libs/androidfw/ZipFileRO.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Open the specified file read-only.  We memory-map the entire thing and</span><br><span class="line"> * close the file before returning.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/* static */</span> ZipFileRO* ZipFileRO::open(<span class="keyword">const</span> <span class="keyword">char</span>* zipFileName)</span><br><span class="line">&#123;</span><br><span class="line">    ZipArchiveHandle handle;</span><br><span class="line">    <span class="comment">//调用ZipArchive库打开zip文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> error = OpenArchive(zipFileName, &amp;handle);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Error opening archive %s: %s"</span>, zipFileName, ErrorCodeString(error));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZipFileRO(handle, strdup(zipFileName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这些就是JNI层打开apk文件的操作了。我么继续回到scanPackageDirtyLI方法中，接着调用NativeLibraryHelper.copyNativeBinariesForSupportedAbi方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copyNativeBinariesForSupportedAbi</span><span class="params">(Handle handle, File libraryRoot,</span><br><span class="line">         String[] abiList, <span class="keyword">boolean</span> useIsaSubdir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//如果目录不存或者是个文件，就重新创建目录    </span></span><br><span class="line">     createNativeLibrarySubdir(libraryRoot);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span><br><span class="line">      * If this is an internal application or our nativeLibraryPath points to</span><br><span class="line">      * the app-lib directory, unpack the libraries if necessary.</span><br><span class="line">      */</span></span><br><span class="line">      <span class="comment">//查找对应的ABI类型</span></span><br><span class="line">     <span class="keyword">int</span> abi = findSupportedAbi(handle, abiList);</span><br><span class="line">     <span class="keyword">if</span> (abi &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">/*</span><br><span class="line">          * If we have a matching instruction set, construct a subdir under the native</span><br><span class="line">          * library root that corresponds to this instruction set.</span><br><span class="line">          */</span></span><br><span class="line">         <span class="comment">//获取so释放之后的目录</span></span><br><span class="line">         <span class="keyword">final</span> String instructionSet = VMRuntime.getInstructionSet(abiList[abi]);</span><br><span class="line">         <span class="keyword">final</span> File subDir;</span><br><span class="line">         <span class="keyword">if</span> (useIsaSubdir) &#123;</span><br><span class="line">             <span class="keyword">final</span> File isaSubdir = <span class="keyword">new</span> File(libraryRoot, instructionSet);</span><br><span class="line">             createNativeLibrarySubdir(isaSubdir);</span><br><span class="line">             subDir = isaSubdir;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             subDir = libraryRoot;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//拷贝so</span></span><br><span class="line">         <span class="keyword">int</span> copyRet = copyNativeBinaries(handle, subDir, abiList[abi]);</span><br><span class="line">         <span class="keyword">if</span> (copyRet != PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">             <span class="keyword">return</span> copyRet;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> abi;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们挑一些重要的分析一下。这里先获取abiList的值，这个通过Build.SUPPORTED_ABIS来获取到的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SUPPORTED_ABIS = getStringList(<span class="string">"ro.product.cpu.abilist"</span>, <span class="string">","</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最终是通过获取系统属性ro.product.cpu.abilist的值来得到的，我们可以使用getprop命令来查看这个属性值，或者直接cat一下/system/build.prop文件:<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/adb.png" alt="查看ABI"><br>&#160; &#160; &#160; &#160;这里获取到的值是x86。然后去分析findSupportedAbi方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSupportedAbi</span><span class="params">(Handle handle, String[] supportedAbis)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> finalRes = NO_NATIVE_LIBRARIES;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">long</span> apkHandle : handle.apkHandles) &#123;</span><br><span class="line">        <span class="comment">//这里调用了native方法</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> res = nativeFindSupportedAbi(apkHandle, supportedAbis);</span><br><span class="line">           <span class="keyword">if</span> (res == NO_NATIVE_LIBRARIES) &#123;</span><br><span class="line">               <span class="comment">// No native code, keep looking through all APKs.</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == INSTALL_FAILED_NO_MATCHING_ABIS) &#123;</span><br><span class="line">               <span class="comment">// Found some native code, but no ABI match; update our final</span></span><br><span class="line">               <span class="comment">// result if we haven't found other valid code.</span></span><br><span class="line">               <span class="keyword">if</span> (finalRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   finalRes = INSTALL_FAILED_NO_MATCHING_ABIS;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Found valid native code, track the best ABI match</span></span><br><span class="line">               <span class="keyword">if</span> (finalRes &lt; <span class="number">0</span> || res &lt; finalRes) &#123;</span><br><span class="line">                   finalRes = res;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Unexpected error; bail</span></span><br><span class="line">               <span class="keyword">return</span> res;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> finalRes;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeFindSupportedAbi</span><span class="params">(<span class="keyword">long</span> handle, String[] supportedAbis)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;NativeLibraryHelper类的findSupportedAbi方法，其实这个方法就是查找系统当前支持的架构型号索引值。调用的本地方法实现为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_findSupportedAbi</span><span class="params">(JNIEnv *env, jclass clazz,</span><br><span class="line">        jlong apkHandle, jobjectArray javaCpuAbisToSearch)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (jint) findSupportedAbi(env, apkHandle, javaCpuAbisToSearch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSupportedAbi</span><span class="params">(JNIEnv *env, jlong apkHandle, jobjectArray supportedAbisArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> numAbis = env-&gt;GetArrayLength(supportedAbisArray);</span><br><span class="line">    Vector&lt;ScopedUtfChars*&gt; supportedAbis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; ++i) &#123;</span><br><span class="line">        supportedAbis.add(<span class="keyword">new</span> ScopedUtfChars(env,</span><br><span class="line">            (jstring) env-&gt;GetObjectArrayElement(supportedAbisArray, i)));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//读取apk文件</span></span><br><span class="line">    ZipFileRO* zipFile = <span class="keyword">reinterpret_cast</span>&lt;ZipFileRO*&gt;(apkHandle);</span><br><span class="line">    <span class="keyword">if</span> (zipFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UniquePtr&lt;NativeLibrariesIterator&gt; it(NativeLibrariesIterator::create(zipFile));</span><br><span class="line">    <span class="keyword">if</span> (it.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZipEntryRO entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> fileName[PATH_MAX];</span><br><span class="line">    <span class="keyword">int</span> status = NO_NATIVE_LIBRARIES;</span><br><span class="line">    <span class="comment">//这里开始遍历apk中每一个文件</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = it-&gt;next()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We're currently in the lib/ directory of the APK, so it does have some native</span></span><br><span class="line">        <span class="comment">// code. We should return INSTALL_FAILED_NO_MATCHING_ABIS if none of the</span></span><br><span class="line">        <span class="comment">// libraries match.</span></span><br><span class="line">        <span class="keyword">if</span> (status == NO_NATIVE_LIBRARIES) &#123;</span><br><span class="line">            status = INSTALL_FAILED_NO_MATCHING_ABIS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* fileName = it-&gt;currentEntry();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* lastSlash = it-&gt;lastSlash();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if this CPU ABI matches what we are looking for.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* abiOffset = fileName + APK_LIB_LEN;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> abiSize = lastSlash - abiOffset;</span><br><span class="line">        <span class="comment">//遍历apk中的子文件，获取so文件的全路径，如果这个路径包含了cpu架构值，就记录返回索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> ScopedUtfChars* abi = supportedAbis[i];</span><br><span class="line">            <span class="keyword">if</span> (abi-&gt;size() == abiSize &amp;&amp; !<span class="built_in">strncmp</span>(abiOffset, abi-&gt;c_str(), abiSize)) &#123;</span><br><span class="line">                <span class="comment">// The entry that comes in first (i.e. with a lower index) has the higher priority.</span></span><br><span class="line">                <span class="keyword">if</span> (((i &lt; status) &amp;&amp; (status &gt;= <span class="number">0</span>)) || (status &lt; <span class="number">0</span>) ) &#123;</span><br><span class="line">                    status = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAbis; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span> supportedAbis[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里看到了，会先读取apk文件，然后遍历apk文件中的so文件，得到全路径然后在和传递进来的abiList进行比较，得到合适的索引值。我们刚才拿到的abiList为：x86，然后就开始比较apk中有没有这些架构平台的so文件，如果有，就直接返回abiList中的索引值即可。比如apk中libs结构如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/apk.png" alt="apk的libs结构"></p>
<p>&#160; &#160; &#160; &#160;那么这个时候就只有这么一种架构，libs文件下也有相关的ABI类型，就只能返回0了；</p>
<p>&#160; &#160; &#160; &#160;假设我们的abiList为：arm64-v8a,armeabi-v7a,armeabi。那么这时候返回来的索引值就是0，代表的是arm64-v8a架构的。如果apk文件中没有arm64-v8a目录的话，那么就返回1，代表的是armeabi-v7a架构的。依次类推。得到应用支持的架构索引之后就可以获取so释放到设备中的目录了。</p>
<p>&#160; &#160; &#160; &#160;下一步就是获取so释放之后的目录，调用VMRuntime.java中的getInstructionSet方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInstructionSet</span><span class="params">(String abi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String instructionSet = ABI_TO_INSTRUCTION_SET_MAP.get(abi);</span><br><span class="line">    <span class="keyword">if</span> (instructionSet == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported ABI: "</span> + abi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instructionSet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; ABI_TO_INSTRUCTION_SET_MAP</span><br><span class="line">        = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"armeabi"</span>, <span class="string">"arm"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"armeabi-v7a"</span>, <span class="string">"arm"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"mips"</span>, <span class="string">"mips"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"mips64"</span>, <span class="string">"mips64"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"x86"</span>, <span class="string">"x86"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"x86_64"</span>, <span class="string">"x86_64"</span>);</span><br><span class="line">    ABI_TO_INSTRUCTION_SET_MAP.put(<span class="string">"arm64-v8a"</span>, <span class="string">"arm64"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一步主要是对获得的ABI架构字符串做了一下转换，比如从x86—&gt;x86，armeabi—&gt;arm等等。</p>
<p>&#160; &#160; &#160; &#160;最后就是释放so了，调用copyNativeBinaries方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copyNativeBinaries</span><span class="params">(Handle handle, File sharedLibraryDir, String abi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> apkHandle : handle.apkHandles) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = nativeCopyNativeBinaries(apkHandle, sharedLibraryDir.getPath(), abi);</span><br><span class="line">        <span class="keyword">if</span> (res != INSTALL_SUCCEEDED) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeCopyNativeBinaries</span><span class="params">(<span class="keyword">long</span> handle,</span><br><span class="line">        String sharedLibraryPath, String abiToCopy)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;JNI层实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint</span><br><span class="line"><span class="title">com_android_internal_content_NativeLibraryHelper_copyNativeBinaries</span><span class="params">(JNIEnv *env, jclass clazz,</span><br><span class="line">        jlong apkHandle, jstring javaNativeLibPath, jstring javaCpuAbi)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//调用iterateOverNativeFiles方法，copyFileIfChanged是个函数指针，完成释放</span></span><br><span class="line">    <span class="keyword">return</span> (jint) iterateOverNativeFiles(env, apkHandle, javaCpuAbi,</span><br><span class="line">            copyFileIfChanged, &amp;javaNativeLibPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> install_status_t</span><br><span class="line"><span class="title">iterateOverNativeFiles</span><span class="params">(JNIEnv *env, jlong apkHandle, jstring javaCpuAbi,</span><br><span class="line">                       iterFunc callFunc, <span class="keyword">void</span>* callArg)</span> </span>&#123;</span><br><span class="line">    ZipFileRO* zipFile = <span class="keyword">reinterpret_cast</span>&lt;ZipFileRO*&gt;(apkHandle);</span><br><span class="line">    <span class="keyword">if</span> (zipFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UniquePtr&lt;NativeLibrariesIterator&gt; it(NativeLibrariesIterator::create(zipFile));</span><br><span class="line">    <span class="keyword">if</span> (it.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> ScopedUtfChars <span class="title">cpuAbi</span><span class="params">(env, javaCpuAbi)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cpuAbi.c_str() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// This would've thrown, so this return code isn't observable by</span></span><br><span class="line">        <span class="comment">// Java.</span></span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125;</span><br><span class="line">    ZipEntryRO entry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = it-&gt;next()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* fileName = it-&gt;currentEntry();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* lastSlash = it-&gt;lastSlash();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure the CPU ABI of this file is one we support.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cpuAbiOffset = fileName + APK_LIB_LEN;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cpuAbiRegionSize = lastSlash - cpuAbiOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cpuAbi.size() == cpuAbiRegionSize &amp;&amp; !<span class="built_in">strncmp</span>(cpuAbiOffset, cpuAbi.c_str(), cpuAbiRegionSize)) &#123;</span><br><span class="line">	        <span class="comment">//释放so，这一句才是关键，copyFileIfChanged完成释放</span></span><br><span class="line">            <span class="keyword">install_status_t</span> ret = callFunc(env, callArg, zipFile, entry, lastSlash + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret != INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                ALOGV(<span class="string">"Failure for entry %s"</span>, lastSlash + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后的释放工作都交给了copyFileIfChanged函数，我们看看这个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Copy the native library if needed.</span><br><span class="line"> *</span><br><span class="line"> * This function assumes the library and path names passed in are considered safe.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> install_status_t</span><br><span class="line"><span class="title">copyFileIfChanged</span><span class="params">(JNIEnv *env, <span class="keyword">void</span>* arg, ZipFileRO* zipFile, ZipEntryRO zipEntry, <span class="keyword">const</span> <span class="keyword">char</span>* fileName)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jstring* javaNativeLibPath = (jstring*) arg;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">nativeLibPath</span><span class="params">(env, *javaNativeLibPath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> uncompLen;</span><br><span class="line">    <span class="keyword">long</span> when;</span><br><span class="line">    <span class="keyword">long</span> crc;</span><br><span class="line">    <span class="keyword">time_t</span> modTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!zipFile-&gt;getEntryInfo(zipEntry, <span class="literal">NULL</span>, &amp;uncompLen, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;when, &amp;crc)) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't read zip entry info\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INVALID_APK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> tm t;</span><br><span class="line">        ZipUtils::zipTimeToTimespec(when, &amp;t);</span><br><span class="line">        modTime = mktime(&amp;t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build local file path</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fileNameLen = <span class="built_in">strlen</span>(fileName);</span><br><span class="line">    <span class="keyword">char</span> localFileName[nativeLibPath.size() + fileNameLen + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localFileName, nativeLibPath.c_str(), <span class="keyword">sizeof</span>(localFileName)) != nativeLibPath.size()) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(localFileName + nativeLibPath.size()) = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localFileName + nativeLibPath.size() + <span class="number">1</span>, fileName, <span class="keyword">sizeof</span>(localFileName)</span><br><span class="line">                    - nativeLibPath.size() - <span class="number">1</span>) != fileNameLen) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only copy out the native file if it's different.</span></span><br><span class="line">    <span class="comment">//只有so本地文件改变了才拷贝</span></span><br><span class="line">    <span class="keyword">struct</span> stat64 st;</span><br><span class="line">    <span class="keyword">if</span> (!isFileDifferent(localFileName, uncompLen, modTime, crc, &amp;st)) &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> localTmpFileName[nativeLibPath.size() + TMP_FILE_PATTERN_LEN + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localTmpFileName, nativeLibPath.c_str(), <span class="keyword">sizeof</span>(localTmpFileName))</span><br><span class="line">            != nativeLibPath.size()) &#123;</span><br><span class="line">        ALOGD(<span class="string">"Couldn't allocate local file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(localFileName + nativeLibPath.size()) = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strlcpy(localTmpFileName + nativeLibPath.size(), TMP_FILE_PATTERN,</span><br><span class="line">                    TMP_FILE_PATTERN_LEN - nativeLibPath.size()) != TMP_FILE_PATTERN_LEN) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't allocate temporary file name for library"</span>);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_INTERNAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//生成一个临时文件，用于拷贝</span></span><br><span class="line">    <span class="keyword">int</span> fd = mkstemp(localTmpFileName);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't open temporary file name: %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解压so文件</span></span><br><span class="line">    <span class="keyword">if</span> (!zipFile-&gt;uncompressEntry(zipEntry, fd)) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Failed uncompressing %s to %s\n"</span>, fileName, localTmpFileName);</span><br><span class="line">        close(fd);</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the modification time for this file to the ZIP's mod time.</span></span><br><span class="line">    <span class="keyword">struct</span> timeval times[<span class="number">2</span>];</span><br><span class="line">    times[<span class="number">0</span>].tv_sec = st.st_atime;</span><br><span class="line">    times[<span class="number">1</span>].tv_sec = modTime;</span><br><span class="line">    times[<span class="number">0</span>].tv_usec = times[<span class="number">1</span>].tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (utimes(localTmpFileName, times) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't change modification time on %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the mode to 755</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">mode_t</span> mode = S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP |  S_IXGRP | S_IROTH | S_IXOTH;</span><br><span class="line">    <span class="keyword">if</span> (chmod(localTmpFileName, mode) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't change permissions on %s: %s\n"</span>, localTmpFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, rename it to the final name.</span></span><br><span class="line">    <span class="keyword">if</span> (rename(localTmpFileName, localFileName) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Couldn't rename %s to %s: %s\n"</span>, localTmpFileName, localFileName, strerror(errno));</span><br><span class="line">        unlink(localTmpFileName);</span><br><span class="line">        <span class="keyword">return</span> INSTALL_FAILED_CONTAINER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Successfully moved %s to %s\n"</span>, localTmpFileName, localFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> INSTALL_SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述就是解压so文件的实现。先判断so名字合不合法，然后判断是不是文件改变了，再者创建一个临时文件，最后解压，用临时文件拷贝so到指定目录，结尾处关闭一些链接。</p>
<p>&#160; &#160; &#160; &#160;小结一下上述SO释放流程：</p>
<ul>
<li>通过遍历apk文件中的so文件的全路径，然后和系统的abiList中的类型值进行比较，如果匹配到了就返回arch类型的索引值</li>
<li>得到了应用所支持的arch类型之后，就开始获取创建本地释放so的目录</li>
<li>然后开始释放so文件</li>
</ul>
<h1 id="失败的尝试"><a href="#失败的尝试" class="headerlink" title="失败的尝试"></a>失败的尝试</h1><p>&#160; &#160; &#160; &#160;上面我们分析了插件apk中加载so库，必须指定DexClassLoader中第三个参数，这就要我们解压apk中的so了。所以我试着调用系统的NativeLibraryHelper相关方法，做了如下实验：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@SuppressLint(<span class="string">"NewApi"</span>)</span><br><span class="line">@<span class="function">Override</span><br><span class="line"><span class="keyword">public</span> boolean <span class="title">loadSO</span><span class="params">(File apkFile, File nativeLibraryRoot)</span> </span>&#123;</span><br><span class="line">	NativeLibraryHelper.Handle handle = null;</span><br><span class="line"> 	<span class="keyword">try</span> &#123;</span><br><span class="line">		handle = NativeLibraryHelper.Handle.create(apkFile);</span><br><span class="line"> 		<span class="comment">//private static Handle create(List&lt;String&gt; codePaths, boolean multiArch) throws IOException</span></span><br><span class="line"> 		<span class="comment">/*Method create2 = NativeLibraryHelper.Handle.class.getDeclaredMethod("create", List.class, boolean.class);</span><br><span class="line"> 		create2.setAccessible(true);</span><br><span class="line"> 		List&lt;String&gt; apkList = new ArrayList&lt;String&gt;();</span><br><span class="line"> 		apkList.add(apkFile.getAbsolutePath());</span><br><span class="line"> 		handle = (Handle) create2.invoke(null, apkList, false);*/</span></span><br><span class="line"> 		<span class="comment">/*Method nativeOpenApk = NativeLibraryHelper.class.getDeclaredMethod("nativeOpenApk", String.class);</span><br><span class="line"> 		nativeOpenApk.setAccessible(true);</span><br><span class="line"> 		long apkHandle = (long) nativeOpenApk.invoke(null, apkFile.getAbsolutePath());</span><br><span class="line"> 		</span><br><span class="line"> 		Method nativeClose = NativeLibraryHelper.class.getDeclaredMethod("nativeClose", long.class);</span><br><span class="line"> 		nativeOpenApk.setAccessible(true);</span><br><span class="line"> 		nativeClose.invoke(null, apkHandle);</span><br><span class="line"> 		</span><br><span class="line"> 		Constructor&lt;Handle&gt; constructMethod = NativeLibraryHelper.Handle.class.getConstructor(long[].class, boolean.class);</span><br><span class="line"> 		constructMethod.setAccessible(true);</span><br><span class="line"> 		handle = constructMethod.newInstance(new long[]&#123;apkHandle&#125;, false);*/</span></span><br><span class="line"> 		</span><br><span class="line"> 		NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,</span><br><span class="line">                   nativeLibraryRoot, Build.SUPPORTED_ABIS, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		<span class="keyword">if</span> (handle != null) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	handle.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然而并无卵用。。。。。。还有那些注释的尝试，也毫无作用= 。 =<br>&#160; &#160; &#160; &#160;如果大家知道原因的话，或者对这一块儿还有更好的实现方案，麻烦多多指教，在此提前献上妹子图。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E5%A1%AB%E5%9D%91%E5%A4%84%E7%90%86/meizi.jpg" alt="妹子图"></p>
<h1 id="剩下的坑"><a href="#剩下的坑" class="headerlink" title="剩下的坑"></a>剩下的坑</h1><p>&#160; &#160; &#160; &#160;关于四大组件生命周期的管理也是一个难点，这里限于篇幅只能止步于此。如果以后有时间的话，我会努力补上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[智能指针简单分析]]></title>
      <url>http://windrunnerlihuan.com/2016/08/23/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160;前一阵子好忙，忙的根本停不下来。现在还好点，能闲一些。所以抽空把之前没研究完的Android智能指针继续研究。<br><a id="more"></a></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&#160; &#160; &#160; &#160;写C++程序时对指针的使用一定要十分谨慎，自己new出来的对象，如果忘记了delete，多次之后就会有比较严重的内存泄露；如果对指针忘记初始化，有时会出现野指针问题；已经释放了申请的内存，但是还在使用指向它的指针，又是一个悬垂指针……其实还有很多使用不当的情况，但是C++又不是java，jvm拥有强大的垃圾回收机制。但是为了避免种种指针使用不当引发的问题，STL标准模板库提供了<strong>智能指针</strong>这个工具。<br>&#160; &#160; &#160; &#160;Google在Android源码中也引入了智能指针这个概念，参考了java垃圾收集器和STL的智能指针，从而自己封装了一套工具类。</p>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>&#160; &#160; &#160; &#160;如果要合理管理内存回收，一般的做法就是使用引用计数的方法。每当有一个指针指向了一个new出来的对象时，就对这个对象的引用计数增加1，每当有一个指针不再使用这个对象时，就对这个对象的引用计数减少1，每次减1之后，如果发现引用计数值为0时，那么，就要delete这个对象了，这样就避免了忘记delete对象或者这个对象被delete之后其它地方还在使用的问题了。但是该如何实现这个引用计数呢？我们知道，C++中对象的创建和销毁会分别调用构造函数和析构函数，所以引用计数的工作就落实在他们身上，同时还应该重载一些运算符，重载一些拷贝构造函数，以完善智能指针的功能。</p>
<p>&#160; &#160; &#160; &#160;在计算机科学领域中，提供垃圾收集（Garbage Collection）功能的系统框架，即提供对象托管功能的系统框架，例如Java应用程序框架，也是采用上述的引用计数技术方案来实现的，然而，简单的引用计数技术不能处理系统中对象间循环引用的情况。考虑这样的一个场景，系统中有两个对象A和B，在对象A的内部引用了对象B，而在对象B的内部也引用了对象A。当两个对象A和B都不再使用时，垃圾收集系统会发现无法回收这两个对象的所占据的内存的，因为系统一次只能收集一个对象，而无论系统决定要收回对象A还是要收回对象B时，都会发现这个对象被其它的对象所引用，因而就都回收不了，这样就造成了内存泄漏。这样，就要采取另外的一种引用计数技术了，即对象的引用计数同时存在强引用和弱引用两种计数，例如，Apple公司提出的<code>Cocoa</code>框架，<strong>当父对象要引用子对象时，就对子对象使用强引用计数技术，而当子对象要引用父对象时，就对父对象使用弱引用计数技术，而当垃圾收集系统执行对象回收工作时，只要发现对象的强引用计数为0，而不管它的弱引用计数是否为0，都可以回收这个对象，但是，如果我们只对一个对象持有弱引用计数，当我们要使用这个对象时，就不直接使用了，必须要把这个弱引用升级成为强引用时，才能使用这个对象，在转换的过程中，如果对象已经不存在，那么转换就失败了，这时候就说明这个对象已经被销毁了，不能再使用了</strong>。</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>&#160; &#160; &#160; &#160;Android系统提供了强大的智能指针技术供我们使用，这些智能指针实现方案既包括简单的引用计数技术，也包括了复杂的引用计数技术，即对象既有强引用计数，也有弱引用计数。我们最常见的智能指针就是强指针sp（Strong Pointer）和弱指针wp（Weak Pointer）。要实现内存的自动释放，sp、wp必须结合RefBase这个类来使用，在Android中，大多数类的最上层基类都是RefBase类。我们就只看这两种比较重要的吧。</p>
<h2 id="强指针"><a href="#强指针" class="headerlink" title="强指针"></a>强指针</h2><p>&#160; &#160; &#160; &#160;强指针使用的引用计数类为RefBase，我们看看它的定义，位于system/core/include/utils/RefBash.h：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//增加强引用计数</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//减少强引用计数</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">forceIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;<span class="comment">//强制增加强引用计数</span></span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> weakref_type <span class="comment">//实现引用计数功能的接口类</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">RefBase*            <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;<span class="comment">//增加弱引用计数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;<span class="comment">//减少弱引用计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a strong reference if there is already one.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a weak reference if there is already one.</span></span><br><span class="line">        <span class="comment">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span></span><br><span class="line">        <span class="comment">// for proper use.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RefBase basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            RefBase();</span><br><span class="line">    <span class="keyword">virtual</span>                 ~RefBase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">extendObjectLifetime</span><span class="params">(<span class="keyword">int32_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Flags for onIncStrongAttempted()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        FIRST_INC_STRONG = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> weakref_type; <span class="comment">//将辅助类设为友元，方便操作完成计数功能</span></span><br><span class="line">    <span class="keyword">class</span> weakref_impl;</span><br><span class="line"></span><br><span class="line">                            RefBase(<span class="keyword">const</span> RefBase&amp; o); <span class="comment">//重载拷贝构造函数，避免默认拷贝构造函数的浅拷贝现象，因此实现类里要实现深拷贝</span></span><br><span class="line">            RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);<span class="comment">//赋值运算符重载</span></span><br><span class="line"></span><br><span class="line">        weakref_impl* <span class="keyword">const</span> mRefs;<span class="comment">//通过这个类实现引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;RefBase类提供了incStrong和decStrong成员函数来操作它的引用计数器，复杂的引用计数技术同时支持强引用计数和弱引用计数，在RefBase类中，这两种计数功能是通过其成员变量mRefs来提供的。<br>&#160; &#160; &#160; &#160;RefBase类的成员变量mRefs的类型为weakref_impl指针，从weakref_impl的类名来看，它应该是一个实现类，那么，就必然有一个对应的接口类，这个对应的接口类的就是RefBase类内部定义的weakref_type类了，这是一种把类的实现与接口定义分离的设计方法，也是一种多态的展现。weakref_impl的实现位于system/core/libutils/RefBash.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RefBase::weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;</span><br><span class="line">    RefBase* <span class="keyword">const</span>      mBase;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS <span class="comment">//如果是Release版本，</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//那就只有这么多，下面都是Debug版本的</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">        , mStrongRefs(<span class="literal">NULL</span>)</span><br><span class="line">        , mWeakRefs(<span class="literal">NULL</span>)</span><br><span class="line">        , mTrackEnabled(!!DEBUG_REFS_ENABLED_BY_DEFAULT)</span><br><span class="line">        , mRetain(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~weakref_impl()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> dumpStack = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mRetain &amp;&amp; mStrongRefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dumpStack = <span class="literal">true</span>;</span><br><span class="line">            ref_entry* refs = mStrongRefs;</span><br><span class="line">            <span class="keyword">while</span> (refs) &#123;</span><br><span class="line">                refs = refs-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mRetain &amp;&amp; mWeakRefs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dumpStack = <span class="literal">true</span>;</span><br><span class="line">            ref_entry* refs = mWeakRefs;</span><br><span class="line">            <span class="keyword">while</span> (refs) &#123;</span><br><span class="line"></span><br><span class="line">                refs = refs-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        addRef(&amp;mStrongRefs, id, mStrong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRetain) &#123;</span><br><span class="line">            removeRef(&amp;mStrongRefs, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addRef(&amp;mStrongRefs, id, -mStrong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">        addRef(&amp;mWeakRefs, id, mWeak);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRetain) &#123;</span><br><span class="line">            removeRef(&amp;mWeakRefs, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addRef(&amp;mWeakRefs, id, -mWeak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> ref_entry</span><br><span class="line">    &#123;</span><br><span class="line">        ref_entry* next;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* id;</span><br><span class="line">        <span class="keyword">int32_t</span> ref;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id, <span class="keyword">int32_t</span> mRef)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTrackEnabled) &#123;</span><br><span class="line">            AutoMutex _l(mMutex);</span><br><span class="line"></span><br><span class="line">            ref_entry* ref = <span class="keyword">new</span> ref_entry;</span><br><span class="line">            <span class="comment">// Reference count at the time of the snapshot, but before the</span></span><br><span class="line">            <span class="comment">// update.  Positive value means we increment, negative--we</span></span><br><span class="line">            <span class="comment">// decrement the reference count.</span></span><br><span class="line">            ref-&gt;ref = mRef;</span><br><span class="line">            ref-&gt;id = id;</span><br><span class="line"></span><br><span class="line">            ref-&gt;next = *refs;</span><br><span class="line">            *refs = ref;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTrackEnabled) &#123;</span><br><span class="line">            AutoMutex _l(mMutex);</span><br><span class="line">            </span><br><span class="line">            ref_entry* <span class="keyword">const</span> head = *refs;</span><br><span class="line">            ref_entry* ref = head;</span><br><span class="line">            <span class="keyword">while</span> (ref != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ref-&gt;id == id) &#123;</span><br><span class="line">                    *refs = ref-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> ref;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                refs = &amp;ref-&gt;next;</span><br><span class="line">                ref = *refs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ref = head;</span><br><span class="line">            <span class="keyword">while</span> (ref) &#123;</span><br><span class="line">                ref = ref-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> Mutex mMutex;</span><br><span class="line">    ref_entry* mStrongRefs;</span><br><span class="line">    ref_entry* mWeakRefs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> mTrackEnabled;</span><br><span class="line">    <span class="comment">// Collect stack traces on addref and removeref, instead of deleting the stack references</span></span><br><span class="line">    <span class="comment">// on removeref that match the address ones.</span></span><br><span class="line">    <span class="keyword">bool</span> mRetain;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//Debug版本结束</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个类看起来很复杂，其实分为两部分看，还是很简单的。我们可以看到将它一分为二的条件宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS  </span></span><br><span class="line">...Release版本...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">...Debug版本...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;if宏里面的都是Release版本的，它的函数都是空实现；else宏下面的是Debug版本代码，它的成员函数都是有实现的，实现这些函数的目的都是为了方便开发人员调试引用计数用的，除此之外，还在内部实现了一个结构体ref_entry：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ref_entry</span><br><span class="line">&#123;</span><br><span class="line">    ref_entry* next;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* id;</span><br><span class="line">    <span class="keyword">int32_t</span> ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个结构体也是为了方便调试的，这是一个链表的节点，那么我猜测Debug版本的引用计数调试时应该用的链表实现的。本来Debug版本我们可以不用关注，但这里本着学习C++的态度还是稍微看一看。比如我们先挑一个addRef(ref_entry<em>* refs, const void</em> id, int32_t mRef)函数看看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id, <span class="keyword">int32_t</span> mRef)</span><span class="comment">//要改变一个指针，必须用到二级指针</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mTrackEnabled) &#123;<span class="comment">//ture</span></span><br><span class="line">           AutoMutex _l(mMutex);</span><br><span class="line"></span><br><span class="line">           ref_entry* ref = <span class="keyword">new</span> ref_entry; <span class="comment">//新建一个节点</span></span><br><span class="line">           <span class="comment">// Reference count at the time of the snapshot, but before the</span></span><br><span class="line">           <span class="comment">// update.  Positive value means we increment, negative--we</span></span><br><span class="line">           <span class="comment">// decrement the reference count.</span></span><br><span class="line">           <span class="comment">//填充节点数据</span></span><br><span class="line">           ref-&gt;ref = mRef;</span><br><span class="line">           ref-&gt;id = id;</span><br><span class="line">		<span class="comment">//头插法插入</span></span><br><span class="line">           ref-&gt;next = *refs;<span class="comment">//将新节点的next指针指向头指针的地址</span></span><br><span class="line">           *refs = ref; <span class="comment">//将头指针重新指向新节点</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个应该很随意吧，就是头插法插入新节点。先把需要插入的节点的next域直线目标链表的头节点内容，然后把头结点重新指向新节点即可。接着我们再看看removeRef(ref_entry<em>* refs, const void</em> id)函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRef</span><span class="params">(ref_entry** refs, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span><span class="comment">///要改变一个指针，必须用到二级指针</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mTrackEnabled) &#123;<span class="comment">//true</span></span><br><span class="line">           AutoMutex _l(mMutex);</span><br><span class="line">           </span><br><span class="line">           ref_entry* <span class="keyword">const</span> head = *refs;<span class="comment">//拿到指向目标指针的地址的指针</span></span><br><span class="line">           ref_entry* ref = head;<span class="comment">//拿到这个指针的头结点</span></span><br><span class="line">           <span class="keyword">while</span> (ref != <span class="literal">NULL</span>) &#123;<span class="comment">//从头往后遍历</span></span><br><span class="line">               <span class="keyword">if</span> (ref-&gt;id == id) &#123;<span class="comment">//如果发现指定节点</span></span><br><span class="line">                   *refs = ref-&gt;next;<span class="comment">//则跳过这个节点的指向，直接指向下一个节点</span></span><br><span class="line">                   <span class="keyword">delete</span> ref;<span class="comment">//然后删除指定节点</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果没有找到指定项，则继续向后遍历</span></span><br><span class="line">               refs = &amp;ref-&gt;next;</span><br><span class="line">               ref = *refs;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ref = head;</span><br><span class="line">           <span class="keyword">while</span> (ref) &#123;</span><br><span class="line">               ref = ref-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一段应该也不难，就是从头到尾依次遍历每个链表节点，发现了指定项就把指向它的节点跳过指向它，直接指向它的下一个节点，然后删除指定项ok。</p>
<p> &#160; &#160; &#160; &#160;总的来说，weakref_impl类只要提供了以下四个成员变量来维护对象的引用计数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;</span><br><span class="line">RefBase* <span class="keyword">const</span>      mBase;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其中mStrong和mWeak分别表示对象的强引用计数和弱引用计数；RefBase类包含了一个weakref_impl类指针mRefs，而这里的 weakref_impl类也有一个成员变量mBase来指向它的宿主类RefBase；mFlags是一个标志位，它指示了维护对象引用计数所使用的策略，它的取值为0，或者以下的枚举值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line"><span class="keyword">enum</span> &#123;  </span><br><span class="line">    OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">    OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">    OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;引用计数器的类RefBase我们就暂时介绍到这里,现在先来看看强指针类和弱指针类的定义。强指针就是sp类，位于system/core/include/utils/StrongPointer.h下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class sp &#123;</span><br><span class="line">public:</span><br><span class="line">    inline sp() : m_ptr(0) &#123; &#125;//构造函数</span><br><span class="line">	//拷贝构造函数</span><br><span class="line">    sp(T* other);</span><br><span class="line">    sp(const sp&lt;T&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; sp(U* other);</span><br><span class="line">    template&lt;typename U&gt; sp(const sp&lt;U&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    ~sp();</span><br><span class="line"></span><br><span class="line">    // Assignment</span><br><span class="line">	//赋值运算符重载</span><br><span class="line">    sp&amp; operator = (T* other);</span><br><span class="line">    sp&amp; operator = (const sp&lt;T&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    template&lt;typename U&gt; sp&amp; operator = (const sp&lt;U&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; sp&amp; operator = (U* other);</span><br><span class="line"></span><br><span class="line">    //! Special optimization for use by ProcessState (and nobody else).</span><br><span class="line">    void force_set(T* other);</span><br><span class="line"></span><br><span class="line">    // Reset</span><br><span class="line"></span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    // Accessors</span><br><span class="line">	//地址相关运算符重载</span><br><span class="line">    inline  T&amp;      operator* () const  &#123; return *m_ptr; &#125;</span><br><span class="line">    inline  T*      operator-&gt; () const &#123; return m_ptr;  &#125;</span><br><span class="line">    inline  T*      get() const         &#123; return m_ptr; &#125;</span><br><span class="line"></span><br><span class="line">    // Operators</span><br><span class="line"></span><br><span class="line">    COMPARE(==)</span><br><span class="line">    COMPARE(!=)</span><br><span class="line">    COMPARE(&gt;)</span><br><span class="line">    COMPARE(&lt;)</span><br><span class="line">    COMPARE(&lt;=)</span><br><span class="line">    COMPARE(&gt;=)</span><br><span class="line"></span><br><span class="line">private:    </span><br><span class="line">	//友元类</span><br><span class="line">    template&lt;typename Y&gt; friend class sp;</span><br><span class="line">    template&lt;typename Y&gt; friend class wp;</span><br><span class="line">    void set_pointer(T* ptr);</span><br><span class="line">    T* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面是对sp类的一些定义，对于实现我们一个个来看。先看看拷贝构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">sp&lt;T&gt;::sp(T* other)  </span><br><span class="line">    : m_ptr(other)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (other) other-&gt;incStrong(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里传进来的参数other一定是继承于RefBase类的，因此，在函数的内部，它调用的是RefBase类的incStrong函数，它定义在system/core/libutils/RefBash.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> RefBase::incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;incWeak(id);<span class="comment">//增加弱引用计数</span></span><br><span class="line">    </span><br><span class="line">    refs-&gt;addStrongRef(id);<span class="comment">//这玩意儿在Release版本是空实现，上面分析过</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_inc(&amp;refs-&gt;mStrong);<span class="comment">//增加强引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  &#123;<span class="comment">//如果不是第一调用则返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果是第一次调用，则要减去mStrong的初始化值</span></span><br><span class="line">    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);</span><br><span class="line">    refs-&gt;mBase-&gt;onFirstRef();<span class="comment">//第一次调用的回调方法，可自己重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个IncStrong函数主要做了三件事：1.增加若引用计数；2.增加强引用计数；3.如果发现是首次调用这个对象的incStrong函数，就会调用一个这个对象的onFirstRef函数，让对象有机会在对象被首次引用时做一些处理逻辑。<br>&#160; &#160; &#160; &#160;android_atomic_inc函数相当于i++表达式，会对变量加一，但是返回的是加一前的值。这里的c返回的是refs-&gt;mStrong加1前的值，如果发现等于INITIAL_STRONG_VALUE，就说明这个对象的强引用计数是第一次被增加，因此，refs-&gt;mStrong就是初始化为INITIAL_STRONG_VALUE的，它的值为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL_STRONG_VALUE (1<span class="meta-string">&lt;&lt;28)</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因为首次调用初始值为INITIAL_STRONG_VALUE，所以为了以后能够正确计数，因此首次需要减去它的初始值，所以才有了—INITIAL_STRONG_VALUE操作，然后android_atomic_inc函数会自动加一，所以首次调用后引用计数为1，逻辑正确。</p>
<p>&#160; &#160; &#160; &#160;然后我们继续回到incStrong函数中，看看弱引用计数是如何增加的。首先是调用weakref_impl类的addWeakRef函数，我们知道，在Release版本中，这个函数也不做，而在Debug版本中，这个函数增加了一个ref_entry对象到了weakref_impl对象的mWeakRefs列表中，表示此weakref_impl对象的弱引用计数被增加了一次。接着又调用了weakref_impl类的incWeak函数，真正增加弱引用计数值就是在这个函数实现的了，weakref_impl类的incWeak函数继承于其父类weakref_type的incWeak函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::incWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);<span class="comment">//强制类型转换</span></span><br><span class="line">    impl-&gt;addWeakRef(id);<span class="comment">//及时是Debug版本，为啥这儿又多调了一遍这个调试方法？excuse me？</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c __unused = android_atomic_inc(&amp;impl-&gt;mWeak);<span class="comment">//增加弱引用计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到最后一行增加了弱引用计数。不过第二行那个再次增加一次Debug版本的调试链表节点很诡异唉，不知为何。有人问过Android源码Binder通信机制模块的作者<a href="http://www.angryredplanet.com/~hackbod/" target="_blank" rel="external">Dianne Hackborn</a> ，他是这样<a href="http://groups.google.com/group/android-platform/browse_thread/thread/cc641db8487dd83" target="_blank" rel="external">回答</a>的：</p>
<blockquote>
<p>Ah I see.  Well the debug code may be broken, though I wouldn’t leap to that<br>        conclusion without actually testing it; I know it has been used in the<br>        past.  Anyway, these things get compiled out in non-debug builds, so there<br>        is no reason to change them unless you are actually trying to use this debug<br>        code and it isn’t working and need to do this to fix it. </p>
</blockquote>
<p>&#160; &#160; &#160; &#160;然而大神也不知道，那我们也不用管了=  。=</p>
<p>&#160; &#160; &#160; &#160;所以sp在其构造函数里面所做的事情就是分别为目标对象的强引用计数和弱引和计数增加了1。</p>
<p>&#160; &#160; &#160; &#160;然后我们再看看析构函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">sp&lt;T&gt;::~sp()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_ptr-&gt;decStrong(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;同样，这里的m_ptr指向的目标对象一定是继承了RefBase类的，因此，这里调用的是RefBase类的decStrong函数，这也是定义在system/core/libutils/RefBash.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);<span class="comment">//Debug版本的，没什么卵用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);<span class="comment">//减少强引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;<span class="comment">//如果强引用计数减为0了</span></span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);<span class="comment">//最后以一次引用了的回调</span></span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//如果是强引用主导生命周期</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;<span class="comment">//则直接回收这个对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id); <span class="comment">//减少弱引用计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;decStrong函数每次先减少强引用计数；然后判断是不是强引用计数是否为0，如果为0则看看标志位是不是设了OBJECT_LIFETIME_WEAK或者其他的，如果没有设置，则直接delete对象；如果受OBJECT_LIFETIME_WEAK等标志位影响，比如受弱应用计数主导生命周期，则等到弱引用计数也为0才能delete对象；最后在减少弱引用计数。<br>&#160; &#160; &#160; &#160;真正实现强引用计数减1的操作下面的refs-&gt;decWeak函数，weakref_impl类没有实现自己的decWeak函数，它继承了weakref_type类的decWeak函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);<span class="comment">//强制类型转换</span></span><br><span class="line">    impl-&gt;removeWeakRef(id);<span class="comment">//这个和上面那个为毛一个道理，Google大神都不知道，不用鸟</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;impl-&gt;mWeak);<span class="comment">//减少弱引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//如果没有减少到0，则直接返回</span></span><br><span class="line">	<span class="comment">//如果弱引用计数减到0了</span></span><br><span class="line">    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//如果生命周期是强引用主导，则直接删除对象</span></span><br><span class="line">        <span class="comment">// This is the regular lifetime case. The object is destroyed</span></span><br><span class="line">        <span class="comment">// when the last strong reference goes away. Since weakref_impl</span></span><br><span class="line">        <span class="comment">// outlive the object, it is not destroyed in the dtor, and</span></span><br><span class="line">        <span class="comment">// we'll have to do it here.</span></span><br><span class="line">        <span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            <span class="comment">// Special case: we never had a strong reference, so we need to</span></span><br><span class="line">            <span class="comment">// destroy the object now.</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span></span><br><span class="line">            <span class="keyword">delete</span> impl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果生命周期受弱引用或者FOREVER类型主导</span></span><br><span class="line">        <span class="comment">// less common case: lifetime is OBJECT_LIFETIME_&#123;WEAK|FOREVER&#125;</span></span><br><span class="line">        impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;<span class="comment">//如果生命周期受弱引用主导</span></span><br><span class="line">            <span class="comment">// this is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span></span><br><span class="line">            <span class="comment">// is gone, we can destroy the object.</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是FOREVER，则需要手动删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里减少了弱引用计数，  减1前如果发现不等于1，那么就什么也不用做就返回了，如果发现等于1，就说明当前对象的弱引用计数值为0了，这时候，就要看看是否要delete这个对象了：<br>&#160; &#160; &#160; &#160;1. 如果目标对象的如果生命周期是强引用主导，就执行下面语句：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the regular lifetime case. The object is destroyed</span></span><br><span class="line"><span class="comment">// when the last strong reference goes away. Since weakref_impl</span></span><br><span class="line"><span class="comment">// outlive the object, it is not destroyed in the dtor, and</span></span><br><span class="line"><span class="comment">// we'll have to do it here.</span></span><br><span class="line"><span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">    <span class="comment">// Special case: we never had a strong reference, so we need to</span></span><br><span class="line">    <span class="comment">// destroy the object now.</span></span><br><span class="line">    <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span></span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一段的注释很重要，通过看注释，这段意思是：这里是减少对象的弱引用计数的地方，如果调用到这里，那么就说明前面一定有增加过此对象的弱引用计数，而增加对象的弱引用计数有两种场景的，一种场景是增加对象的强引用计数的时候，会同时增加对象的弱引用计数，另一种场景是当我们使用一个弱指针来指向对象时，在弱指针对象的构造函数里面，也会增加对象的弱引用计数，不过这时候，就只是增加对象的弱引用计数了，并没有同时增加对象的强引用计数。因此，这里在减少对象的弱引用计数时，就要分两种情况来考虑。</p>
<p>&#160; &#160; &#160; &#160;如果是前一种场景，这里的impl-&gt;mStrong就必然等于0，而不会等于INITIAL_STRONG_VALUE值，因此，这里就不需要delete目标对象了（impl-&gt;mBase），因为前面的RefBase::decStrong函数会负责delete这个对象。这里唯一需要做的就是把weakref_impl对象delete掉，但是，为什么要在这里delete这个weakref_impl对象呢？这里的weakref_impl对象是在RefBase的构造函数里面new出来的，理论上说应该在在RefBase的析构函数里delete掉这个weakref_impl对象的。在RefBase的析构函数里面，的确是会做这件事情：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RefBase::~RefBase()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRefs-&gt;mStrong == INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">        <span class="comment">// we never acquired a strong (and/or weak) reference on this object.</span></span><br><span class="line">        <span class="keyword">delete</span> mRefs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// life-time of this object is extended to WEAK or FOREVER, in</span></span><br><span class="line">        <span class="comment">// which case weakref_impl doesn't out-live the object and we</span></span><br><span class="line">        <span class="comment">// can free it now.</span></span><br><span class="line">        <span class="keyword">if</span> ((mRefs-&gt;mFlags &amp; OBJECT_LIFETIME_MASK) != OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="comment">// It's possible that the weak count is not 0 if the object</span></span><br><span class="line">            <span class="comment">// re-acquired a weak reference in its destructor</span></span><br><span class="line">            <span class="keyword">if</span> (mRefs-&gt;mWeak == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> mRefs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for debugging purposes, clear this.</span></span><br><span class="line">    <span class="keyword">const_cast</span>&lt;weakref_impl*&amp;&gt;(mRefs) = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;但是不要忘记，在这个场景下，目标对象是前面的RefBase::decStrong函数delete掉的，这时候目标对象就会被析构，但是它的弱引用计数值尚未执行减1操作，因此，这里的mRefs-&gt;mWeak == 0条件就不成立，于是就不会delete这个weakref_impl对象，因此，就延迟到执行这里decWeak函数时再执行。</p>
<p> &#160; &#160; &#160; &#160;如果是后一种情景，这里的impl-&gt;mStrong值就等于INITIAL_STRONG_VALUE了，这时候由于没有地方会负责delete目标对象，因此，就需要把目标对象（imp-&gt;mBase）delete掉了，否则就会造成内存泄漏。在delete这个目标对象的时候，就会执行RefBase类的析构函数，这时候目标对象的弱引用计数等于0，于是，就会把weakref_impl对象也一起delete掉了。</p>
<p> &#160; &#160; &#160; &#160;2. 然后回到else逻辑中，如果目标对象的生命周期是受弱引用计数或者OBJECT_LIFETIME_FOREVER控制的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl-&gt;mBase-&gt;onLastWeakRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) &#123;<span class="comment">//如果生命周期受弱引用主导</span></span><br><span class="line">            <span class="comment">// this is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span></span><br><span class="line">            <span class="comment">// is gone, we can destroy the object.</span></span><br><span class="line">            <span class="keyword">delete</span> impl-&gt;mBase;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//如果是FOREVER，则需要手动删除</span></span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;理论上说，如果目标对象的生命周期是受弱引用计数控制的，那么当强引用计数和弱引用计数都为0的时候，这时候就应该delete目标对象了，但是这里还有另外一层控制，我们可以设置目标对象的标志值为OBJECT_LIFETIME_FOREVER，即目标对象的生命周期完全不受强引用计数和弱引用计数控制，在这种情况下，即使目标对象的强引用计数和弱引用计数都同时为0，这里也不能delete这个目标对象，那么，由谁来delete掉呢？当然是谁new出来的，就谁来delete掉了，这时候智能指针就完全退化为普通指针了，这里的智能指针设计的非常强大。</p>
<p>&#160; &#160; &#160; &#160;强指针这里就分析完了，小结一下：</p>
<ul>
<li>如果对象的标志位被设置为0，那么只要发现对象的强引用计数值为0，那就会自动delete掉这个对象；</li>
<li>如果对象的标志位被设置为OBJECT_LIFETIME_WEAK，那么只有当对象的强引用计数和弱引用计数都为0的时候，才会自动delete掉这个对象；</li>
<li>如果对象的标志位被设置为OBJECT_LIFETIME_FOREVER，那么对象就永远不会自动被delete掉，谁new出来的对象谁来delete掉。</li>
</ul>
<h2 id="弱指针"><a href="#弱指针" class="headerlink" title="弱指针"></a>弱指针</h2><p>&#160; &#160; &#160; &#160;弱指针所使用的引用计数类与强指针一样，都是RefBase类。我们直接看弱指针的实现，即wp类，位于system/core/include/utils/RefBase.h中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class wp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef typename RefBase::weakref_type weakref_type;</span><br><span class="line">    </span><br><span class="line">    inline wp() : m_ptr(0) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    wp(T* other);</span><br><span class="line">    wp(const wp&lt;T&gt;&amp; other);</span><br><span class="line">    wp(const sp&lt;T&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; wp(U* other);</span><br><span class="line">    template&lt;typename U&gt; wp(const sp&lt;U&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; wp(const wp&lt;U&gt;&amp; other);</span><br><span class="line"></span><br><span class="line">    ~wp();</span><br><span class="line">    </span><br><span class="line">    // Assignment</span><br><span class="line"></span><br><span class="line">    wp&amp; operator = (T* other);</span><br><span class="line">    wp&amp; operator = (const wp&lt;T&gt;&amp; other);</span><br><span class="line">    wp&amp; operator = (const sp&lt;T&gt;&amp; other);</span><br><span class="line">    </span><br><span class="line">    template&lt;typename U&gt; wp&amp; operator = (U* other);</span><br><span class="line">    template&lt;typename U&gt; wp&amp; operator = (const wp&lt;U&gt;&amp; other);</span><br><span class="line">    template&lt;typename U&gt; wp&amp; operator = (const sp&lt;U&gt;&amp; other);</span><br><span class="line">    </span><br><span class="line">    void set_object_and_refs(T* other, weakref_type* refs);</span><br><span class="line"></span><br><span class="line">    // promotion to sp</span><br><span class="line">    </span><br><span class="line">    sp&lt;T&gt; promote() const;</span><br><span class="line"></span><br><span class="line">    // Reset</span><br><span class="line">    </span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    // Accessors</span><br><span class="line">    </span><br><span class="line">    inline  weakref_type* get_refs() const &#123; return m_refs; &#125;</span><br><span class="line">    </span><br><span class="line">    inline  T* unsafe_get() const &#123; return m_ptr; &#125;</span><br><span class="line"></span><br><span class="line">    // Operators</span><br><span class="line"></span><br><span class="line">    COMPARE_WEAK(==)</span><br><span class="line">    COMPARE_WEAK(!=)</span><br><span class="line">    COMPARE_WEAK(&gt;)</span><br><span class="line">    COMPARE_WEAK(&lt;)</span><br><span class="line">    COMPARE_WEAK(&lt;=)</span><br><span class="line">    COMPARE_WEAK(&gt;=)</span><br><span class="line"></span><br><span class="line">    inline bool operator == (const wp&lt;T&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) &amp;&amp; (m_refs == o.m_refs);</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    inline bool operator == (const wp&lt;U&gt;&amp; o) const &#123;</span><br><span class="line">        return m_ptr == o.m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline bool operator &gt; (const wp&lt;T&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) ? (m_refs &gt; o.m_refs) : (m_ptr &gt; o.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    inline bool operator &gt; (const wp&lt;U&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) ? (m_refs &gt; o.m_refs) : (m_ptr &gt; o.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inline bool operator &lt; (const wp&lt;T&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) ? (m_refs &lt; o.m_refs) : (m_ptr &lt; o.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    inline bool operator &lt; (const wp&lt;U&gt;&amp; o) const &#123;</span><br><span class="line">        return (m_ptr == o.m_ptr) ? (m_refs &lt; o.m_refs) : (m_ptr &lt; o.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">                         inline bool operator != (const wp&lt;T&gt;&amp; o) const &#123; return m_refs != o.m_refs; &#125;</span><br><span class="line">    template&lt;typename U&gt; inline bool operator != (const wp&lt;U&gt;&amp; o) const &#123; return !operator == (o); &#125;</span><br><span class="line">                         inline bool operator &lt;= (const wp&lt;T&gt;&amp; o) const &#123; return !operator &gt; (o); &#125;</span><br><span class="line">    template&lt;typename U&gt; inline bool operator &lt;= (const wp&lt;U&gt;&amp; o) const &#123; return !operator &gt; (o); &#125;</span><br><span class="line">                         inline bool operator &gt;= (const wp&lt;T&gt;&amp; o) const &#123; return !operator &lt; (o); &#125;</span><br><span class="line">    template&lt;typename U&gt; inline bool operator &gt;= (const wp&lt;U&gt;&amp; o) const &#123; return !operator &lt; (o); &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    template&lt;typename Y&gt; friend class sp;</span><br><span class="line">    template&lt;typename Y&gt; friend class wp;</span><br><span class="line"></span><br><span class="line">    T*              m_ptr;</span><br><span class="line">    weakref_type*   m_refs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;与强指针类相比，它们都有一个成员变量m_ptr指向目标对象，但是弱指针还有一个额外的成员变量m_refs，它的类型是weakref_type指针，下面我们分析弱指针的构造函数时再看看它是如果初始化的。这里我们需要关注的仍然是弱指针的构造函数和析构函数。</p>
<p> &#160; &#160; &#160; &#160;先看拷贝构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">wp&lt;T&gt;::wp(T* other)  </span><br><span class="line">    : m_ptr(other)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (other) m_refs = other-&gt;createWeak(<span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;这里的参数other一定是继承了RefBase类，因此，这里调用了RefBase类的createWeak函数，它定义在system/core/libutils/RefBase.cpp文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RefBase::weakref_type* RefBase::createWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    mRefs-&gt;incWeak(id);</span><br><span class="line">    <span class="keyword">return</span> mRefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这里的成员变量mRefs的类型为weakref_impl指针，weakref_impl类的incWeak函数我们在前面已经看过了，它的作用就是增加对象的弱引用计数。函数最后返回mRefs，于是，弱指针对象的成员变量m_refs就指向目标对象的weakref_impl对象了。</p>
<p>&#160; &#160; &#160; &#160;再看看析构函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">wp&lt;T&gt;::~wp()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里，弱指针在析构的时候，与强指针析构不一样，它直接就调用目标对象的weakref_impl对象的decWeak函数来减少弱引用计数了，当弱引用计数为0的时候，就会根据在目标对象的标志位（0、OBJECT_LIFETIME_WEAK或者OBJECT_LIFETIME_FOREVER）来决定是否要delete目标对象，前面我们已经介绍过了，这里就不再介绍了。</p>
<p>&#160; &#160; &#160; &#160;分析到这里，弱指针还没介绍完，它最重要的特性我们还没有分析到。前面我们说过，弱指针的最大特点是它不能直接操作目标对象，这是怎么样做到的呢？秘密就在于弱指针类没有重载*和-&gt;操作符号，而强指针重载了这两个操作符号。但是，如果我们要操作目标对象，应该怎么办呢，这就要把弱指针升级为强指针了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">sp&lt;T&gt; wp&lt;T&gt;::promote() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;T&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr &amp;&amp; m_refs-&gt;attemptIncStrong(&amp;result)) &#123;</span><br><span class="line">        result.set_pointer(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;升级的方式就使用成员变量m_ptr和m_refs来构造一个强指针sp，这里的m_ptr为指目标对象的一个指针，而m_refs则是指向目标对象里面的weakref_impl对象。主要就是初始化指向目标对象的成员变量m_ptr了，如果目标对象还存在，这个m_ptr就指向目标对象，如果目标对象已经不存在，m_ptr就为NULL，升级成功与否就要看refs-&gt;attemptIncStrong函数的返回结果了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> RefBase::weakref_type::attemptIncStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span><br><span class="line">&#123;</span><br><span class="line">    incWeak(id);<span class="comment">//先增加弱引用计数</span></span><br><span class="line">    </span><br><span class="line">    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">int32_t</span> curCount = impl-&gt;mStrong;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) &#123;<span class="comment">//如果强引用计数大于0，且不是第一次引用，直接强引用计数加一</span></span><br><span class="line">        <span class="comment">// we're in the easy/common case of promoting a weak-reference</span></span><br><span class="line">        <span class="comment">// from an existing strong reference.</span></span><br><span class="line">        <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount+<span class="number">1</span>, &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">        <span class="comment">// situation.</span></span><br><span class="line">        curCount = impl-&gt;mStrong;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span> || curCount == INITIAL_STRONG_VALUE) &#123;<span class="comment">//强引用计数小于等于0，或者从未被强指针引用过</span></span><br><span class="line">        <span class="comment">// we're now in the harder case of either:</span></span><br><span class="line">        <span class="comment">// - there never was a strong reference on us</span></span><br><span class="line">        <span class="comment">// - or, all strong references have been released</span></span><br><span class="line">        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//如果生命周期是强引用计数导向</span></span><br><span class="line">            <span class="comment">// this object has a "normal" life-time, i.e.: it gets destroyed</span></span><br><span class="line">            <span class="comment">// when the last strong reference goes away</span></span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;<span class="comment">//强引用计数为0，说明对象已被销毁，则升级失败</span></span><br><span class="line">                <span class="comment">// the last strong-reference got released, the object cannot</span></span><br><span class="line">                <span class="comment">// be revived.</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// here, curCount == INITIAL_STRONG_VALUE, which means</span></span><br><span class="line">            <span class="comment">// there never was a strong-reference, so we can try to</span></span><br><span class="line">            <span class="comment">// promote this object; we need to do that atomically.</span></span><br><span class="line">            <span class="keyword">while</span> (curCount &gt; <span class="number">0</span>) &#123;<span class="comment">//从未被强指针引用过，则强引用计数+1</span></span><br><span class="line">                <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount + <span class="number">1</span>,</span><br><span class="line">                        &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">                <span class="comment">// situation (e.g.: another thread has inc/decStrong'ed us)</span></span><br><span class="line">                curCount = impl-&gt;mStrong;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;如果多线程操作，入另一个线程销毁了这个对象，则升级失败</span><br><span class="line">                <span class="comment">// promote() failed, some other thread destroyed us in the</span></span><br><span class="line">                <span class="comment">// meantime (i.e.: strong count reached zero).</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果生命周期收弱引用计数导向，或者是BJECT_LIFETIME_FOREVER</span></span><br><span class="line">            <span class="comment">// this object has an "extended" life-time, i.e.: it can be</span></span><br><span class="line">            <span class="comment">// revived from a weak-reference only.</span></span><br><span class="line">            <span class="comment">// Ask the object's implementation if it agrees to be revived</span></span><br><span class="line">            <span class="keyword">if</span> (!impl-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) &#123;<span class="comment">//尝试升级，默认为true</span></span><br><span class="line">                <span class="comment">// it didn't so give-up.</span></span><br><span class="line">                decWeak(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// grab a strong-reference, which is always safe due to the</span></span><br><span class="line">            <span class="comment">// extended life-time.</span></span><br><span class="line">            curCount = android_atomic_inc(&amp;impl-&gt;mStrong);<span class="comment">//升级后强引用计数+1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the strong reference count has already been incremented by</span></span><br><span class="line">        <span class="comment">// someone else, the implementor of onIncStrongAttempted() is holding</span></span><br><span class="line">        <span class="comment">// an unneeded reference.  So call onLastStrongRef() here to remove it.</span></span><br><span class="line">        <span class="comment">// (No, this is not pretty.)  Note that we MUST NOT do this if we</span></span><br><span class="line">        <span class="comment">// are in fact acquiring the first reference.</span></span><br><span class="line">        <span class="keyword">if</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount &lt; INITIAL_STRONG_VALUE) &#123;</span><br><span class="line">            impl-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    impl-&gt;addStrongRef(id);<span class="comment">//没什么卵用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now we need to fix-up the count if it was INITIAL_STRONG_VALUE</span></span><br><span class="line">    <span class="comment">// this must be done safely, i.e.: handle the case where several threads</span></span><br><span class="line">    <span class="comment">// were here in attemptIncStrong().</span></span><br><span class="line">    curCount = impl-&gt;mStrong;</span><br><span class="line">    <span class="keyword">while</span> (curCount &gt;= INITIAL_STRONG_VALUE) &#123;<span class="comment">//如果此弱指针是允计提升为强指针的，并且此目标对象是第一次被强指针引用，还需要调整一下目标对象的强引用计数值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount-INITIAL_STRONG_VALUE,</span><br><span class="line">                &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the strong-count changed on us, we need to re-assert the situation,</span></span><br><span class="line">        <span class="comment">// for e.g.: it's possible the fix-up happened in another thread.</span></span><br><span class="line">        curCount = impl-&gt;mStrong;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数的作用是试图增加目标对象的强引用计数，但是有可能会失败，失败的原因可能是因为目标对象已经被delete掉了，或者是其它的原因，下面会分析到。前面我们在讨论强指针的时候说到，增加目标对象的强引用计数的同时，也会增加目标对象的弱引用计数，因此，函数在开始的地方首先就是调用incWeak函数来先增加目标对象的引用计数，如果后面试图增加目标对象的强引用计数失败时，会调用decWeak函数来回滚前面的incWeak操作。</p>
<p>&#160; &#160; &#160; &#160;这里试图增加目标对象的强引用计数时，分两种情况讨论，一种情况是此时目标对象正在被其它强指针引用，即它的强引用计数大于0，并且不等于INITIAL_STRONG_VALUE，另一种情况是此时目标对象没有被任何强指针引用，即它的强引用计数小于等于0，或者等于INITIAL_STRONG_VALUE。</p>
<p>&#160; &#160; &#160; &#160; 第一种情况比较简单，因为这时候说明目标对象一定存在，因此，是可以将这个弱指针提升为强指针的，在这种情况下，只要简单地增加目标对象的强引用计数值就行了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) &#123;<span class="comment">//如果强引用计数大于0，且不是第一次引用，直接强引用计数加一</span></span><br><span class="line">       <span class="comment">// we're in the easy/common case of promoting a weak-reference</span></span><br><span class="line">       <span class="comment">// from an existing strong reference.</span></span><br><span class="line">       <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount+<span class="number">1</span>, &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">       <span class="comment">// situation.</span></span><br><span class="line">       curCount = impl-&gt;mStrong;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;当我们在这里对目标对象的强引用计数执行加1操作时，要保证原子性，因为其它地方也有可能正在对这个目标对象的强引用计数执行加1的操作，前面我们一般是调用android_atomic_inc函数来完成，但是这里是通过调用android_atomic_cmpxchg函数来完成，android_atomic_cmpxchg函数是体系结构相关的函数，在提供了一些特殊的指令的体系结构上，调用android_atomic_cmpxchg函数来执行加1操作的效率会比调用android_atomic_inc函数更高一些。函数android_atomic_cmpxchg是在system/core/include/cutils/atomic.h文件中定义的一个宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">android_atomic_release_cas</span><span class="params">(<span class="keyword">int32_t</span> oldvalue, <span class="keyword">int32_t</span> newvalue,  </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int32_t</span>* addr)</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> android_atomic_cmpxchg android_atomic_release_cas</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它实际执行的函数是android_atomic_release_cas，这个函数的工作原理大概是这样的：如果它发现<em>addr == oldvalue，就会执行</em>addr = newvalue的操作，然后返回0，否则什么也不做，返回1。在我们讨论的这个场景中，oldvalue等于curCount，而newvalue等于curCount + 1，于是，在<em>addr == oldvalue的条件下，就相当于是对目标对象的强引用计数值增加了1。什么情况下</em>addr != oldvalue呢？在调用android_atomic_release_cas函数之前，oldvalue和值就是从地址addr读出来的，如果在执行android_atomic_release_cas函数的时候，有其它地方也对地址addr进行操作，那么就会有可能出现*addr != oldvalue的情况，这时候就说明其它地方也在操作目标对象的强引用计数了，因此，这里就不能执行增加目标对象的强引用计数的操作了，它必须要等到其它地方操作完目标对象的强引用计数之后再重新执行，这就是为什么要通过一个while循环来执行了。</p>
<p>&#160; &#160; &#160; &#160;第二种情况比较复杂一点，因为这时候目标对象可能还存在，也可能不存了，这要根据实际情况来判断。如果此时目标对象的强引用计数值等于INITIAL_STRONG_VALUE，说明此目标对象还从未被强指针引用过，这时候弱指针能够被提升为强指针的条件就为:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curCount &lt;= <span class="number">0</span> || curCount == INITIAL_STRONG_VALUE) &#123;<span class="comment">//强引用计数小于等于0，或者从未被强指针引用过</span></span><br><span class="line">    <span class="comment">// we're now in the harder case of either:</span></span><br><span class="line">    <span class="comment">// - there never was a strong reference on us</span></span><br><span class="line">    <span class="comment">// - or, all strong references have been released</span></span><br><span class="line">    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) &#123;<span class="comment">//如果生命周期是强引用计数导向</span></span><br><span class="line">        <span class="comment">// this object has a "normal" life-time, i.e.: it gets destroyed</span></span><br><span class="line">        <span class="comment">// when the last strong reference goes away</span></span><br><span class="line">        <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;<span class="comment">//强引用计数为0，说明对象已被销毁，则升级失败</span></span><br><span class="line">            <span class="comment">// the last strong-reference got released, the object cannot</span></span><br><span class="line">            <span class="comment">// be revived.</span></span><br><span class="line">            decWeak(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// here, curCount == INITIAL_STRONG_VALUE, which means</span></span><br><span class="line">        <span class="comment">// there never was a strong-reference, so we can try to</span></span><br><span class="line">        <span class="comment">// promote this object; we need to do that atomically.</span></span><br><span class="line">        <span class="keyword">while</span> (curCount &gt; <span class="number">0</span>) &#123;<span class="comment">//从未被强指针引用过，则强引用计数+1</span></span><br><span class="line">            <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount + <span class="number">1</span>,</span><br><span class="line">                    &amp;impl-&gt;mStrong) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// the strong count has changed on us, we need to re-assert our</span></span><br><span class="line">            <span class="comment">// situation (e.g.: another thread has inc/decStrong'ed us)</span></span><br><span class="line">            curCount = impl-&gt;mStrong;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) &#123;如果多线程操作，入另一个线程销毁了这个对象，则升级失败</span><br><span class="line">            <span class="comment">// promote() failed, some other thread destroyed us in the</span></span><br><span class="line">            <span class="comment">// meantime (i.e.: strong count reached zero).</span></span><br><span class="line">            decWeak(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果生命周期收弱引用计数导向，或者是BJECT_LIFETIME_FOREVER</span></span><br><span class="line">        <span class="comment">// this object has an "extended" life-time, i.e.: it can be</span></span><br><span class="line">        <span class="comment">// revived from a weak-reference only.</span></span><br><span class="line">        <span class="comment">// Ask the object's implementation if it agrees to be revived</span></span><br><span class="line">        <span class="keyword">if</span> (!impl-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) &#123;<span class="comment">//尝试升级，默认为true</span></span><br><span class="line">            <span class="comment">// it didn't so give-up.</span></span><br><span class="line">            decWeak(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// grab a strong-reference, which is always safe due to the</span></span><br><span class="line">        <span class="comment">// extended life-time.</span></span><br><span class="line">        curCount = android_atomic_inc(&amp;impl-&gt;mStrong);<span class="comment">//升级后强引用计数+1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1) 即如果目标对象的生命周期只受到强引用计数控制或者在目标对象的具体实现中总是允许这种情况发生。怎么理解呢？如果目标对象的生命周期只受强引用计数控制（它的标志位mFlags为0），而这时目标对象又还未被强指针引用过，它自然就不会被delete掉，因此，这时候可以判断出目标对象是存在的；如果目标对象的生命周期受弱引用计数控制（OBJECT_LIFETIME_WEAK），这时候由于目标对象正在被弱指针引用，因此，弱引用计数一定不为0，目标对象一定存在；如果目标对象的生命周期不受引用计数控制（BJECT_LIFETIME_FOREVER），这时候目标对象也是下在被弱指针引用，因此，目标对象的所有者必须保证这个目标对象还没有被delete掉，否则就会出问题了。</p>
<p>&#160; &#160; &#160; &#160;在后面两种场景下，因为目标对象的生命周期都是不受强引用计数控制的，而现在又要把弱指针提升为强指针，就需要进一步调用目标对象的onIncStrongAttempted来看看是否允许这种情况发生，这又该怎么理解呢？可以这样理解，目标对象的设计者可能本身就不希望这个对象被强指针引用，只能通过弱指针来引用它，因此，这里它就可以重载其父类的onIncStrongAttempted函数，然后返回false，这样就可以阻止弱指针都被提升为强指针。在RefBase类中，其成员函数onIncStrongAttempted默认是返回true的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RefBase::onIncStrongAttempted(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> (flags&amp;FIRST_INC_STRONG) ? <span class="literal">true</span> : <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2) 如果此时目标对象的强引用计数值小于等于0，那就说明该对象之前一定被强指针引用过，这时候就必须保证目标对象是被弱引用计数控制的（BJECT_LIFETIME_WEAK），否则的话，目标对象就已经被delete了。同样，这里也要调用一下目标对象的onIncStrongAttempted成员函数，来询问一下目标对象在强引用计数值小于等于0的时候，是否允计将弱指针提升为强指针。</p>
<p>&#160; &#160; &#160; &#160;然后将强引用计数加一，还有一些收尾处理，函数的最后，如果此弱指针是允计提升为强指针的，并且此目标对象是第一次被强指针引用，还需要调整一下目标对象的强引用计数值。</p>
<p>&#160; &#160; &#160; &#160;到这里弱指针就分析完了，它和强指针逻辑大同小异。</p>
<h1 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h1><p>&#160; &#160; &#160; &#160;说了这么多原理，下面该看看智能指针该如何使用了。假设现在有一个类MyClass，如果要使用智能指针来引用这个类的对象，那么这个类需满足下列两个前提条件：<br>1：这个类是基类RefBase的子类或间接子类；<br>2：这个类必须定义虚构造函数，即它的构造函数需要这样定义：<br>&#160; &#160; &#160; &#160;virtual ~MyClass();<br>&#160; &#160; &#160; &#160;满足了上述条件的类就可以定义为Android智能指针了，定义方法和普通指针类似。比如&#160; &#160; &#160; &#160;普通指针是这样定义：<br>&#160; &#160; &#160; &#160;MyClass<em> p_obj;<br>&#160; &#160; &#160; &#160;智能指针是这样定义：<br>&#160; &#160; &#160; &#160;sp<myclass> p_obj;<br>&#160; &#160; &#160; &#160;注意不要定义成sp<myclass></myclass></myclass></em> p_obj。这是初学者很容易犯的错误，这样其实相当于定义了一个指针的指针。尽管在语法上没有问题，但是最好不要这样定义。<br>&#160; &#160; &#160; &#160;定义了一个智能指针的变量，就可以象普通指针那样使用它，包括赋值、访问对象成员、作为函数的返回值、作为函数的参数等。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p_obj = <span class="keyword">new</span> MyClass(); <span class="comment">// 注意不要写成 p_obj = new sp&lt;MyClass&gt; </span></span><br><span class="line">sp&lt;MyClass&gt; p_obj2 = p_obj; </span><br><span class="line">p_obj-&gt;func(); </span><br><span class="line">p_obj = create_obj(); </span><br><span class="line">some_func(p_obj);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;注意不要试图delete一个智能指针，即 delete p_obj。不要担心对象的销毁问题，智能指针的最大作用就是自动销毁不再使用的对象。不需要再使用一个对象后，直接将指针赋值为NULL即可：<br>&#160; &#160; &#160; &#160;p_obj = NULL;<br>&#160; &#160; &#160; &#160;上面说的都是强指针，弱指针的定义方法和强指针类似，但是不能通过弱指针来访问对象的成员。下面是弱指针的示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wp&lt;MyClass&gt; wp_obj = <span class="keyword">new</span> MyClass(); </span><br><span class="line">p_obj = wp_obj.promote(); <span class="comment">// 升级为强指针。不过这里要用.而不是-&gt;，真是有负其指针之名啊 </span></span><br><span class="line">wp_obj = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;至此，智能指针部分就分析完了，我们不得不赞叹Google设计的强大。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg" alt="结语"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android消息处理零散分析]]></title>
      <url>http://windrunnerlihuan.com/2016/07/31/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160;Android消息机制是开发人员用滥的内容，不过内部原理比较复杂，因此今天抽空从头到位彻底分析一下。<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;我们知道，Android应用程序是通过消息来驱动的。Google参考了Windows的消息处理机制，在Android系统中实现了一套类似的消息处理机制。<br>&#160; &#160; &#160; &#160;了解过Win32开发的同学应该都知道windows是事件驱动的，事件驱动围绕着消息的产生与处理展开，事件驱动是靠消息循环机制来实现的。消息机制的三大要点：消息队列、消息循环(分发)、消息处理。其结构如下：<br> <div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/looper.jpg"></div></p>
<ul>
<li><strong>消息队列</strong>就是存放消息的一种队列，具有先进先出的特点。每产生一个消息都会添加进消息队列中，在Windows中消息队列是在操作系统中定义的。消息队列就如同一群排队打饭的同学，这群人中光景较好的排在前面，光景较差的排在后面，可以理解成是一种优先级队列！</li>
<li><strong>消息循环</strong>就是通过循环(如while)不断地从消息队列中取得队首的消息，并将消息分发出去。类似于食堂打饭的阿姨。</li>
<li><strong>消息处理</strong>就是在接收到消息之后根据不同的消息类型做出不同的处理。食堂阿姨根据学生点的不同类型的菜名给他们打不同的饭菜就是消息处理，学生手点的菜名就是消息所携带的信息</li>
<li><strong>事件</strong>是根据接收到的消息的具体信息做出的特定的处理，放在代码中是事件响应函数。上面的例子中学生拿到饭菜后吃饭就是具体的事件。</li>
</ul>
<p>&#160; &#160; &#160; &#160;Android的消息处理机制也是基于上述模型的，实现消息驱动对应模型为：</p>
<ul>
<li>Message：消息，理解为线程间通讯的数据单元。</li>
<li>MessageQueue：消息队列，用来存放通过Handler发布的消息，按照先进先出执行。</li>
<li>Looper：消息循环，扮演MessageQueue和Handler之间桥梁的角色，循环取出MessageQueue里面的Message，并交付给相应的Handler进行处理。</li>
<li>Handler：Handler是Message的主要处理者，负责将Message添加到消息队列以及对消息队列中的Message进行处理。</li>
</ul>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><h2 id="初始化消息队列"><a href="#初始化消息队列" class="headerlink" title="初始化消息队列"></a>初始化消息队列</h2><p>&#160; &#160; &#160; &#160;Android应用程序进程在启动时，会在进程中加载ActivityThread类，并且执行这个类的main方法，应用程序的消息循环过程就是在这个main方法里面实现的。ActivityThread位于frameworks/base/core/java/android/app/ActivityThread.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        </span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">        Looper.loop();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;main方法做了两件事，一是在主线程创建了一个ActivityThread实例，二是通过Looper类使主线程进入消息循环。我们只关注后者。先看Looper.prepareMainLooper方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    private static Looper sMainLooper;</span><br><span class="line">    final MessageQueue mQueue;//消息队列</span><br><span class="line">    final Thread mThread;//当前线程，这里是主线程</span><br><span class="line">    </span><br><span class="line">    public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);//调用prepare(false)方法</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException("The main Looper has already </span><br><span class="line">been prepared.");</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //带参数prepare方法，参数quitAllowed表示是否可以退出消息循环</span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        if (sThreadLocal.get() != null) &#123;</span><br><span class="line">            throw new RuntimeException("Only one Looper may be created per </span><br><span class="line">thread");</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));//存入sThreadLocal</span><br><span class="line">线程局部变量</span><br><span class="line">    &#125; </span><br><span class="line">    private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);//初始化一个消息队列</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;       </span><br><span class="line">    public static Looper myLooper() &#123;</span><br><span class="line">        return sThreadLocal.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;prepareMainLooper方法其实就是在线程中创建了一个Looper对象，这个Looper对象存放在类型为ThreadLocal的sThreadLocal线程局部变量中，保证每一个调用prepareMainLooper方法的线程只有一个独立的Looper对象。<br>&#160; &#160; &#160; &#160;Looper对象的构造方法里又创建了一个消息队列MessageQueue，后续消息Message就是存放在这个队列中。我们看看它的创建过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// True if the message queue can be quit.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mQuitAllowed;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"></span><br><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;<span class="comment">//quitAllowed为false，说明main线程消息循环不允许退出</span></span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;MessageQueue的初始化都交给了nativeInit这个本地方法，我们看看它的具体实现，位于frameworks/base/core/jni/android_os_MessageQueue.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();<span class="comment">//建立一个NativeMessageQueue消息队列对象</span></span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);<span class="comment">//强引用计数+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);<span class="comment">//强转为java层long类型变量，返回给java层mPtr变量保存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在JNI层也相应建立一个消息队列NativeMessageQueue，建立成功后会将它的强引用计数加一，Google的智能指针需要这么干；然后通过C++操作符reinterpret_cast将NativeMessageQueue类型变量强转为jlong类型，并返回到java层，方便java层操作。 NativeMessageQueue同样定义在frameworks/base/core/jni/android_os_MessageQueue.cpp中，我们看看它的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() : mInCallback(<span class="literal">false</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);<span class="comment">//创建一个JNI层的Looper对象</span></span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它主要就是在内部创建了一个Looper对象，注意，这个Looper对象是实现在JNI层的，它与上面Java层中的Looper是不一样的，不过它们是对应的，下面我们进一步分析消息循环的过程的时候，就会清楚地了解到它们之间的关系。我们接着看JNI层Looper的构造函数实现，位于system/core/libutils/Looper.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">        mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];<span class="comment">//准备两个文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> result = pipe(wakeFds);<span class="comment">//创建一个管道</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];<span class="comment">//管道读端</span></span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];<span class="comment">//管道写端</span></span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);<span class="comment">//将管道读端设为非阻塞模式</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);<span class="comment">//管道写端同样设为非阻塞</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    mIdling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the epoll instance and register the wake pipe.</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);<span class="comment">//创建一个epoll专用的文件描述符</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//epoll其中一个专用结构体</span></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">    <span class="comment">//把结构体清零</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    <span class="comment">//重新赋值</span></span><br><span class="line">    eventItem.events = EPOLLIN;<span class="comment">//EPOLLIN ：表示对应的文件描述符可以读；</span></span><br><span class="line">    eventItem.data.fd = mWakeReadPipeFd;<span class="comment">//fd：关联的文件描述符；</span></span><br><span class="line">    <span class="comment">//epoll_ctl函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。这里是添加事件 </span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个构造函数做的事情非常重要，它跟我们后面要介绍的应用程序主线程在消息队列中没有消息时要进入等待状态以及当消息队列有消息时要把应用程序主线程唤醒的这两个知识点息息相关。<br>&#160; &#160; &#160; &#160;它主要做了两件事：<br>&#160; &#160; &#160; &#160;（1）通过pipe系统调用来创建了一个管道了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> wakeFds[<span class="number">2</span>];  </span><br><span class="line"><span class="keyword">int</span> result = pipe(wakeFds);  </span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line">mWakeReadPipeFd = wakeFds[<span class="number">0</span>];  </span><br><span class="line">mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;管道是Linux系统中的一种进程间通信机制。<strong>简单来说，管道就是一个文件，在管道的两端，分别是两个打开文件文件描述符，这两个打开文件描述符都是对应同一个文件，其中一个是用来读的，另一个是用来写的。一般的使用方式就是，一个线程通过读文件描述符中来读管道的内容，当管道没有内容时，这个线程就会进入等待状态；而另外一个线程通过写文件描述符来向管道中写入内容，写入内容的时候，如果另一端正有线程正在等待管道中的内容，那么这个线程就会被唤醒。</strong>这个等待和唤醒的操作是如何进行的呢，这就要借助Linux系统中的epoll机制了。<br>&#160; &#160; &#160; &#160;Linux系统中的epoll机制为处理大批量句柄而作了改进的poll，是Linux下多路复用I/O接口select/poll的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。但是这里我们其实只需要监控的I/O接口只有mWakeReadPipeFd一个，即前面我们所创建的管道的读端，为什么还需要用到epoll呢？有点用牛刀来杀鸡的味道。其实不然，这个Looper类是非常强大的，它除了监控内部所创建的管道接口之外，还提供了addFd接口供外界面调用，外界可以通过这个接口把自己想要监控的I/O事件一并加入到这个Looper对象中去，当所有这些被监控的I/O接口上面有事件发生时，就会唤醒相应的线程来处理，不过这里我们只关心刚才所创建的管道的I/O事件的发生。</p>
<p>&#160; &#160; &#160; &#160;（2）epoll机制相关初始化：<br>&#160; &#160; &#160; &#160;要使用Linux系统的epoll机制，首先要通过epoll_create来创建一个epoll专用的文件描述符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;epoll_create(int size)函数生成一个epoll专用的文件描述符。它其实是在内核申请一空间，用来存放你想关注的fd上是否发生以及发生了什么事件。size就是你在这个epoll fd上能关注的最大fd数。我们这里传入的二是EPOLL_SIZE_HINT。</p>
<p>&#160; &#160; &#160; &#160;接着还要通过epoll_ctl函数来告诉epoll要监控相应的文件描述符的什么事件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll其中一个专用结构体</span></span><br><span class="line">   <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">   <span class="comment">//把结构体清零</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">   <span class="comment">//重新赋值</span></span><br><span class="line">   eventItem.events = EPOLLIN;<span class="comment">//EPOLLIN ：表示对应的文件描述符可以读；</span></span><br><span class="line">   eventItem.data.fd = mWakeReadPipeFd;<span class="comment">//fd：关联的文件描述符；</span></span><br><span class="line">   <span class="comment">//epoll_ctl函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。这里是添加事件 </span></span><br><span class="line">   result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;epoll_ctl函数如下：<br>函数声明：int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)<br>该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。<br>参数：<br>epfd：由 epoll_create 生成的epoll专用的文件描述符；<br>op：要进行的操作例如注册事件，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修 改、EPOLL_CTL_DEL 删除<br>fd：关联的文件描述符；<br>event：指向epoll_event结构体的指针；<br>返回值：<br>如果调用成功返回0,不成功返回-1 </p>
<p>&#160; &#160; &#160; &#160;用到的结构体如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> epoll_event &#123;   </span><br><span class="line"><span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span>   <span class="comment">//事件类型</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span>   </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;   </span><br><span class="line"><span class="keyword">void</span> *ptr;   </span><br><span class="line"><span class="keyword">int</span> fd;   <span class="comment">//关联的文件描述符</span></span><br><span class="line"><span class="keyword">__uint32_t</span> u32;   </span><br><span class="line"><span class="keyword">__uint64_t</span> u64;   </span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;epoll_event 结构体常用的事件类型:<br>EPOLLIN ：表示对应的文件描述符可以读；<br>EPOLLOUT：表示对应的文件描述符可以写；<br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读<br>EPOLLERR：表示对应的文件描述符发生错误；<br>EPOLLHUP：表示对应的文件描述符被挂断；<br>EPOLLET：表示对应的文件描述符有事件发生；</p>
<p>&#160; &#160; &#160; &#160;这里就是告诉mEpollFd，它要监控mWakeReadPipeFd文件描述符的EPOLLIN事件，即当管道中有内容可读时，就唤醒当前正在等待管道中的内容的线程。<br>&#160; &#160; &#160; &#160;C++层的这个Looper对象创建好了之后，就返回到JNI层的NativeMessageQueue的构造函数，最后就返回到Java层的消息队列MessageQueue的创建过程，这样，Java层的Looper对象就准备好了。</p>
<p>&#160; &#160; &#160; &#160;对上面内容小结一下就是：<br>&#160; &#160; &#160; &#160;①在Java层，创建了一个Looper对象，这个Looper对象是用来进入消息循环的，它的内部有一个消息队列MessageQueue对象mQueue；<br>&#160; &#160; &#160; &#160;②在JNI层，创建了一个NativeMessageQueue对象，这个NativeMessageQueue对象保存在Java层的消息队列对象mQueue的成员变量mPtr中；<br>&#160; &#160; &#160; &#160;③在C++层，创建了一个Looper对象，保存在JNI层的NativeMessageQueue对象的成员变量mLooper中，这个对象的作用是，当Java层的消息队列中没有消息时，就使Android应用程序主线程进入等待状态，而当Java层的消息队列中来了新的消息后，就唤醒Android应用程序的主线程来处理这个消息。</p>
<h2 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h2><p>&#160; &#160; &#160; &#160;继续回到上面ActivitThread的main方法里，在上面这些工作都准备好之后就调用Looper.loop方法进入到消息循环中了。<br>&#160; &#160; &#160; &#160;消息循环就会取出消息进行处理，在看消息处理之前，先看一下消息是怎么被添加到消息队列的。</p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>&#160; &#160; &#160; &#160;在Java层，Message类表示一个消息对象，要发送消息首先就要先获得一个消息对象，Message类的构造函数是public的，但是不建议直接new Message，Message内部保存了一个缓存的消息池，我们可以用obtain从缓存池获得一个消息，Message使用完后系统会调用recycle回收，如果自己new很多Message，每次使用完后系统放入缓存池，会占用很多内存的。我们看看Message类相关方法和变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">         <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Message m = sPool;<span class="comment">//取出表头</span></span><br><span class="line">             sPool = m.next;</span><br><span class="line">             m.next = <span class="keyword">null</span>;</span><br><span class="line">             m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">             sPoolSize--;</span><br><span class="line">             <span class="keyword">return</span> m;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                     + <span class="string">"is still in use."</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     recycleUnchecked();</span><br><span class="line"> &#125;    </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">     <span class="comment">// Clear out all other details.</span></span><br><span class="line">     flags = FLAG_IN_USE;</span><br><span class="line">     what = <span class="number">0</span>;</span><br><span class="line">     arg1 = <span class="number">0</span>;</span><br><span class="line">     arg2 = <span class="number">0</span>;</span><br><span class="line">     obj = <span class="keyword">null</span>;</span><br><span class="line">     replyTo = <span class="keyword">null</span>;</span><br><span class="line">     sendingUid = -<span class="number">1</span>;</span><br><span class="line">     when = <span class="number">0</span>;</span><br><span class="line">     target = <span class="keyword">null</span>;</span><br><span class="line">     callback = <span class="keyword">null</span>;</span><br><span class="line">     data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">         <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">             next = sPool;</span><br><span class="line">             sPool = <span class="keyword">this</span>;</span><br><span class="line">             sPoolSize++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Message内部通过next成员实现了一个链表，这样sPool就了为了一个Messages的缓存链表。</p>
<p>&#160; &#160; &#160; &#160;消息对象获取到了怎么发送呢，大家都知道是通过Handler的post、sendMessage等方法，其实这些方法最终都是调用的同一个方法sendMessageAtTime:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;sendMessageAtTime获取到消息队列然后调用enqueueMessage方法，消息队列mQueue是从与Handler关联的Looper获得的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;enqueueMessage将message的target设置为当前的handler，然后调用MessageQueue的enqueueMessage，在调用queue.enqueueMessage之前判断了mAsynchronous，从名字看是异步消息的意思，要明白Asynchronous的作用，需要先了解一个概念Barrier。</p>
<h3 id="Barrier与Asynchronous-Message"><a href="#Barrier与Asynchronous-Message" class="headerlink" title="Barrier与Asynchronous Message"></a>Barrier与Asynchronous Message</h3><p>&#160; &#160; &#160; &#160;Barrier是什么意思呢，从名字看是一个拦截器，在这个拦截器后面的消息都暂时无法执行，直到这个拦截器被移除了，MessageQueue有一个函数叫enqueueSyncBarier可以添加一个Barrier。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息队列的队头，消息队列按时间从小到大排序，这是最小的</span></span><br><span class="line">Message mMessages;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">enqueueSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">       <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;<span class="comment">//一个用来返回的自增int值作为token</span></span><br><span class="line">           <span class="keyword">final</span> Message msg = Message.obtain();<span class="comment">//创建一个路障</span></span><br><span class="line">           msg.markInUse();<span class="comment">//标记为正在使用</span></span><br><span class="line">           msg.when = when;<span class="comment">//路障的时间</span></span><br><span class="line">           msg.arg1 = token;<span class="comment">//打个token</span></span><br><span class="line"></span><br><span class="line">           Message prev = <span class="keyword">null</span>;</span><br><span class="line">           Message p = mMessages;<span class="comment">//访问消息队列队头</span></span><br><span class="line">           <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;<span class="comment">//遍历一遍消息队列，按时间找到路障位置</span></span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next //在时间所在队列位置插入路障</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//路障时间小于队头时间，或者消息队列为空，将路障设为队头</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> token;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在enqueueSyncBarrier中，obtain了一个Message，并设置msg.arg1=token，token仅是一个每次调用enqueueSyncBarrier时自增的int值，目的是每次调用enqueueSyncBarrier时返回唯一的一个token，这个Message同样需要设置执行时间，然后插入到消息队列，<strong>特殊的是这个Message没有设置target，即msg.target为null。</strong><br>&#160; &#160; &#160; &#160;如果队列头部的消息的target为null就表示它是个Barrier，因为只有两种方法往mMessages中添加消息，一种是enqueueMessage，另一种是enqueueBarrier，而enqueueMessage中如果mst.target为null是直接抛异常的，后面会看到。</p>
<p>&#160; &#160; &#160; &#160;所谓的异步消息其实就是这样的，我们可以通过enqueueBarrier往消息队列中插入一个Barrier，那么队列中执行时间在这个Barrier以后的同步消息都会被这个Barrier拦截住无法执行，直到我们调用removeBarrier移除了这个Barrier，而异步消息则没有影响，消息默认就是同步消息，除非我们调用了Message的setAsynchronous，这个方法是隐藏的。只有在初始化Handler时通过参数指定往这个Handler发送的消息都是异步的，这样在Handler的enqueueMessage中就会调用Message的setAsynchronous设置消息是异步的，从上面Handler.enqueueMessage的代码中可以看到。<br>&#160; &#160; &#160; &#160;所谓异步消息，其实只有一个作用，就是在设置Barrier时仍可以不受Barrier的影响被正常处理，如果没有设置Barrier，异步消息就与同步消息没有区别，可以通过removeSyncBarrier移除Barrier：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;<span class="comment">//取出队头</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;<span class="comment">//循环遍历消息队列，找出路障</span></span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;<span class="comment">//参数token就是enqueueSyncBarrier的返回值，如果没有调用指定的token是会抛异常的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></span><br><span class="line">                    + <span class="string">" barrier token has not been posted or has already been removed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;<span class="comment">//找到路障，移除路障</span></span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);<span class="comment">//唤醒操作下面再讲</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h3><p>&#160; &#160; &#160; &#160;接着我们顺着上面内容，看一下是MessageQueue的enqueueMessage的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//注意这里，当msg.target为null时是直接抛异常的，上面提到过</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;<span class="comment">//正在使用时不能重复加入队列</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//如果已经退出消息循环，则会异常返回</span></span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();<span class="comment">//给消息打上正在使用标签</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;<span class="comment">//取出队头</span></span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//如果当前的消息队列为空，或者新添加的消息的执行时间when是0，</span></span><br><span class="line">        <span class="comment">//或者新添加的消息的执行时间比消息队列头的消息的执行时间还早，</span></span><br><span class="line">        <span class="comment">//就把消息添加到消息队列头（消息队列按时间排序）</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;<span class="comment">//当前消息队列为空时，这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则就要找到合适的位置将当前消息添加到消息队列</span></span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            <span class="comment">//通常我们不用唤醒队列，除非有路障在队头并且插入的消息是更早的异步消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//循环遍历队列，找到应该插入的位置</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<span class="comment">// 消息队列中有异步消息并且执行时间在新消息之前，所以不需要唤醒</span></span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next 将目标消息插入队列位置</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;<span class="comment">//唤醒下面再讲</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;注意方法内第一行，当msg.target为null时是直接抛异常的。</p>
<p>&#160; &#160; &#160; &#160;在enqueueMessage中首先判断，如果当前的消息队列为空，这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它（唤醒我们下面再讲）。或者新添加的消息的执行时间when是0，或者新添加的消息的执行时间比消息队列头的消息的执行时间还早，就把消息添加到消息队列头（消息队列按时间排序），否则就要找到合适的位置将当前消息添加到消息队列。</p>
<h3 id="消息循环-1"><a href="#消息循环-1" class="headerlink" title="消息循环"></a>消息循环</h3><p>&#160; &#160; &#160; &#160;消息队列初始化好了，也知道怎么发消息了，下面就是怎么处理消息了，看Looper.loop函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">      <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">          <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">          msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这里就是进入到消息循环中去了，它不断地从消息队列mQueue中去获取下一个要处理的消息msg，如果消息的target成员变量为null，就表示要退出消息循环了，否则的话就要调用这个target对象的dispatchMessage成员函数来处理这个消息，这个target对象的类型为Handler，下面我们分析消息的发送时会看到这个消息对象msg是如设置的。<br>&#160; &#160; &#160; &#160;这个函数最关键的地方便是从消息队列中获取下一个要处理的消息了，即MessageQueue.next函数，我们看看它的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">     <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">     <span class="comment">// which is not supported.</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">     <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">     <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;<span class="comment">//当前消息队列中没有消息，它要等待的时间</span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//本地方法，一次消息轮训</span></span><br><span class="line">         nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">             <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">             Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">             Message msg = mMessages;<span class="comment">//取出队头消息</span></span><br><span class="line">             <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//如果队头消息是路障，就往后找到第一个异步消息</span></span><br><span class="line">                 <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                 do &#123;</span><br><span class="line">                     prevMsg = msg;</span><br><span class="line">                     msg = msg.next;</span><br><span class="line">                 &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//循环查找第一个异步消息</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;<span class="comment">//取出消息不为空</span></span><br><span class="line">                 <span class="keyword">if</span> (now &lt; msg.when) &#123;<span class="comment">//如果时间还未到，就要等待</span></span><br><span class="line">                     <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                     nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;<span class="comment">//取出这个消息，并从消息队列移除</span></span><br><span class="line">                     <span class="comment">// Got a message.</span></span><br><span class="line">                     mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         prevMsg.next = msg.next;</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         mMessages = msg.next;</span><br><span class="line">                     &#125;</span><br><span class="line">                     msg.next = <span class="keyword">null</span>;</span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                     </span><br><span class="line">                     <span class="comment">//返回取出的消息</span></span><br><span class="line">                     <span class="keyword">return</span> msg;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果消息队列中没有消息，那就要进入无穷等待状态直到有新消息了</span></span><br><span class="line">                 <span class="comment">// No more messages.</span></span><br><span class="line">                 nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">             <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                 dispose();</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">             <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">             <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">             <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                     &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                 pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                 mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">             &#125;</span><br><span class="line">             mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Run the idle handlers.</span></span><br><span class="line">         <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">             <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">             mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 keep = idler.queueIdle();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                 Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                 <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                     mIdleHandlers.remove(idler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">         pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">         <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">         nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;调用这个函数的时候，有可能会让线程进入等待状态。什么情况下，线程会进入等待状态呢？两种情况，一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。消息队列中的消息是按时间先后来排序的，上面我们分析过了。</p>
<p>&#160; &#160; &#160; &#160;执行下面语句是看看当前消息队列中有没有消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nativePollOnce(mPtr, nextPollTimeoutMillis);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这是一个JNI方法，我们等一下再分析，这里传入的参数mPtr就是指向前面我们在JNI层创建的NativeMessageQueue对象了，而参数nextPollTimeoutMillis则表示如果当前消息队列中没有消息，它要等待的时候，for循环开始时，传入的值为0，表示不等待。<br>&#160; &#160; &#160; &#160;当前nativePollOnce返回后，就去看看消息队列中有没有消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">Message msg = mMessages;<span class="comment">//取出队头消息</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//如果队头消息是路障，就往后找到第一个异步消息</span></span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    do &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//循环查找第一个异步消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;<span class="comment">//取出消息不为空</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.when) &#123;<span class="comment">//如果时间还未到，就要等待</span></span><br><span class="line">        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//取出这个消息，并从消息队列移除</span></span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回取出的消息</span></span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//如果消息队列中没有消息，那就要进入无穷等待状态直到有新消息了</span></span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;取消息队列头部的消息，如果头部消息是Barrier（target==null）就往后遍历找到第一个异步消息；</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;提前说明：nextPollTimeoutMillis 的值的意义是，-1表示下次调用nativePollOnce时，如果消息中没有消息，就进入无限等待状态中去。<br>&#160; &#160; &#160; &#160;这里计算出来的等待时间都是在下次调用nativePollOnce时使用的。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;接下来检测获取到的消息（消息队列头部的消息或者第一个异步消息），如果为null表示没有消息要执行，设置nextPollTimeoutMillis = -1，就要无限等待下去；<br>&#160; &#160; &#160; &#160;否则检测这个消息要执行的时间，如果到执行时间了就将这个消息markInUse并从消息队列移除，然后从next返回到loop；<br>&#160; &#160; &#160; &#160;否则设置nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE)，即距离最近要执行的消息还需要多久。</p>
<p>&#160; &#160; &#160; &#160;这里说的等待，是空闲等待，而不是忙等待，因此，在进入空闲等待状态前，如果应用程序注册了IdleHandler接口来处理一些事情，那么就会先执行这里IdleHandler，然后再进入等待状态。IdlerHandler是定义在MessageQueue的一个内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Callback interface for discovering when a thread is going to block</span><br><span class="line"> * waiting for more messages.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Called when the message queue has run out of messages and will now</span><br><span class="line">     * wait for more.  Return true to keep your idle handler active, false</span><br><span class="line">     * to have it removed.  This may be called if there are still messages</span><br><span class="line">     * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="line">     * after the current time.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它只有一个成员函数queueIdle，执行这个函数时，如果返回值为false，那么就会从应用程序中移除这个IdleHandler，否则的话就会在应用程序中继续维护着这个IdleHandler，下次空闲时仍会再执会这个IdleHandler。MessageQueue提供了addIdleHandler和removeIdleHandler两注册和删除IdleHandler。</p>
<p>&#160; &#160; &#160; &#160;回到MessageQueue的next方法中，它接下来就是在进入等待状态前，看看有没有IdleHandler是需要执行的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果没有，即pendingIdleHandlerCount等于0，那下面的逻辑就不执行了，通过continue语句直接进入下一次循环，否则就要把注册在mIdleHandlers中的IdleHandler取出来，放在mPendingIdleHandlers数组中去。</p>
<p>&#160; &#160; &#160; &#160;接下来就是执行这些注册了的IdleHanlder了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the idle handlers.</span></span><br><span class="line">         <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">             <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">             mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 keep = idler.queueIdle();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                 Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                 <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                     mIdleHandlers.remove(idler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;执行完这些IdleHandler之后，线程下次调用nativePollOnce函数时，就不设置超时时间了，因为，很有可能在执行IdleHandler的时候，已经有新的消息加入到消息队列中去了，因此，要重置nextPollTimeoutMillis的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// While calling an idle handler, a new message could have been delivered  </span></span><br><span class="line"><span class="comment">// so go back and look again for a pending message without waiting.  </span></span><br><span class="line">nextPollTimeoutMillis = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里MessageQueue的next方法的java部分就分析完了，我们重点看一下native方法nativePollOnce，看看它是如何进入等待状态的。这个函数定义在frameworks/base/core/jni/android_os_MessageQueue.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数首先是通过传进入的参数ptr取回前面在Java层创建MessageQueue对象时在JNI层创建的NatvieMessageQueue对象，然后调用它的pollOnce函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    ......</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里将操作转发给mLooper对象的pollOnce函数处理，这里的mLooper对象是在C++层的对象，它也是在前面在JNI层创建的NatvieMessageQueue对象时创建的，它的pollOnce函数定义在system/core/libutils/Looper.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;  </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        result = pollInner(timeoutMillis);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;省略一些障眼法，它主要就是调用pollInner函数来进一步操作，如果pollInner返回值不等于0，这个函数就可以返回了。函数pollInner的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> result = ALOOPER_POLL_WAKE;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItems[EPOLL_MAX_EVENTS];  </span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);  </span><br><span class="line">    <span class="keyword">bool</span> acquiredLock = <span class="literal">false</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    ......  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;  </span><br><span class="line">            <span class="keyword">goto</span> Done;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        LOGW(<span class="string">"Poll failed with an unexpected error, errno=%d"</span>, errno);  </span><br><span class="line">        result = ALOOPER_POLL_ERROR;  </span><br><span class="line">        <span class="keyword">goto</span> Done;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">        result = ALOOPER_POLL_TIMEOUT;  </span><br><span class="line">        <span class="keyword">goto</span> Done;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOOPER_USES_EPOLL  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;  </span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;  </span><br><span class="line">                awoken();  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                LOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (acquiredLock) &#123;  </span><br><span class="line">        mLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">Done: ;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">    ......  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;省略一些障眼法，这里，首先是调用epoll_wait函数来看看epoll专用文件描述符mEpollFd所监控的文件描述符是否有IO事件发生，它设置监控的超时时间为timeoutMillis：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;epoll_wait函数 如下：<br>函数声明:int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout)<br>该函数用于轮询I/O事件的发生；<br>参数：<br>epfd:由epoll_create 生成的epoll专用的文件描述符；<br>epoll_event:用于回传代处理事件的数组；<br>maxevents:每次能处理的事件数；<br>timeout:等待I/O事件发生的超时值；-1相当于阻塞，0相当于非阻塞。一般用-1即可<br>返回值：<br>返回发生事件数。 </p>
<p>&#160; &#160; &#160; &#160;epoll_wait运行的原理是 ：<br>等侍注册在epfd上的fd的事件的发生，如果发生则将发生的fd和事件类型放入到events数组中。<br>并 且将注册在epfd上的fd的事件类型给清空，所以如果下一个循环你还要关注这个fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置fd的事件类型。这时不用EPOLL_CTL_ADD,因为fd并未清空，只是事件类型清空。</p>
<p>&#160; &#160; &#160; &#160;回忆一下前面的Looper的构造函数，我们在里面设置了要监控mWakeReadPipeFd文件描述符的EPOLLIN事件。<br>&#160; &#160; &#160; &#160;当mEpollFd所监控的文件描述符发生了要监控的I/O事件后或者监控时间超时后，线程就从epoll_wait返回了，否则线程就会在epoll_wait函数中进入睡眠状态了。返回后如果eventCount等于0，就说明是超时了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;  </span><br><span class="line">    ......  </span><br><span class="line">    result = ALOOPER_POLL_TIMEOUT;  </span><br><span class="line">    <span class="keyword">goto</span> Done;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 如果eventCount不等于0，就说明发生要监控的事件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;  </span><br><span class="line">    <span class="keyword">int</span> fd = eventItems[i].data.fd;  </span><br><span class="line">    <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;  </span><br><span class="line">    <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;  </span><br><span class="line">            awoken();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            LOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            ......  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里我们只关注mWakeReadPipeFd文件描述符上的事件，如果在mWakeReadPipeFd文件描述符上发生了EPOLLIN就说明应用程序中的消息队列里面有新的消息需要处理了，接下来它就会先调用awoken函数清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。<br>&#160; &#160; &#160; &#160;函数awoken的实现很简单，它只是把管道中的内容都读取出来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::awoken() &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">16</span>];  </span><br><span class="line">    <span class="keyword">ssize_t</span> nRead;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));  </span><br><span class="line">    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="keyword">sizeof</span>(buffer));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;因为当其它的线程向应用程序的消息队列加入新的消息时，会向这个管道写入新的内容来通知应用程序主线程有新的消息需要处理了，从而唤醒它，下面我们分析一下。</p>
<h3 id="唤醒时机"><a href="#唤醒时机" class="headerlink" title="唤醒时机"></a>唤醒时机</h3><p>&#160; &#160; &#160; &#160;上面讲发送消息时讲过，把消息加入到消息队列时，分两种情况，一种当前消息队列为空时，这时候应用程序的主线程一般就是处于空闲等待状态了，这时候就要唤醒它，另一种情况是应用程序的消息队列不为空，这时候就不需要唤醒应用程序的主线程了，因为这时候它一定是在忙着处于消息队列中的消息，因此不会处于空闲等待的状态。<br>&#160; &#160; &#160; &#160;把消息加入到消息队列去后，如果应用程序的主线程正处于空闲等待状态，就需要调用natvieWake函数来唤醒它了，这是一个JNI方法，定义在frameworks/base/core/jni/android_os_MessageQueue.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个JNI层的NativeMessageQueue对象我们在前面分析消息循环的时候创建好的，保存在Java层的MessageQueue对象的mPtr成员变量中，这里把它取回来之后，就调用它的wake函数来唤醒应用程序的主线程，这个函数也是定义在frameworks/base/core/jni/android_os_MessageQueue.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里它又通过成员变量mLooper的wake函数来执行操作，这里的mLooper成员变量是一个C++层实现的Looper对象，它定义在system/core/libutils/Looper.cpp文件中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);  </span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);  </span><br><span class="line">  </span><br><span class="line">    .......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个wake函数很简单，只是通过打开文件描述符mWakeWritePipeFd往管道的写入一个”W”字符串。其实，往管道写入什么内容并不重要，往管道写入内容的目的是为了唤醒应用程序的主线程。前面我们在分析应用程序的消息循环时说到，当应用程序的消息队列中没有消息处理时，应用程序的主线程就会进入空闲等待状态，而这个空闲等待状态就是通过调用这个Looper类的pollInner函数来进入的，具体就是在pollInner函数中调用epoll_wait函数来等待管道中有内容可读的。<br>&#160; &#160; &#160; &#160;这时候既然管道中有内容可读了，应用程序的主线程就会从这里的Looper类的pollInner函数返回到JNI层的nativePollOnce函数，最后返回到Java层中的MessageQueue.next函数中去，这里它就会发现消息队列中有新的消息需要处理了，于就会处理这个消息。</p>
<p>&#160; &#160; &#160; &#160;剩下就是对消息的处理了，这个就更随意了。回到Looper.loop方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Looper me = myLooper();  </span><br><span class="line">        MessageQueue queue = me.mQueue;  </span><br><span class="line">  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block  </span></span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    <span class="comment">// No target is a magic identifier for the quit message.  </span></span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                ......  </span><br><span class="line">  </span><br><span class="line">                msg.target.dispatchMessage(msg);  <span class="comment">//处理消息</span></span><br><span class="line">                  </span><br><span class="line">                ......  </span><br><span class="line">  </span><br><span class="line">                msg.recycle();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它从消息队列中获得消息对象msg后，就会调用它的target成员变量的dispatchMessage函数来处理这个消息。在前面分析消息的发送时说过，这个消息对象msg的成员变量target是在发送消息的时候设置好的，一般就通过哪个Handler来发送消息，就通过哪个Handler来处理消息。<br>&#160; &#160; &#160; &#160;我们这里的Handler是ActivityThread的成员变量mH，是一个类型为H的Handler。 H类没有实现自己的dispatchMessage函数，但是它继承了父类Handler的dispatchMessage函数，我们看看Handler的dispatchMessage方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里的消息对象msg的callback成员变量和Handler类的mCallBack成员变量一般都为null，于是，就会调用Handler类的handleMessage函数来处理这个消息，由于H类在继承Handler类时，重写了handleMessage函数，因此，这里调用的实际上是H类的handleMessage函数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#160; &#160; &#160; &#160;至此，我们就分析完Android应用程序的消息处理机制了，简单做一个总结：</p>
<ul>
<li><p>Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。</p>
</li>
<li><p>Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。</p>
</li>
<li><p>当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。</p>
</li>
<li><p>当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。</p>
</li>
</ul>
<p>&#160; &#160; &#160; &#160;上述分析的是系统启动过程中的消息机制，如果我们想看一下一个线程想实现消息循环应该怎么做，可以看看HandlerThread的实现，和上面内容大同小异，有兴趣的同学可以自己研究研究。</p>
<p>&#160; &#160; &#160; &#160;结尾处贴个妹纸吧，这是今年ChinaJoy会场一个show girl，前同事拍的（我设备太渣了，所以在馆内只参加了活动，玩了些游戏=  。=）。<br> <div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/meizi2.jpg"></div><br> <div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/meizi1.jpg"></div></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析Bitmap占据内存大小]]></title>
      <url>http://windrunnerlihuan.com/2016/07/12/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160; Bitmap的使用是开发时绕不过的坑，使用时要处处留意内存问题，稍有不慎就会报OOM（out of memory）。所以这次我们就研究研究程序中Bitmap到底占据多少内存。<br><a id="more"></a></p>
<h1 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h1><p>&#160; &#160; &#160; &#160; 比如我们使用一张图片，将其放入到工程目录中，想当然的会以为为这张图片建立的bitmap使用内存大小为：宽×高×像素大小。为了验证这个猜想，我在度娘上随便找了幅图：</p>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/picture.jpg" title="素材"></div><br>&#160; &#160; &#160; &#160; 规格是768×1152，大小为153.3KB，格式为支持ARGB四阶的32位色的JPG图片。<br>&#160; &#160; &#160; &#160; 我们猜想，如果按照内存大小计算公式，所占内存应为：<strong>768×1152×4=3538944</strong>，字节。因为JPG格式是有损压缩格式，所以存储大小比内存大小小多了。<br>&#160; &#160; &#160; &#160; 然后将这张图片放到<strong>res/drawable-xhdpi</strong>下，通过如下代码计算内存大小：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> density = <span class="keyword">this</span>.getResources().getDisplayMetrics().density;</span><br><span class="line"><span class="keyword">int</span> dpi = <span class="keyword">this</span>.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">Log.e(TAG, <span class="string">"density = "</span> + density + <span class="string">"------"</span> + <span class="string">"dpi = "</span> + dpi);</span><br><span class="line"></span><br><span class="line">Bitmap b = BitmapFactory.decodeResource(getResources(), R.drawable.picture);</span><br><span class="line"><span class="keyword">int</span> w = b.getWidth();</span><br><span class="line"><span class="keyword">int</span> h = b.getHeight();</span><br><span class="line"><span class="keyword">int</span> size = b.getByteCount();</span><br><span class="line"><span class="keyword">int</span> config = b.getConfig().ordinal();</span><br><span class="line"></span><br><span class="line">Log.e(TAG, <span class="string">"w = "</span> + w + <span class="string">";"</span> + <span class="string">"h = "</span> + h + <span class="string">";"</span> + <span class="string">"size = "</span> + size + <span class="string">";"</span> + <span class="string">"config = "</span> + config);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;测试机器规格为：<strong>Google Nexus 5 - 5.1.0 - API 22 - 1080×1920(480dpi)</strong>。<br>&#160; &#160; &#160; &#160;打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 1152;h = 1728;size = 7962624;config = 3</p>
</blockquote>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/excuse.jpg" title="excuse me"></div><br>&#160; &#160; &#160; &#160;Why？How did you do it？这个不按套路出牌啊，宽高明显被拉伸了啊。。。。。。然后我又试了下将这张图片放到了<strong>res/drawable-xxhdpi</strong>下，打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 768;h = 1152;size = 3538944;config = 3</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;这次倒是和理论计算的大小一样了，我们大概猜到了什么。。。。。接着我又把这张图片放到了<strong>assets</strong>目录下，然后修改了一下获取图片的代码，打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 768;h = 1152;size = 3538944;config = 3</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;这次也是和理论值一样的，因为放到assets目录下的图片是不会被压缩的。</p>
<p>&#160; &#160; &#160; &#160;如果多试几次，把图片放入不同目录下再运行几遍，我们也能够总结出规律的。但这些都是现象，我们组的老大也曾经说过：开发人员不要轻易根据现象得出结论…….所以我们也要分析一下本质原因。</p>
<h1 id="求证"><a href="#求证" class="headerlink" title="求证"></a>求证</h1><p>&#160; &#160; &#160; &#160;做适配的同学要经常和density、densityDpi搞好关系，简单来说，可以理解为 density 的数值是 1dp=density px；densityDpi 是屏幕每英寸对应多少个点（不是像素点），在 DisplayMetrics 当中，这两个的关系是线性的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">density</th>
<th style="text-align:right">0.75</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1.5</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">3.5</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">densityDpi</td>
<td style="text-align:right">120</td>
<td style="text-align:center">160</td>
<td style="text-align:center">240</td>
<td style="text-align:center">320</td>
<td style="text-align:center">480</td>
<td style="text-align:center">560</td>
<td style="text-align:center">640</td>
</tr>
<tr>
<td style="text-align:left">DpiFolder</td>
<td style="text-align:right">ldpi</td>
<td style="text-align:center">mdpi</td>
<td style="text-align:center">hdpi</td>
<td style="text-align:center">xhdpi</td>
<td style="text-align:center">xxhdpi</td>
<td style="text-align:center">xxxhdpi</td>
<td style="text-align:center">xxxxhdpi</td>
</tr>
</tbody>
</table>
<p>&#160; &#160; &#160; &#160;这些内容每个人应该都知道，先放到这里，方便后面查表。</p>
<h2 id="非压缩计算"><a href="#非压缩计算" class="headerlink" title="非压缩计算"></a>非压缩计算</h2><p>&#160; &#160; &#160; &#160;如果图片不被压缩，按照常规计算内存大小方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bitmap的getByteCount方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getByteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// int result permits bitmaps up to 46,340 x 46,340</span></span><br><span class="line">       <span class="keyword">return</span> getRowBytes() * getHeight();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Bitmap的getRowBytes方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getRowBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nativeRowBytes(mNativeBitmap);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">nativeRowBytes</span><span class="params">(<span class="keyword">long</span> nativeBitmap)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;getHeight 就是图片的高度（单位：px），getRowBytes 从字面意思看应该是行字节大小。我们往下看，找找JNI实现，查看 frameworks/base/core/jni/android/graphics/Bitmap.cpp文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">Bitmap_rowBytes</span><span class="params">(JNIEnv* env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">    SkBitmap* bitmap = <span class="keyword">reinterpret_cast</span>&lt;SkBitmap*&gt;(bitmapHandle);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;jint&gt;(bitmap-&gt;rowBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;（reinterpret_cast和static_cast是C++经常用到的用来处理无关类型之间转换的强制类型转换符，建议有时间可以研究研究，或者把C++回顾一下，毕竟挺重要的。这里先给个<a href="http://www.cnblogs.com/jerry19880126/archive/2012/08/14/2638192.html" target="_blank" rel="external">科普文章</a>）<br>&#160; &#160; &#160; &#160;上一篇关于的弹幕文章提到过，java层的Bitmap对应native层是由skia图形引擎创建的SkBitmap，关于<a href="https://skia.org/" target="_blank" rel="external">skia</a>这玩意儿东西比较多，不是专业的一时半会儿也玩不转。所以我们还是简单看看，继续往下找SkBitmap：(/external/skia/include/core/SkBitmap.h)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Return the number of bytes between subsequent rows of the bitmap. */</span></span><br><span class="line"><span class="keyword">size_t</span> rowBytes() <span class="keyword">const</span> &#123; <span class="keyword">return</span> fRowBytes; &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;得到上述fRowBytes的大小会在SkBitmap.cpp文件里计算：（/external/skia/src/core/SkBitmap.cpp）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算fRowBytes大小</span></span><br><span class="line"><span class="keyword">size_t</span> SkBitmap::ComputeRowBytes(Config c, <span class="keyword">int</span> width) &#123;</span><br><span class="line">    <span class="keyword">return</span> SkColorTypeMinRowBytes(SkBitmapConfigToColorType(c), width);<span class="comment">//SkColorTypeMinRowBytes是/SkImageInfo.h的方法；SkBitmapConfigToColorType是SkImagePriv.cpp的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkImageInfo.h的SkColorTypeMinRowBytes方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">SkColorTypeMinRowBytes</span><span class="params">(SkColorType ct, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> width * SkColorTypeBytesPerPixel(ct);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkImageInfo.h的SkColorTypeBytesPerPixel方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SkColorTypeBytesPerPixel</span><span class="params">(SkColorType ct)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint8_t</span> gSize[] = &#123;</span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// Unknown</span></span><br><span class="line">        <span class="number">1</span>,  <span class="comment">// Alpha_8</span></span><br><span class="line">        <span class="number">2</span>,  <span class="comment">// RGB_565</span></span><br><span class="line">        <span class="number">2</span>,  <span class="comment">// ARGB_4444</span></span><br><span class="line">        <span class="number">4</span>,  <span class="comment">// RGBA_8888</span></span><br><span class="line">        <span class="number">4</span>,  <span class="comment">// BGRA_8888</span></span><br><span class="line">        <span class="number">1</span>,  <span class="comment">// kIndex_8</span></span><br><span class="line">    &#125;;</span><br><span class="line">	...省略障眼法的宏...</span><br><span class="line">    <span class="keyword">return</span> gSize[ct];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkBitmapConfigToColorType是SkImagePriv.cpp的方法</span></span><br><span class="line"><span class="function">SkColorType <span class="title">SkBitmapConfigToColorType</span><span class="params">(SkBitmap::Config config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SkColorType gCT[] = &#123;</span><br><span class="line">        kUnknown_SkColorType,   <span class="comment">// kNo_Config</span></span><br><span class="line">        kAlpha_8_SkColorType,   <span class="comment">// kA8_Config</span></span><br><span class="line">        kIndex_8_SkColorType,   <span class="comment">// kIndex8_Config</span></span><br><span class="line">        kRGB_565_SkColorType,   <span class="comment">// kRGB_565_Config</span></span><br><span class="line">        kARGB_4444_SkColorType, <span class="comment">// kARGB_4444_Config</span></span><br><span class="line">        kN32_SkColorType,   <span class="comment">// kARGB_8888_Config</span></span><br><span class="line">    &#125;;</span><br><span class="line">    SkASSERT((<span class="keyword">unsigned</span>)config &lt; SK_ARRAY_COUNT(gCT));</span><br><span class="line">    <span class="keyword">return</span> gCT[config];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;跟踪到这里，还记得我们上面大log的地方么。int config = b.getConfig().ordinal()返回的是3，那么在Bitmap.Config里面索引第4个枚举变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Config &#123;</span><br><span class="line">    ALPHA_8     (<span class="number">1</span>),</span><br><span class="line">    RGB_565     (<span class="number">3</span>),</span><br><span class="line">    ARGB_4444   (<span class="number">4</span>),</span><br><span class="line">    ARGB_8888   (<span class="number">5</span>);<span class="comment">//索引第四个是这个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> nativeInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从这个列表可以看出它与skia支持的图片格式一一对应，但是Android只支持上面4种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Config sConfigs[] = &#123;</span><br><span class="line">        <span class="keyword">null</span>, ALPHA_8, <span class="keyword">null</span>, RGB_565, ARGB_4444, ARGB_8888</span><br><span class="line">    &#125;;       </span><br><span class="line">    Config(<span class="keyword">int</span> ni) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nativeInt = ni;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Config <span class="title">nativeToConfig</span><span class="params">(<span class="keyword">int</span> ni)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sConfigs[ni];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;依照上面C++文件，我们发现 ARGB_8888（也就是我们最常用的 Bitmap 的格式）的一个像素占用 4byte，那么 rowBytes 实际上就是 4*width bytes。则理论上 ARGB_8888 的 Bitmap 占用内存的计算公式为：</p>
<p><strong>bitmapInRam = bitmapWidth × bitmapHeight × 4 bytes</strong></p>
<h2 id="压缩计算"><a href="#压缩计算" class="headerlink" title="压缩计算"></a>压缩计算</h2><p>&#160; &#160; &#160; &#160;如果我们不将图片放到assets目录下，内存大小计算方式就和上面完全不同了。我们读取的是 drawable 目录下面的图片，用的是 decodeResource 方法,该方法本质上就两步：</p>
<ul>
<li>读取原始资源，这个调用了 <strong>Resource.openRawResource</strong> 方法，这个方法调用完成之后会对 TypedValue 进行赋值，其中包含了原始资源的 density 等信息；</li>
<li>调用 <strong>decodeResourceStream</strong> 对原始资源进行解码和适配。这个过程实际上就是原始资源的 density 到屏幕 density 的一个映射。<br>&#160; &#160; &#160; &#160;原始资源的 density 其实取决于资源存放的目录（比如 xxhdpi 对应的是480），而屏幕 density 的赋值，请看下面这段代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> decodeResource(res, id, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id, Options opts)</span> </span>&#123;</span><br><span class="line">      Bitmap bm = <span class="keyword">null</span>;</span><br><span class="line">      InputStream is = <span class="keyword">null</span>; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> TypedValue value = <span class="keyword">new</span> TypedValue();</span><br><span class="line">          is = res.openRawResource(id, value);<span class="comment">//对 TypedValue 进行赋值，其中包含了原始资源的 density 等信息</span></span><br><span class="line"></span><br><span class="line">          bm = decodeResourceStream(res, value, is, <span class="keyword">null</span>, opts);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResourceStream</span><span class="params">(Resources res, TypedValue value,</span><br><span class="line">          InputStream is, Rect pad, Options opts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (opts == <span class="keyword">null</span>) &#123;<span class="comment">//opt为null</span></span><br><span class="line">          opts = <span class="keyword">new</span> Options();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (opts.inDensity == <span class="number">0</span> &amp;&amp; value != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> density = value.density;</span><br><span class="line">          <span class="keyword">if</span> (density == TypedValue.DENSITY_DEFAULT) &#123;</span><br><span class="line">              opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (density != TypedValue.DENSITY_NONE) &#123;</span><br><span class="line">              opts.inDensity = density;<span class="comment">//这里density的值如果对应资源目录为xhdpi的话，就是320</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//请注意，inTargetDensity就是当前的显示密度，比如Google Nexus 5就是480</span></span><br><span class="line">          opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> decodeStream(is, pad, opts);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeStream</span><span class="params">(InputStream is, Rect outPadding, Options opts)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      bm = decodeStreamInternal(is, outPadding, opts);</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> bm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">decodeStreamInternal</span><span class="params">(InputStream is, Rect outPadding, Options opts)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> nativeDecodeStream(is, tempStorage, outPadding, opts);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">nativeDecodeStream</span><span class="params">(InputStream is, <span class="keyword">byte</span>[] storage,</span><br><span class="line">          Rect padding, Options opts)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们看到 opts 这个值被初始化，而它的构造居然如此简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Options</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inDither = <span class="keyword">false</span>;</span><br><span class="line">    inScaled = <span class="keyword">true</span>;</span><br><span class="line">    inPremultiplied = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;所以我们就很容易的看到，Option.inScreenDensity 这个值没有被初始化，而实际上后面我们也会看到这个值根本不会用到；我们最应该关心的是什么呢？是 inDensity 和 inTargetDensity，这两个值与下面 cpp 文件里面的 density 和 targetDensity 相对应——重复一下，inDensity 就是原始资源的 density，inTargetDensity 就是屏幕的 density。<br>&#160; &#160; &#160; &#160;紧接着，用到了 nativeDecodeStream 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">nativeDecodeStream</span><span class="params">(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage,</span><br><span class="line">        jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jobject bitmap = NULL;</span><br><span class="line">		......</span><br><span class="line">        bitmap = doDecode(env, bufferedStream, padding, options);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">doDecode</span><span class="params">(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> density = env-&gt;GetIntField(options, gOptions_densityFieldID);<span class="comment">//对应xhdpi的时候，是320</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID);<span class="comment">//Google Nexus 5为480</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID);</span><br><span class="line">        <span class="keyword">if</span> (density != <span class="number">0</span> &amp;&amp; targetDensity != <span class="number">0</span> &amp;&amp; density != screenDensity) &#123;</span><br><span class="line">            scale = (<span class="keyword">float</span>) targetDensity / density;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> bool willScale = scale != <span class="number">1.0f</span>;</span><br><span class="line">......</span><br><span class="line">SkBitmap decodingBitmap;</span><br><span class="line"><span class="keyword">if</span> (!decoder-&gt;decode(stream, &amp;decodingBitmap, prefColorType,decodeMode)) &#123;</span><br><span class="line">   <span class="keyword">return</span> nullObjectReturn(<span class="string">"decoder-&gt;decode returned false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里这个deodingBitmap就是解码出来的bitmap，大小是图片原始的大小</span></span><br><span class="line"><span class="keyword">int</span> scaledWidth = decodingBitmap.width();</span><br><span class="line"><span class="keyword">int</span> scaledHeight = decodingBitmap.height();</span><br><span class="line"><span class="keyword">if</span> (willScale &amp;&amp; decodeMode != SkImageDecoder::kDecodeBounds_Mode) &#123;</span><br><span class="line">    scaledWidth = <span class="keyword">int</span>(scaledWidth * scale + <span class="number">0.5f</span>);</span><br><span class="line">    scaledHeight = <span class="keyword">int</span>(scaledHeight * scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> sx = scaledWidth / <span class="keyword">float</span>(decodingBitmap.width());</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> sy = scaledHeight / <span class="keyword">float</span>(decodingBitmap.height());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> avoid copying when scaled size equals decodingBitmap size</span></span><br><span class="line">    SkColorType colorType = colorTypeForScaledOutput(decodingBitmap.colorType());</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> If the alphaType is kUnpremul and the image has alpha, the</span></span><br><span class="line">    <span class="comment">// colors may not be correct, since Skia does not yet support drawing</span></span><br><span class="line">    <span class="comment">// to/from unpremultiplied bitmaps.</span></span><br><span class="line">    outputBitmap-&gt;setInfo(SkImageInfo::Make(scaledWidth, scaledHeight,</span><br><span class="line">            colorType, decodingBitmap.alphaType()));</span><br><span class="line">    <span class="keyword">if</span> (!outputBitmap-&gt;allocPixels(outputAllocator, NULL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nullObjectReturn(<span class="string">"allocation failed for scaled bitmap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If outputBitmap's pixels are newly allocated by Java, there is no need</span></span><br><span class="line">    <span class="comment">// to erase to 0, since the pixels were initialized to 0.</span></span><br><span class="line">    <span class="keyword">if</span> (outputAllocator != &amp;javaAllocator) &#123;</span><br><span class="line">        outputBitmap-&gt;eraseColor(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    SkPaint paint;</span><br><span class="line">    paint.setFilterLevel(SkPaint::kLow_FilterLevel);</span><br><span class="line"> </span><br><span class="line">    <span class="function">SkCanvas <span class="title">canvas</span><span class="params">(*outputBitmap)</span></span>;</span><br><span class="line">    canvas.scale(sx, sy);</span><br><span class="line">    canvas.drawBitmap(decodingBitmap, <span class="number">0.0f</span>, <span class="number">0.0f</span>, &amp;paint);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;注意到其中有个 density 和 targetDensity，前者是 decodingBitmap 的 density，这个值跟这张图片的放置的目录有关（比如 xhdpi 是320，xxhdpi 是480），这部分代码我跟了一下，太长了，就不列出来了；targetDensity 实际上是我们加载图片的目标 density，这个值的来源我们已经在前面给出了，就是 DisplayMetrics 的 densityDpi，如果是Google Nexus 5那么这个数值就是480。sx 和sy 实际上是约等于 scale 的，因为 scaledWidth 和 scaledHeight 是由 width 和 height 乘以 scale 得到的。我们看到 Canvas 放大了 scale 倍，然后又把读到内存的这张 bitmap 画上去，相当于把这张 bitmap 放大了 scale 倍。</p>
<p>&#160; &#160; &#160; &#160;然后我们再次验证上面打log的地方，win + r ，输入calc呼出计算器。<strong>这里千万不要忘了了精度</strong>：</p>
<p><strong>float scale = 480/320f = 1.5</strong><br><strong>int scaledWidth = int(768 * 1.5 + 0.5f) = 1152</strong><br><strong>int scaledHeight = int(1152 * 1.5 + 0.5f) = 1728</strong></p>
<p><strong>size = 1152 <em> 1728 </em> 4 = 7962624</strong></p>
<p>&#160; &#160; &#160; &#160;果然和上面log打印的一模一样！因此我们可以得出结论。Bitmap在内存中大小取决于：</p>
<ul>
<li>色彩格式，前面我们已经提到，如果是 ARG_B8888 那么就是一个像素4个字节，如果是 RGB_565 那就是2个字节</li>
<li>原始文件存放的资源目录(是 hdpi 还是 xxhdpi 等等)</li>
<li>目标屏幕的密度（所以同等条件下，红米在资源方面消耗的内存肯定是要小于三星S6的）</li>
</ul>
<p>&#160; &#160; &#160; &#160;内存大小计算公式大概为（压缩计算情况下）（已忽略精度）：</p>
<blockquote>
<p><strong>内存大小 = （设备屏幕dpi / 资源所在目录dpi）^ 2 × 图片原始宽 × 图片原始高 × 像素大小</strong></p>
</blockquote>
<h1 id="瞎猜"><a href="#瞎猜" class="headerlink" title="瞎猜"></a>瞎猜</h1><p>&#160; &#160; &#160; &#160;上面分析Bitmap.Config时发现Android官方并不完全支持skia图形引擎的所有像素格式，供java层设置的Config只有这么4个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Config &#123;</span><br><span class="line">    <span class="comment">// these native values must match up with the enum in SkBitmap.h</span></span><br><span class="line"> </span><br><span class="line">    ALPHA_8     (<span class="number">1</span>),</span><br><span class="line">    RGB_565     (<span class="number">3</span>),</span><br><span class="line">    ARGB_4444   (<span class="number">4</span>),</span><br><span class="line">    ARGB_8888   (<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    inal <span class="keyword">int</span> nativeInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其实 Java 层的枚举变量的 nativeInt 对应的就是 Skia 库当中枚举的索引值；而skia却支持这么多：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Skbitmap.h文件</span></span><br><span class="line">    <span class="keyword">enum</span> Config &#123;</span><br><span class="line">        kNo_Config,         <span class="comment">//!&lt; bitmap has not been configured</span></span><br><span class="line">        kA8_Config,         <span class="comment">//!&lt; 8-bits per pixel, with only alpha specified (0 is transparent, 0xFF is opaque)</span></span><br><span class="line">        kIndex8_Config,     <span class="comment">//!&lt; 8-bits per pixel, using SkColorTable to specify the colors</span></span><br><span class="line">        kRGB_565_Config,    <span class="comment">//!&lt; 16-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">        kARGB_4444_Config,  <span class="comment">//!&lt; 16-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">        kARGB_8888_Config,  <span class="comment">//!&lt; 32-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述枚举中第三个类型为<strong>索引图</strong>类型。<a href="http://www.tulaoshi.com/n/20160128/1466750.html" target="_blank" rel="external">索引位图</a>，每个像素只占 1 Byte，不仅支持 RGB，还支持 alpha。微软画图工具应该都玩过吧（win + r，输入mspaint），里面的调色板就是索引色盘。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/huatu.jpg" alt="画图工具"><br>&#160; &#160; &#160; &#160;而Android其他的config类型一个像素点占的字节比这个大多了，所以我们有时候能不能也用索引色去悄悄替换原来格式呢？<br>&#160; &#160; &#160; &#160;我的猜想是，反射构造一个Bitmap.Config枚举对象，然后反射设置nativeInt字段的值为2，猜想代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options op = <span class="keyword">new</span> Options();</span><br><span class="line">op.inPreferredConfig = ...反射构建Bitmap.Config相关内容...</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.drawable.picture, op);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;不过我没有实践过，也是瞎猜的，不知道能不能行的通。。。。。。</p>
<p>&#160; &#160; &#160; &#160;但是我对上一篇文章种调skia生成弹幕bitmap处的代码做了修改，修改了DanmakuFlameMaster工程里的NativeBitmapFactory.java文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">createNativeBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Config config, <span class="keyword">boolean</span> hasAlpha)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int nativeConfig = getNativeConfig(config);</span></span><br><span class="line">        <span class="keyword">int</span> nativeConfig = <span class="number">2</span>;<span class="comment">//直接改为索引色</span></span><br><span class="line">        <span class="keyword">return</span> android.os.Build.VERSION.SDK_INT == <span class="number">19</span> ? createBitmap19(width, height,</span><br><span class="line">                nativeConfig, hasAlpha) : createBitmap(width, height, nativeConfig, hasAlpha);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;将色彩格式改为索引色，然后重新编译运行。。。。。。然而弹幕压根没出来。。。。。等以后有机会问问<code>ctiao</code>吧，请教一下为何。<br>&#160; &#160; &#160; &#160;这些瞎猜只能暂时放着，等以后有机会再验证吧。。。。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[弹幕框架DanmakuFlameMaster简单分析]]></title>
      <url>http://windrunnerlihuan.com/2016/07/02/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160;随着B站逐渐崛起，其开源弹幕项目<a href="https://github.com/Bilibili/DanmakuFlameMaster" target="_blank" rel="external">DanmakuFlameMaster</a>应用场景也越来越多。我也是在一次偶然机会下发现了这个项目，被其惊艳的效果震撼。以前我就对弹幕技术很感兴趣，可能是因为B站动漫看多，几乎每一部番都是漫天的弹幕乱飞，如果哪部剧没有弹幕反而觉得不适应；久而久之就愈发倾向钻研其原理。<br>&#160; &#160; &#160; &#160;看到效果后，我猜想<strong>绘制原理</strong>应该是创建一个定时器作为全部弹幕的时间参考，然后每条弹幕出现的位置都以这个定时器去计算x、y值，然后定时任务定期postInvalidate，弹幕画布重新绘制onDraw；弹幕如此之多，应该有<strong>缓存机制</strong>，也许建立了一个弹幕池让出现过的弹幕缓存起来，新弹幕可以复用旧弹幕item。<br>&#160; &#160; &#160; &#160;先这么假设吧，然后验证我们的猜想，看看有哪些坑。<br><a id="more"></a></p>
<hr>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>&#160; &#160; &#160; &#160;首先是添加控件，项目里提供了三个控件：DanmakuSurfaceView、DanmakuTextureView和DanmakuView，使用其中三个任意一个都可以。我们选个DanmakuView方便分析。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span>	</span><br><span class="line">    </span><br><span class="line">	省略一些布局...</span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">master.flame.danmaku.ui.widget.DanmakuView</span></span><br><span class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/sv_danmaku"</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">    省略一些布局...  </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后是代码配置，先看一下初始化相关：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line">      findViews();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">省略一些代码...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// DanmakuView</span></span><br><span class="line">mDanmakuView = (IDanmakuView) findViewById(R.id.sv_danmaku);</span><br><span class="line">      <span class="comment">// 设置最大显示行数</span></span><br><span class="line">      HashMap&lt;Integer, Integer&gt; maxLinesPair = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">      maxLinesPair.put(BaseDanmaku.TYPE_SCROLL_RL, <span class="number">5</span>); <span class="comment">// 滚动弹幕最大显示5行</span></span><br><span class="line">      <span class="comment">// 设置是否禁止重叠</span></span><br><span class="line">      HashMap&lt;Integer, Boolean&gt; overlappingEnablePair = <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();</span><br><span class="line">      overlappingEnablePair.put(BaseDanmaku.TYPE_SCROLL_RL, <span class="keyword">true</span>);</span><br><span class="line">      overlappingEnablePair.put(BaseDanmaku.TYPE_FIX_TOP, <span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">//创建弹幕控件上下文，类似Context，里面可以进行一系列配置</span></span><br><span class="line">      mContext = DanmakuContext.create();</span><br><span class="line">mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, <span class="number">3</span>)<span class="comment">//设置描边样式</span></span><br><span class="line">.setDuplicateMergingEnabled(<span class="keyword">false</span>) <span class="comment">//设置不合并相同内容弹幕</span></span><br><span class="line">.setScrollSpeedFactor(<span class="number">1.2f</span>) <span class="comment">//设置弹幕滚动速度缩放比例，越大速度越慢</span></span><br><span class="line">.setScaleTextSize(<span class="number">1.2f</span>) <span class="comment">//设置字体缩放比例</span></span><br><span class="line">   .setCacheStuffer(<span class="keyword">new</span> SpannedCacheStuffer(), mCacheStufferAdapter) <span class="comment">// 图文混排使用SpannedCacheStuffer  </span></span><br><span class="line"><span class="comment">//.setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</span></span><br><span class="line">      .setMaximumLines(maxLinesPair) <span class="comment">//设置最大行数策略</span></span><br><span class="line">      .preventOverlapping(overlappingEnablePair); <span class="comment">//设置禁止重叠策略</span></span><br><span class="line">      	       </span><br><span class="line">省略一些代码...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuContext设置setCacheStuffer(CacheStuffer, Proxy)时，如果不设置此方法，则CacheStuffer默认为SimpleTextCacheStuffer，proxy默认为null；第一个参数，项目例子中提供了BackgroundCacheStuffer和SpannedCacheStuffer，其实也可以自己扩展，第二个参数例子中也写了一个mCacheStufferAdapter，同理也可以自己扩展。这个sample中注释也写得比较明确，我们往下分析原理时会解释。<br>&#160; &#160; &#160; &#160;然后设置数据源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">			<span class="comment">//替换为A站弹幕数据源，因为A站弹幕数据是json，B站是xml，为了方便分析因此替换为A站源</span></span><br><span class="line">            <span class="comment">//mParser = createParser(this.getResources().openRawResource(R.raw.comments));</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mParser = createParser(<span class="keyword">this</span>.getAssets().open(<span class="string">"comment.json"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BaseDanmakuParser <span class="title">createParser</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BaseDanmakuParser() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> Danmakus <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Danmakus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_BILI);</span></span><br><span class="line">        ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader.load(stream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalDataException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        BaseDanmakuParser parser = new BiliDanmukuParser();</span></span><br><span class="line">        BaseDanmakuParser parser = <span class="keyword">new</span> AcFunDanmakuParser();</span><br><span class="line">        IDataSource&lt;?&gt; dataSource = loader.getDataSource();</span><br><span class="line">        parser.load(dataSource);</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后启动弹幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置弹幕view相关回调</span></span><br><span class="line">mDanmakuView.setCallback(<span class="keyword">new</span> DrawHandler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTimer</span><span class="params">(DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawingFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">danmakuShown</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//Log.d("DFM", "danmakuShown(): text=" + danmaku.text);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"DFM"</span>, <span class="string">"MainActivity inline callback's method prepared"</span>);</span><br><span class="line">            mDanmakuView.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    mDanmakuView.prepare(mParser, mContext);</span><br><span class="line">    mDanmakuView.showFPS(<span class="keyword">true</span>);</span><br><span class="line">    mDanmakuView.enableDanmakuDrawingCache(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;基本使用在项目的例子中都写的很清楚，这些应该难度不大。接下来应该是分析流程了。</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160;DanmakuFlameMaster流程确实十分复杂，因为变量实在太多了，所以分析时推荐先整体看个大概，然后一步一步打断点确认细节。</p>
<h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><p>&#160; &#160; &#160; &#160;上面写基本使用法，第一步是初始配置，我们看看到底初始化了哪些参数。对比上面的调用顺序，首先进入DanmakuContext看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">//相关配置如下，主要初始化一下变量</span></span><br><span class="line">		mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, <span class="number">3</span>)<span class="comment">//设置描边样式</span></span><br><span class="line">		.setDuplicateMergingEnabled(<span class="keyword">false</span>) <span class="comment">//设置不合并相同内容弹幕</span></span><br><span class="line">		.setScrollSpeedFactor(<span class="number">1.2f</span>) <span class="comment">//设置弹幕滚动速度缩放比例，越大速度越慢</span></span><br><span class="line">		.setScaleTextSize(<span class="number">1.2f</span>) <span class="comment">//设置字体缩放比例</span></span><br><span class="line">	    .setCacheStuffer(<span class="keyword">new</span> SpannedCacheStuffer(), mCacheStufferAdapter) <span class="comment">// 图文混排使用SpannedCacheStuffer  </span></span><br><span class="line">		<span class="comment">//.setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</span></span><br><span class="line">        .setMaximumLines(maxLinesPair) <span class="comment">//设置最大行数策略</span></span><br><span class="line">        .preventOverlapping(overlappingEnablePair); <span class="comment">//设置禁止重叠策略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//DanmakuContext 类重要方法</span></span><br><span class="line">		<span class="comment">/*------------DanmakuContext STAET-----------*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbsDisplayer mDisplayer = <span class="keyword">new</span> AndroidDisplayer();<span class="comment">//创建DanmakuContext 对象时直接new了个mDisplayer 全局变量</span></span><br><span class="line">	 <span class="comment">/**</span><br><span class="line">     * 设置缓存绘制填充器，默认使用SimpleTextCacheStuffer只支持纯文字显示, 如果需要图文混排请设置SpannedCacheStuffer </span><br><span class="line">     * 如果需要定制其他样式请扩展SimpleTextCacheStuffer或者SpannedCacheStuffer</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DanmakuContext <span class="title">setCacheStuffer</span><span class="params">(BaseCacheStuffer cacheStuffer, BaseCacheStuffer.Proxy cacheStufferAdapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mCacheStuffer = cacheStuffer;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCacheStuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCacheStuffer.setProxy(cacheStufferAdapter);</span><br><span class="line">            mDisplayer.setCacheStuffer(<span class="keyword">this</span>.mCacheStuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*------------DanmakuContext END-----------*/</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;以上配置主要配置一些常规参数，记不住也没关系，我们可以打断点一一查看。</p>
<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><p>&#160; &#160; &#160; &#160;然后就是加载弹幕源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> BaseDanmakuParser <span class="title">createParser</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建A站弹幕加载器</span></span><br><span class="line">      ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//将数据流载入加载器里</span></span><br><span class="line">          loader.load(stream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalDataException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建弹幕解析器</span></span><br><span class="line">      BaseDanmakuParser parser = <span class="keyword">new</span> AcFunDanmakuParser();</span><br><span class="line">      <span class="comment">//取出数据源</span></span><br><span class="line">      IDataSource&lt;?&gt; dataSource = loader.getDataSource();</span><br><span class="line">      <span class="comment">//解析器放入数据源</span></span><br><span class="line">      parser.load(dataSource);</span><br><span class="line">      <span class="keyword">return</span> parser;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们一步一步来，先创建A站弹幕加载器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据不同标签创建不同加载器，可以根据不同业务自己扩展定制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoader <span class="title">create</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (TAG_BILI.equalsIgnoreCase(tag)) &#123;</span><br><span class="line">           <span class="keyword">return</span> BiliDanmakuLoader.instance();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(TAG_ACFUN.equalsIgnoreCase(tag))<span class="comment">//我们到了这里</span></span><br><span class="line">       	<span class="keyword">return</span> AcFunDanmakuLoader.instance();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入数据流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IllegalDataException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		dataSource = <span class="keyword">new</span> JSONSource(in);<span class="comment">//这里创建了一个JSONSource</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalDataException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSONSource构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JSONSource</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> JSONException</span>&#123;</span><br><span class="line">	init(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	mInput = in;</span><br><span class="line">	String json = IOUtils.getString(mInput);<span class="comment">//将流转成字符串</span></span><br><span class="line">	init(json);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String json)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!TextUtils.isEmpty(json))&#123;</span><br><span class="line">		mJSONArray = <span class="keyword">new</span> JSONArray(json);<span class="comment">//将json字符串保存到一个JSONArray全局变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出JSONSource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入数据流就是读取弹幕数据文件流，然后转成字符串，最后保存到一个JSONArray变量里存起来。<br>&#160; &#160; &#160; &#160;继续往下分析创建弹幕解析器、取出数据源、解析器放入数据源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AcFunDanmakuParser的load方法，将上一步得到的JSONSource放入到AcFunDanmakuParser中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseDanmakuParser <span class="title">load</span><span class="params">(IDataSource&lt;?&gt; source)</span> </span>&#123;</span><br><span class="line">      mDataSource = source;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里数据就载入到解析器里了，parser里有弹幕源数据了。</p>
<h2 id="启动弹幕"><a href="#启动弹幕" class="headerlink" title="启动弹幕"></a>启动弹幕</h2><p>&#160; &#160; &#160; &#160;启动弹幕重要的就是这一句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDanmakuView.prepare(mParser, mContext);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;此时mParser和mContext都已经初始化完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(BaseDanmakuParser parser, DanmakuContext config)</span> </span>&#123;</span><br><span class="line">     prepare();<span class="comment">///创建一个 DrawHandler</span></span><br><span class="line">     handler.setConfig(config);</span><br><span class="line">     handler.setParser(parser);</span><br><span class="line">     handler.setCallback(mCallback);</span><br><span class="line">     handler.prepare();<span class="comment">//然后调用DrawHandler的prepare方法</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//创建一个 DrawHandler</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (handler == <span class="keyword">null</span>)</span><br><span class="line">         handler = <span class="keyword">new</span> DrawHandler(getLooper(mDrawingThreadType), <span class="keyword">this</span>, mDanmakuVisible);<span class="comment">//mDanmakuVisible为true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;设置一些全局变量后，会调用DrawHandler的prepare方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendEmptyMessage(DrawHandler.PREPARE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> what = msg.what;</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> PREPARE:</span><br><span class="line">            mTimeBase = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (mParser == <span class="keyword">null</span> || !mDanmakuView.isViewReady()) &#123;<span class="comment">// false || false</span></span><br><span class="line">                sendEmptyMessageDelayed(PREPARE, <span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prepare(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//会继续调用prepare重载方法</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pausedPosition = <span class="number">0</span>;</span><br><span class="line">                        mReady = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mCallback.prepared();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> DanmakuTimer timer = <span class="keyword">new</span> DanmakuTimer();<span class="comment">//已经初始化timer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (drawTask == <span class="keyword">null</span>) &#123;<span class="comment">//会继续调用createDrawTask方法</span></span><br><span class="line">        drawTask = createDrawTask(mDanmakuView.isDanmakuDrawingCacheEnabled(), timer,</span><br><span class="line">                mDanmakuView.getContext(), mDanmakuView.getWidth(), mDanmakuView.getHeight(),</span><br><span class="line">                mDanmakuView.isHardwareAccelerated(), <span class="keyword">new</span> IDrawTask.TaskListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        initRenderingConfigs();</span><br><span class="line">                        runnable.run();</span><br><span class="line">                    &#125;</span><br><span class="line">		......</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续调用createDrawTask(true, timer, context, width, height, true, listener)方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> IDrawTask <span class="title">createDrawTask</span><span class="params">(<span class="keyword">boolean</span> useDrwaingCache, DanmakuTimer timer,</span><br><span class="line">                                 Context context,</span><br><span class="line">                                 <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span><br><span class="line">                                 <span class="keyword">boolean</span> isHardwareAccelerated,</span><br><span class="line">                                 IDrawTask.TaskListener taskListener)</span> </span>&#123;</span><br><span class="line">    mDisp = mContext.getDisplayer();<span class="comment">//AndroidDisplayer赋给它，顾名思义，Displayer就是显示器</span></span><br><span class="line">    mDisp.setSize(width, height);<span class="comment">//设置弹幕视图宽高</span></span><br><span class="line">    DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();</span><br><span class="line">    mDisp.setDensities(displayMetrics.density, displayMetrics.densityDpi,</span><br><span class="line">            displayMetrics.scaledDensity);<span class="comment">//设置密度先关</span></span><br><span class="line">    mDisp.resetSlopPixel(mContext.scaleTextSize);<span class="comment">//设置字体缩放比例，之前设过了1.2</span></span><br><span class="line">    mDisp.setHardwareAccelerated(isHardwareAccelerated);<span class="comment">//硬件加速，true</span></span><br><span class="line">    <span class="comment">//useDrwaingCache 为true</span></span><br><span class="line">    IDrawTask task = useDrwaingCache ?</span><br><span class="line">            <span class="keyword">new</span> CacheManagingDrawTask(timer, mContext, taskListener, <span class="number">1024</span> * <span class="number">1024</span> * AndroidUtils.getMemoryClass(context) / <span class="number">3</span>)</span><br><span class="line">            : <span class="keyword">new</span> DrawTask(timer, mContext, taskListener);</span><br><span class="line">    task.setParser(mParser);<span class="comment">//把存放数据源的mParser放入CacheManagingDrawTask中</span></span><br><span class="line">    task.prepare();<span class="comment">//这个才是重点，调用CacheManagingDrawTask的prepare方法</span></span><br><span class="line">    obtainMessage(NOTIFY_DISP_SIZE_CHANGED, <span class="keyword">false</span>).sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述过程最后一个调用了createDrawTask方法，这里先初始化了一下AndroidDisplayer配置，就把他当做显示器吧，我猜<code>ctiao</code>当初设计时也是这么比喻的吧。<br>&#160; &#160; &#160; &#160;设置好弹幕显示相关的参数，然后就是创建绘制任务IDrawTask 了。这里有两个选择，如果使用缓存就创建CacheManagingDrawTask，不使用就创建DrawTask。不过CacheManagingDrawTask比DrawTask复杂很多。</p>
<h3 id="CacheManagingDrawTask绘制任务"><a href="#CacheManagingDrawTask绘制任务" class="headerlink" title="CacheManagingDrawTask绘制任务"></a>CacheManagingDrawTask绘制任务</h3><p>&#160; &#160; &#160; &#160;我们的useDrwaingCache为true（<code>其实把它改为false也没关系，并且这样就用不上那些so库了</code>），则创建CacheManagingDrawTask绘制任务，然后调用prepare方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheManagingDrawTask</span><span class="params">(DanmakuTimer timer, DanmakuContext config, TaskListener taskListener, <span class="keyword">int</span> maxCacheSize)</span> </span>&#123;<span class="comment">//传入定时器timer，config，listener，还有三分一应用分配内存大小的maxCacheSize</span></span><br><span class="line">      <span class="keyword">super</span>(timer, config, taskListener);<span class="comment">//会调用父类DrawTask的构造方法</span></span><br><span class="line">      NativeBitmapFactory.loadLibs();<span class="comment">//加载so库，用于创建bitmap，同时测试时候加载成功</span></span><br><span class="line">      mMaxCacheSize = maxCacheSize;</span><br><span class="line">      <span class="keyword">if</span> (NativeBitmapFactory.isInNativeAlloc()) &#123;<span class="comment">//true,将最大内存扩大到2倍</span></span><br><span class="line">          mMaxCacheSize = maxCacheSize * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mCacheManager = <span class="keyword">new</span> CacheManager(maxCacheSize, MAX_CACHE_SCREEN_SIZE);</span><br><span class="line">      mRenderer.setCacheManager(mCacheManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//看看父类的构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawTask</span><span class="params">(DanmakuTimer timer, DanmakuContext context,</span><br><span class="line">          TaskListener taskListener)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mContext = context;</span><br><span class="line">      mDisp = context.getDisplayer();</span><br><span class="line">      mTaskListener = taskListener;</span><br><span class="line">      mRenderer = <span class="keyword">new</span> DanmakuRenderer(context);</span><br><span class="line">......</span><br><span class="line">      initTimer(timer);<span class="comment">//初始化相关定时器</span></span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">(DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">      mTimer = timer;</span><br><span class="line">      mCacheTimer = <span class="keyword">new</span> DanmakuTimer();</span><br><span class="line">      mCacheTimer.update(timer.currMillisecond);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;CacheManagingDrawTask的构造方法设置了一些变量。其中NativeBitmapFactory.loadLibs()加载了用于创建bitmap的so文件，就是用skia图形处理库直接创建bitmap，Android对2D图形处理采用的就是skia，3D图形处理用的是OpenGL ES。这样通过native层创建bitmap直接跳过Dalvik，毕竟java层内存用多了很容易oom。因为以前我就对native层比较感兴趣，所以我要任性的跟一遍源码 ^O.O^。为了怕跟完后自己晕了，找不到现在分析的地方了，所以在这里打个标签，mark一下。如不感兴趣，可以跳过= 。=<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg" alt="标签"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NativeBitmapFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        System.loadLibrary(<span class="string">"ndkbitmap"</span>);<span class="comment">//载入so</span></span><br><span class="line">		......</span><br><span class="line">        <span class="comment">//测试功能</span></span><br><span class="line">        <span class="keyword">if</span> (nativeLibLoaded) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> libInit = init();<span class="comment">//这是一个native方法</span></span><br><span class="line">            <span class="keyword">if</span> (!libInit) &#123;</span><br><span class="line">                release();</span><br><span class="line">                notLoadAgain = <span class="keyword">true</span>;</span><br><span class="line">                nativeLibLoaded = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始化成功后</span></span><br><span class="line">                initField();<span class="comment">//反射Bitmap.Config的nativeInt字段</span></span><br><span class="line">                <span class="keyword">boolean</span> confirm = testLib();<span class="comment">//测试例子</span></span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(<span class="string">"NativeBitmapFactory"</span>, <span class="string">"loaded"</span> + nativeLibLoaded);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射Bitmap.Config的nativeInt字段</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nativeIntField = Bitmap.Config.class.getDeclaredField(<span class="string">"nativeInt"</span>);</span><br><span class="line">            nativeIntField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            nativeIntField = <span class="keyword">null</span>;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里会调用测试方法testLib：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">testLib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nativeIntField == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">     Canvas canvas = <span class="keyword">null</span>;</span><br><span class="line">     ......</span><br><span class="line">      <span class="comment">//用native方法创建一个bitmap</span></span><br><span class="line">         bitmap = createNativeBitmap(<span class="number">2</span>, <span class="number">2</span>, Bitmap.Config.ARGB_8888, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">boolean</span> result = (bitmap != <span class="keyword">null</span> &amp;&amp; bitmap.getWidth() == <span class="number">2</span> &amp;&amp; bitmap.getHeight() == <span class="number">2</span>);</span><br><span class="line">......</span><br><span class="line">             canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">             Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">             paint.setColor(Color.RED);</span><br><span class="line">             paint.setTextSize(<span class="number">20f</span>);</span><br><span class="line">             canvas.drawRect(<span class="number">0f</span>, <span class="number">0f</span>, (<span class="keyword">float</span>) bitmap.getWidth(), (<span class="keyword">float</span>) bitmap.getHeight(),</span><br><span class="line">                     paint);</span><br><span class="line">             canvas.drawText(<span class="string">"TestLib"</span>, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">createNativeBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Config config, <span class="keyword">boolean</span> hasAlpha)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> nativeConfig = getNativeConfig(config);<span class="comment">//反射设置Bitmap.Config.ARGB_8888</span></span><br><span class="line">     <span class="keyword">return</span> android.os.Build.VERSION.SDK_INT == <span class="number">19</span> ? createBitmap19(width, height,</span><br><span class="line">             nativeConfig, hasAlpha) : createBitmap(width, height, nativeConfig, hasAlpha);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNativeConfig</span><span class="params">(Bitmap.Config config)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (nativeIntField == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nativeIntField.getInt(config);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">createBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> nativeConfig,</span><br><span class="line">         <span class="keyword">boolean</span> hasAlpha)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">createBitmap19</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> nativeConfig,</span><br><span class="line">         <span class="keyword">boolean</span> hasAlpha)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述最终用native方法创建bitmap，C++文件地址为 <a href="https://github.com/Bilibili/NativeBitmapFactory" target="_blank" rel="external">https://github.com/Bilibili/NativeBitmapFactory</a> ，接着继续查看native方法具体实现NativeBitmapFactory.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看java层init方法对应的本地方法</span></span><br><span class="line"><span class="function">jboolean <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_init</span><span class="params">(JNIEnv *env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//继续看Start方法</span></span><br><span class="line">    <span class="keyword">int</span> r = Start();</span><br><span class="line">    <span class="keyword">return</span> r == SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Start</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类型为ndkbitmap_obj 的结构体指针</span></span><br><span class="line">    ndkbitmap_obj = (<span class="keyword">ndkbitmap_object_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*ndkbitmap_obj));</span><br><span class="line">    <span class="keyword">int</span> r = Open(ndkbitmap_obj);</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Open</span><span class="params">(<span class="keyword">ndkbitmap_object_t</span> *obj)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类型为skbitmap_sys_t 的结构体指针</span></span><br><span class="line">    <span class="keyword">skbitmap_sys_t</span> *sys = (<span class="keyword">skbitmap_sys_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (*sys));</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//打开libskia.so动态链接库，初始化一些参数并返回动态链接库的句柄</span></span><br><span class="line">    sys-&gt;libskia = InitLibrary(sys);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//打开libandroid_runtime.so动态链接库，初始化一些参数并返回动态链接库的句柄</span></span><br><span class="line">    sys-&gt;libjnigraphics = InitLibrary2(sys);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//将初始化过后的结构指针sys赋给结构体obj的sys成员</span></span><br><span class="line">    obj-&gt;sys = sys;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;init方法主要是打开和skia相关的动态链接库，并初始化一些配置。(InitLibrary和InitLibrary2方法的细节我没有贴，里面实现需要一些专业知识，有兴趣的可以找资料钻研)然后就是createBitmap：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_createBitmap</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, obj, w, h, config, hasAlpha, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_createBitmap19</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, obj, w, h, config, hasAlpha, <span class="number">0x3</span>, <span class="number">19</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">createBitmap</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha, <span class="keyword">int</span> isMuttable, <span class="keyword">int</span> api)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bm = createSkBitmap(ndkbitmap_obj, config, w, h);<span class="comment">//调用重载方法创建bitmap指针</span></span><br><span class="line">    <span class="keyword">if</span> (bm == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    jobject result = NULL;</span><br><span class="line">    skbitmap_sys_t *p_sys = ndkbitmap_obj-&gt;sys;</span><br><span class="line">    <span class="keyword">if</span>(p_sys-&gt;libjnigraphics) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p_sys-&gt;gjni_createBitmap) </span><br><span class="line">        &#123;<span class="comment">//SDK版本小于19</span></span><br><span class="line">	        <span class="comment">//通过这个函数指针把JNI层bitmap的转换对象return给java层</span></span><br><span class="line">            result = p_sys-&gt;gjni_createBitmap(env, bm, isMuttable, NULL, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p_sys-&gt;gjni_createBitmap_19later) &#123;<span class="comment">//SDK版本19以后返回值</span></span><br><span class="line">            result = p_sys-&gt;gjni_createBitmap_19later(env, bm, NULL, isMuttable, NULL, NULL, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建bitmap指针，并通过相关指针函数设置bitmap参数</span></span><br><span class="line">inline <span class="keyword">void</span> *createSkBitmap(ndkbitmap_object_t *obj, <span class="keyword">int</span> config, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span><br><span class="line">&#123;</span><br><span class="line">    skbitmap_sys_t *p_sys = obj-&gt;sys;</span><br><span class="line">    <span class="keyword">if</span> (p_sys == NULL || p_sys-&gt;libskia == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请内存，创建skBitmap 指针</span></span><br><span class="line">    <span class="keyword">void</span> *skBitmap = malloc(SIZE_OF_SKBITMAP);</span><br><span class="line">    <span class="keyword">if</span> (!skBitmap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    *((uint32_t *) ((uint32_t)skBitmap + SIZE_OF_SKBITMAP - <span class="number">4</span>)) = <span class="number">0xbaadbaad</span>;</span><br><span class="line">    <span class="comment">//ctor   </span></span><br><span class="line">    p_sys-&gt;sk_ctor(skBitmap);</span><br><span class="line">    <span class="keyword">if</span> (p_sys-&gt;sk_setConfig)</span><br><span class="line">    &#123;</span><br><span class="line">        p_sys-&gt;sk_setConfig(skBitmap, config, w, h, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p_sys-&gt;sk_setConfig_19later)</span><br><span class="line">    &#123;</span><br><span class="line">        p_sys-&gt;sk_setConfig_19later(skBitmap, config, w, h, <span class="number">0</span>, (uint8_t)kPremul_SkAlphaType);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p_sys-&gt;sk_setInfo) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> imageInfo[<span class="number">4</span>] = &#123;w, h, SkBitmapConfigToColorType(config), kPremul_SkAlphaType&#125;;</span><br><span class="line">        p_sys-&gt;sk_setInfo(skBitmap, imageInfo, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p_sys-&gt;sk_allocPixels(skBitmap, NULL, NULL);</span><br><span class="line">    p_sys-&gt;sk_eraseARGB(skBitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(*((uint32_t *) ((uint32_t)skBitmap + SIZE_OF_SKBITMAP - <span class="number">4</span>)) == <span class="number">0xbaadbaad</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        free(skBitmap);</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;通过skia图形库创建bitmap流程大概就是这些，其实skia的东西也是巨多无比，如果是从事这一方面工作应该都轻车熟路，我是完全的小白，能力有限，只能先到这儿。</p>
<p>&#160; &#160; &#160; &#160;好了，继续回到上次打标签的地方。接着该调用CacheManagingDrawTask的prepare方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (mParser != <span class="keyword">null</span>);</span><br><span class="line">    loadDanmakus(mParser);</span><br><span class="line">    mCacheManager.begin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先调用loadDanmakus方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> IDanmakus danmakuList;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadDanmakus</span><span class="params">(BaseDanmakuParser parser)</span> </span>&#123;</span><br><span class="line">        danmakuList = parser.setConfig(mContext)</span><br><span class="line">                            .setDisplayer(mDisp)</span><br><span class="line">                            .setTimer(mTimer)</span><br><span class="line">                            .getDanmakus();<span class="comment">//从parser中取出弹幕数据,做出相关处理</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(danmakuList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLastDanmaku = danmakuList.last();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;parser设置完DanmakuContext，AndroidDisplayer，DanmakuTimer之后，再调用getDanmakus取出弹幕信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IDanmakus <span class="title">getDanmakus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDanmakus != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> mDanmakus;</span><br><span class="line">    mContext.mDanmakuFactory.resetDurationsData();<span class="comment">//重庆内置一些变量为null</span></span><br><span class="line">    mDanmakus = parse();<span class="comment">//解析弹幕</span></span><br><span class="line">    releaseDataSource();<span class="comment">//关闭JSONSource</span></span><br><span class="line">    mContext.mDanmakuFactory.updateMaxDanmakuDuration();<span class="comment">//修正弹幕最大时长</span></span><br><span class="line">    <span class="keyword">return</span> mDanmakus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;进入AcFunDanmakuParser的parse方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Danmakus <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDataSource != <span class="keyword">null</span> &amp;&amp; mDataSource <span class="keyword">instanceof</span> JSONSource) &#123;</span><br><span class="line">            JSONSource jsonSource = (JSONSource) mDataSource;</span><br><span class="line">            <span class="keyword">return</span> doParse(jsonSource.data());<span class="comment">//go on</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Danmakus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Danmakus <span class="title">doParse</span><span class="params">(JSONArray danmakuListData)</span> </span>&#123;</span><br><span class="line">        Danmakus danmakus = <span class="keyword">new</span> Danmakus();</span><br><span class="line">        <span class="keyword">if</span> (danmakuListData == <span class="keyword">null</span> || danmakuListData.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> danmakus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; danmakuListData.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JSONObject danmakuArray = danmakuListData.getJSONObject(i);</span><br><span class="line">                <span class="keyword">if</span> (danmakuArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    danmakus = _parse(danmakuArray, danmakus);<span class="comment">//解析每一条弹幕</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> danmakus;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * &#123;"c":"19.408,16777215,1,25,178252,1376325904","m":"金刚如来！"&#125;</span><br><span class="line">     // 0:时间(弹幕出现时间)</span><br><span class="line">     // 1:颜色</span><br><span class="line">     // 2:类型(1从右往左滚动弹幕|6从右至左滚动弹幕|5顶端固定弹幕|4底端固定弹幕|7高级弹幕|8脚本弹幕)</span><br><span class="line">     // 3:字号</span><br><span class="line">     // 4:用户id ?</span><br><span class="line">     // 5:时间戳 ?</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Danmakus <span class="title">_parse</span><span class="params">(JSONObject jsonObject, Danmakus danmakus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (danmakus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            danmakus = <span class="keyword">new</span> Danmakus();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jsonObject == <span class="keyword">null</span> || jsonObject.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> danmakus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonObject.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JSONObject obj = jsonObject;</span><br><span class="line">                String c = obj.getString(<span class="string">"c"</span>);<span class="comment">//弹幕配置信息</span></span><br><span class="line">                String[] values = c.split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">if</span> (values.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> type = Integer.parseInt(values[<span class="number">2</span>]); <span class="comment">// 弹幕类型</span></span><br><span class="line">                    <span class="keyword">if</span> (type == <span class="number">7</span>)</span><br><span class="line">                        <span class="comment">// FIXME : hard code</span></span><br><span class="line">                        <span class="comment">// TODO : parse advance danmaku json</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">long</span> time = (<span class="keyword">long</span>) (Float.parseFloat(values[<span class="number">0</span>]) * <span class="number">1000</span>); <span class="comment">// 出现时间</span></span><br><span class="line">                    <span class="keyword">int</span> color = Integer.parseInt(values[<span class="number">1</span>]) | <span class="number">0xFF000000</span>; <span class="comment">// 颜色</span></span><br><span class="line">                    <span class="keyword">float</span> textSize = Float.parseFloat(values[<span class="number">3</span>]); <span class="comment">// 字体大小</span></span><br><span class="line">                    <span class="comment">//使用弹幕工厂创建一条弹幕</span></span><br><span class="line">                    BaseDanmaku item = mContext.mDanmakuFactory.createDanmaku(type, mContext);</span><br><span class="line">                    <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        item.time = time;</span><br><span class="line">                        item.textSize = textSize * (mDispDensity - <span class="number">0.6f</span>);</span><br><span class="line">                        item.textColor = color;</span><br><span class="line">                        item.textShadowColor = color &lt;= Color.BLACK ? Color.WHITE : Color.BLACK;</span><br><span class="line">                        <span class="comment">//弹幕文字内容，如果多行文本会拆分内容</span></span><br><span class="line">                        DanmakuUtils.fillText(item, obj.optString(<span class="string">"m"</span>, <span class="string">"...."</span>));</span><br><span class="line">                        item.index = i;</span><br><span class="line">                        item.setTimer(mTimer);<span class="comment">//将定时器设置给每一条弹幕</span></span><br><span class="line">                        danmakus.addItem(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> danmakus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DanmakuUtilsdefillText方法，多行文本会拆分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillText</span><span class="params">(BaseDanmaku danmaku, CharSequence text)</span> </span>&#123;</span><br><span class="line">        danmaku.text = text;</span><br><span class="line">        <span class="comment">//如果文本没有换行符则不用拆分</span></span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(text) || !text.toString().contains(BaseDanmaku.DANMAKU_BR_CHAR)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果有换行符则拆分，然后将拆分的数组付给lines 属性</span></span><br><span class="line">        String[] lines = String.valueOf(danmaku.text).split(BaseDanmaku.DANMAKU_BR_CHAR, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lines.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            danmaku.lines = lines;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从JSONSource里解析每一条弹幕，接着我们看看弹幕工厂DanmakuFactory创建弹幕的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, DanmakuContext context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      sLastConfig = context;</span><br><span class="line">      sLastDisp = context.getDisplayer();</span><br><span class="line">      <span class="keyword">return</span> createDanmaku(type, sLastDisp.getWidth(), sLastDisp.getHeight(), CURRENT_DISP_SIZE_FACTOR, context.scrollSpeedFactor);<span class="comment">// go on overload method</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> viewportWidth, <span class="keyword">int</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportScale, <span class="keyword">float</span> scrollSpeedFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createDanmaku(type, (<span class="keyword">float</span>) viewportWidth, (<span class="keyword">float</span>) viewportHeight, viewportScale, scrollSpeedFactor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> viewportWidth, <span class="keyword">float</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportSizeFactor, <span class="keyword">float</span> scrollSpeedFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> oldDispWidth = CURRENT_DISP_WIDTH; <span class="comment">// 默认是0</span></span><br><span class="line">      <span class="keyword">int</span> oldDispHeight = CURRENT_DISP_HEIGHT; <span class="comment">// 默认是0</span></span><br><span class="line">      <span class="comment">//修正试图宽高，缩放比，弹幕时长</span></span><br><span class="line">      <span class="keyword">boolean</span> sizeChanged = updateViewportState(viewportWidth, viewportHeight, viewportSizeFactor);</span><br><span class="line">      <span class="comment">//滚动弹幕的Duration赋值</span></span><br><span class="line">      <span class="keyword">if</span> (MAX_Duration_Scroll_Danmaku == <span class="keyword">null</span>) &#123;</span><br><span class="line">          MAX_Duration_Scroll_Danmaku = <span class="keyword">new</span> Duration(REAL_DANMAKU_DURATION);</span><br><span class="line">          MAX_Duration_Scroll_Danmaku.setFactor(scrollSpeedFactor);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">          MAX_Duration_Scroll_Danmaku.setValue(REAL_DANMAKU_DURATION);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//固定位置弹幕的Duration赋值</span></span><br><span class="line">      <span class="keyword">if</span> (MAX_Duration_Fix_Danmaku == <span class="keyword">null</span>) &#123;</span><br><span class="line">          MAX_Duration_Fix_Danmaku = <span class="keyword">new</span> Duration(COMMON_DANMAKU_DURATION);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sizeChanged &amp;&amp; viewportWidth &gt; <span class="number">0</span>) &#123;<span class="comment">// true &amp;&amp; true</span></span><br><span class="line">          updateMaxDanmakuDuration();<span class="comment">// 修正弹幕最长时长</span></span><br><span class="line">	......</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BaseDanmaku instance = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 从右往左滚动</span></span><br><span class="line">              instance = <span class="keyword">new</span> R2LDanmaku(MAX_Duration_Scroll_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 底端固定</span></span><br><span class="line">              instance = <span class="keyword">new</span> FBDanmaku(MAX_Duration_Fix_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 顶端固定</span></span><br><span class="line">              instance = <span class="keyword">new</span> FTDanmaku(MAX_Duration_Fix_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// 从左往右滚动</span></span><br><span class="line">              instance = <span class="keyword">new</span> L2RDanmaku(MAX_Duration_Scroll_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// 特殊弹幕</span></span><br><span class="line">              instance = <span class="keyword">new</span> SpecialDanmaku();</span><br><span class="line">              sSpecialDanmakus.addItem(instance);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修正试图宽高，缩放比，弹幕时长</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateViewportState</span><span class="params">(<span class="keyword">float</span> viewportWidth, <span class="keyword">float</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportSizeFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> sizeChanged = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (CURRENT_DISP_WIDTH != (<span class="keyword">int</span>) viewportWidth</span><br><span class="line">              || CURRENT_DISP_HEIGHT != (<span class="keyword">int</span>) viewportHeight</span><br><span class="line">              || CURRENT_DISP_SIZE_FACTOR != viewportSizeFactor) &#123;</span><br><span class="line">          sizeChanged = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//弹幕时长 t = 3800 * (1.2 * 视图宽 / 682)</span></span><br><span class="line">          REAL_DANMAKU_DURATION = (<span class="keyword">long</span>) (COMMON_DANMAKU_DURATION * (viewportSizeFactor</span><br><span class="line">                  * viewportWidth / BILI_PLAYER_WIDTH));</span><br><span class="line">          <span class="comment">// t = min(t, 9000)</span></span><br><span class="line">          REAL_DANMAKU_DURATION = Math.min(MAX_DANMAKU_DURATION_HIGH_DENSITY,</span><br><span class="line">                  REAL_DANMAKU_DURATION);</span><br><span class="line">          <span class="comment">// t = max(t, 4000)        </span></span><br><span class="line">          REAL_DANMAKU_DURATION = Math.max(MIN_DANMAKU_DURATION, REAL_DANMAKU_DURATION);</span><br><span class="line">          </span><br><span class="line">          CURRENT_DISP_WIDTH = (<span class="keyword">int</span>) viewportWidth;</span><br><span class="line">          CURRENT_DISP_HEIGHT = (<span class="keyword">int</span>) viewportHeight;</span><br><span class="line">          CURRENT_DISP_SIZE_FACTOR = viewportSizeFactor;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sizeChanged;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修正弹幕最长时长</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMaxDanmakuDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> maxScrollDuration = (MAX_Duration_Scroll_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span>: MAX_Duration_Scroll_Danmaku.value), </span><br><span class="line">            maxFixDuration = (MAX_Duration_Fix_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span> : MAX_Duration_Fix_Danmaku.value), </span><br><span class="line">            maxSpecialDuration = (MAX_Duration_Special_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span>: MAX_Duration_Special_Danmaku.value);</span><br><span class="line"></span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(maxScrollDuration, maxFixDuration);</span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(MAX_DANMAKU_DURATION, maxSpecialDuration);</span><br><span class="line"></span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(COMMON_DANMAKU_DURATION, MAX_DANMAKU_DURATION);</span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(REAL_DANMAKU_DURATION, MAX_DANMAKU_DURATION);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuFactory创建弹幕主要是计算了弹幕时长，然后根据不同类型创建不同的弹幕。</p>
<p>&#160; &#160; &#160; &#160;到此CacheManagingDrawTask的loadDanmakus方法走完了。loadDanmakus方法主要从 mParser里的JSONSource解析弹幕数据源，根据不同类型的type用DanmakuFactory创建不同的Danmaku，分别计算Duration，最后存放到一个Danmakus对象里。</p>
<p>&#160; &#160; &#160; &#160; 继续回到刚才的prepare方法，往下继续执行:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> (mParser != <span class="keyword">null</span>);</span><br><span class="line">     loadDanmakus(mParser);<span class="comment">//走完了</span></span><br><span class="line">     mCacheManager.begin();<span class="comment">//走这个</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//CacheManager的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         mEndFlag = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//创建一个HandlerThread用于在工作线程处理事务</span></span><br><span class="line">         <span class="keyword">if</span> (mThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">             mThread = <span class="keyword">new</span> HandlerThread(<span class="string">"DFM Cache-Building Thread"</span>);</span><br><span class="line">             mThread.start();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//创建一个Handler和HandlerThread搭配用</span></span><br><span class="line">         <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>)</span><br><span class="line">             mHandler = <span class="keyword">new</span> CacheHandler(mThread.getLooper());</span><br><span class="line">         mHandler.begin();<span class="comment">// 走到这里</span></span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//HandlerThread的begin方法 </span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             sendEmptyMessage(PREPARE);</span><br><span class="line">	......</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到创建了一个HandlerThread，然后创建了一个CacheHandler，所以CacheHandler发送消息后，处理消息内容都是在子线程。<br>&#160; &#160; &#160; &#160;然后发送了PREPARE消息，然后就是回调handleMessage方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">     DrawingCachePoolManager mCachePoolManager = <span class="keyword">new</span> DrawingCachePoolManager();</span><br><span class="line">     <span class="comment">//创建一个缓存个数上限为800的FinitePool池</span></span><br><span class="line">        Pool&lt;DrawingCache&gt; mCachePool = Pools.finitePool(mCachePoolManager, <span class="number">800</span>);</span><br><span class="line">        <span class="comment">//Pools的finitePool方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Poolable&lt;T&gt;&gt; <span class="function">Pool&lt;T&gt; <span class="title">finitePool</span><span class="params">(PoolableManager&lt;T&gt; manager, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinitePool&lt;T&gt;(manager, limit);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> what = msg.what;</span><br><span class="line">               <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">                   <span class="keyword">case</span> PREPARE:</span><br><span class="line">                       evictAllNotInScreen();<span class="comment">//清除所有不在屏幕内的缓存，此时还没有缓存</span></span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;<span class="comment">//在池里放300个预留缓存，以链式存储方式存放</span></span><br><span class="line">                           mCachePool.release(<span class="keyword">new</span> DrawingCache());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//FinitePool的release方法：回收缓存对象，并且用头插法，以链式存储（类似链表）	</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!element.isPooled()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mInfinite || mPoolCount &lt; mLimit) &#123;</span><br><span class="line">               mPoolCount++;</span><br><span class="line">               element.setNextPoolable(mRoot);</span><br><span class="line">               element.setPooled(<span class="keyword">true</span>);</span><br><span class="line">               mRoot = element;</span><br><span class="line">           &#125;</span><br><span class="line">           mManager.onReleased(element);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.print(<span class="string">"[FinitePool] Element is already in pool: "</span> + element);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;处理完PREPARE消息后，会继续进入DISPATCH_ACTIONS逻辑处理中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	......</span><br><span class="line">          <span class="keyword">case</span> DISPATCH_ACTIONS:</span><br><span class="line">              <span class="keyword">long</span> delayed = dispatchAction();<span class="comment">//走到这里</span></span><br><span class="line">              <span class="keyword">if</span> (delayed &lt;= <span class="number">0</span>) &#123;<span class="comment">// true</span></span><br><span class="line">               <span class="comment">//会没隔半条弹幕时间发送一次DISPATCH_ACTIONS消息</span></span><br><span class="line">                  delayed = mContext.mDanmakuFactory.MAX_DANMAKU_DURATION / <span class="number">2</span>;</span><br><span class="line">              &#125;</span><br><span class="line">           sendEmptyMessageDelayed(DISPATCH_ACTIONS, delayed);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          ......</span><br><span class="line">    <span class="comment">/*----------dispatchAction方法START----------*/</span>        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">dispatchAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">...省略一些第一次不会执行的逻辑...</span><br><span class="line">            </span><br><span class="line">            removeMessages(BUILD_CACHES);</span><br><span class="line">            sendEmptyMessage(BUILD_CACHES);<span class="comment">//发送BUILD_CACHES消息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*----------dispatchAction方法END----------*/</span></span><br><span class="line">          ......</span><br><span class="line">                <span class="keyword">case</span> BUILD_CACHES:</span><br><span class="line">                    removeMessages(BUILD_CACHES);</span><br><span class="line">                    <span class="keyword">boolean</span> repositioned = ((mTaskListener != <span class="keyword">null</span> </span><br><span class="line">                    &amp;&amp; mReadyState == <span class="keyword">false</span>) || mSeekedFlag);<span class="comment">// 为true</span></span><br><span class="line">                    prepareCaches(repositioned);<span class="comment">//调用prepareCaches方法</span></span><br><span class="line">                    <span class="keyword">if</span> (repositioned)</span><br><span class="line">                        mSeekedFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mTaskListener != <span class="keyword">null</span> &amp;&amp; mReadyState == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        mTaskListener.ready();<span class="comment">//然后回到mTaskListener监听ready方法</span></span><br><span class="line">                        mReadyState = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们发现，处理接着处理DISPATCH_ACTIONS消息时，会每隔半条弹幕时间发送一次DISPATCH_ACTIONS消息。<br>&#160; &#160; &#160; &#160;处理DISPATCH_ACTIONS消息内会执行dispatchAction方法，这个方法内逻辑情况比较多，我们先挖个坑，先把刚开始时会走的逻辑执行了，其他逻辑以后用时会填上。（挖坑 ^O_O^）<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/wakeng.jpg" alt="挖坑"><br>&#160; &#160; &#160; &#160;首次调用dispatchAction方法内发送了BUILD_CACHES消息消息，会先调用prepareCaches(true)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">prepareCaches</span><span class="params">(<span class="keyword">boolean</span> repositioned)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> curr = mCacheTimer.currMillisecond;<span class="comment">// 0</span></span><br><span class="line">                <span class="comment">//3条弹幕时间</span></span><br><span class="line">                <span class="keyword">long</span> end = curr + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION * mScreenSize;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; mTimer.currMillisecond) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">                IDanmakus danmakus = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> tryCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                do &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">	                    <span class="comment">//截取三条弹幕时间中所有的弹幕</span></span><br><span class="line">                        danmakus = danmakuList.subnew(curr, end);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        hasException = <span class="keyword">true</span>;</span><br><span class="line">                        SystemClock.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (++tryCount &lt; <span class="number">3</span> &amp;&amp; danmakus == <span class="keyword">null</span> &amp;&amp; hasException);<span class="comment">//截取成功后跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (danmakus == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCacheTimer.update(end);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				......</span><br><span class="line">                IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">                BaseDanmaku item = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> sizeInScreen = danmakus.size();</span><br><span class="line">                <span class="keyword">while</span> (!mPause &amp;&amp; !mCancelFlag) &#123;<span class="comment">//</span></span><br><span class="line">                    <span class="keyword">boolean</span> hasNext = itr.hasNext();</span><br><span class="line">                    <span class="keyword">if</span> (!hasNext) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    item = itr.next();</span><br><span class="line"></span><br><span class="line">					 ......</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// build cache ，省略了一些障眼法,这才是重点，建立缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (buildCache(item, <span class="keyword">false</span>) == RESULT_FAILED) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					......</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;<span class="comment">//截取的最后一条弹幕,更新缓存定时器时间</span></span><br><span class="line">                    mCacheTimer.update(item.time);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCacheTimer.update(end);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> consumingTime;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;为截取的每一条弹幕建立缓存会调用buildCache(item, false)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// measure ,先测量每一条弹幕的宽高</span></span><br><span class="line">           <span class="keyword">if</span> (!item.isMeasured()) &#123;</span><br><span class="line">               item.measure(mDisp, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           DrawingCache cache = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// try to find reuseable cache, 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</span></span><br><span class="line">               BaseDanmaku danmaku = findReuseableCache(item, <span class="keyword">true</span>, <span class="number">20</span>);</span><br><span class="line">               <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">//如果查找出了这样的弹幕</span></span><br><span class="line">                   cache = (DrawingCache) danmaku.cache;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                   cache.increaseReference();<span class="comment">//则将引用计数 +1</span></span><br><span class="line">                   item.cache = cache;<span class="comment">//将目标弹幕缓存的引用指向查找出来的弹幕缓存，即多个引用指向同一个对象</span></span><br><span class="line">                   <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                   mCacheManager.push(item, <span class="number">0</span>, forceInsert);</span><br><span class="line">                   <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// try to find reuseable cache from timeout || no-refrerence caches</span></span><br><span class="line">               <span class="comment">//如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的</span></span><br><span class="line">               <span class="comment">//，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)</span></span><br><span class="line">               <span class="comment">//，而且宽高和目标弹幕差值在规定范围内的弹幕</span></span><br><span class="line">               danmaku = findReuseableCache(item, <span class="keyword">false</span>, <span class="number">50</span>);</span><br><span class="line">               <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到了这样的弹幕</span></span><br><span class="line">                   cache = (DrawingCache) danmaku.cache;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                   danmaku.cache = <span class="keyword">null</span>;<span class="comment">//先清除过时弹幕的缓存</span></span><br><span class="line">                   <span class="comment">//再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</span></span><br><span class="line">                   cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);  <span class="comment">//redraw</span></span><br><span class="line">                   item.cache = cache;<span class="comment">//将缓存应用赋给目标弹幕</span></span><br><span class="line">                   mCacheManager.push(item, <span class="number">0</span>, forceInsert);<span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                   <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上述两次查找缓存都没找到，则进入下面逻辑</span></span><br><span class="line">               <span class="comment">// guess cache size</span></span><br><span class="line">               <span class="keyword">if</span> (!forceInsert) &#123;<span class="comment">//如果forceInsert为false，则表示不检测内存超出</span></span><br><span class="line">                <span class="comment">//计算此弹幕bitmap的大小，width * height * 4</span></span><br><span class="line">                <span class="comment">//(因为用native创建的Bitmap的Config为ARGB_8888，所以一个像素占4个字节)</span></span><br><span class="line">                   <span class="keyword">int</span> cacheSize = DanmakuUtils.getCacheSize((<span class="keyword">int</span>) item.paintWidth,</span><br><span class="line">                           (<span class="keyword">int</span>) item.paintHeight);</span><br><span class="line">                   <span class="comment">//如果当前已经使用大小 + 此弹幕缓存大小 &gt; 设置的最大内存（2/3 应用内存）        </span></span><br><span class="line">                   <span class="keyword">if</span> (mRealSize + cacheSize &gt; mMaxSize) &#123;<span class="comment">//没有超</span></span><br><span class="line">                       <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">//从FinitePool中的300个DrawingCache对象中取出来一个</span></span><br><span class="line">               cache = mCachePool.acquire();</span><br><span class="line">               <span class="comment">//如果从上面的FinitePool取完了，则会直接new一个DrawingCache，配置DrawingCache</span></span><br><span class="line">               cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);</span><br><span class="line">               item.cache = cache;</span><br><span class="line">               <span class="comment">//将item存入mCaches缓存，同时更新已使用大小mRealSize</span></span><br><span class="line">               <span class="keyword">boolean</span> pushed = mCacheManager.push(item, sizeOf(item), forceInsert);</span><br><span class="line">               <span class="keyword">if</span> (!pushed) &#123;<span class="comment">//如果item存放失败(使用内存超出规定大小)</span></span><br><span class="line">                   releaseDanmakuCache(item, cache);<span class="comment">//释放DrawingCache</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> pushed ? RESULT_SUCCESS : RESULT_FAILED;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">               releaseDanmakuCache(item, cache);</span><br><span class="line">               <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               releaseDanmakuCache(item, cache);</span><br><span class="line">               <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;buildCache(item, false)为每一条弹幕建立缓存，其中有几处：</p>
<ul>
<li>先测量弹幕的宽高</li>
<li>在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</li>
<li>如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的 ，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)，而且宽高和目标弹幕差值在规定范围内的弹幕，再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</li>
<li>如果上述两次查找缓存都没找到，则从FinitePool中取出一个，没有就new一个，然后同上配置DrawingCache</li>
</ul>
<p>&#160; &#160; &#160; &#160;1）我们一个一个来，先测量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弹幕的基类都是BaseDanmaku,只有子类R2LDanmaku重写了measure方法</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//R2LDanmaku的measure方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(IDisplayer displayer, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.measure(displayer, fromWorkerThread);<span class="comment">//调用了父类的方法</span></span><br><span class="line">        mDistance = (<span class="keyword">int</span>) (displayer.getWidth() + paintWidth);<span class="comment">//滚动弹幕的距离都是 视图宽度+弹幕宽度，很好理解</span></span><br><span class="line">        mStepX = mDistance / (<span class="keyword">float</span>) duration.value; <span class="comment">//每秒步长就是总滚动距离除以弹幕时长</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类BaseDanmaku的measure方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(IDisplayer displayer, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">        displayer.measure(<span class="keyword">this</span>, fromWorkerThread);<span class="comment">//AndroidDisplayer的measure方法</span></span><br><span class="line">        <span class="keyword">this</span>.measureResetFlag = flags.MEASURE_RESET_FLAG;<span class="comment">//设置已经测量过了的标签</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着会调用AndroidDisplayer的measure方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">	...设置画笔style,color,alpha,省略...</span><br><span class="line">       calcPaintWH(danmaku, paint, fromWorkerThread);<span class="comment">//计算宽高</span></span><br><span class="line">	...设置画笔style,color,alpha,省略...</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span> BaseCacheStuffer sStuffer = <span class="keyword">new</span> SimpleTextCacheStuffer();<span class="comment">//默认是SimpleTextCacheStuffer</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcPaintWH</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       sStuffer.measure(danmaku, paint, fromWorkerThread);<span class="comment">//sStuffer就是我们在MainActivity里配置DanmakuContext时设置的，默认是SimpleTextCacheStuffer</span></span><br><span class="line">       </span><br><span class="line">       ...加上描边，padding等额外值，省略...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;还记得在MainActivity里配置DanmakuContext吗？当时是这么写的：<br>                .setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter) // 图文混排使用SpannedCacheStuffer<br>//              .setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</p>
<p>&#160; &#160; &#160; &#160;比如SpannedCacheStuffer的measure方法是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//SpannedCacheStuffer的measure方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (danmaku.text <span class="keyword">instanceof</span> Spanned) &#123;</span><br><span class="line">          CharSequence text = danmaku.text;</span><br><span class="line">          <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//可看到将弹幕的宽高，文字等信息包在了一个StaticLayout对象中，然后付给danmaku的obj对象</span></span><br><span class="line">              StaticLayout staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) Math.ceil(StaticLayout.getDesiredWidth(danmaku.text, paint)), Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">              danmaku.paintWidth = staticLayout.getWidth();</span><br><span class="line">              danmaku.paintHeight = staticLayout.getHeight();</span><br><span class="line">              danmaku.obj = <span class="keyword">new</span> SoftReference&lt;&gt;(staticLayout);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">super</span>.measure(danmaku, paint, fromWorkerThread);<span class="comment">//如果不是图文混排类型，则调用父类SimpleTextCacheStuffer的方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>可以看到measure方法创建了一个StaticLayout对象，并将它的软引用赋给了danmaku的obj属性；如果是图文混排类型弹幕，则danmaku.obj不为空；如果是普通弹幕则danmaku.obj为空</strong>。<br>&#160; &#160; &#160; &#160;BackgroundCacheStuffer也差不多，都是对弹幕样式的一些改造。</p>
<p>&#160; &#160; &#160; &#160;然后我们看SimpleTextCacheStuffer的measure方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的measure方法   </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mProxy != <span class="keyword">null</span>) &#123;<span class="comment">//这个mProxy 是BaseCacheStuffer.Proxy类型的对象，也是初始化DanmakuContext调用setCacheStuffer(cacheStuffer, proxy)时设置的</span></span><br><span class="line">           mProxy.prepareDrawing(danmaku, fromWorkerThread);<span class="comment">//根据你的条件检查是否需要需要更新弹幕</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">float</span> w = <span class="number">0</span>;</span><br><span class="line">       Float textHeight = <span class="number">0f</span>;</span><br><span class="line">       <span class="keyword">if</span> (danmaku.lines == <span class="keyword">null</span>) &#123;<span class="comment">//不是多行文本</span></span><br><span class="line">           <span class="keyword">if</span> (danmaku.text == <span class="keyword">null</span>) &#123;</span><br><span class="line">               w = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               w = paint.measureText(danmaku.text.toString());<span class="comment">//测量出文字宽度</span></span><br><span class="line">               textHeight = getCacheHeight(danmaku, paint);<span class="comment">//计算出文字高度</span></span><br><span class="line">           &#125;</span><br><span class="line">           danmaku.paintWidth = w;</span><br><span class="line">           danmaku.paintHeight = textHeight;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是多行文本</span></span><br><span class="line">           textHeight = getCacheHeight(danmaku, paint);<span class="comment">//计算出单行文字高度</span></span><br><span class="line">           <span class="keyword">for</span> (String tempStr : danmaku.lines) &#123;<span class="comment">//计算出多行文本总宽高</span></span><br><span class="line">               <span class="keyword">if</span> (tempStr.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">float</span> tr = paint.measureText(tempStr);</span><br><span class="line">                   w = Math.max(tr, w);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           danmaku.paintWidth = w;</span><br><span class="line">           danmaku.paintHeight = danmaku.lines.length * textHeight;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Float, Float&gt; sTextHeightCache = <span class="keyword">new</span> HashMap&lt;Float, Float&gt;();<span class="comment">//key是字号大小，value是字体高度</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Float <span class="title">getCacheHeight</span><span class="params">(BaseDanmaku danmaku, Paint paint)</span> </span>&#123;</span><br><span class="line">       Float textSize = paint.getTextSize();</span><br><span class="line">       Float textHeight = sTextHeightCache.get(textSize);</span><br><span class="line">       <span class="keyword">if</span> (textHeight == <span class="keyword">null</span>) &#123;</span><br><span class="line">           Paint.FontMetrics fontMetrics = paint.getFontMetrics();</span><br><span class="line">           <span class="comment">//Android对文字绘制有些特殊，基准点是baseline，也就是例如canvas.drawText(text, baseX, baseY, textPaint)中写入的baseY大小</span></span><br><span class="line">           <span class="comment">//Ascent是baseline之上字符最高处的y值；</span></span><br><span class="line">		<span class="comment">//Descent是baseline之下字符最低处的y值；</span></span><br><span class="line">		<span class="comment">//Leading其实是上一行字符的descent到下一行的ascent之间的距离。</span></span><br><span class="line">		<span class="comment">//所以文本高度就是descent - ascent + leading </span></span><br><span class="line">           textHeight = fontMetrics.descent - fontMetrics.ascent + fontMetrics.leading;</span><br><span class="line">           sTextHeightCache.put(textSize, textHeight);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> textHeight;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就计算完了每一条弹幕的宽高，完成了测量。</p>
<p>&#160; &#160; &#160; &#160;2） 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)：<br>&#160; &#160; &#160; &#160;先回到buildCache方法中这个位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line"></span><br><span class="line">	...测量已经完成...</span><br><span class="line">             DrawingCache cache = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// try to find reuseable cache, 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</span></span><br><span class="line">                 BaseDanmaku danmaku = findReuseableCache(item, <span class="keyword">true</span>, <span class="number">20</span>);</span><br><span class="line">                 <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">//如果查找出了这样的弹幕</span></span><br><span class="line">                     cache = (DrawingCache) danmaku.cache;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                     cache.increaseReference();<span class="comment">//则将引用计数 +1</span></span><br><span class="line">                     item.cache = cache;<span class="comment">//将目标弹幕缓存的引用指向查找出来的弹幕缓存，即多个引用指向同一个对象</span></span><br><span class="line">                     <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                     mCacheManager.push(item, <span class="number">0</span>, forceInsert);</span><br><span class="line">                     <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">                 &#125;</span><br><span class="line">             ......    </span><br><span class="line">   &#125; </span><br><span class="line">     <span class="comment">//在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)             </span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> BaseDanmaku <span class="title">findReuseableCache</span><span class="params">(BaseDanmaku refDanmaku,</span><br><span class="line">                                            <span class="keyword">boolean</span> strictMode,</span><br><span class="line">                                            <span class="keyword">int</span> maximumTimes)</span> </span>&#123;<span class="comment">//item， true， 20</span></span><br><span class="line">         IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">......</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (it.hasNext() &amp;&amp; count++ &lt; maximumTimes) &#123;  <span class="comment">// limit maximum times 20</span></span><br><span class="line">             BaseDanmaku danmaku = it.next();</span><br><span class="line">             IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">             <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//对比mCaches中的弹幕和目标的内幕文字、大小、边框、下划线、颜色是否完全相同</span></span><br><span class="line">             <span class="keyword">if</span> (danmaku.paintWidth == refDanmaku.paintWidth</span><br><span class="line">                     &amp;&amp; danmaku.paintHeight == refDanmaku.paintHeight</span><br><span class="line">                     &amp;&amp; danmaku.underlineColor == refDanmaku.underlineColor</span><br><span class="line">                     &amp;&amp; danmaku.borderColor == refDanmaku.borderColor</span><br><span class="line">                     &amp;&amp; danmaku.textColor == refDanmaku.textColor</span><br><span class="line">                     &amp;&amp; danmaku.text.equals(refDanmaku.text)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> danmaku;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (strictMode) &#123;<span class="comment">//true</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">	......</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CacheManagingDrawTask.CacheManager的push方法</span></span><br><span class="line">     <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(BaseDanmaku item, <span class="keyword">int</span> itemSize, <span class="keyword">boolean</span> forcePush)</span> </span>&#123;<span class="comment">//item，0，false</span></span><br><span class="line">         <span class="keyword">int</span> size = itemSize; <span class="comment">//0</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//这里注意mCaches是Danmakus类型，addItem方法里面实现其实是类型为TreeSet的集合去添加，如果是同一个对象，则不会添加</span></span><br><span class="line">         <span class="keyword">this</span>.mCaches.addItem(item);</span><br><span class="line">         mRealSize += size;<span class="comment">//因为已经存在相同的缓存，因此已经使用缓存总大小不再增加</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//Danmakus的addItem方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addItem</span><span class="params">(BaseDanmaku item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (items != <span class="keyword">null</span>) &#123;<span class="comment">//items 类型为TreeSet</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (items.add(item)) &#123;<span class="comment">//如果是相同对象，则返回false，mSize个数不会增加</span></span><br><span class="line">                 mSize++;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述情况仅仅在相同样式，大小，颜色等都相同的弹幕第二次和以后的才会进入这段逻辑。对于不同的弹幕不会进入这个逻辑。（<strong>而且即使是相同弹幕，mCaches也只会存一个对象的，因为内部TreeSet的特性</strong>）<br>&#160; &#160; &#160; &#160;所以我们继续看下一种逻辑。</p>
<p>&#160; &#160; &#160; &#160;3）在前50条缓存中查找对比当前时间已经过时的 ，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)，而且宽高和目标弹幕差值在规定范围内的弹幕，再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)：<br>&#160; &#160; &#160; &#160;继续回到buildCache方法这个位置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line">		...测量过了...</span><br><span class="line">		...第一策略已经pass...</span><br><span class="line">			<span class="comment">// try to find reuseable cache from timeout || no-refrerence caches</span></span><br><span class="line">                  <span class="comment">//如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的</span></span><br><span class="line">                  <span class="comment">//，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)</span></span><br><span class="line">                  <span class="comment">//，而且宽高和目标弹幕差值在规定范围内的弹幕</span></span><br><span class="line">                  danmaku = findReuseableCache(item, <span class="keyword">false</span>, <span class="number">50</span>);</span><br><span class="line">                  <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到了这样的弹幕</span></span><br><span class="line">                      cache = (DrawingCache) danmaku.cache;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                      danmaku.cache = <span class="keyword">null</span>;<span class="comment">//先清除过时弹幕的缓存</span></span><br><span class="line">                      <span class="comment">//再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</span></span><br><span class="line">                      cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);  <span class="comment">//redraw</span></span><br><span class="line">                      item.cache = cache;<span class="comment">//将缓存应用赋给目标弹幕</span></span><br><span class="line">                      mCacheManager.push(item, <span class="number">0</span>, forceInsert);<span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                      <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">                  &#125;</span><br><span class="line">              ......    </span><br><span class="line">&#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> BaseDanmaku <span class="title">findReuseableCache</span><span class="params">(BaseDanmaku refDanmaku,</span><br><span class="line">                                             <span class="keyword">boolean</span> strictMode,</span><br><span class="line">                                             <span class="keyword">int</span> maximumTimes)</span> </span>&#123;<span class="comment">//item,false,50</span></span><br><span class="line">          IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">          <span class="keyword">int</span> slopPixel = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (!strictMode) &#123;<span class="comment">//进入逻辑，非严苛模式</span></span><br><span class="line">              slopPixel = mDisp.getSlopPixel() * <span class="number">2</span>;<span class="comment">//允许目标弹幕与mCaches中找到的弹幕宽高偏差</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (it.hasNext() &amp;&amp; count++ &lt; maximumTimes) &#123;  <span class="comment">// limit maximum times 20</span></span><br><span class="line">              BaseDanmaku danmaku = it.next();</span><br><span class="line">              IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">              <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//在这种第二策略中这段逻辑根本不会执行，因为以已经被上面的第一策略拦截了</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.paintWidth == refDanmaku.paintWidth</span><br><span class="line">                      &amp;&amp; danmaku.paintHeight == refDanmaku.paintHeight</span><br><span class="line">                      &amp;&amp; danmaku.underlineColor == refDanmaku.underlineColor</span><br><span class="line">                      &amp;&amp; danmaku.borderColor == refDanmaku.borderColor</span><br><span class="line">                      &amp;&amp; danmaku.textColor == refDanmaku.textColor</span><br><span class="line">                      &amp;&amp; danmaku.text.equals(refDanmaku.text)) &#123;</span><br><span class="line">                  <span class="keyword">return</span> danmaku;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (strictMode) &#123;<span class="comment">//false</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!danmaku.isTimeOut()) &#123;<span class="comment">//还必须在mCaches中过时的弹幕中查找</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (cache.hasReferences()) &#123;<span class="comment">//如果是相同弹幕被重新引用的，第二策略没有这样的</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//所以会走到这里，比较mCaches中过时的弹幕和目标弹幕宽高在不在允许的偏差内，如果在就返回查找出的这个弹幕</span></span><br><span class="line">              <span class="keyword">float</span> widthGap = cache.width() - refDanmaku.paintWidth;</span><br><span class="line">              <span class="keyword">float</span> heightGap = cache.height() - refDanmaku.paintHeight;</span><br><span class="line">              <span class="keyword">if</span> (widthGap &gt;= <span class="number">0</span> &amp;&amp; widthGap &lt;= slopPixel &amp;&amp;</span><br><span class="line">                      heightGap &gt;= <span class="number">0</span> &amp;&amp; heightGap &lt;= slopPixel) &#123;</span><br><span class="line">                  <span class="keyword">return</span> danmaku;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果在上述第二策略中，在过时的缓存中找到了和目标弹幕宽高差不多的缓存项，则根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)，调用DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DrawingCache <span class="title">buildDanmakuDrawingCache</span><span class="params">(BaseDanmaku danmaku, IDisplayer disp,</span><br><span class="line">          DrawingCache cache)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>)</span><br><span class="line">          cache = <span class="keyword">new</span> DrawingCache();</span><br><span class="line"><span class="comment">//组建弹幕缓存(bitmap,canvas)</span></span><br><span class="line">      cache.build((<span class="keyword">int</span>) Math.ceil(danmaku.paintWidth), (<span class="keyword">int</span>) Math.ceil(danmaku.paintHeight), disp.getDensityDpi(), <span class="keyword">false</span>);</span><br><span class="line">      DrawingCacheHolder holder = cache.get();</span><br><span class="line">      <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//绘制弹幕内容</span></span><br><span class="line">          ((AbsDisplayer) disp).drawDanmaku(danmaku, holder.canvas, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">if</span>(disp.isHardwareAccelerated()) &#123;<span class="comment">//如果有硬件加速</span></span><br><span class="line">           <span class="comment">//超过一屏的弹幕要切割</span></span><br><span class="line">              holder.splitWith(disp.getWidth(), disp.getHeight(), disp.getMaximumCacheWidth(),</span><br><span class="line">                      disp.getMaximumCacheHeight());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;重新设置缓存分三步：1.组建弹幕缓存,2.绘制弹幕内容,3.切割超过一屏的弹幕。</p>
<p>&#160; &#160; &#160; &#160;No.1 组建弹幕缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawingCache的build方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> density, <span class="keyword">boolean</span> checkSizeEquals)</span> </span>&#123;<span class="comment">//checkSizeEquals为false</span></span><br><span class="line">       <span class="keyword">final</span> DrawingCacheHolder holder = mHolder;</span><br><span class="line">       <span class="comment">//每个DrawingCache都有一个DrawingCacheHolder</span></span><br><span class="line">       holder.buildCache(w, h, density, checkSizeEquals);<span class="comment">//DrawingCacheHolder的buildCache方法</span></span><br><span class="line">       mSize = mHolder.bitmap.getRowBytes() * mHolder.bitmap.getHeight();<span class="comment">//返回创建的bitmap的大小</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawingCacheHolder的buildCache方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> density, <span class="keyword">boolean</span> checkSizeEquals)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> reuse = checkSizeEquals ? (w == width &amp;&amp; h == height) : (w &lt;= width &amp;&amp; h &lt;= height);<span class="comment">//检测大小 ？ 宽高相等 ： 小于已经缓存的bitmap宽高</span></span><br><span class="line">       <span class="keyword">if</span> (reuse &amp;&amp; bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果能够复用bitmap</span></span><br><span class="line">           bitmap.eraseColor(Color.TRANSPARENT);<span class="comment">//擦出之前的颜色</span></span><br><span class="line">           canvas.setBitmap(bitmap);<span class="comment">//给Canvas重新预设bitmap</span></span><br><span class="line">           recycleBitmapArray();<span class="comment">//回收超过一屏弹幕切割后的bitmap数组，这个接下来会讲</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果不能复用，则回收旧的缓存bitmap</span></span><br><span class="line">           recycle();</span><br><span class="line">       &#125;</span><br><span class="line">       width = w;</span><br><span class="line">       height = h;</span><br><span class="line">       bitmap = NativeBitmapFactory.createBitmap(w, h, Bitmap.Config.ARGB_8888);<span class="comment">//用native方法创建一个bitmap</span></span><br><span class="line">       <span class="keyword">if</span> (density &gt; <span class="number">0</span>) &#123;<span class="comment">//设置density</span></span><br><span class="line">           mDensity = density;</span><br><span class="line">           bitmap.setDensity(density);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置canvas</span></span><br><span class="line">       <span class="keyword">if</span> (canvas == <span class="keyword">null</span>)&#123;</span><br><span class="line">           canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">           canvas.setDensity(density);</span><br><span class="line">       &#125;<span class="keyword">else</span></span><br><span class="line">           canvas.setBitmap(bitmap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;组建弹幕缓存就是为个DrawingCache根据目标弹幕大小创建bitmap和canvas。</p>
<p>&#160; &#160; &#160; &#160;No.2 绘制弹幕内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">drawDanmaku</span><span class="params">(BaseDanmaku danmaku, Canvas canvas, </span><br><span class="line">  <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;<span class="comment">//danmaku, holder.canvas, 0, 0, true</span></span><br><span class="line">      <span class="keyword">float</span> _left = left;</span><br><span class="line">      <span class="keyword">float</span> _top = top;</span><br><span class="line">      </span><br><span class="line">...一些杂项，忽略...</span><br><span class="line"></span><br><span class="line">      TextPaint paint = getPaint(danmaku, fromWorkerThread);<span class="comment">//获取画笔</span></span><br><span class="line">      <span class="comment">//绘制背景，sStuffer可以自己设置，默认是SimpleTextCacheStuffer,默认drawBackground为空</span></span><br><span class="line">      <span class="comment">//这个可以自己扩展，上面讲过</span></span><br><span class="line">      sStuffer.drawBackground(danmaku, canvas, _left, _top);</span><br><span class="line">      <span class="keyword">if</span> (danmaku.lines != <span class="keyword">null</span>) &#123;<span class="comment">//如果是多行文本</span></span><br><span class="line">          String[] lines = danmaku.lines;</span><br><span class="line">          <span class="keyword">if</span> (lines.length == <span class="number">1</span>) &#123;<span class="comment">//多行文本行数为1</span></span><br><span class="line">              <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">               <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">                  applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">                  <span class="keyword">float</span> strokeTop = top - paint.ascent();</span><br><span class="line">                  ......</span><br><span class="line">                  <span class="comment">//绘制描边</span></span><br><span class="line">                  sStuffer.drawStroke(danmaku, lines[<span class="number">0</span>], canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">              applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">              <span class="comment">//绘制文字</span></span><br><span class="line">              sStuffer.drawText(danmaku, lines[<span class="number">0</span>], canvas, left, top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//多行文本行数大于1</span></span><br><span class="line">           <span class="comment">//先计算每行文本的高度</span></span><br><span class="line">              <span class="keyword">float</span> textHeight = (danmaku.paintHeight - <span class="number">2</span> * danmaku.padding) / lines.length;</span><br><span class="line">              <span class="comment">//循环绘制每一行文本</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; lines.length; t++) &#123;</span><br><span class="line">                  ......</span><br><span class="line">                  <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">                   <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">                      applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">                      <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">                      <span class="keyword">float</span> strokeTop = t * textHeight + top - paint.ascent();</span><br><span class="line">				......</span><br><span class="line">                      <span class="comment">//绘制描边</span></span><br><span class="line">                      sStuffer.drawStroke(danmaku, lines[t], canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">                  applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="comment">//绘制文字</span></span><br><span class="line">                  sStuffer.drawText(danmaku, lines[t], canvas, left, t * textHeight + top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是单行文本</span></span><br><span class="line">          <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">           <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">              applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">              <span class="keyword">float</span> strokeTop = top - paint.ascent();</span><br><span class="line">		......</span><br><span class="line">              <span class="comment">//绘制描边</span></span><br><span class="line">              sStuffer.drawStroke(danmaku, <span class="keyword">null</span>, canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">          applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">          <span class="comment">//绘制文字</span></span><br><span class="line">          sStuffer.drawText(danmaku, <span class="keyword">null</span>, canvas, left, top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// draw underline</span></span><br><span class="line">      <span class="keyword">if</span> (danmaku.underlineColor != <span class="number">0</span>) &#123;<span class="comment">//绘制下划线（if）</span></span><br><span class="line">          Paint linePaint = getUnderlinePaint(danmaku);</span><br><span class="line">          <span class="keyword">float</span> bottom = _top + danmaku.paintHeight - UNDERLINE_HEIGHT;</span><br><span class="line">          canvas.drawLine(_left, bottom, _left + danmaku.paintWidth, bottom, linePaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//draw border</span></span><br><span class="line">      <span class="keyword">if</span> (danmaku.borderColor != <span class="number">0</span>) &#123;<span class="comment">//绘制外框</span></span><br><span class="line">          Paint borderPaint = getBorderPaint(danmaku);</span><br><span class="line">          canvas.drawRect(_left, _top, _left + danmaku.paintWidth, _top + danmaku.paintHeight,</span><br><span class="line">                  borderPaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置画笔</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPaintConfig</span><span class="params">(BaseDanmaku danmaku, Paint paint, <span class="keyword">boolean</span> stroke)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">          <span class="keyword">if</span> (stroke) &#123;</span><br><span class="line">              paint.setStyle(HAS_PROJECTION ? Style.FILL : Style.STROKE);</span><br><span class="line">              paint.setColor(danmaku.textShadowColor &amp; <span class="number">0x00FFFFFF</span>);</span><br><span class="line">              <span class="keyword">int</span> alpha = HAS_PROJECTION ? sProjectionAlpha : AlphaValue.MAX;</span><br><span class="line">              paint.setAlpha(alpha);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              paint.setStyle(Style.FILL);</span><br><span class="line">              paint.setColor(danmaku.textColor &amp; <span class="number">0x00FFFFFF</span>);</span><br><span class="line">              paint.setAlpha(AlphaValue.MAX);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述就是绘制弹幕内容过程，主要就是sStuffer的drawStroke，drawText方法。如果你在DanmakuContext中没有设置CacheStuffer，则上述drawDanmaku方法中的sStuffer为默认的SimpleTextCacheStuffer。<br>&#160; &#160; &#160; &#160;drawStroke方法及其扩展都一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的drawStroke方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawStroke</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, Paint paint)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lineText != <span class="keyword">null</span>) &#123;</span><br><span class="line">           canvas.drawText(lineText, left, top, paint);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           canvas.drawText(danmaku.text.toString(), left, top, paint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们设了SpannedCacheStuffer, drawText方法有些区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的drawText方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lineText != <span class="keyword">null</span>) &#123;</span><br><span class="line">           canvas.drawText(lineText, left, top, paint);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           canvas.drawText(danmaku.text.toString(), left, top, paint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//SpannedCacheStuffer的drawText方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (danmaku.obj == <span class="keyword">null</span>) &#123;<span class="comment">//普通弹幕</span></span><br><span class="line">           <span class="keyword">super</span>.drawText(danmaku, lineText, canvas, left, top, paint, fromWorkerThread);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果是图文混排弹幕</span></span><br><span class="line">       SoftReference&lt;StaticLayout&gt; reference = (SoftReference&lt;StaticLayout&gt;) danmaku.obj;</span><br><span class="line">       StaticLayout staticLayout = reference.get();</span><br><span class="line">       <span class="comment">//按位与，判断标志位是否有效。这里判断是否请求重新测量</span></span><br><span class="line">       <span class="keyword">boolean</span> requestRemeasure = <span class="number">0</span> != (danmaku.requestFlags &amp; BaseDanmaku.FLAG_REQUEST_REMEASURE);</span><br><span class="line">       <span class="comment">//判断是否请求重绘</span></span><br><span class="line">       <span class="keyword">boolean</span> requestInvalidate = <span class="number">0</span> != (danmaku.requestFlags &amp; BaseDanmaku.FLAG_REQUEST_INVALIDATE);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (requestInvalidate || staticLayout == <span class="keyword">null</span>) &#123;<span class="comment">//如果请求重绘或者staticLayout 软引用被回收了</span></span><br><span class="line">           <span class="keyword">if</span> (requestInvalidate) &#123;</span><br><span class="line">            <span class="comment">//与非操作，清除标志位。清除请求重绘标志位</span></span><br><span class="line">               danmaku.requestFlags &amp;= ~BaseDanmaku.FLAG_REQUEST_INVALIDATE;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mProxy != <span class="keyword">null</span>) &#123;<span class="comment">//这个在设置DanmakuContext时设置，上面讲过，可以自己扩展</span></span><br><span class="line">               mProxy.prepareDrawing(danmaku, fromWorkerThread);</span><br><span class="line">           &#125;</span><br><span class="line">           CharSequence text = danmaku.text;</span><br><span class="line">           <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (requestRemeasure) &#123;<span class="comment">//重新测量</span></span><br><span class="line">                   staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) Math.ceil(StaticLayout.getDesiredWidth(danmaku.text, paint)), Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">                   danmaku.paintWidth = staticLayout.getWidth();</span><br><span class="line">                   danmaku.paintHeight = staticLayout.getHeight();</span><br><span class="line">                   danmaku.requestFlags &amp;= ~BaseDanmaku.FLAG_REQUEST_REMEASURE;<span class="comment">//清除标志位</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="comment">//不用重新测量</span></span><br><span class="line">                   staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) danmaku.paintWidth, Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               danmaku.obj = <span class="keyword">new</span> SoftReference&lt;&gt;(staticLayout);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//staticLayout可以继续用</span></span><br><span class="line">       <span class="keyword">boolean</span> needRestore = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="number">0</span> &amp;&amp; top != <span class="number">0</span>) &#123;</span><br><span class="line">           canvas.save();</span><br><span class="line">           canvas.translate(left, top + paint.ascent());</span><br><span class="line">           needRestore = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//绘制弹幕内容</span></span><br><span class="line">       staticLayout.draw(canvas);</span><br><span class="line">       <span class="keyword">if</span> (needRestore) &#123;</span><br><span class="line">           canvas.restore();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;绘制弹幕内容就完了，主要是绘制描边，绘制文字，绘制下划线，边框等等。</p>
<p>&#160; &#160; &#160; &#160;No.3 切割超过一屏的弹幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawingCacheHolder的splitWith方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">splitWith</span><span class="params">(<span class="keyword">int</span> dispWidth, <span class="keyword">int</span> dispHeight, <span class="keyword">int</span> maximumCacheWidth, <span class="keyword">int</span> maximumCacheHeight)</span> </span>&#123;</span><br><span class="line">       recycleBitmapArray();<span class="comment">//回收已存的bitmapArray数组</span></span><br><span class="line">       <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> || bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果弹幕的宽高都没有超过屏幕宽高，则不切割bitmap</span></span><br><span class="line">       <span class="keyword">if</span> (width &lt;= maximumCacheWidth &amp;&amp; height &lt;= maximumCacheHeight) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//切割超过一屏的弹幕</span></span><br><span class="line">       maximumCacheWidth = Math.min(maximumCacheWidth, dispWidth);</span><br><span class="line">       maximumCacheHeight = Math.min(maximumCacheHeight, dispHeight);</span><br><span class="line">       <span class="comment">//计算弹幕宽高是屏幕宽高的倍数，然后决定切割成多少块</span></span><br><span class="line">       <span class="keyword">int</span> xCount = width / maximumCacheWidth + (width % maximumCacheWidth == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> yCount = height / maximumCacheHeight + (height % maximumCacheHeight == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后求切割后弹幕每一块宽和高的平均值</span></span><br><span class="line">       <span class="keyword">int</span> averageWidth = width / xCount;</span><br><span class="line">       <span class="keyword">int</span> averageHeight = height / yCount;</span><br><span class="line">       <span class="comment">//建立二位bitmap数组，用于存放切割碎片</span></span><br><span class="line">       <span class="keyword">final</span> Bitmap[][] bmpArray = <span class="keyword">new</span> Bitmap[yCount][xCount];</span><br><span class="line">       <span class="keyword">if</span> (canvas == <span class="keyword">null</span>)&#123;</span><br><span class="line">           canvas = <span class="keyword">new</span> Canvas();</span><br><span class="line">           <span class="keyword">if</span> (mDensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               canvas.setDensity(mDensity);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Rect rectSrc = <span class="keyword">new</span> Rect();</span><br><span class="line">       Rect rectDst = <span class="keyword">new</span> Rect();</span><br><span class="line">       <span class="comment">//切割bitmap到bitmapArray中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> yIndex = <span class="number">0</span>; yIndex &lt; yCount; yIndex++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> xIndex = <span class="number">0</span>; xIndex &lt; xCount; xIndex++) &#123;</span><br><span class="line">            <span class="comment">//创建每一块小块bitmap</span></span><br><span class="line">               Bitmap bmp = bmpArray[yIndex][xIndex] = NativeBitmapFactory.createBitmap(</span><br><span class="line">                       averageWidth, averageHeight, Bitmap.Config.ARGB_8888);</span><br><span class="line">               <span class="keyword">if</span> (mDensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   bmp.setDensity(mDensity);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//将弹幕的大bitmap绘制进每个小块bitmap中</span></span><br><span class="line">               canvas.setBitmap(bmp);</span><br><span class="line">               <span class="keyword">int</span> left = xIndex * averageWidth, top = yIndex * averageHeight;</span><br><span class="line">               rectSrc.set(left, top, left + averageWidth, top + averageHeight);</span><br><span class="line">               rectDst.set(<span class="number">0</span>, <span class="number">0</span>, bmp.getWidth(), bmp.getHeight());</span><br><span class="line">               canvas.drawBitmap(bitmap, rectSrc, rectDst, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       canvas.setBitmap(bitmap);</span><br><span class="line">       bitmapArray = bmpArray;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;切割超过一屏的弹幕，<strong>就像玩切田字格游戏一样</strong>，完成后保存了一个bitmapArray数组。</p>
<p>&#160; &#160; &#160; &#160;到这里我们buildCache(item, false)的策略二中的重新设置缓存DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache)就走完了。然后将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize。同时注意mCaches内部成员items是TreeSet类型，不能添加相同的对象。</p>
<p>&#160; &#160; &#160; &#160;策略二设计的挺复杂的，我们可以看到这个策略应该是弹幕已经播放时不断执行的，对过时弹幕缓存的重复利用。不过我们刚开始，这一策略还未起作用，所以跳过，进入下一阶段：</p>
<p> &#160; &#160; &#160; &#160;4）如果上述两次查找缓存都没找到，则从FinitePool中取出一个，没有就new一个，然后同上配置DrawingCache：<br> &#160; &#160; &#160; &#160;继续回到buildCache方法这个位置： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line">		...测量过了...</span><br><span class="line">		...第一策略已经pass...</span><br><span class="line">		...第二策略已经pass...</span><br><span class="line">                  <span class="comment">//如果上述两次查找缓存都没找到，则进入下面逻辑</span></span><br><span class="line">                  <span class="comment">// guess cache size</span></span><br><span class="line">                  <span class="keyword">if</span> (!forceInsert) &#123;<span class="comment">//如果forceInsert为false，则表示不检测内存超出</span></span><br><span class="line">                      <span class="comment">//计算此弹幕bitmap的大小，width * height * 4</span></span><br><span class="line">                      <span class="comment">//(因为用native创建的Bitmap的Config为ARGB_8888，所以一个像素占4个字节)</span></span><br><span class="line">                      <span class="keyword">int</span> cacheSize = DanmakuUtils.getCacheSize((<span class="keyword">int</span>) item.paintWidth,</span><br><span class="line">                              (<span class="keyword">int</span>) item.paintHeight);</span><br><span class="line">                      <span class="comment">//如果当前已经使用大小 + 此弹幕缓存大小 &gt; 设置的最大内存（2/3 应用内存）        </span></span><br><span class="line">                      <span class="keyword">if</span> (mRealSize + cacheSize &gt; mMaxSize) &#123;<span class="comment">//没有超</span></span><br><span class="line">                          <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//从FinitePool中的300个DrawingCache对象中取出来一个</span></span><br><span class="line">                  cache = mCachePool.acquire();</span><br><span class="line">                  <span class="comment">//如果从上面的FinitePool取完了，则会直接new一个DrawingCache，配置DrawingCache</span></span><br><span class="line">                  cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);</span><br><span class="line">                  item.cache = cache;</span><br><span class="line">                  <span class="comment">//将item存入mCaches缓存，同时更新已使用大小mRealSize</span></span><br><span class="line">                  <span class="keyword">boolean</span> pushed = mCacheManager.push(item, sizeOf(item), forceInsert);</span><br><span class="line">                  <span class="keyword">if</span> (!pushed) &#123;<span class="comment">//如果item存放失败(使用内存超出规定大小)</span></span><br><span class="line">                      releaseDanmakuCache(item, cache);<span class="comment">//释放DrawingCache</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> pushed ? RESULT_SUCCESS : RESULT_FAILED;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//FinitePool的acquire方法，从缓存链表头取出一个对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T element;</span><br><span class="line">		<span class="comment">//mRoot 就是缓存链表表头指向的对象</span></span><br><span class="line">        <span class="keyword">if</span> (mRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            element = mRoot;</span><br><span class="line">            mRoot = element.getNextPoolable();</span><br><span class="line">            mPoolCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element = mManager.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">	        <span class="keyword">if</span> (element != <span class="keyword">null</span>) &#123;</span><br><span class="line">            element.setNextPoolable(<span class="keyword">null</span>);</span><br><span class="line">            element.setPooled(<span class="keyword">false</span>);</span><br><span class="line">            mManager.onAcquired(element);</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上述策略三是直接新建一个缓存DrawingCache，然后根据目标弹幕样式等配置它然后将它付给目标弹幕，再将目标弹幕放入缓存mCaches中。<br>&#160; &#160; &#160; &#160;刚开始时会执行策略三，因为刚开始时还没有缓存供我们使用，所以只能新建。</p>
<p>&#160; &#160; &#160; &#160;到此buildCache方法就走完了。我们可以看到buildCache主要截取了从当前时间开始的3倍弹幕时间内所有弹幕，然后为每一条弹幕建立缓存（创建DrawingCache对象，然后测量弹幕大小，再绘制弹幕内容，最后将信息保存到DrawingCache中，然后将它赋给目标弹幕的cache属性），并将这些弹幕保存到缓存mCaches中。</p>
<p>&#160; &#160; &#160; &#160;再次回顾一下上面的逻辑：</p>
<ul>
<li>子线程从发送PREPARE消息开始，然后接着发送了DISPATCH_ACTIONS消息；</li>
<li>DISPATCH_ACTIONS消息处理逻辑内部又会发送DISPATCH_ACTIONS消息，时间间隔为半条弹幕时间就这样不断循环发送；</li>
<li>DISPATCH_ACTIONS消息处理会调用dispatchAction方法，dispatchAction方法会发送BUILD_CACHES消息；</li>
<li>BUILD_CACHES消息处理会调用prepareCaches方法，prepareCaches方法内部会调用buildCache方法为从当前时间开始的3倍弹幕时间内所有的弹幕做缓存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;buildCache走完后，赶紧回到它之前调用方法的地方，不要把自己搞晕了= 。=<br>&#160; &#160; &#160; &#160;回到CacheManagingDrawTask的prepareCaches方法中，<strong>最后更新一下缓存定时器的时间，到缓存的最后一条弹幕的出现时间</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">prepareCaches</span><span class="params">(<span class="keyword">boolean</span> repositioned)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...截取三倍弹幕时间内所有弹幕，并为他们一一建立缓存...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;<span class="comment">//截取的最后一条弹幕,更新缓存定时器时间到它的出现时间</span></span><br><span class="line">        mCacheTimer.update(item.time);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCacheTimer.update(end);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;prepareCaches方法走完后，回到处理原先处理BUILD_CACHES消息的逻辑中，继续执行剩余部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">case</span> BUILD_CACHES:</span><br><span class="line">        removeMessages(BUILD_CACHES);</span><br><span class="line">        <span class="keyword">boolean</span> repositioned = ((mTaskListener != <span class="keyword">null</span> </span><br><span class="line">         &amp;&amp; mReadyState == <span class="keyword">false</span>) || mSeekedFlag);<span class="comment">// 为true</span></span><br><span class="line">        prepareCaches(repositioned);<span class="comment">//首次建立缓存已经完毕</span></span><br><span class="line">        <span class="keyword">if</span> (repositioned)</span><br><span class="line">         mSeekedFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTaskListener != <span class="keyword">null</span> &amp;&amp; mReadyState == <span class="keyword">false</span>) &#123;</span><br><span class="line">         mTaskListener.ready();<span class="comment">//然后回到mTaskListener监听ready方法</span></span><br><span class="line">         mReadyState = <span class="keyword">true</span>;<span class="comment">//将mReadyState标志位置为true，下次BUILD_CACHES不会进入这段逻辑了</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">       ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;执行mTaskListener.ready()方法，得回到上层逻辑DrawHandler的prepare(runnable)方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的prepare方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (drawTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">           drawTask = createDrawTask(mDanmakuView.isDanmakuDrawingCacheEnabled(), timer,</span><br><span class="line">                   mDanmakuView.getContext(), mDanmakuView.getWidth(), mDanmakuView.getHeight(),</span><br><span class="line">                   mDanmakuView.isHardwareAccelerated(), <span class="keyword">new</span> IDrawTask.TaskListener() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           initRenderingConfigs();<span class="comment">//初始化一些渲染参数</span></span><br><span class="line">                           runnable.run();<span class="comment">//执行runnable的run方法，继续追踪</span></span><br><span class="line">                       &#125;</span><br><span class="line">				......</span><br><span class="line">                   &#125;);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           runnable.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawHandler的initRenderingConfigs方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRenderingConfigs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> averageFrameConsumingTime = <span class="number">16</span>;<span class="comment">//平均每帧渲染间隔</span></span><br><span class="line">       mCordonTime = Math.max(<span class="number">33</span>, (<span class="keyword">long</span>) (averageFrameConsumingTime * <span class="number">2.5f</span>));<span class="comment">//40，警戒值1</span></span><br><span class="line">       mCordonTime2 = (<span class="keyword">long</span>) (mCordonTime * <span class="number">2.5f</span>);<span class="comment">//100，警戒值2</span></span><br><span class="line">       mFrameUpdateRate = Math.max(<span class="number">16</span>, averageFrameConsumingTime / <span class="number">15</span> * <span class="number">15</span>);<span class="comment">//16，每帧渲染间隔</span></span><br><span class="line">       mThresholdTime = mFrameUpdateRate + <span class="number">3</span>;<span class="comment">//19，渲染间隔阀值</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;初始化一些渲染参数，主要就是计算一下警戒时间和渲染频率。然后继续追踪runnable.run()方法，这个得回到DrawHandler的handleMessage方法中处理DrawHandler.PREPARE逻辑处：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> what = msg.what;</span><br><span class="line">       <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">           <span class="keyword">case</span> PREPARE:</span><br><span class="line">		......</span><br><span class="line">                   prepare(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//会回调到这里</span></span><br><span class="line">                           pausedPosition = <span class="number">0</span>;</span><br><span class="line">                           mReady = <span class="keyword">true</span>;<span class="comment">//将mReady 标志位置为true</span></span><br><span class="line">                           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               mCallback.prepared();<span class="comment">//回调callback监听</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               ......</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续追踪mCallback.prepared()，会回到MainActivity当中我们设置DanmakuView的地方：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity中设置mDanmakuView</span></span><br><span class="line">   mDanmakuView.setCallback(<span class="keyword">new</span> master.flame.danmaku.controller.DrawHandler.Callback() &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">    mDanmakuView.start();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//继续产看DanmaKuView的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       start(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">long</span> postion)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       handler.obtainMessage(DrawHandler.START, postion).sendToTarget();<span class="comment">//DrawHandler发送START消息</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后就是DrawHandler发送START消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        <span class="keyword">case</span> START:</span><br><span class="line">               Long startTime = (Long) msg.obj;<span class="comment">//0</span></span><br><span class="line">               <span class="keyword">if</span> (startTime != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   pausedPosition = startTime;<span class="comment">//0</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   pausedPosition = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">case</span> SEEK_POS:</span><br><span class="line">			......</span><br><span class="line">           <span class="keyword">case</span> RESUME:</span><br><span class="line">               quitFlag = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (mReady) &#123;<span class="comment">//true</span></span><br><span class="line">				......</span><br><span class="line">                   mTimeBase = SystemClock.uptimeMillis() - pausedPosition;<span class="comment">//将时间基线设为当前时间</span></span><br><span class="line">                   timer.update(pausedPosition);<span class="comment">//更新主定时器时间到初始位置，为0</span></span><br><span class="line">                   removeMessages(RESUME);</span><br><span class="line">                   sendEmptyMessage(UPDATE);<span class="comment">//发送UPDATE消息</span></span><br><span class="line">                   drawTask.start();<span class="comment">//CacheManagingDrawTask的start方法</span></span><br><span class="line">				......</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  ......</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> UPDATE:</span><br><span class="line">               <span class="keyword">if</span> (mUpdateInNewThread) &#123;<span class="comment">//在DrawHandler构造方法里赋值的变量，只有当可用CPU个数大于3时才为true</span></span><br><span class="line">                   updateInNewThread();<span class="comment">//四核，八核的请进</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   updateInCurrentThread();<span class="comment">//单核，双核的请进</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述逻辑最后会进入RESUME消息处理中，先调用CacheManagingDrawTask的start方法，然后处理UPDATE消息。我们先看看CacheManagingDrawTask的start方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheManagingDrawTask的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       mCacheManager.resume();<span class="comment">//CacheManager的resume方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//继续跟CacheManager的resume方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ......</span><br><span class="line">           mHandler.resume();<span class="comment">//CacheManagingDrawTask的resume方法</span></span><br><span class="line">		......</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//继续跟CacheManagingDrawTask的resume方法   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           mCancelFlag = <span class="keyword">false</span>;</span><br><span class="line">           mPause = <span class="keyword">false</span>;</span><br><span class="line">           removeMessages(DISPATCH_ACTIONS);</span><br><span class="line">           sendEmptyMessage(DISPATCH_ACTIONS);<span class="comment">//发送DISPATCH_ACTIONS消息，我们上面分析过，就是建立缓存</span></span><br><span class="line">           sendEmptyMessageDelayed(CLEAR_TIMEOUT_CACHES, mContext.mDanmakuFactory.MAX_DANMAKU_DURATION);<span class="comment">//延时发送CLEAR_TIMEOUT_CACHES消息</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到CacheManagingDrawTask的start方法最终做了两件事，一件是发送DISPATCH_ACTIONS再次建立缓存，这个流程我们上面分析过；第二件是<code>延时发送</code>CLEAR_TIMEOUT_CACHES消息。</p>
<p>&#160; &#160; &#160; &#160;所以我们看看CLEAR_TIMEOUT_CACHES消息处理逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	 .......</span><br><span class="line">	 <span class="keyword">case</span> CLEAR_TIMEOUT_CACHES:</span><br><span class="line">            clearTimeOutCaches();<span class="comment">//继续跟这个</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ......    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 clearTimeOutCaches方法</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearTimeOutCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          clearTimeOutCaches(mTimer.currMillisecond);<span class="comment">//调用重载方法，参数为主定时器当前时间</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用重载方法，参数为主定时器当前时间</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearTimeOutCaches</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">          IDanmakuIterator it = mCaches.iterator();<span class="comment">//从之前buildCache中建立的缓存中一一遍历</span></span><br><span class="line">          <span class="keyword">while</span> (it.hasNext() &amp;&amp; !mEndFlag) &#123;<span class="comment">//mEndFlag = false</span></span><br><span class="line">              BaseDanmaku val = it.next();</span><br><span class="line">              <span class="keyword">if</span> (val.isTimeOut()) &#123;<span class="comment">//如果缓存的弹幕已经超时</span></span><br><span class="line">			......</span><br><span class="line">                  entryRemoved(<span class="keyword">false</span>, val, <span class="keyword">null</span>);<span class="comment">//销毁缓存</span></span><br><span class="line">                  it.remove();<span class="comment">//从缓存mCaches中移除此引用</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;顺着逻辑看看entryRemoved(false, val, null)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, BaseDanmaku oldValue, BaseDanmaku newValue)</span> </span>&#123;<span class="comment">//第1个和第3个参数没用到</span></span><br><span class="line">    IDrawingCache&lt;?&gt; cache = oldValue.getDrawingCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> releasedSize = clearCache(oldValue);<span class="comment">//调用了clearCache方法</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue.isTimeOut()) &#123;</span><br><span class="line">         <span class="comment">//这个方法最终会调用我们最初设置DanmakuContext.setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter)</span></span><br><span class="line">         <span class="comment">//中第二个参数类型为BaseCacheStuffer.Proxy的releaseResource方法,</span></span><br><span class="line">         <span class="comment">//方法注释是这么写的 TODO 重要:清理含有ImageSpan的text中的一些占用内存的资源 例如drawable</span></span><br><span class="line">            mContext.getDisplayer().getCacheStuffer().releaseResource(oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (releasedSize &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        mRealSize -= releasedSize;<span class="comment">//真正缓存大小减去需要释放的缓存大小</span></span><br><span class="line">        mCachePool.release((DrawingCache) cache);<span class="comment">//将Drawingcache放回到FinitePool中，已供下次取出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//往下看，看看clearCache方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">clearCache</span><span class="params">(BaseDanmaku oldValue)</span> </span>&#123;</span><br><span class="line">    IDrawingCache&lt;?&gt; cache = oldValue.cache;</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache.hasReferences()) &#123;<span class="comment">//如果DrawingCache缓存还被重复引用</span></span><br><span class="line">        cache.decreaseReference();<span class="comment">//则将引用计数-1</span></span><br><span class="line">        oldValue.cache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不销毁缓存(bitmap,canvas等)，只有等到引用计数为0时才会销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> size = sizeOf(oldValue);<span class="comment">//计算缓存的bitmap大小</span></span><br><span class="line">    cache.destroy();<span class="comment">//同时销毁bitmap等</span></span><br><span class="line">    oldValue.cache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存的bitmap的大小</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(BaseDanmaku value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value.cache != <span class="keyword">null</span> &amp;&amp; !value.cache.hasReferences()) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.cache.size();<span class="comment">//返回的是Drawing中bitmap对象的大小，上面讲过的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;CLEAR_TIMEOUT_CACHES消息处理就分析完了，就是移除缓存弹幕mCache中过时的弹幕，并且销毁他们持有的DrawingCache，同时销毁内部的bitmap、canvas等。</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>&#160; &#160; &#160; &#160;现在重点来了！还记得我们之前挖的一个大坑么？就是妹子图那个地方。那是CacheHandler给工作线程发送DISPATCH_ACTIONS消息时调用的dispatchAction方法。因为CacheHandler每个半条弹幕时间就会发DISPATCH_ACTIONS消息，所以我们得仔细分析一下dispatchAction方法的各种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">dispatchAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//如果上一次buildCache完成后得到的缓存弹幕末尾项的时间（上面分析过，这个值存在mCacheTimer.currMillisecond中）</span></span><br><span class="line">         <span class="comment">//和主定时器当前时间之间的时间差值已经大于一条弹幕时间,</span></span><br><span class="line">         <span class="comment">//则会清除所有不在屏幕内的缓存，然后重新buildCache建立缓存</span></span><br><span class="line">            <span class="keyword">if</span> (mCacheTimer.currMillisecond &lt;= mTimer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                evictAllNotInScreen();<span class="comment">//则会清除所有不在屏幕内的缓存</span></span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//重新建立缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> level = getPoolPercent();<span class="comment">//获得缓存实际大小占设置最大内存的百分比</span></span><br><span class="line">            BaseDanmaku firstCache = mCaches.first();</span><br><span class="line">            <span class="comment">//TODO 如果firstcache大于当前时间超过半屏并且水位在0.5f以下,就要往里蓄水</span></span><br><span class="line">            <span class="keyword">long</span> gapTime = firstCache != <span class="keyword">null</span> ? firstCache.time - mTimer.currMillisecond : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> doubleScreenDuration = mContext.mDanmakuFactory.MAX_DANMAKU_DURATION * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (level &lt; <span class="number">0.6f</span> &amp;&amp; gapTime &gt; mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                removeMessages(BUILD_CACHES);</span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//重新建立缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level &gt; <span class="number">0.4f</span> &amp;&amp; gapTime &lt; -doubleScreenDuration) &#123;<span class="comment">//如果水位在0.5以上，并且上一次蓄水距离现在已经超过两条弹幕时间了，就要开闸放水</span></span><br><span class="line">                <span class="comment">// clear timeout caches</span></span><br><span class="line">                removeMessages(CLEAR_TIMEOUT_CACHES);</span><br><span class="line">                sendEmptyMessage(CLEAR_TIMEOUT_CACHES);<span class="comment">//CLEAR_TIMEOUT_CACHES消息刚分析过了，清除过时缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (level &gt;= <span class="number">0.9f</span>) &#123;<span class="comment">//水位快满了，等待下次放水</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check cache time</span></span><br><span class="line">            <span class="keyword">long</span> deltaTime = mCacheTimer.currMillisecond - mTimer.currMillisecond;</span><br><span class="line">            <span class="comment">//缓存的第一条弹幕已经过时了，并且缓存弹幕末尾时间和现在时间差值已经超过一条弹幕时间了</span></span><br><span class="line">            <span class="keyword">if</span> (firstCache != <span class="keyword">null</span> &amp;&amp; firstCache.isTimeOut() &amp;&amp; deltaTime &lt; -mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                sendEmptyMessage(CLEAR_OUTSIDE_CACHES);<span class="comment">//先清除过时缓存</span></span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//再重组缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaTime &gt; doubleScreenDuration) &#123;<span class="comment">//如果缓存的最后一条弹幕时间距离现在还有双倍弹幕时间多，则啥都不做</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//剩余情况组建缓存</span></span><br><span class="line">            removeMessages(BUILD_CACHES);</span><br><span class="line">            sendEmptyMessage(BUILD_CACHES);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//则会清除所有不在屏幕内的缓存    </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictAllNotInScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        evictAllNotInScreen(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictAllNotInScreen</span><span class="params">(<span class="keyword">boolean</span> removeAllReferences)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCaches != <span class="keyword">null</span>) &#123;</span><br><span class="line">            IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                BaseDanmaku danmaku = it.next();</span><br><span class="line">	......</span><br><span class="line">                <span class="keyword">if</span> (danmaku.isOutside()) &#123;<span class="comment">//如果弹幕已经走完了，超过屏幕</span></span><br><span class="line">                    entryRemoved(<span class="keyword">true</span>, danmaku, <span class="keyword">null</span>);<span class="comment">//回收缓存</span></span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        mRealSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得缓存实际大小占设置最大内存的百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPoolPercent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMaxSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mRealSize / (<span class="keyword">float</span>) mMaxSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;dispatchAction方法主要分为以下几种规则：</p>
<ul>
<li>如果上一次buildCache完成后得到的缓存弹幕末尾项的时间（上面分析过，这个值存在mCacheTimer.currMillisecond中）和主定时器当前时间之间的时间差值已经大于一条弹幕时间, 则会清除所有不在屏幕内的缓存，然后重新buildCache建立缓存；</li>
<li>如果缓存弹幕的第一项出现时间大于当前时间超过半屏，并且总缓存大小在规定最大值一半以下, 就要重新建立缓存；</li>
<li>如果总缓存大小在规定最大值一半以上，并且上一次建立缓存距离现在已经超过两条弹幕时间了，就要清除超时缓存；</li>
<li>如果总缓存大小快达到规定最大值，就等待下一次清除超时缓存；</li>
<li>缓存的第一条弹幕已经过时了，并且缓存弹幕末尾时间和现在时间差值已经超过一条弹幕时间了，先清除过时缓存，再重组缓存；</li>
<li>如果缓存的最后一条弹幕时间距离现在还有双倍弹幕时间多，则啥都不做;</li>
<li>剩余情况就是重组缓存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;因为DISPATCH_ACTIONS消息是每隔半条弹幕时间发送一次，所以会不断执行dispatchAction方法。然后根据上述出现的情况不断BUILD_CACHES和CLEAR_TIMEOUT_CACHES,这样工作线程就形成了一套缓存机制。</p>
<h3 id="绘制弹幕界面"><a href="#绘制弹幕界面" class="headerlink" title="绘制弹幕界面"></a>绘制弹幕界面</h3><p>&#160; &#160; &#160; &#160;到此CacheManagingDrawTask的start方法就分析完了，继续回到DrawHandler的handleMessage方法，接着处理UPDATE消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">case</span> UPDATE:</span><br><span class="line">               <span class="keyword">if</span> (mUpdateInNewThread) &#123;<span class="comment">//在DrawHandler构造方法里赋值的变量，只有当可用CPU个数大于3时才为true</span></span><br><span class="line">                   updateInNewThread();<span class="comment">//四核，八核的请进</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   updateInCurrentThread();<span class="comment">//单核，双核的请进</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ...... 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里，我们应该能猜到接下要进行应该就是绘制工作了。其实updateInNewThread和updateInCurrentThread做的事情是一样的，只不过其中一个新开了子线程去做这些事情。两者的工作原理都是更新定时器，然后postInvalidate，使DanmakuView重绘，然后再发UPDATE消息，重复上述过程。</p>
<p>&#160; &#160; &#160; &#160;鉴于目前四核手机已经烂大街了，我们也就挑个多核的方法进去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInNewThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mThread = <span class="keyword">new</span> UpdateThread(<span class="string">"DFM Update"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> lastTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> dTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isQuited() &amp;&amp; !quitFlag) &#123;</span><br><span class="line">                <span class="keyword">long</span> startMS = SystemClock.uptimeMillis();</span><br><span class="line">                dTime = SystemClock.uptimeMillis() - lastTime;</span><br><span class="line">                <span class="keyword">long</span> diffTime = mFrameUpdateRate - dTime;<span class="comment">//mFrameUpdateRate 为16，之前计算过</span></span><br><span class="line">                <span class="keyword">if</span> (diffTime &gt; <span class="number">1</span>) &#123;<span class="comment">//如果间隔时间太短，则会延时，一定要等够16毫秒，达到绘制时间间隔</span></span><br><span class="line">                    SystemClock.sleep(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;d</span><br><span class="line">                <span class="comment">//上面逻辑是为了延时，稳定帧率</span></span><br><span class="line">                lastTime = startMS;</span><br><span class="line">                <span class="keyword">long</span> d = syncTimer(startMS);<span class="comment">//同步主定时器时间</span></span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">                d = mDanmakuView.drawDanmakus();<span class="comment">//开始postInvalidate，绘制弹幕，同时返回绘制时间</span></span><br><span class="line">                <span class="comment">//这种情况出现在绘制时间内，绘制时子线程在wait，等待绘制结束，然后返回差值必定大于警戒值100</span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; mCordonTime2) &#123;  <span class="comment">// this situation may be cuased by ui-thread waiting of DanmakuView, so we sync-timer at once</span></span><br><span class="line">                    timer.add(d);<span class="comment">//绘制完成后更新主定时器时间</span></span><br><span class="line">                    mDrawTimes.clear();</span><br><span class="line">                &#125;</span><br><span class="line">	......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    mThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;updateInNewThread主要做了两件事：延时然后同步主定时器时间，然后通知DanmakuView重绘。</p>
<p>&#160; &#160; &#160; &#160;我们先看同步主定时器时间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">syncTimer</span><span class="params">(<span class="keyword">long</span> startMS)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">long</span> d = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> time = startMS - mTimeBase;<span class="comment">//当前时间到初始时间的时间差</span></span><br><span class="line">       ......</span><br><span class="line">          <span class="keyword">long</span> gapTime = time - timer.currMillisecond;<span class="comment">//总时间差减去上一次绘制完成时间，得到绘制间隙时间</span></span><br><span class="line">          <span class="keyword">long</span> averageTime = Math.max(mFrameUpdateRate, getAverageRenderingTime());<span class="comment">//计算绘制间隙平均时间，大于等于16（getAverageRenderingTime方法是计算加入mDrawTimes队列的已经绘制过的时间总和除以帧数，得到平均时间，这个下面会讲到）</span></span><br><span class="line">          <span class="comment">//若果距离上次间隙时间过长||上次渲染时间大于第一警戒时间（40 ms）||上一步计算的绘制间隙平均时间大于第一警戒时间</span></span><br><span class="line">          <span class="keyword">if</span> (gapTime &gt; <span class="number">2000</span> || mRenderingState.consumingTime &gt; mCordonTime || averageTime &gt; mCordonTime) &#123;</span><br><span class="line">              d = gapTime;</span><br><span class="line">              gapTime = <span class="number">0</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是普通情况</span></span><br><span class="line">              d = averageTime + gapTime / mFrameUpdateRate;<span class="comment">//将绘制间隙平均时间赋给d，后面的项值不大，可以忽略</span></span><br><span class="line">              d = Math.max(mFrameUpdateRate, d);<span class="comment">//大于等于固定绘制间隔16</span></span><br><span class="line">              d = Math.min(mCordonTime, d);<span class="comment">//小于第一警戒时间40</span></span><br><span class="line">       </span><br><span class="line">		......</span><br><span class="line">          &#125;</span><br><span class="line">          ......</span><br><span class="line">          timer.add(d);<span class="comment">//更新主定时器时间，加上计算的时间间隔</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算平均绘制间隔时间</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getAverageRenderingTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> frames = mDrawTimes.size();</span><br><span class="line">      <span class="keyword">if</span>(frames &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> dtime = mDrawTimes.getLast() - mDrawTimes.getFirst();</span><br><span class="line">      <span class="keyword">return</span> dtime / frames;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;syncTimer主要是计算了一下绘制间隔时间，然后同步一下主定时器。</p>
<p>&#160; &#160; &#160; &#160;然后我们看看通知DanmakuView重绘部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuView的drawDanmakus方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">drawDanmakus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> stime = SystemClock.uptimeMillis();</span><br><span class="line">       lockCanvas();<span class="comment">//再看看lockCanvas</span></span><br><span class="line">       <span class="keyword">return</span> SystemClock.uptimeMillis() - stime;<span class="comment">//返回等待时间差</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DanmakuView的lockCanvas方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       postInvalidateCompat();<span class="comment">//通知view重绘</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mDrawMonitor) &#123;</span><br><span class="line">           <span class="keyword">while</span> ((!mDrawFinished) &amp;&amp; (handler != <span class="keyword">null</span>)) &#123;<span class="comment">//mDrawFinished标志位为false，所以会进入循环。只有onDraw方法的绘制走完了才会将他置为true，才会跳出循环</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   mDrawMonitor.wait(<span class="number">200</span>);<span class="comment">//onDraw没走完就会一直循环等待</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (mDanmakuVisible == <span class="keyword">false</span> || handler == <span class="keyword">null</span> || handler.isStop()) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       Thread.currentThread().interrupt();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mDrawFinished = <span class="keyword">false</span>;<span class="comment">//绘制结束后，将标志位置为false，一边下次进入方法后再次进入上述等待逻辑</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postInvalidateCompat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mRequestRender = <span class="keyword">true</span>;<span class="comment">//将mRequestRender 标志位置为true，一遍onDraw方法逻辑执行</span></span><br><span class="line">       <span class="comment">//通知view重绘</span></span><br><span class="line">       <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.postInvalidateOnAnimation();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.postInvalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就能保证保证每隔一定时间（这个时间通过syncTimer计算），更新主定时器（就是从0开始，往后每次加上（间隔时间 + 绘制时间）），然后执行postInvalidate通知DanmakuView重绘。</p>
<p>&#160; &#160; &#160; &#160;postInvalidate后，View重绘，会重走onDraw方法，所以我们进入DanmakuView的onDraw方法看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuView的onDraw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((!mDanmakuVisible) &amp;&amp; (!mRequestRender)) &#123;<span class="comment">//如果没有请求重绘则mRequestRender为false，不会绘制弹幕</span></span><br><span class="line">           <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	......</span><br><span class="line">           <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">               RenderingState rs = handler.draw(canvas);<span class="comment">//DrawHandler的draw方法</span></span><br><span class="line">			......</span><br><span class="line">           &#125;</span><br><span class="line">      ......</span><br><span class="line">       <span class="comment">//绘制结束后将mRequestRender 标志位重新设为false，</span></span><br><span class="line">       <span class="comment">//以便下一次发绘制消息时进入等待逻辑等候绘制结束，这个上面DanmakuView的drawDanmakus方法提到过</span></span><br><span class="line">       mRequestRender = <span class="keyword">false</span>;</span><br><span class="line">       unlockCanvasAndPost();<span class="comment">//通知UpdateThread绘制完成</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (mDrawMonitor) &#123;</span><br><span class="line">           mDrawFinished = <span class="keyword">true</span>;<span class="comment">//将mDrawFinished 置为true，以便DanmakuView的lockCanvas方法跳出循环，这个上面也提到过</span></span><br><span class="line">           mDrawMonitor.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuView的onDraw回调逻辑会执行DrawHandler的draw方法，我们继续跟进去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mDisp.setExtraData(canvas);<span class="comment">//将canvas一些信息设置给AndroidDisplayer</span></span><br><span class="line">      mRenderingState.set(drawTask.draw(mDisp));<span class="comment">//绘制部分是drawTask.draw(mDisp)</span></span><br><span class="line">      recordRenderingTime();<span class="comment">//记录绘制结束时间</span></span><br><span class="line">      <span class="keyword">return</span> mRenderingState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//还记得上面的DrawHandler的syncTimer方法吗？里面调用了getAverageRenderingTime计算绘制平均间隔时间，</span></span><br><span class="line">  <span class="comment">//其中用到的mDrawTimes变量就是在这里添加元素的</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recordRenderingTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> lastTime = SystemClock.uptimeMillis();</span><br><span class="line">      mDrawTimes.addLast(lastTime);<span class="comment">//将绘制结束时间加入到类型为LinkedList的mDrawTimes集合中</span></span><br><span class="line">      <span class="keyword">int</span> frames = mDrawTimes.size();</span><br><span class="line">      <span class="keyword">if</span> (frames &gt; MAX_RECORD_SIZE) &#123;<span class="comment">//最大容量为500个绘制时间，超出了则移除第一个</span></span><br><span class="line">          mDrawTimes.removeFirst();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述逻辑中，我的注释部分先分析了记录绘制结束时间部分，填了上边syncTimer时的坑。<br>&#160; &#160; &#160; &#160;然后应该进入主要绘制部分了drawTask.draw(mDisp)，也就是CacheManagingDrawTask的draw方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheManagingDrawTask的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(AbsDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       RenderingState result = <span class="keyword">super</span>.draw(displayer);<span class="comment">//会调用父类的draw方法</span></span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawTask的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> RenderingState <span class="title">draw</span><span class="params">(AbsDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> drawDanmakus(displayer,mTimer);<span class="comment">//又调用了drawDanmakus方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawTask的drawDanmakus方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> RenderingState <span class="title">drawDanmakus</span><span class="params">(AbsDisplayer disp, DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">if</span> (danmakuList != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Canvas canvas = (Canvas) disp.getExtraData();<span class="comment">//取出DanmakuView的canvas</span></span><br><span class="line">		<span class="comment">//当前时间 - 1屏弹幕时间 -100 （多减100是为了下次重新截取弹幕组时让绘制边界做到无缝衔接）</span></span><br><span class="line">           <span class="keyword">long</span> beginMills = timer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - <span class="number">100</span>;</span><br><span class="line">           <span class="comment">//当前时间 + 1屏弹幕时间</span></span><br><span class="line">           <span class="keyword">long</span> endMills = timer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;</span><br><span class="line">           <span class="comment">//每过了一屏的弹幕时间，就会进入如下if逻辑，截取以当前时间为基准的前后两屏弹幕；</span></span><br><span class="line">           <span class="comment">//如果距离上次截取时间不到一屏弹幕时间，则不会进入if的逻辑</span></span><br><span class="line">           <span class="keyword">if</span>(mLastBeginMills &gt; beginMills || timer.currMillisecond &gt; mLastEndMills) &#123;</span><br><span class="line">               IDanmakus subDanmakus = danmakuList.sub(beginMills, endMills);</span><br><span class="line">               <span class="keyword">if</span>(subDanmakus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   danmakus = subDanmakus;</span><br><span class="line">               &#125;</span><br><span class="line">               mLastBeginMills = beginMills;</span><br><span class="line">               mLastEndMills = endMills;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//距离上次截取时间不到一屏时间</span></span><br><span class="line">		......</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (danmakus != <span class="keyword">null</span> &amp;&amp; !danmakus.isEmpty()) &#123;<span class="comment">//开始绘制弹幕</span></span><br><span class="line">               RenderingState renderingState = mRenderingState = mRenderer.draw(mDisp, danmakus, mStartRenderTime);</span><br><span class="line">		......</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到第一次进入会截取以当前时间为基准的前后两屏弹幕。以后每过一屏弹幕时间，会重新截取当时时间为基准的前后两屏弹幕，如果不到一屏时间则不截取，还是以前的弹幕数据。</p>
<p>&#160; &#160; &#160; &#160;截取完弹幕数据后，就是绘制了，继续执行下面逻辑(mRenderer.draw(mDisp, danmakus, mStartRenderTime))，开始绘制工作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuRenderer的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(IDisplayer disp, IDanmakus danmakus, <span class="keyword">long</span> startRenderTime)</span> </span>&#123;</span><br><span class="line">       ......       </span><br><span class="line">       IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">       ......      </span><br><span class="line"></span><br><span class="line">       BaseDanmaku drawItem = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">           drawItem = itr.next();</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">		<span class="comment">//如果弹幕还没有到出现时间，则检查它有没有缓存，如果没有则为它建立缓存</span></span><br><span class="line">           <span class="keyword">if</span> (drawItem.isLate()) &#123;</span><br><span class="line">               IDrawingCache&lt;?&gt; cache = drawItem.getDrawingCache();</span><br><span class="line">               <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span> &amp;&amp; (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   mCacheManager.addDanmaku(drawItem);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">           <span class="comment">// measure 测量，我们之前prepareCache已经为他们在buildCache是测量过了</span></span><br><span class="line">           <span class="keyword">if</span> (!drawItem.isMeasured()) &#123;</span><br><span class="line">               drawItem.measure(disp, <span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// layout 布局，计算弹幕在屏幕上应该显示的位置</span></span><br><span class="line">           mDanmakusRetainer.fix(drawItem, disp, mVerifier);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// draw //绘制弹幕</span></span><br><span class="line">           <span class="keyword">if</span> (!drawItem.isOutside() &amp;&amp; drawItem.isShown()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (drawItem.lines == <span class="keyword">null</span> &amp;&amp; drawItem.getBottom() &gt; disp.getHeight()) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;    <span class="comment">// skip bottom outside danmaku ，忽略超过视图底部的弹幕</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//开始绘制</span></span><br><span class="line">               <span class="keyword">int</span> renderingType = drawItem.draw(disp);</span><br><span class="line">               <span class="keyword">if</span>(renderingType == IRenderer.CACHE_RENDERING) &#123;<span class="comment">//如果是使用缓存bitmap绘制的</span></span><br><span class="line">                   ......</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderingType == IRenderer.TEXT_RENDERING) &#123;<span class="comment">//如果使用缓存绘制失败，则会使用原声方法Canvas去draw</span></span><br><span class="line">                   ......</span><br><span class="line">                   <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       mCacheManager.addDanmaku(drawItem);<span class="comment">//再次为词条弹幕构建缓存，以便下次使用缓存bitmap绘制</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">			......</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从截取的弹幕中遍历每一个，然后一一绘制。绘制步骤有如下几步：</p>
<ul>
<li>如果弹幕还没有到出现时间，则检查它有没有缓存，如果没有则为它建立缓存；</li>
<li>measure 测量，我们之前prepareCache已经为他们在buildCache时测量过了;</li>
<li>layout 布局，计算弹幕在屏幕上应该显示的位置；</li>
<li>draw 绘制弹幕。</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们一步一步分析：<br>&#160; &#160; &#160; &#160;1）弹幕未到出现时间，检查是否建立缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用CacheManagingDrawTask的addDanmaku方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDanmaku</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//CacheHandler</span></span><br><span class="line">                  mHandler.obtainMessage(CacheHandler.ADD_DANMAKKU, danmaku).sendToTarget();</span><br><span class="line">            ......</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//CacheHandler</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">case</span> ADD_DANMAKKU:</span><br><span class="line">              BaseDanmaku item = (BaseDanmaku) msg.obj;</span><br><span class="line">              addDanmakuAndBuildCache(item);<span class="comment">//调用了addDanmakuAndBuildCache方法</span></span><br><span class="line">              <span class="keyword">break</span>;        </span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//调用了addDanmakuAndBuildCache方法</span></span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addDanmakuAndBuildCache</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//过时了 || 并且弹幕时间不在3屏弹幕时间内(因为mCaches只缓存了3屏时间内的所有弹幕，上面说过的),并且它不是直播弹幕。则不建立缓存</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.isTimeOut() || (danmaku.time &gt; mCacheTimer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION &amp;&amp; !danmaku.isLive)) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//优先级为0或者在过滤规则内，不建立缓存</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.priority == <span class="number">0</span> &amp;&amp; danmaku.isFiltered()) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">              <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;<span class="comment">//如果弹幕没有缓存</span></span><br><span class="line">                  buildCache(danmaku, <span class="keyword">true</span>);<span class="comment">//建立缓存（buildCache方法我们上面分析过，就是用来建立缓存的）</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2）测量，这个我们上面再buildCache时分析过了，不再赘述；</p>
<p>&#160; &#160; &#160; &#160;3）布局：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用DanmakusRetainer的fix方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(BaseDanmaku danmaku, IDisplayer disp, Verifier verifier)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> type = danmaku.getType();</span><br><span class="line">       <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SCROLL_RL:</span><br><span class="line">               rldrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SCROLL_LR:</span><br><span class="line">               lrdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_FIX_TOP:</span><br><span class="line">               ftdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_FIX_BOTTOM:</span><br><span class="line">               fbdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SPECIAL:</span><br><span class="line">               danmaku.layout(disp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;类型太多了，我们只分析TYPE_SCROLL_RL类型弹幕其他的就不分析，有兴趣的可以自己分析一下其他的。接着会调用AlignTopRetainer的fix方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存需要显示的弹幕容器类（保存的一行只有一条弹幕，下面会说明的），内部持有一个以弹幕的y坐标排序的TreeSet集合，这个需要注意</span></span><br><span class="line"><span class="keyword">protected</span> Danmakus mVisibleDanmakus = <span class="keyword">new</span> Danmakus(Danmakus.ST_BY_YPOS);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//AlignTopRetainer的fix方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(BaseDanmaku drawItem, IDisplayer disp, Verifier verifier)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (drawItem.isOutside())<span class="comment">//如果弹幕已经滚动到视图边界外，则不会为它布局</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">float</span> topPos = <span class="number">0</span>;<span class="comment">//弹幕的y坐标</span></span><br><span class="line">          <span class="keyword">int</span> lines = <span class="number">0</span>;<span class="comment">//弹幕在第几行显示</span></span><br><span class="line">          <span class="keyword">boolean</span> shown = drawItem.isShown();<span class="comment">//弹幕是否已经显示</span></span><br><span class="line">          <span class="keyword">boolean</span> willHit = !shown &amp;&amp; !mVisibleDanmakus.isEmpty();<span class="comment">//是否会和其他弹幕碰撞</span></span><br><span class="line">          <span class="keyword">boolean</span> isOutOfVertialEdge = <span class="keyword">false</span>;<span class="comment">//弹幕y值是否超过试图高度</span></span><br><span class="line">          BaseDanmaku removeItem = <span class="keyword">null</span>;<span class="comment">//需要移除的弹幕</span></span><br><span class="line">          <span class="comment">//为即将显示的弹幕确认位置</span></span><br><span class="line">          <span class="keyword">if</span> (!shown) &#123;</span><br><span class="line">              mCancelFixingFlag = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 确定弹幕位置开始</span></span><br><span class="line">              IDanmakuIterator it = mVisibleDanmakus.iterator();</span><br><span class="line">              <span class="comment">//这四个变量分别为：</span></span><br><span class="line">              <span class="comment">//insertItem ---- 确认目标弹幕插入到哪一行的同行参考弹幕</span></span><br><span class="line">              <span class="comment">//firstItem ---- 已经布局过的弹幕保存容器中的第一项</span></span><br><span class="line">              <span class="comment">//lastItem ---- 已经布局过的弹幕保存容器中最后一项</span></span><br><span class="line">              <span class="comment">//minRightRow ---- 已经布局过弹幕中x值最小的弹幕，即最左边的弹幕</span></span><br><span class="line">              BaseDanmaku insertItem = <span class="keyword">null</span>, firstItem = <span class="keyword">null</span>, lastItem = <span class="keyword">null</span>, minRightRow = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">boolean</span> overwriteInsert = <span class="keyword">false</span>;<span class="comment">//是否超出插入范围</span></span><br><span class="line">              <span class="comment">//遍历已经绘制过的弹幕，因为mVisibleDanmakus 内弹幕以y值排序的，所以按y值从小到大遍历</span></span><br><span class="line">              <span class="keyword">while</span> (!mCancelFixingFlag &amp;&amp; it.hasNext()) &#123;</span><br><span class="line">                  lines++;<span class="comment">//每次循环都会将行号+1</span></span><br><span class="line">                  BaseDanmaku item = it.next();</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">if</span>(item == drawItem)&#123;<span class="comment">//如果已经布局过了，说明已经存在自己位置了</span></span><br><span class="line">                      insertItem = item;<span class="comment">//将布局过的弹幕复制给参考弹幕insertItem </span></span><br><span class="line">                      lastItem = <span class="keyword">null</span>;<span class="comment">//置空 lastItem </span></span><br><span class="line">                      shown = <span class="keyword">true</span>;<span class="comment">//shown 置为true，以便末尾不再执行加入mVisibleDanmakus逻辑</span></span><br><span class="line">                      willHit = <span class="keyword">false</span>;<span class="comment">//本身已经存在自己位置了，当然没有碰壁一说</span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//怕被下面干扰晕的可以跳出去继续看</span></span><br><span class="line">                  &#125;</span><br><span class="line">			</span><br><span class="line">                  <span class="keyword">if</span> (firstItem == <span class="keyword">null</span>)<span class="comment">//找到已经布局过的弹幕第一项</span></span><br><span class="line">                      firstItem = item;</span><br><span class="line">			<span class="comment">//如果插入目标弹幕后，y值超过了视图高度</span></span><br><span class="line">                  <span class="keyword">if</span> (drawItem.paintHeight + item.getTop() &gt; disp.getHeight()) &#123;</span><br><span class="line">                      overwriteInsert = <span class="keyword">true</span>;<span class="comment">//则将超出插入范围标签置为true</span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//怕晕的跳出循环</span></span><br><span class="line">                  &#125;</span><br><span class="line">			<span class="comment">//找出最左边的弹幕</span></span><br><span class="line">                  <span class="keyword">if</span> (minRightRow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      minRightRow = item;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (minRightRow.getRight() &gt;= item.getRight()) &#123;</span><br><span class="line">                          minRightRow = item;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 检查如果插入目标弹幕是否会和正在遍历的已经布局过的参考弹幕碰撞</span></span><br><span class="line">                  willHit = DanmakuUtils.willHitInDuration(disp, item, drawItem,</span><br><span class="line">                          drawItem.getDuration(), drawItem.getTimer().currMillisecond);</span><br><span class="line">                  <span class="keyword">if</span> (!willHit) &#123;<span class="comment">//如果没有碰撞</span></span><br><span class="line">                      insertItem = item;<span class="comment">//则将它复制给参考弹幕insertItem </span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//然后跳出循环，下去确定位置</span></span><br><span class="line">                  &#125;<span class="comment">/*如果有碰撞，则继续弹幕缩小添加范围，寻找可以添加的条件，最后出while循环，下去布局*/</span></span><br><span class="line">                  </span><br><span class="line">			</span><br><span class="line">                  lastItem = item;<span class="comment">//暂时找到已经布局过的弹幕最后一项，然后继续循环</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">boolean</span> checkEdge = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">if</span> (insertItem != <span class="keyword">null</span>) &#123;<span class="comment">//已经布局过了||目标弹幕不会碰壁可以插入</span></span><br><span class="line">                  <span class="keyword">if</span> (lastItem != <span class="keyword">null</span>)<span class="comment">//目标弹幕插入，y值即为上一次遍历的弹幕的底部</span></span><br><span class="line">                      topPos = lastItem.getBottom();</span><br><span class="line">                  <span class="keyword">else</span><span class="comment">//已经布局过了，则y的位置不变</span></span><br><span class="line">                      topPos = insertItem.getTop();</span><br><span class="line">                      </span><br><span class="line">                  <span class="keyword">if</span> (insertItem != drawItem)&#123;<span class="comment">//如果目标弹幕可以插入</span></span><br><span class="line">                   <span class="comment">//这里需要注意，因为一行可以放n多条弹幕，只要前后不碰撞就行；</span></span><br><span class="line">                   <span class="comment">//所以下次我们在同一行插入弹幕判断碰壁时，当然要和这行最后一条弹幕去判断；</span></span><br><span class="line">                   <span class="comment">//因此我们移除前一条弹幕，放入插入的目标弹幕，下次添加弹幕判断时就和目标弹幕判断，然后这么循环下去</span></span><br><span class="line">                      removeItem = insertItem;</span><br><span class="line">                      </span><br><span class="line">                      shown = <span class="keyword">false</span>;<span class="comment">//置为false，以便mVisibleDanmakus 添加还未布局的新弹幕</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overwriteInsert &amp;&amp; minRightRow != <span class="keyword">null</span>) &#123;<span class="comment">//没有空行可以插入</span></span><br><span class="line">                  topPos = minRightRow.getTop();<span class="comment">//暂时放到最最左边的弹幕那一行（excuse me ？？？）</span></span><br><span class="line">                  checkEdge = <span class="keyword">false</span>;<span class="comment">//不做范围检查</span></span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastItem != <span class="keyword">null</span>) &#123;<span class="comment">//找不到插入的位置</span></span><br><span class="line">                  topPos = lastItem.getBottom();<span class="comment">//暂时放到最低位置的弹幕下面，下面检测边界时会酌情河蟹</span></span><br><span class="line">                  willHit = <span class="keyword">false</span>;<span class="comment">//置false碰壁标志</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstItem != <span class="keyword">null</span>) &#123;<span class="comment">////mVisibleDanmakus只有第一条数据，截取弹幕集的第二条弹幕没有和第一条碰壁时</span></span><br><span class="line">                  topPos = firstItem.getTop();<span class="comment">//此时第二条弹幕和第一条在同一行</span></span><br><span class="line">                  removeItem = firstItem;</span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;<span class="comment">//mVisibleDanmakus 没有数据，截取弹幕集的第一条弹幕</span></span><br><span class="line">                  topPos = <span class="number">0</span>;<span class="comment">//第一条弹幕当然在最上面</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (checkEdge) &#123;<span class="comment">//如果检查范围</span></span><br><span class="line">               <span class="comment">//检查是否超出布局范围</span></span><br><span class="line">                  isOutOfVertialEdge = isOutVerticalEdge(overwriteInsert, drawItem, disp, topPos, firstItem,</span><br><span class="line">                          lastItem);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (isOutOfVertialEdge) &#123;<span class="comment">//如果超出布局范围，等待河蟹</span></span><br><span class="line">                  topPos = <span class="number">0</span>;</span><br><span class="line">                  willHit = <span class="keyword">true</span>;</span><br><span class="line">                  lines = <span class="number">1</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removeItem != <span class="keyword">null</span>) &#123;<span class="comment">//上面可以插入目标弹幕的逻辑用上了</span></span><br><span class="line">                  lines--;<span class="comment">//因为参考弹幕和目标弹幕在同一行，但是每进入while循环一次就将行号+1，所有要减回去和参考弹幕保持相同行号</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (topPos == <span class="number">0</span>) &#123;<span class="comment">//方便加入容器</span></span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//这是河蟹规则，都是在设置DanmakuContext时指定的，比如最大行数限制，重复限制等等。</span></span><br><span class="line">	<span class="comment">//这里限于篇幅已经太长了，也实在写不动了，就不再跟下去了。内部逻辑也不难，大家有兴趣可以自己看看。</span></span><br><span class="line">          <span class="keyword">if</span> (verifier != <span class="keyword">null</span> &amp;&amp; verifier.skipLayout(drawItem, topPos, lines, willHit)) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (isOutOfVertialEdge) &#123;<span class="comment">//mVisibleDanmakus中所有弹幕绘制出来都超出范围了</span></span><br><span class="line">              clear();</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//这才是真正确认弹幕位置的地方</span></span><br><span class="line">          drawItem.layout(disp, drawItem.getLeft(), topPos);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!shown) &#123;<span class="comment">//如果还未显示，则加入即将显示的容器中。可以看到，最终会把所有截取的弹幕加入到这个容器里</span></span><br><span class="line">              mVisibleDanmakus.removeItem(removeItem);<span class="comment">//移除同一行之前的参考弹幕，保持保存的一行只有一条弹幕，上面说明过</span></span><br><span class="line">              mVisibleDanmakus.addItem(drawItem);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//清除容器，重新放入新的内容</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          mCancelFixingFlag = <span class="keyword">true</span>;</span><br><span class="line">          mVisibleDanmakus.clear();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这绝对是我写的注释最多的方法了ToT。。。。。。其实思路挺好理解的，通俗地讲就是这样的过程：</p>
<ul>
<li><strong>先添往最第一行添加一条弹幕，把它存到一个容器里（这个容器会把新添加进来的弹幕按照y值从小到大排序，而且容器只保存每一行的最后一条弹幕）</strong>。</li>
<li><strong>然后添加第二条弹幕，从第一行开始添加，先判断和第一条弹幕会不会碰壁，如果不会碰壁则添加到这一行，然后容器内移除之前第一条的弹幕，保存这一条弹幕；如果会碰壁则添加到下一行，然后容器保存这条弹幕</strong>；</li>
<li><strong>然后添加第三条，继续从第一行开始添加，先判断和第一条……(重复第二条的逻辑)……</strong>；<br>。。。。。。</li>
</ul>
<p>&#160; &#160; &#160; &#160;就是这么个思路，但是写起来真心不是随意就能写出来的。即使先不说写，把这个思路想出来，让我去设计一套规则，估计都相当困难啊。唉，人与人之间的差距始终在思维。。。。。。</p>
<p>&#160; &#160; &#160; &#160;扯远了，我们继续回归正题，上面逻辑完成了弹幕定位规则(内部那个layout接下来再讲)，限于篇幅，我只挑一个检查碰撞的代码贴出来分析，其它的请有兴趣者自行跟踪。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">willHitInDuration</span><span class="params">(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2,</span><br><span class="line">          <span class="keyword">long</span> duration, <span class="keyword">long</span> currTime)</span> </span>&#123;<span class="comment">//disp, item, drawItem, drawItem.getDuration(), drawItem.getTimer().currMillisecond</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> type1 = d1.getType();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> type2 = d2.getType();</span><br><span class="line">      <span class="comment">// allow hit if different type 不同类型的弹幕允许碰撞</span></span><br><span class="line">      <span class="keyword">if</span>(type1 != type2)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(d1.isOutside())&#123;<span class="comment">//item已经跑出视图了，不存在碰撞问题</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> dTime = d2.time - d1.time;</span><br><span class="line">      <span class="keyword">if</span> (dTime &lt;= <span class="number">0</span>)<span class="comment">//drawItem在item前面，已经碰撞了</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//两者出现时间已经相差一条弹幕时间了 || item超时跑出去了 || drawItem超时 ，都不会碰撞    </span></span><br><span class="line">      <span class="keyword">if</span> (Math.abs(dTime) &gt;= duration || d1.isTimeOut() || d2.isTimeOut()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//item和drawItem都是顶部或者底部固定弹幕，因为在同一行，必定碰撞</span></span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_FIX_TOP || type1 == BaseDanmaku.TYPE_FIX_BOTTOM) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//调用checkHitAtTime方法</span></span><br><span class="line">      <span class="keyword">return</span> checkHitAtTime(disp, d1, d2, currTime) </span><br><span class="line">              || checkHitAtTime(disp, d1, d2,  d1.time + d1.getDuration());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用checkHitAtTime方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkHitAtTime</span><span class="params">(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2, <span class="keyword">long</span> time)</span></span>&#123;<span class="comment">//time = currTime || time = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span>[] rectArr1 = d1.getRectAtTime(disp, time);<span class="comment">//time获得item在视图的（l，t，r，b）</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span>[] rectArr2 = d2.getRectAtTime(disp, time);<span class="comment">//time获得drawItem在视图的（l，t，r，b）</span></span><br><span class="line">      <span class="keyword">if</span> (rectArr1 == <span class="keyword">null</span> || rectArr2 == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> checkHit(d1.getType(), d2.getType(), rectArr1, rectArr2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用checkHit方法    </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkHit</span><span class="params">(<span class="keyword">int</span> type1, <span class="keyword">int</span> type2, <span class="keyword">float</span>[] rectArr1,</span><br><span class="line">          <span class="keyword">float</span>[] rectArr2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(type1 != type2)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_SCROLL_RL) &#123;<span class="comment">//只要drawItem的left小于item的right就碰撞了</span></span><br><span class="line">          <span class="comment">// hit if left2 &lt; right1</span></span><br><span class="line">          <span class="keyword">return</span> rectArr2[<span class="number">0</span>] &lt; rectArr1[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_SCROLL_LR)&#123;</span><br><span class="line">          <span class="comment">// hit if right2 &gt; left1</span></span><br><span class="line">          <span class="keyword">return</span> rectArr2[<span class="number">2</span>] &gt; rectArr1[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//R2LDanmaku的getRectAtTime方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">float</span>[] getRectAtTime(IDisplayer displayer, <span class="keyword">long</span> time) &#123;<span class="comment">//time = currTime || time = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">if</span> (!isMeasured())</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">float</span> left = getAccurateLeft(displayer, time);<span class="comment">//获得此时弹幕在视图的x坐标</span></span><br><span class="line">      <span class="keyword">if</span> (RECT == <span class="keyword">null</span>) &#123;</span><br><span class="line">          RECT = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">4</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      RECT[<span class="number">0</span>] = left;<span class="comment">//left</span></span><br><span class="line">      RECT[<span class="number">1</span>] = y;<span class="comment">//top</span></span><br><span class="line">      RECT[<span class="number">2</span>] = left + paintWidth;<span class="comment">//right</span></span><br><span class="line">      RECT[<span class="number">3</span>] = y + paintHeight;<span class="comment">//bottom</span></span><br><span class="line">      <span class="keyword">return</span> RECT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//R2LDanmaku的getAccurateLeft方法</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getAccurateLeft</span><span class="params">(IDisplayer displayer, <span class="keyword">long</span> currTime)</span> </span>&#123;<span class="comment">//currTime = timer.currTime || currTime = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">long</span> elapsedTime = currTime - time;<span class="comment">//当前时间 - 弹幕出现时间</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//因此返回弹幕位于视图的x坐标，即视图宽度 - 弹幕已经显示了多少秒 * 每秒移动步长</span></span><br><span class="line"><span class="keyword">return</span> displayer.getWidth() - elapsedTime * mStepX;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;检查碰撞逻辑比较简单，就是先根据当前时间就算出两条弹幕的位置（l1，t1，r1，b1），看看是否前面弹幕的 r1 小于后面弹幕的 l1；再根据前面弹幕的结束时间，计算出两条弹幕的位置（l2，t2，r2，b2）再次看看是否前面弹幕的 r2小于后面弹幕的 l2。只有两条都满足才不会碰撞。</p>
<p>&#160; &#160; &#160; &#160;好了检测碰撞就先到这里，然后继续回到AlignTopRetainer的fix方法，还有一个drawItem.layout(disp, drawItem.getLeft(), topPos);没讲呢，这才是真正确认弹幕位置的地方，继续查看L2RDanmaku的layout方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(IDisplayer displayer, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;<span class="comment">//disp, drawItem.getLeft(), topPos</span></span><br><span class="line">    <span class="keyword">if</span> (mTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> currMS = mTimer.currMillisecond;</span><br><span class="line">        <span class="keyword">long</span> deltaDuration = currMS - time;<span class="comment">//计算出出现时间和当前时间的时间差</span></span><br><span class="line">        <span class="keyword">if</span> (deltaDuration &gt; <span class="number">0</span> &amp;&amp; deltaDuration &lt; duration.value) &#123;<span class="comment">//如果还没有到出现时间或者超出弹幕时间</span></span><br><span class="line">            <span class="keyword">this</span>.x = getAccurateLeft(displayer, currMS);<span class="comment">//计算出当前时间弹幕的x坐标，上面刚讲过</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isShown()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.y = y;<span class="comment">//把上面计算好的y值赋过来</span></span><br><span class="line">                <span class="keyword">this</span>.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mLastTime = currMS;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastTime = currMS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样弹幕的位置也就确定了，layout步骤就走完了。下一步就是draw步骤了。</p>
<p>&#160; &#160; &#160; &#160;4）绘制弹幕：<br>&#160; &#160; &#160; &#160;赶紧回到DanmakuRenderer的draw方法，这个时候千万不要把自己搞晕了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuRenderer的draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(IDisplayer disp, IDanmakus danmakus, <span class="keyword">long</span> startRenderTime)</span> </span>&#123;</span><br><span class="line">        ......       </span><br><span class="line">        IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">        ......      </span><br><span class="line"></span><br><span class="line">        BaseDanmaku drawItem = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            drawItem = itr.next();</span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line">			...检查是否建立缓存...            </span><br><span class="line">			......</span><br><span class="line"></span><br><span class="line">            ...是否测量...</span><br><span class="line"></span><br><span class="line">            ...layout布局...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// draw //绘制弹幕</span></span><br><span class="line">            <span class="keyword">if</span> (!drawItem.isOutside() &amp;&amp; drawItem.isShown()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (drawItem.lines == <span class="keyword">null</span> &amp;&amp; drawItem.getBottom() &gt; disp.getHeight()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;    <span class="comment">// skip bottom outside danmaku ，忽略超过视图底部的弹幕</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始绘制</span></span><br><span class="line">                <span class="keyword">int</span> renderingType = drawItem.draw(disp);</span><br><span class="line">                <span class="keyword">if</span>(renderingType == IRenderer.CACHE_RENDERING) &#123;<span class="comment">//如果是使用缓存bitmap绘制的</span></span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderingType == IRenderer.TEXT_RENDERING) &#123;<span class="comment">//如果使用缓存绘制失败，则会使用原声方法Canvas去draw</span></span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mCacheManager.addDanmaku(drawItem);<span class="comment">//再次为词条弹幕构建缓存，以便下次使用缓存bitmap绘制</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				......    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续跟踪int renderingType = drawItem.draw(disp) 这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseDanmaku的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">draw</span><span class="params">(IDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> displayer.draw(<span class="keyword">this</span>);<span class="comment">//调用AndroidDisplayer的draw方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用AndroidDisplayer的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">draw</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">float</span> top = danmaku.getTop();<span class="comment">//弹幕在视图的y值</span></span><br><span class="line">       <span class="keyword">float</span> left = danmaku.getLeft();<span class="comment">//弹幕在视图的x值</span></span><br><span class="line">       <span class="keyword">if</span> (canvas != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">			</span><br><span class="line">           <span class="comment">// drawing cache</span></span><br><span class="line">           <span class="keyword">boolean</span> cacheDrawn = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">int</span> result = IRenderer.CACHE_RENDERING;</span><br><span class="line">           IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">           <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果弹幕有缓存</span></span><br><span class="line">            <span class="comment">//取出缓存</span></span><br><span class="line">               DrawingCacheHolder holder = (DrawingCacheHolder) cache.get();</span><br><span class="line">               <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//DrawingCacheHolder的draw方法，我们在上面的buildCache时分析过了，将每一条弹幕的bitmap绘制到视图的canvas上</span></span><br><span class="line">                   cacheDrawn = holder.draw(canvas, left, top, alphaPaint);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!cacheDrawn) &#123;<span class="comment">//如果缓存绘制失败</span></span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//则使用Android原生的canvas.drawText等方法绘制，drawDanmaku方法我们上面buildCache时也分析过</span></span><br><span class="line">               drawDanmaku(danmaku, canvas, left, top, <span class="keyword">false</span>);</span><br><span class="line">               result = IRenderer.TEXT_RENDERING;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> IRenderer.NOTHING_RENDERING;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面逻辑比较简单，先查看弹幕有没有缓存，如果有，就使用缓存绘制。在上面的buildCache时我们知道，缓存绘制的每一条弹幕都是一条bitmap，所以这里用缓存也是将bitmap绘制到视图的Canvas中。如果使用缓存绘制失败，会调用drawDanmaku方法，这个方法我们在上面的buildCache也分析过，则使用Android原生的canvas.drawText等绘制。</p>
<p>&#160; &#160; &#160; &#160;这样弹幕就被绘制到视图界面上了。        </p>
<p>&#160; &#160; &#160; &#160;终于完了，以上就是DanmakuFlameMaster的流程分析过程了，分析的快吐学了ToT。。。。。。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>&#160; &#160; &#160; &#160;上面刚开始奖CacheManagingDrawTask时曾经说过，也可以不用CacheManagingDrawTask，直接使用DrawTask，只要将<strong>DanmakuView</strong>的<strong>mEnableDanmakuDrwaingCache</strong>变量改为false就可以了。这样改动之后就用不上工程里那些so库了，也就不用建立那么复杂的缓存机制。</p>
<p>&#160; &#160; &#160; &#160;还有一点区别就是使用CacheManagingDrawTask画出来的每一条弹幕都是bitmap，而用DrawTask的弹幕都是Canvas.drawText画出来的。</p>
<p>&#160; &#160; &#160; &#160;限于篇幅，DrawTask就不分析了，逻辑比CacheManagingDrawTask简单多了，大家有兴趣的自己看看。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;DanmakuFlameMaster到此就分析完全了，简单总结一下流程就是：</p>
<ul>
<li>加载弹幕资源</li>
<li>开启缓存机制，不断建立缓存和回收</li>
<li>开始绘制任务，根据定时器时间确定弹幕位置，绘制弹幕</li>
</ul>
<p>&#160; &#160; &#160; &#160;这篇文章写的过程中也是十分蛋疼的，写的我差点over了。因为DanmakuFlameMaster源码实在太复杂了，坑非常多，所以很多细节都没有顾及。下次我绝对不会再写这么长的文章了，身体和脑力真心伤不起啊。赶紧休息一下<del>~</del>~~~~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android属性动画流程分析]]></title>
      <url>http://windrunnerlihuan.com/2016/06/24/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<blockquote>
<p>&#160; &#160; &#160; &#160;<strong>摘要</strong>：Google在Android3.0之后给我们带来了属性动画，是真正意义上的改变属性。对比以前的Tween动画，只能作用于View，而且Tween动画改变的只是View的绘制效果，View真正的属性并没有改变。比如，一个按钮做平移的动画，虽然按钮的确做了平移，但按钮可点击的区域并没随着平移而改变，还是在原来的位置。而属性动画则可以改变真正的属性，从而实现按钮平移时点击区域也跟着平移。通俗点说，属性动画其实就是在一定时间内，按照一定规律来改变对象的属性，从而使对象展现出动画效果。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160; Google在Android3.0之后给我们带来了属性动画，是真正意义上的改变属性。对比以前的Tween动画，只能作用于View，而且Tween动画改变的只是View的绘制效果，View真正的属性并没有改变。比如，一个按钮做平移的动画，虽然按钮的确做了平移，但按钮可点击的区域并没随着平移而改变，还是在原来的位置。而属性动画则可以改变真正的属性，从而实现按钮平移时点击区域也跟着平移。通俗点说，属性动画其实就是在一定时间内，按照一定规律来改变对象的属性，从而使对象展现出动画效果。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>&#160; &#160; &#160; &#160;我们要了解属性动画的原理，首先要知道他的用法。先整一个比较大众的吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator  </span><br><span class="line">  .ofInt(target,propName,values[])  </span><br><span class="line">  .setInterpolator(LinearInterpolator)  </span><br><span class="line">  .setEvaluator(IntEvaluator)  </span><br><span class="line">  .setDuration(<span class="number">1000</span>)  </span><br><span class="line">  .start();</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个应该都会吧，设置目标view，作用的属性，动画时长；设置插值器、估值器，这两个玩意设置最多的应该是插值器，估值器设置的应该比较少。这两个东西我们下面会逐一跟踪其踪迹；（当然还有对动画过程的回调监听，比如addListener，然后监听onAnimationStart、onAnimationEnd等等回调。不过我们这里没设，下面篇幅为讲到此处功能）；最后start,动画开始。</p>
<h2 id="猜想与假设"><a href="#猜想与假设" class="headerlink" title="猜想与假设"></a>猜想与假设</h2><p>&#160; &#160; &#160; &#160; 一般的对象中的某个属性，如果要改变其值，要么是这个属性对外<strong>public</strong>，拿到对象后可以直接修改；要么这个对象的类有自己的<strong>get/set</strong>方法。但这都是理想的情况，如果不满足以上条件，如果想改变对象属性的值，就只能通过<strong>反射</strong>了。我们先这样假设，然后往下逐一验证。</p>
<p>&#160; &#160; &#160; &#160; 再者属性动画，我们断章取义一下，既然有动画这个词在内，就会有在规定时间内按固定规则对象属性的改变，就像函数一样，y=f(x)。属性动画也一样，y好比属性值property，x好比时间time，f关系就是插值器/估值器（Interpolator/TypeEvaluator）的作用。（先这么假设吧，是否合理我们往下深挖就知道了）</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160; 我们按着上述猜测，然后进入验证阶段，直接整源码吧。源码文件不难找，并且都在两个固定目录，frameworks\base\core\java\android\animation\ 和 frameworks\base\core\java\android\view\animation\ 下。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160; 阅读源码不一定要把 <a href="http://source.android.com/source/index.html" target="_blank" rel="external">源码</a> 整个下载下来，比如有的在SDK里本来就有的文件，用 AS 或者 Eclipse 都可以直接看。不过我推荐有时间还是把重要的源码都下载下来，用<strong>Source Insight</strong> 或者 <strong>Sublime Text</strong> 来查看。<br>&#160; &#160; &#160; &#160;其次，阅读源码一方面能让我们更清晰的理解Android SDK提供的API的流程原理，有助于开发人员更好的使用这些功能，遇到坑会有更好的解决方案。另一方面，也能够掌握其中的思想，因为一切业务都是思想的实体化，掌握了思想，才能在以后遇到问题或者需求的时候，能很快从脑中勾勒出解决思路，而不至于一脸懵逼无从下手。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; 根据上述例子，一步一步分析。</p>
<h2 id="主流程源码"><a href="#主流程源码" class="headerlink" title="主流程源码"></a>主流程源码</h2><h3 id="ofInt"><a href="#ofInt" class="headerlink" title="ofInt"></a>ofInt</h3><p>&#160; &#160; &#160; &#160;先从ofInt入手，例如这么用：.ofInt(view, “translationX”, 100)。挑一个简单明了的重载方法，其实其他的也是相同的道理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">ofInt</span><span class="params">(Object target, String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    ObjectAnimator anim = <span class="keyword">new</span> ObjectAnimator(target, propertyName);</span><br><span class="line">    anim.setIntValues(values);</span><br><span class="line">    <span class="keyword">return</span> anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;new了一个ObjectAnimator，构造方法传入target和propName，这么不难。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ObjectAnimator</span><span class="params">(Object target, String propertyName)</span> </span>&#123;</span><br><span class="line">       setTarget(target);</span><br><span class="line">       setPropertyName(propertyName);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//有两个方法，以此往下</span></span><br><span class="line"><span class="comment">//设置目标对象target赋给属性动画全局变量mTarget </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(@Nullable Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object oldTarget = getTarget();</span><br><span class="line">       <span class="keyword">if</span> (oldTarget != target) &#123;</span><br><span class="line">           mTarget = target == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> WeakReference&lt;Object&gt;(target);</span><br><span class="line">           <span class="comment">// New target should cause re-initialization prior to starting</span></span><br><span class="line">           mInitialized = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//同上，将propertyName赋给mPropertyName </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyName</span><span class="params">(@NonNull String propertyName)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// mValues could be null if this is being constructed piecemeal. Just record the</span></span><br><span class="line">       <span class="comment">// propertyName to be used later when setValues() is called if so.</span></span><br><span class="line">       <span class="comment">// 此时mValues为空，可以忽略判断逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (mValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">           PropertyValuesHolder valuesHolder = mValues[<span class="number">0</span>];</span><br><span class="line">           String oldName = valuesHolder.getPropertyName();</span><br><span class="line">           valuesHolder.setPropertyName(propertyName);</span><br><span class="line">           mValuesMap.remove(oldName);</span><br><span class="line">           mValuesMap.put(propertyName, valuesHolder);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//赋值给全局变量</span></span><br><span class="line">       mPropertyName = propertyName;</span><br><span class="line">       <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">       mInitialized = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;记录完target和propName，调用setIntValues。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 此时mValues为空</span></span><br><span class="line">    <span class="keyword">if</span> (mValues == <span class="keyword">null</span> || mValues.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No values yet - this animator is being constructed piecemeal. Init the values with</span></span><br><span class="line">        <span class="comment">// whatever the current propertyName is</span></span><br><span class="line">        <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123; <span class="comment">// mProperty 也为空</span></span><br><span class="line">            setValues(PropertyValuesHolder.ofInt(mProperty, values));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//因此会走到这里</span></span><br><span class="line">            setValues(PropertyValuesHolder.ofInt(mPropertyName, values));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setIntValues(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后会走到setValues(PropertyValuesHolder.ofInt(mPropertyName, values)); 这里把我们传入的propName和values作为参数，又调用了PropertyValuesHolder的ofInt方法，我们先看里面这个，外面的那个setValues待会儿再看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofInt</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntPropertyValuesHolder(propertyName, values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IntPropertyValuesHolder是PropertyValuesHolder的子类，也是个内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntPropertyValuesHolder</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(propertyName);<span class="comment">//这里会调用父类的构造</span></span><br><span class="line"> setIntValues(values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类一个参数构造方法如下，将propertyName赋给全局变量mPropertyName </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PropertyValuesHolder</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">    mPropertyName = propertyName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setIntValues(values);<span class="comment">//同样会调用父类的setIntValues方法</span></span><br><span class="line">    mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;<span class="comment">// 将父类方法得到的mKeyframes 再付给mIntKeyframes </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类setIntValues方法，为mValueType 赋值，同时为利用参数values调用KeyframeSet.ofInt(values)为mKeyframes赋值 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">    mKeyframes = KeyframeSet.ofInt(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我们可以看到，PropertyValuesHolder的ofInt方法让器内部存储了我们的propName，然后存储了我们的mValueType，即 int.class ，并且保存了一个新的变量 <strong>mIntKeyframes</strong>。<br> &#160; &#160; &#160; &#160; 这个<strong>mIntKeyframes</strong>由 KeyframeSet.ofInt(values) 得到，顾名思义，这玩意儿应该是关键帧之类的意思吧。我们联想一下关键帧，视频不就是一帧一帧的画面组成么，其中有参考帧和关键帧，且参考帧解码也依赖于关键帧，因此关键帧是视频图像流畅完整的保证（扯远了，我们先这么理解吧，然后再验证我们的猜测）。<br>  &#160; &#160; &#160; &#160; <strong>mIntKeyframes</strong>类型为Keyframes，是个接口，实现类型为KeyframeSet。看着名字应该是关键帧集合吧，每个关键帧应该保存动画time/value(时间/值)对。那么继续验证，找到KeyframeSet.ofInt(values)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyframeSet <span class="title">ofInt</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeyframes = values.length;</span><br><span class="line">    IntKeyframe keyframes[] = <span class="keyword">new</span> IntKeyframe[Math.max(numKeyframes,<span class="number">2</span>)];<span class="comment">//最少应该有2帧</span></span><br><span class="line">    <span class="keyword">if</span> (numKeyframes == <span class="number">1</span>) &#123;<span class="comment">//如果只传了一个参数，比如我们前面给"translationX"属性的values传入移动300            </span></span><br><span class="line">     keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>);<span class="comment">// 起始帧，属性保持原样</span></span><br><span class="line">        keyframes[<span class="number">1</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">1f</span>, values[<span class="number">0</span>]);<span class="comment">//结束帧，直接到达结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//可以设置某个属性的多个值，比如动态改变view的alpha值，例如1.0，0.8，0.4......</span></span><br><span class="line">        keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>, values[<span class="number">0</span>]);<span class="comment">//起始帧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numKeyframes; ++i) &#123;<span class="comment">//后续n帧</span></span><br><span class="line">         <span class="comment">//注意里面有个么一个片段:(float) i / (numKeyframes - 1)，这是按values个数等比例划分的</span></span><br><span class="line">            keyframes[i] =</span><br><span class="line">                    (IntKeyframe) Keyframe.ofInt((<span class="keyword">float</span>) i / (numKeyframes - <span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframeSet(keyframes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 这里应该看到KeyframeSet.ofInt(values)方法，根据values的长度构造keyframes数组，然后分别通过Keyframe的ofInt方法，去构造keyframe对象。老规矩，继续看Keyframe.ofInt如何构造Keyframe：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> mValue;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Keyframe <span class="title">ofInt</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframe(fraction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也就简单存了一下fraction，此时value默认值为0</span></span><br><span class="line">   IntKeyframe(<span class="keyword">float</span> fraction) &#123;</span><br><span class="line">       mFraction = fraction;</span><br><span class="line">       mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Keyframe <span class="title">ofInt</span><span class="params">(<span class="keyword">float</span> fraction, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframe(fraction, value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也就简单存了一下fraction，value等</span></span><br><span class="line">   IntKeyframe(<span class="keyword">float</span> fraction, <span class="keyword">int</span> value) &#123;</span><br><span class="line">       mFraction = fraction;</span><br><span class="line">       mValue = value;</span><br><span class="line">       mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">       mHasValue = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也就简单存了一下fraction和value，每个fraction对应相应的value。前面注释我特意写了个注意，这个fraction是按照帧的个数n存的，起始为0，结束为1，也就是个个数为n的等差数列an={0，1/(n-1), 2/(n-1), 3/(n-1)，……, (n-2)/(n-1), 1}。<br>&#160; &#160; &#160; &#160;然后我们看它的 return new IntKeyframeSet(keyframes);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IntKeyframeSet构造方法，调其父类KeyframeSet构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntKeyframeSet</span><span class="params">(IntKeyframe... keyframes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(keyframes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//KeyframeSet构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KeyframeSet</span><span class="params">(Keyframe... keyframes)</span> </span>&#123;</span><br><span class="line">    mNumKeyframes = keyframes.length;</span><br><span class="line">    mKeyframes = <span class="keyword">new</span> ArrayList&lt;Keyframe&gt;();</span><br><span class="line">    mKeyframes.addAll(Arrays.asList(keyframes));</span><br><span class="line">    mFirstKeyframe = mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    mLastKeyframe = mKeyframes.get(mNumKeyframes - <span class="number">1</span>);</span><br><span class="line">    mInterpolator = mLastKeyframe.getInterpolator();<span class="comment">//这个插值器是null，感觉没什么卵用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;存了有多少关键帧，开始帧，结束帧，以及插值器。</p>
<p>&#160; &#160; &#160; &#160;到这里PropertyValuesHolder.ofInt(mPropertyName, values)走完了，这个过程我们为PropertyValuesHolder对象赋了propName，valueType，keyframeSet，而keyframeSet中又存了Keyframe集合，keyframe中存储了（fraction , valuetype , value , hasValue）。</p>
<p>&#160; &#160; &#160; &#160;上面说过setValues(int… values) 会走setValues(PropertyValuesHolder.ofInt(mPropertyName, values));这一步，这是其父类ValueAnimator的方法，我们进入其父类看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PropertyValuesHolder... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numValues = values.length;</span><br><span class="line">    mValues = values;<span class="comment">//将刚才得到的PropertyValuesHolder存入</span></span><br><span class="line">    mValuesMap = <span class="keyword">new</span> HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">    <span class="comment">//再包装一层map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        PropertyValuesHolder valuesHolder = values[i];</span><br><span class="line">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">    mInitialized = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;首先记录了mValues，注意这里的values是PropertyValuesHolder类型的，然后通过一个mValueMap记录：key为属性的名称，值为PropertyValuesHolder 。</p>
<p>&#160; &#160; &#160; &#160;到此ofInt流程算是走完了，小结一下：<strong>ofInt记录了target,propName,values（是将我们传入的int型values，辗转转化成了PropertyValuesHolder）,以及一个mValueMap，这个map的key是propName，value是PropertyValuesHolder，在PropertyValuesHolder内部又存储了proprName, valueType , keyframeSet等等</strong>。</p>
<h3 id="setInterpolator"><a href="#setInterpolator" class="headerlink" title="setInterpolator"></a>setInterpolator</h3><p>&#160; &#160; &#160; &#160;设置插值器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterpolator</span><span class="params">(TimeInterpolator value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInterpolator = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = <span class="keyword">new</span> LinearInterpolator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也是父类ValueAnimator的方法，可以看到如果没有设置插值器，默认就是线性插值器LinearInterpolator。</p>
<h3 id="setEvaluator"><a href="#setEvaluator" class="headerlink" title="setEvaluator"></a>setEvaluator</h3><p>&#160; &#160; &#160; &#160;设置估值器，这东西用的不多。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; mValues != <span class="keyword">null</span> &amp;&amp; mValues.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          mValues[<span class="number">0</span>].setEvaluator(value);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mValues就是我们刚才ofInt里得到的PropertyValuesHolder对象，然后调用PropertyValuesHolder.setEvalutor：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">    mEvaluator = evaluator;<span class="comment">// 记录evaluator</span></span><br><span class="line">    mKeyframes.setEvaluator(evaluator);<span class="comment">// KeyframeSet再次记录evaluator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;KeyframeSet再次记录evaluator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">     mEvaluator = evaluator;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;setEvaluator这一步就完了，也就是把估值器evaluator分别交给PropertyValuesHolder和KeyframeSet。</p>
<h3 id="setDuration"><a href="#setDuration" class="headerlink" title="setDuration"></a>setDuration</h3><p>&#160; &#160; &#160; &#160; 设置动画时长。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ObjectAnimator 的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectAnimator <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setDuration(duration); <span class="comment">//父类实现</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//VauleAnimator的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ValueAnimator <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Animators cannot have negative duration: "</span> +</span><br><span class="line">                   duration);</span><br><span class="line">       &#125;</span><br><span class="line">       mUnscaledDuration = duration;</span><br><span class="line">       updateScaledDuration();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sDurationScale = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mDuration = (<span class="keyword">long</span>)(<span class="number">300</span> * sDurationScale);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> mUnscaledDuration = <span class="number">300</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateScaledDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mDuration = (<span class="keyword">long</span>)(mUnscaledDuration * sDurationScale);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 就是简单在mDuration中记录了一下动画的持续时间，这个sDurationScale默认为1，貌似是用于调整，观察动画的，比如你可以调整为10，动画就会慢10倍的播放。</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>&#160; &#160; &#160; &#160; 以上的都比较简单，那么我们猜测start方法一定是巨复杂的。休息一下~<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子图"><br>&#160; &#160; &#160; &#160;OK，我们继续，走start()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//省略干扰代码</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">super</span>.start(); <span class="comment">//最终会调用父类的方法</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//ValueAnimator的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       start(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mPlayingBackwards = playBackwards; <span class="comment">//动画是否reverse</span></span><br><span class="line">       mCurrentIteration = <span class="number">0</span>;<span class="comment">//记录当前的动画的执行次数（与setRepeatCount有关）</span></span><br><span class="line">       mPlayingState = STOPPED;<span class="comment">//动画的状态为STOPPED</span></span><br><span class="line">       mStarted = <span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">       mStartedDelay = <span class="keyword">false</span>;</span><br><span class="line">       mPaused = <span class="keyword">false</span>;<span class="comment">//标志位</span></span><br><span class="line">       updateScaledDuration(); <span class="comment">// in case the scale factor has changed since creation time</span></span><br><span class="line">       AnimationHandler animationHandler = getOrCreateAnimationHandler();<span class="comment">//生成一个AnimationHandler对象，getOrCreateAnimationHandler就是在当前线程变量ThreadLocal中取出来，没有的话，则创建一个，然后set进去。</span></span><br><span class="line">       animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);<span class="comment">//AnimationHandler中包含一些List集合用于存储各种状态的ValueAnimator，将当前ValueAnimator对象，加入  animationHandler.mPendingAnimations 集合</span></span><br><span class="line">       <span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) &#123; <span class="comment">//mStartDelay 默认为0，进入</span></span><br><span class="line">           <span class="comment">// This sets the initial value of the animation, prior to actually starting it running</span></span><br><span class="line">           setCurrentPlayTime(<span class="number">0</span>); <span class="comment">//这个接下来会说明</span></span><br><span class="line">           mPlayingState = STOPPED;<span class="comment">//动画的状态为STOPPED</span></span><br><span class="line">           mRunning = <span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">           notifyStartListeners();<span class="comment">//回调监听动画的接口AnimatorListener的onAnimationStart方法，如果你设置了回调监听，此时就会进行回调。</span></span><br><span class="line">       &#125;</span><br><span class="line">       animationHandler.start();<span class="comment">//最后调用，这个会细说</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> ThreadLocal&lt;AnimationHandler&gt; sAnimationHandler =</span><br><span class="line">           <span class="keyword">new</span> ThreadLocal&lt;AnimationHandler&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AnimationHandler <span class="title">getOrCreateAnimationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       AnimationHandler handler = sAnimationHandler.get();</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           handler = <span class="keyword">new</span> AnimationHandler();</span><br><span class="line">           sAnimationHandler.set(handler);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handler;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyStartListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mListeners != <span class="keyword">null</span> &amp;&amp; !mStartListenersCalled) &#123;</span><br><span class="line">           ArrayList&lt;AnimatorListener&gt; tmpListeners =</span><br><span class="line">                   (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();</span><br><span class="line">           <span class="keyword">int</span> numListeners = tmpListeners.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">               tmpListeners.get(i).onAnimationStart(<span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       mStartListenersCalled = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;start方法做了一些状态和变量初始化，其他的都很好理解，有两处方法要细说：setCurrentPlayTime(0)和animationHandler.start()，我们先看setCurrentPlayTime(0)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentPlayTime</span><span class="params">(<span class="keyword">long</span> playTime)</span> </span>&#123;</span><br><span class="line">    initAnimation();<span class="comment">//初始化动画，接下来看</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = AnimationUtils.currentAnimationTimeMillis();<span class="comment">//得到当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (mPlayingState != RUNNING) &#123; <span class="comment">//之前将mPlayingState设为了STOPPED</span></span><br><span class="line">        mSeekTime = playTime;<span class="comment">//为0</span></span><br><span class="line">        mPlayingState = SEEKED; <span class="comment">//将mPlayingState 改为SEEKED</span></span><br><span class="line">    &#125;</span><br><span class="line">    mStartTime = currentTime - playTime;<span class="comment">//起始时间为当前时间</span></span><br><span class="line">    doAnimationFrame(currentTime);<span class="comment">//接下来也会看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 先看initAnimation()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mInitialized) &#123;</span><br><span class="line">        <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].init(); <span class="comment">//mValues也就是之前ofInt方法得到的IntPropertyValueHolder对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        mInitialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 接着找IntPropertyValueHolder的init方法，在其父类发现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We already handle int and float automatically, but not their Object</span></span><br><span class="line">        <span class="comment">// equivalents</span></span><br><span class="line">        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator :</span><br><span class="line">                (mValueType == Float.class) ? sFloatEvaluator :</span><br><span class="line">                <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// KeyframeSet knows how to evaluate the common types - only give it a custom</span></span><br><span class="line">        <span class="comment">// evaluator if one has been set on this class</span></span><br><span class="line">        mKeyframes.setEvaluator(mEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 其实就是遍历设置PropertyValuesHolder中的mEvaluator属性，默认根据valueType进行判断，IntEvaluator或者FloatEvaluator。</p>
<p>&#160; &#160; &#160; &#160;initAnimation()完了，然后看doAnimationFrame(currentTime)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPlayingState == STOPPED) &#123; <span class="comment">//上面已赋为SEEKED，所以不进入下面逻辑</span></span><br><span class="line">        mPlayingState = RUNNING;</span><br><span class="line">        <span class="keyword">if</span> (mSeekTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mStartTime = frameTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStartTime = frameTime - mSeekTime;</span><br><span class="line">            <span class="comment">// Now that we're playing, reset the seek time</span></span><br><span class="line">            mSeekTime = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;<span class="comment">//mPaused上面已赋为false</span></span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = frameTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;<span class="comment">//默认是false</span></span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mStartTime += (frameTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The frame time might be before the start time during the first frame of</span></span><br><span class="line">    <span class="comment">// an animation.  The "current time" must always be on or after the start</span></span><br><span class="line">    <span class="comment">// time to avoid animating frames at negative time intervals.  In practice, this</span></span><br><span class="line">    <span class="comment">// is very rare and only happens when seeking backwards.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</span><br><span class="line">    <span class="keyword">return</span> animationFrame(currentTime);<span class="comment">//最后只走了这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 继续跟animationFrame(currentTime)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">switch</span> (mPlayingState) &#123;<span class="comment">//上面已赋为SEEKED</span></span><br><span class="line">     <span class="keyword">case</span> RUNNING:</span><br><span class="line">     <span class="keyword">case</span> SEEKED:</span><br><span class="line">         <span class="keyword">float</span> fraction = mDuration &gt; <span class="number">0</span> ? (<span class="keyword">float</span>)(currentTime - mStartTime) / mDuration : <span class="number">1f</span>;<span class="comment">//此时currentTime和mStartTime相等，fraction为0，刚开始嘛</span></span><br><span class="line">         <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//刚开始不会走这段逻辑</span></span><br><span class="line">             <span class="keyword">if</span> (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</span><br><span class="line">                 <span class="comment">// Time to repeat</span></span><br><span class="line">                 <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">int</span> numListeners = mListeners.size();</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                         mListeners.get(i).onAnimationRepeat(<span class="keyword">this</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (mRepeatMode == REVERSE) &#123;</span><br><span class="line">                     mPlayingBackwards = !mPlayingBackwards;</span><br><span class="line">                 &#125;</span><br><span class="line">                 mCurrentIteration += (<span class="keyword">int</span>)fraction;</span><br><span class="line">                 fraction = fraction % <span class="number">1f</span>;</span><br><span class="line">                 mStartTime += mDuration;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 done = <span class="keyword">true</span>;</span><br><span class="line">                 fraction = Math.min(fraction, <span class="number">1.0f</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (mPlayingBackwards) &#123;<span class="comment">//这个是false，因为没有设置reverse</span></span><br><span class="line">             fraction = <span class="number">1f</span> - fraction;</span><br><span class="line">         &#125;</span><br><span class="line">         animateValue(fraction);<span class="comment">//最后只会走这个，继续往下看</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> done;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 然后又到了这一步animateValue(fraction)，此时fraction是0，刚开始嘛。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里会调用子类ObjectAnimator的animateValue方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object target = getTarget();</span><br><span class="line">       <span class="keyword">if</span> (mTarget != <span class="keyword">null</span> &amp;&amp; target == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// We lost the target reference, cancel and clean up.</span></span><br><span class="line">           cancel();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">super</span>.animateValue(fraction);<span class="comment">//这里调用父类的方法</span></span><br><span class="line">       <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">           mValues[i].setAnimatedValue(target);<span class="comment">//设置属性，下面会分析</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//ValueAnimator的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       fraction = mInterpolator.getInterpolation(fraction);<span class="comment">//插值器处理一下fraction</span></span><br><span class="line">       mCurrentFraction = fraction;</span><br><span class="line">       <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">           mValues[i].calculateValue(fraction);<span class="comment">//之前ofInt得到的IntPropertyValueHolder对象的calculateValue方法</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//UpdateListener监听接口开始回调，比较简单</span></span><br><span class="line">       <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> numListeners = mUpdateListeners.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">               mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我们跟一下IntPropertyValueHolder的calculateValue方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;<span class="comment">//这个fraction是经过插值器处理过的fraction</span></span><br><span class="line">    mIntAnimatedValue = mIntKeyframes.getIntValue(fraction);<span class="comment">//这里注意是IntKeyFrameSet，千万不要看错方法了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;go on，IntKeyFrameSet的getIntValue方法，fraction是经过插值器处理过的fraction ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;<span class="comment">//raction是经过插值器处理过的fraction</span></span><br><span class="line">    <span class="keyword">if</span> (mNumKeyframes == <span class="number">2</span>) &#123;<span class="comment">//在ofInt里只设置了一个value，则只有两个关键帧，上面分析过</span></span><br><span class="line">        <span class="keyword">if</span> (firstTime) &#123;<span class="comment">//默认是true</span></span><br><span class="line">            firstTime = <span class="keyword">false</span>;</span><br><span class="line">            firstValue = ((IntKeyframe) mKeyframes.get(<span class="number">0</span>)).getIntValue();<span class="comment">//取起始帧的value，为0</span></span><br><span class="line">            lastValue = ((IntKeyframe) mKeyframes.get(<span class="number">1</span>)).getIntValue();<span class="comment">//结束帧的value，即我们设进去的值</span></span><br><span class="line">            deltaValue = lastValue - firstValue;<span class="comment">//计算delta值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInterpolator != <span class="keyword">null</span>) &#123;<span class="comment">//这玩意儿是null，他是IntKeyFrameSet的，不是ObjectAnimator的</span></span><br><span class="line">            fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;<span class="comment">//估值器，其实此处设与不设一样，实现都是firstValue + (int)(fraction * deltaValue)；这个很好看懂，想想函数y=f(X)之类，return的就是y</span></span><br><span class="line">            <span class="keyword">return</span> firstValue + (<span class="keyword">int</span>)(fraction * deltaValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//扒一下IntEvaluator和上面那个一样</span></span><br><span class="line">            <span class="keyword">return</span> ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面逻辑是ofInt设置了多个value的</span></span><br><span class="line">    <span class="keyword">if</span> (fraction &lt;= <span class="number">0f</span>) &#123;<span class="comment">//小于区间范围，将第0和第1帧作为参考</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);<span class="comment">//第1帧</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">1</span>);<span class="comment">//第2帧</span></span><br><span class="line">        <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();<span class="comment">//第1帧的属性值y1</span></span><br><span class="line">        <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();<span class="comment">//第2帧属性值y2</span></span><br><span class="line">        <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();<span class="comment">//第1帧的关系因子，x1</span></span><br><span class="line">        <span class="keyword">float</span> nextFraction = nextKeyframe.getFraction();<span class="comment">//第2帧的关系因子，x2</span></span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;<span class="comment">//null</span></span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(x-x1)/(x2-x1)</span></span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);</span><br><span class="line">        <span class="comment">//y=y1 + (x-x1)/(x2-x1)*(y2-y1),怎么样，直线方程既视感</span></span><br><span class="line">        <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                        intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//大于区间范围，将倒1和倒2帧作为参考，一下逻辑同上</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">        <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">        <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">float</span> nextFraction = nextKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);</span><br><span class="line">        <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常范围</span></span><br><span class="line">    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mNumKeyframes; ++i) &#123;<span class="comment">//循环遍历</span></span><br><span class="line">        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);</span><br><span class="line">        <span class="keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;<span class="comment">//这就比较好理解了，就进参考，往下逻辑同上</span></span><br><span class="line">            <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">            <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> intervalFraction = (fraction - prevKeyframe.getFraction()) /</span><br><span class="line">                (nextKeyframe.getFraction() - prevKeyframe.getFraction());</span><br><span class="line">            <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                    prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                            intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        prevKeyframe = nextKeyframe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// shouldn't get here</span></span><br><span class="line">    <span class="comment">//确实不该到这儿，google注释都这么说了</span></span><br><span class="line">    <span class="keyword">return</span> ((Number)mKeyframes.get(mNumKeyframes - <span class="number">1</span>).getValue()).intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;看注释是不是有种学霸附体的感觉^  。^至于第一种在ofInt里只设置了一个value，则只有两个关键帧，这个很好理解。可以比喻为：已知x和y成线性关系，公式为y=kx+b，告知其中一点x值为x1，求y1。一次函数的直视感。</p>
<p>&#160; &#160; &#160; &#160;第二种设置多个value也很好理解，因为动画是连续的，这是个连续函数，所以函数曲线是一条连续的线。每个关键帧都是连续函数上的固定点。虽然函数图像是连续的，但是他确是个分段函数，这些关键帧就是分段函数的拐点，而两个拐点之间的规则是一样的，就是我们定义的插值器interpolator 。<br>&#160; &#160; &#160; &#160;动画之间都是连续的，如果要求出某个时间段对象的属性值，一定要参考距离它最近两帧。所以问题就转为已知两点坐标（x1，y1），（x2，y2），和另一点的x值，求其y值。果断高一数学的直线方程整起：<br>$$    \dfrac{x-x1 }{x2-x1} = \dfrac{y-y1}{y2-y1} $$</p>
<p>$$    y=\dfrac{(x-x1) * (y2-y1) }{x2-x1} +y1 $$</p>
<p>&#160; &#160; &#160; &#160;IntKeyFrameSet的getIntValue方法就分析玩了，然后找到之前的逻辑。这样就求出属性值了，并把它赋给了ObjectAnimator的IntPropertyValueHolder类对象mValues的mIntAnimatedValue中。回到上面的子类animateValue(fraction)方法，还有一步mValues[i].setAnimatedValue(target)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIntProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mIntProperty.setValue(target, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProperty.set(target, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mJniSetter != <span class="number">0</span>) &#123;</span><br><span class="line">        nCallIntMethod(target, mJniSetter, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTmpValueArray[<span class="number">0</span>] = mIntAnimatedValue;</span><br><span class="line">            mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;果然有反射，看来我们的猜测八九不离十。这样就把刚才计算的属性值设置给目标对象了。</p>
<p>&#160; &#160; &#160; &#160;确实有点晕了。。。。。回一下神，赶紧回到ObjectAnimator父类ValueAnimator的start方法里，还要继续分析第二个重要地方animationHandler.start()。animationHandler我们上面已经介绍了，存储在当前线程的ThreadLocal里面，里面放了一些集合用于存储各种状态的ObjectAnimator，我们当前的ObjectAnimator对象也存储在其mPendingAnimations的集合中（上面提到过~~）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    scheduleAnimation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAnimationScheduled) &#123;<span class="comment">//mAnimationScheduled默认false</span></span><br><span class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, <span class="keyword">this</span>, <span class="keyword">null</span>);<span class="comment">//Choreographer.CALLBACK_ANIMATION为1</span></span><br><span class="line">        mAnimationScheduled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;要用到mChoreographer这个对象的postCallback方法，其中有一个参数是this；至于什么是Choreographer，暂时不用管；但是你需要知道一件事，其实我们的animationHandler是Runnable的子类，而 mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null);类似与handler发送消息，最终执行这个Runnable的run方法。<br>&#160; &#160; &#160; &#160;Choreographer这个类里面障眼法太多了，就不贴了。绕来绕去，其实就是一句话，这里调用了animationHandler的 run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">        doAnimationFrame(mChoreographer.getFrameTime());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mPendingAnimations holds any animations that have requested to be started</span></span><br><span class="line">        <span class="comment">// We're going to clear mPendingAnimations, but starting animation may</span></span><br><span class="line">        <span class="comment">// cause more to be added to the pending list (for example, if one animation</span></span><br><span class="line">        <span class="comment">// starting triggers another starting). So we loop until mPendingAnimations</span></span><br><span class="line">        <span class="comment">// is empty.</span></span><br><span class="line">        <span class="keyword">while</span> (mPendingAnimations.size() &gt; <span class="number">0</span>) &#123;<span class="comment">//while循环，遍历所有在mPendingAnimations中的ObjectAnimator，依次调用anim.startAnimation(this);</span></span><br><span class="line">            ArrayList&lt;ValueAnimator&gt; pendingCopy =</span><br><span class="line">                    (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone();</span><br><span class="line">            mPendingAnimations.clear();</span><br><span class="line">            <span class="keyword">int</span> count = pendingCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = pendingCopy.get(i);</span><br><span class="line">                <span class="comment">// If the animation has a startDelay, place it on the delayed list</span></span><br><span class="line">                <span class="keyword">if</span> (anim.mStartDelay == <span class="number">0</span>) &#123;<span class="comment">//不延时的直接start</span></span><br><span class="line">                    anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//延时的先加入mDelayedAnims队列</span></span><br><span class="line">                    mDelayedAnims.add(anim);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, process animations currently sitting on the delayed queue, adding</span></span><br><span class="line">        <span class="comment">// them to the active animations if they are ready</span></span><br><span class="line">        <span class="comment">//看有多少延时的，如果延时的时间到了就加入到准备队列mReadyAnims</span></span><br><span class="line">        <span class="keyword">int</span> numDelayedAnims = mDelayedAnims.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDelayedAnims; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = mDelayedAnims.get(i);</span><br><span class="line">            <span class="keyword">if</span> (anim.delayedAnimationFrame(frameTime)) &#123;<span class="comment">//看方法注释就是说如果延时到了就该加入动画准备集合</span></span><br><span class="line">                mReadyAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备队列的开始start</span></span><br><span class="line">        <span class="keyword">int</span> numReadyAnims = mReadyAnims.size();</span><br><span class="line">        <span class="keyword">if</span> (numReadyAnims &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numReadyAnims; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = mReadyAnims.get(i);</span><br><span class="line">                anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">                anim.mRunning = <span class="keyword">true</span>;</span><br><span class="line">                mDelayedAnims.remove(anim);</span><br><span class="line">            &#125;</span><br><span class="line">            mReadyAnims.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now process all active animations. The return value from animationFrame()</span></span><br><span class="line">        <span class="comment">// tells the handler whether it should now be ended</span></span><br><span class="line">        <span class="comment">//将animationHandler的mAnimations集合中的每个anim，加入到mTmpAnimations中；</span></span><br><span class="line">        <span class="keyword">int</span> numAnims = mAnimations.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">            mTmpAnimations.add(mAnimations.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次调用mTmpAnimations中的anim，anim.doAnimationFrame(frameTime)。doAnimationFrame（frameTime）上面已经分析过了，如果返回true，即doAnimationFrame的done为true，则将该动画加入到结束动画集合。 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = mTmpAnimations.get(i);</span><br><span class="line">            <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</span><br><span class="line">                mEndingAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mTmpAnimations.clear();</span><br><span class="line">        <span class="comment">//循环调用mEndingAnims， mEndingAnims.get(i).endAnimation(this);内部，会将动画移除mAnimations，回调动画监听接口onAnimationEnd；以及重置各种标志变量。</span></span><br><span class="line">        <span class="keyword">if</span> (mEndingAnims.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mEndingAnims.size(); ++i) &#123;</span><br><span class="line">                mEndingAnims.get(i).endAnimation(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mEndingAnims.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are still active or delayed animations, schedule a future call to</span></span><br><span class="line">        <span class="comment">// onAnimate to process the next frame of the animations.</span></span><br><span class="line">        <span class="comment">//如果mAnimations不为null，则再次调用scheduleAnimation();</span></span><br><span class="line">        <span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</span><br><span class="line">            scheduleAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * Internal function called to process an animation frame on an animation that is currently</span><br><span class="line"> * sleeping through its &lt;code&gt;startDelay&lt;/code&gt; phase. The return value indicates whether it</span><br><span class="line"> * should be woken up and put on the active animations queue.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> currentTime The current animation time, used to calculate whether the animation</span><br><span class="line"> * has exceeded its &lt;code&gt;startDelay&lt;/code&gt; and should be started.</span><br><span class="line"> * <span class="doctag">@return</span> True if the animation's &lt;code&gt;startDelay&lt;/code&gt; has been exceeded and the animation</span><br><span class="line"> * should be added to the set of active animations.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">delayedAnimationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStartedDelay) &#123;<span class="comment">//默认false</span></span><br><span class="line">        mStartedDelay = <span class="keyword">true</span>;</span><br><span class="line">        mDelayStartTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;<span class="comment">//默认false</span></span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;<span class="comment">//默认false</span></span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mDelayStartTime += (currentTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> deltaTime = currentTime - mDelayStartTime;<span class="comment">//延时间隔</span></span><br><span class="line">    <span class="keyword">if</span> (deltaTime &gt; mStartDelay) &#123;<span class="comment">//延时超了规定延时时间，应该执行了</span></span><br><span class="line">        <span class="comment">// startDelay ended - start the anim and record the</span></span><br><span class="line">        <span class="comment">// mStartTime appropriately</span></span><br><span class="line">        mStartTime = currentTime - (deltaTime - mStartDelay);</span><br><span class="line">        mPlayingState = RUNNING;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(AnimationHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</span><br><span class="line">        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, getNameForTrace(),</span><br><span class="line">                System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    initAnimation();</span><br><span class="line">    handler.mAnimations.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span> &amp;&amp; mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Listeners were already notified in start() if startDelay is 0; this is</span></span><br><span class="line">        <span class="comment">// just for delayed animations</span></span><br><span class="line">        notifyStartListeners();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;scheduleAnimation()一旦调用，就像Handler不停发消息一样，AnimationHandler的run方法就会一直调用，mChoreographer.getFrameTime()控制动画时间段，然后一直调用AnimationHandler的doAnimationFrame方法，这个方法里面又调用了ValueAnimator的doAnimationFrame方法，这个方法上面分析过了，就是计算属性应该的值，然后反射设置；再startAnimation通知回调。这样动画就一帧一帧的执行了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#160; &#160; &#160; &#160;ofInt中实例化了一个ObjectAnimator对象，然后设置了target，propName，values(PropertyValuesHolder) ；然后分别在setInterpolator，setDuration设置了Interpolator和duration。其中setEvaluator是给PropertyValuesHolder，以及keyframeSet设置估值算法。</p>
<p>&#160; &#160; &#160; &#160;PropertyValueHolder实际上是IntPropertyValueHolder类型对象，包含propName,valueType,keyframeSet .</p>
<p>&#160; &#160; &#160; &#160;keyframeset中存了Keyframe集合，keyframe中存储了（fraction , valuetype , value , hasValue）。</p>
<p>&#160; &#160; &#160; &#160;start()中：<br>&#160; &#160; &#160; &#160;首先更新动画各种状态，然后初步计算fraction为(currentTime - mStartTime) / mDuration；然后将这个fraction交给我们的插值器计算后得到新的fraction，再将新的fraction交给我们的估值算法，估值算法根据开始、结束、fraction得到当前属性（动画作用的属性）应该的值，最大调用反射进行设置；<br>&#160; &#160; &#160; &#160;start中还会根据动画的状态，如果没有结束，不断的调用AnimationHanlder的run方法;该方法内部利用mChoreographer不断的去重复第一步。</p>
<p>&#160; &#160; &#160; &#160;至此属性动画流程分析完了，也算马马虎虎，至少和我们的猜想八九不离十。看源码看的也快吐血了，这么长代码也只能了解个大概，以后有时间再好好整理一下思路。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android跨进程通信机制Binder简要分析]]></title>
      <url>http://windrunnerlihuan.com/2016/06/12/Binder%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160; 在Android系统中，每个应用都是由四大组件中之几组成，我们经常要去写一些Activity或者Service，这些Activity或者Service有时候会运行在不同的进程中，如果我们要让这些不同的Activity或者Service之间通信，就要用到Android提供的Binder机制了。</p>
<blockquote>
<p>&#160;&#160;&#160;&#160;Binder其实也不是Android提出来的一套新的进程间通信机制，它是基于<a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">OpenBinder</a>来实现的。OpenBinder最先是由<a href="https://en.wikipedia.org/wiki/Be_Inc." target="_blank" rel="external">Be Inc.</a>开发的，接着<a href="https://en.wikipedia.org/wiki/Palm,_Inc." target="_blank" rel="external">Palm Inc.</a>也着使用。现在OpenBinder的作者<a href="http://www.angryredplanet.com/~hackbod/" target="_blank" rel="external">Dianne Hackborn</a>就是在Google工作，负责Android平台的开发工作。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; Android系统是基于Linux内核的，Linux已经拥有管道，system V IPC，socket等IPC手段，比如pipe管道（有血缘关系的进程），fifo有名管道（无血缘关系的进程），mmap/munmap内存共享映射，Unix Domain Socket等等。但是Android却采用了Binder这种不同上述几种类型的特有机制，至于原因肯定有很多，比如安全，实现方式合理性，内存优化，性能等等。（这一块儿坑的很多，需要积累很多linux系统相关内容，我也是恶补了许多知识。并且Binder远远不是三言两语能够概括清楚的，所以很多底层细节无法为大家展现，比如内核部分代码细节。既然不幸入坑了，我们就一步一步往下挖吧=。=）<br><a id="more"></a></p>
<hr>
<h1 id="Binder通信模型"><a href="#Binder通信模型" class="headerlink" title="Binder通信模型"></a>Binder通信模型</h1><h2 id="Binder的优势"><a href="#Binder的优势" class="headerlink" title="Binder的优势"></a>Binder的优势</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>&#160; &#160; &#160; &#160; Binder使用Client-Server通信方式：一个进程作为Server提供诸如视频/音频解码，视频捕获，地址本查询，网络连接等服务；多个进程作为Client向Server发起服务请求，获得所需要的服务。要想实现Client-Server通信据必须实现以下两点：一是server必须有确定的访问接入点或者说地址来接受Client的请求，并且Client可以通过某种途径获知Server的地址；二是制定Command-Reply协议来传输数据。例如在网络通信中Server的访问接入点就是Server主机的IP地址+端口号，传输协议为TCP协议。对Binder而言，Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>&#160; &#160; &#160; &#160; 如果是传统的Linux IPC方式中，socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。</p>
<p>&#160; &#160; &#160; &#160; 举个例子如，Client要将一块内存数据传递给Server，一般的做法是，Client将这块数据从它的进程空间拷贝到内核空间中，然后内核再将这个数据从内核空间拷贝到Server的进程空间，这样，Server就可以访问这个数据了。但是在这种方法中，执行了两次内存拷贝操作。所以Binder设计时采用了折衷的方式，只需要把Client进程空间的数据拷贝一次到内核空间，然后Server与内核共享这个数据就可以了，整个过程只需要执行一次内存拷贝，提高了效率。同时这样更有C/S架构的模型，方便管理。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>&#160; &#160; &#160; &#160; Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</p>
<p>&#160; &#160; &#160; &#160; 基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式的安全性，这就是Binder。Binder为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。</p>
<h2 id="通信方式和引用"><a href="#通信方式和引用" class="headerlink" title="通信方式和引用"></a>通信方式和引用</h2><p>&#160; &#160; &#160; &#160; 与其它IPC不同，Binder使用了面向对象的思想来描述作为访问接入点的Binder及其在Client中的入口：Binder是一个实体位于Server中的对象，该对象提供了一套方法用以实现对服务的请求，就象类的成员函数。遍布于client中的入口可以看成指向这个binder对象的‘指针’，一旦获得了这个‘指针’就可以调用该对象的方法访问server。在Client看来，通过Binder‘指针’调用其提供的方法和通过指针调用其它任何本地对象的方法并无区别，尽管前者的实体位于远端Server中，而后者实体位于本地内存中。‘指针’是C/C++的术语，换成java的说法是引用，即Client通过Binder的引用访问Server。如果借用Windows系统开发的一个术语‘句柄’也可以用来表述Binder在Client中的存在方式。从通信的角度看，Client中的Binder也可以看作是Server Binder的<code>‘代理’</code>，在本地代表远端Server为Client提供服务。本文中会使用‘引用’或‘句柄’这个两广泛使用的术语。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160; 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。最诱人的是，这个引用和Java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; 当然面向对象只是针对应用程序而言，对于Binder驱动和内核其它模块一样使用C语言实现，没有类和对象的概念。Binder驱动为面向对象的进程间通信提供底层支持。</p>
<h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h2><p>&#160; &#160; &#160; &#160; 从英文字面上意思看，Binder具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户空间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了，其中，核心组件便是Binder驱动程序了，Service Manager提供了辅助管理的功能，Client和Server正是在Binder驱动和Service Manager提供的基础设施上，进行Client-Server之间的通信。这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，Service Manager是域名服务器（DNS），Binder驱动是路由器。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p>&#160; &#160; &#160; &#160; 和路由器一样，Binder驱动虽然默默无闻，却是通信的核心。尽管名叫‘驱动’，实际上和硬件设备没有任何关系，只是实现方式和设备驱动程序是一样的：它工作于内核态，提供open()，mmap()，poll()，ioctl()等标准文件操作，以字符驱动设备中的misc设备注册在设备目录/dev下，用户通过/dev/binder访问该它。驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。驱动和应用程序之间定义了一套接口协议，主要功能由ioctl()接口实现，不提供read()，write()接口，因为ioctl()灵活方便，且能够一次调用实现先写后读以满足同步交互，而不必分别调用write()和read()。Binder驱动的代码每个分支位置不一样，再加上我也没有下内核的代码，<a href="https://android.googlesource.com/kernel/common/+/android-4.4/drivers/android/binder.c" target="_blank" rel="external">这里</a>先给个4.4的<code>Binder.c</code>的地址,有兴趣的可以自己研究。</p>
<h3 id="ServiceManager-与实名Binder"><a href="#ServiceManager-与实名Binder" class="headerlink" title="ServiceManager 与实名Binder"></a>ServiceManager 与实名Binder</h3><p>&#160; &#160; &#160; &#160; 和DNS类似，ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。注册了名字的Binder叫实名Binder，就象每个网站除了有IP地址外还有自己的网址。Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名叫张三的Binder，它位于某个Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及ServiceManager对实体的引用，将名字及新建的引用打包传递给ServiceManager。ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。</p>
<p>&#160; &#160; &#160; &#160; 细心的读者可能会发现其中的蹊跷：ServiceManager是一个进程，Server是另一个进程，Server向ServiceManager注册Binder必然会涉及进程间通信。当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。Binder的实现比较巧妙：预先创造一只鸡来孵蛋：ServiceManager和其它进程同样采用Binder通信，ServiceManager是Server端，有自己的Binder对象（实体），其它进程都是Client，需要通过这个Binder的引用来实现Binder的注册，查询和获取。ServiceManager提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成ServiceManager（会用到ioctl(fd, cmd, arg)函数，cmd为BINDER_SET_CONTEXT_MGR）时Binder驱动会自动为它创建Binder实体（这就是那只预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。也就是说，一个Server若要向ServiceManager注册自己Binder就必需通过0（即NULL指针）这个引用号和ServiceManager的Binder通信。类比网络通信，0号引用就好比域名服务器的地址，你必须预先手工或动态配置好。要注意这里说的Client是相对ServiceManager而言的，一个应用程序可能是个提供服务的Server，但对ServiceManager来说它仍然是个Client。</p>
<h3 id="Client-获得实名Binder的引用"><a href="#Client-获得实名Binder的引用" class="headerlink" title="Client 获得实名Binder的引用"></a>Client 获得实名Binder的引用</h3><p>&#160; &#160; &#160; &#160; Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Client也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请获得名字叫张三的Binder的引用。ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder的引用，将该引用作为回复发送给发起请求的Client。从面向对象的角度，这个Binder对象现在有了两个引用：一个位于ServiceManager中，一个位于发起请求的Client中。如果接下来有更多的Client请求该Binder，系统中就会有更多的引用指向该Binder，就象java里一个对象存在多个引用一样。而且类似的这些指向Binder的引用是强类型，从而确保只要有引用Binder实体就不会被释放掉。通过以上过程可以看出，ServiceManager象个火车票代售点，收集了所有火车的车票，可以通过它购买到乘坐各趟火车的票-得到某个Binder的引用。</p>
<h3 id="匿名-Binder"><a href="#匿名-Binder" class="headerlink" title="匿名 Binder"></a>匿名 Binder</h3><p>&#160; &#160; &#160; &#160; 并不是所有Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。如果我们是从事application开发，跨进程的自己手写AIDL文件，或者相同进程的bindService自己添加一个继承Binder的子类，那么这个Binder没有向ServiceManager注册名字，所以是个匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。</p>
<hr>
<p>好了，理论性的科普先到这里，再继续下去估计要扑（pu）街（gai）了 =。=，先来美图放松放松。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6Binder%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子图"></p>
<h1 id="Binder机制跨进程原理"><a href="#Binder机制跨进程原理" class="headerlink" title="Binder机制跨进程原理"></a>Binder机制跨进程原理</h1><p>&#160; &#160; &#160; &#160; 上文给出了Binder的通信模型，指出了通信过程的四个角色: Client, Server, ServiceManager, driver; 但是我们仍然不清楚<code>Client到底是如何与Server完成通信的</code>,因为实现细节我们还没讲。</p>
<p>&#160; &#160; &#160; &#160; 虽然Binder用到了面向对象的思想，但并不限制应用程序一定要使用面向对象的语言，无论是C语言还是C++语言都可以很容易的使用Binder来通信。例如尽管Android主要使用java/C++，象ServiceManager这么重要的进程就是用C语言实现的。</p>
<p>&#160; &#160; &#160; &#160; Binder本质上只是一种底层通信方式，和具体服务没有关系。为了提供具体服务，Server必须提供一套接口函数以便Client通过远程访问使用各种服务。这时通常采用Proxy设计模式：将接口函数定义在一个抽象类中，Server和Client都会以该抽象类为基类实现所有接口函数，所不同的是Server端是真正的功能实现，而Client端是对这些函数远程调用请求的包装。如何将Binder和Proxy设计模式结合起来是应用程序实现面向对象Binder通信的根本问题。</p>
<h2 id="Binder-在Server端的表述-–-Binder实体"><a href="#Binder-在Server端的表述-–-Binder实体" class="headerlink" title="Binder 在Server端的表述 – Binder实体"></a>Binder 在Server端的表述 – Binder实体</h2><p>&#160; &#160; &#160; &#160; 做为Proxy设计模式的基础，首先定义一个抽象接口类封装Server所有功能，其中包含一系列纯虚函数留待Server和Proxy各自实现（如果是java层则为接口方法，或者是AIDL文件，编译后大同小异）。由于这些函数需要跨进程调用，须为其一一编号，从而Server可以根据收到的编号决定调用哪个函数。其次就要引入Binder了。Server端定义另一个Binder抽象类处理来自Client的Binder请求数据包，其中最重要的成员是虚函数onTransact()。该函数分析收到的数据包，调用相应的接口函数处理请求。</p>
<p>&#160; &#160; &#160; &#160; 接下来采用继承方式以接口类和Binder抽象类为基类构建Binder在Server中的实体，实现基类里所有的虚函数，包括公共接口函数以及数据包处理函数：onTransact()。这个函数的输入是来自Client的binder_transaction_data结构的数据包（java层为Parcel对象，对应native层还是这个结构体某一部分）。前面提到，该结构里有个成员code，包含这次请求的接口函数编号。onTransact()将case-by-case地解析code值，从数据包里取出函数参数，调用接口类中相应的，已经实现的公共接口函数。函数执行完毕，如果需要返回数据就再构建一个binder_transaction_data包将返回数据包填入其中。</p>
<p>&#160; &#160; &#160; &#160; 那么各个Binder实体的onTransact()又是什么时候调用呢？这就需要驱动参与了。前面说过，Binder实体须要以Binde传输结构flat_binder_object形式发送给其它进程才能建立Binder通信，而Binder实体指针就存放在该结构的handle域中。驱动根据Binder位置数组从传输数据中获取该Binder的传输结构，为它创建位于内核中的Binder节点，将Binder实体指针记录在该节点中。如果接下来有其它进程向该Binder发送数据，驱动会根据节点中记录的信息将Binder实体指针填入binder_transaction_data的target.ptr中返回给接收线程。接收线程从数据包中取出该指针，reinterpret_cast成Binder抽象类并调用onTransact()函数。由于这是个虚函数，不同的Binder实体中有各自的实现，从而可以调用到不同Binder实体提供的onTransact()。</p>
<h2 id="Binder-在Client端的表述-–-Binder引用"><a href="#Binder-在Client端的表述-–-Binder引用" class="headerlink" title="Binder 在Client端的表述 – Binder引用"></a>Binder 在Client端的表述 – Binder引用</h2><p>&#160; &#160; &#160; &#160; 做为Proxy设计模式的一部分，Client端的Binder同样要继承Server提供的公共接口类并实现公共函数。但这不是真正的实现，而是对远程函数调用的包装：将函数参数打包，通过Binder向Server发送申请并等待返回值。为此Client端的Binder还要知道Binder实体的相关信息，即对Binder实体的引用。该引用或是由ServiceManager转发过来的，对实名Binder的引用或是由另一个进程直接发送过来的，对匿名Binder的引用。</p>
<p>&#160; &#160; &#160; &#160; 由于继承了同样的公共接口类，Client Binder提供了与Server Binder一样的函数原型，使用户感觉不出Server是运行在本地还是远端。Client Binder中，公共接口函数的包装方式是：创建一个binder_transaction_data数据包，将其对应的编码填入code域，将调用该函数所需的参数填入data.buffer指向的缓存中，并指明数据包的目的地，那就是已经获得的对Binder实体的引用，填入数据包的target.handle中。注意这里和Server的区别：实际上target域是个联合体，包括ptr和handle两个成员，前者用于接收数据包的Server，指向 Binder实体对应的内存空间；后者用于作为请求方的Client，存放Binder实体的引用，告知驱动数据包将路由给哪个实体。数据包准备好后，通过驱动接口发送出去。经过BC_TRANSACTION/BC_REPLY回合完成函数的远程调用并得到返回值。</p>
<hr>
<p>&#160; &#160; &#160; &#160; 以上主要是C++层实现步骤，java层也相同原理，只不过最终还会通过JNI调用C++层实现方法。<br>&#160; &#160; &#160; &#160; 我们举个栗子来描述会更通俗易懂一些：</p>
<p>&#160; &#160; &#160; &#160; 假设Client进程想要调用Server进程的<code>object</code>对象的一个方法<code>add</code>;<br>&#160; &#160; &#160; &#160; 首先，Server进程要向ServiceManager注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉ServiceManager，它叫<code>zhangsan</code>，它有一个<code>object</code>对象，可以执行<code>add</code> 操作；于是ServiceManager建立了一张表：<code>zhangsan</code>这个名字对应进程Server; </p>
<p>&#160; &#160; &#160; &#160; 然后Client向ServiceManager查询：我需要联系一个名字叫做<code>zhangsan</code>的进程里面的<code>object</code>对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的<code>object</code>对象，而是返回一个看起来跟<code>object</code>一模一样的代理对象<code>objectProxy</code>，这个<code>objectProxy</code>也有一个<code>add</code>方法，但是这个<code>add</code>方法没有Server进程里面<code>object</code>对象的<code>add</code>方法那个能力；<code>objectProxy</code>的<code>add</code>只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了ServiceManager的流程)</p>
<p>&#160; &#160; &#160; &#160; 但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着<code>objectProxy</code>对象然后调用<code>add</code>方法；我们说过，这个<code>add</code>什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>&#160; &#160; &#160; &#160; 驱动收到这个消息，发现是这个<code>objectProxy</code>；一查表就明白了：我之前用<code>objectProxy</code>替换了<code>object</code>发送给Client了，它真正应该要访问的是<code>object</code>对象的<code>add</code>方法；于是Binder驱动通知Server进程，调用你的<code>object</code>对象的<code>add</code>方法，然后把结果发给我，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给Client进程；于是整个过程就完成了。</p>
<p>&#160; &#160; &#160; &#160; 由于驱动返回的<code>objectProxy</code>与Server进程里面原始的<code>object</code>是如此相似，给人感觉好像是<strong>直接把Server进程里面的对象<code>object</code>传递到了Client进程</strong> ；因此，我们可以说<strong>Binder对象是可以进行跨进程传递的对象</strong>。</p>
<p>&#160; &#160; &#160; &#160; 但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p>
<p>&#160; &#160; &#160; &#160; 理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是代理模式, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>&#160; &#160; &#160; &#160; 另外我们为了简化整个流程，隐藏了ServiceManager这一部分驱动进行的操作；实际上，由于ServiceManager与Server通常不在一个进程，Server进程向ServiceManager注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：ServiceManager中存在的Server端的对象实际上也是代理对象，后面Client向ServiceManager查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>&#160; &#160; &#160; &#160; 一句话总结就是：<strong>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信</strong>。</p>
<h1 id="分析Java层的Binder"><a href="#分析Java层的Binder" class="headerlink" title="分析Java层的Binder"></a>分析Java层的Binder</h1><p>&#160; &#160; &#160; &#160;  Android系统的很多服务都是由C++层的Binder实现，过程复杂先不说，主要是代码量巨多，分析起来篇幅远远不够，即使不分析完全，估计粘一半代码都快吐血了，所以就选了java层的Binder，会重点分析AIDL过程。</p>
<p>&#160; &#160; &#160; &#160;  我们使用AIDL接口的时候，经常会接触到这些类：<strong>IBinder/IInterface/Binder/BinderProxy/Stub</strong>，相关功能如下：</p>
<ul>
<li>IBinder是一个接口，它代表了<strong>一种跨进程传输的能力</strong>；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是<strong>Binder本地对象</strong>。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<h2 id="AIDL过程分析"><a href="#AIDL过程分析" class="headerlink" title="AIDL过程分析"></a>AIDL过程分析</h2><p>&#160; &#160; &#160; &#160; 现在我们通过一个AIDL的使用，分析一下整个通信过程中，各个角色到底做了什么，AIDL到底是如何完成通信的。<br>&#160; &#160; &#160; &#160; 首先定一个一个简单的aidl接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ITest.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.windrunnerlihuan;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后用编译工具编译之后，可以得到对应的ITest.java类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.windrunnerlihuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITest</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span></span><br><span class="line">			<span class="title">com</span>.<span class="title">windrunnerlihuan</span>.<span class="title">ITest</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.windrunnerlihuan.ITest"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * Cast an IBinder object into an com.windrunnerlihuan.ITest interface,</span><br><span class="line">		 * generating a proxy if needed.</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> com.windrunnerlihuan.<span class="function">ITest <span class="title">asInterface</span><span class="params">(</span><br><span class="line">				android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">			<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.windrunnerlihuan.ITest))) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((com.windrunnerlihuan.ITest) iin);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> com.windrunnerlihuan.ITest.Stub.Proxy(obj);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span><br><span class="line">				android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">				<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">			<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">			<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">				reply.writeString(DESCRIPTOR);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">				data.enforceInterface(DESCRIPTOR);</span><br><span class="line">				<span class="keyword">int</span> _arg0;</span><br><span class="line">				_arg0 = data.readInt();</span><br><span class="line">				<span class="keyword">int</span> _arg1;</span><br><span class="line">				_arg1 = data.readInt();</span><br><span class="line">				<span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">				reply.writeNoException();</span><br><span class="line">				reply.writeInt(_result);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">windrunnerlihuan</span>.<span class="title">ITest</span> </span>&#123;</span><br><span class="line">			<span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">			Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">				mRemote = remote;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> mRemote;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">				android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">				android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">				<span class="keyword">int</span> _result;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">					_data.writeInt(a);</span><br><span class="line">					_data.writeInt(b);</span><br><span class="line">					mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">					_reply.readException();</span><br><span class="line">					_result = _reply.readInt();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					_reply.recycle();</span><br><span class="line">					_data.recycle();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> _result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 系统帮我们生成了这个文件之后，我们只需要继承ITest.Stub这个抽象类，实现它的方法，然后在Service 的onBind方法里面返回就实现了AIDL。这个Stub类非常重要，具体看看它做了什么。</p>
<p>&#160; &#160; &#160; &#160; Stub类继承自Binder，意味着这个Stub其实自己是一个Binder本地对象，然后实现了ITest接口，ITest本身是一个IInterface，因此他携带某种客户端需要的能力（这里是方法<code>add</code>)。此类有一个内部类Proxy，也就是Binder代理对象；</p>
<p>&#160; &#160; &#160; &#160; 然后看看<code>asInterface</code>方法，我们在bind一个Service之后，在onServiceConnecttion的回调里面，就是通过这个方法拿到一个远程的service的，这个方法做了什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Cast an IBinder object into an com.windrunnerlihuan.ITest interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.windrunnerlihuan.<span class="function">ITest <span class="title">asInterface</span><span class="params">(</span><br><span class="line">		android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">	<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.windrunnerlihuan.ITest))) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((com.windrunnerlihuan.ITest) iin);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> com.windrunnerlihuan.ITest.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 首先看函数的参数<code>IBinder</code>类型的obj，这个对象是驱动给我们的，如果是Binder本地对象，那么它就是Binder类型，如果是Binder代理对象，那就是<code>BinderProxy</code>类型；然后，正如上面自动生成的文档所说，它会试着查找Binder本地对象，如果找到，说明Client和Server都在同一个进程，这个参数直接就是本地对象，直接强制类型转换然后返回，如果找不到，说明是远程对象（处于另外一个进程）那么就需要创建一个Binde代理对象，让这个Binder代理实现对于远程对象的访问。一般来说，如果是与一个远程Service对象进行通信，那么这里返回的一定是一个Binder代理对象，这个IBinder参数的实际上是BinderProxy;</p>
<p>&#160; &#160; &#160; &#160; 再看看我们对于aidl的<code>add</code> 方法的实现；在<code>Stub</code>类里面，add是一个抽象方法，我们需要继承这个类并实现它；如果Client和Server在同一个进程，那么直接就是调用这个方法；那么，如果是远程调用，这中间发生了什么呢？Client是如何调用到Server的方法的？</p>
<p>&#160; &#160; &#160; &#160; 我们知道，对于远程方法的调用，是通过Binder代理完成的，在这个例子里面就是<code>Proxy</code>类；<code>Proxy</code>对于<code>add</code>方法的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">	android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">	<span class="keyword">int</span> _result;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">		_data.writeInt(a);</span><br><span class="line">		_data.writeInt(b);</span><br><span class="line">		mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">		_reply.readException();</span><br><span class="line">		_result = _reply.readInt();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		_reply.recycle();</span><br><span class="line">		_data.recycle();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 它首先用<code>Parcel</code>把数据序列化了，然后调用了<code>transact</code>方法；这个<code>transact</code>到底做了什么呢？这个<code>Proxy</code>类在<code>asInterface</code>方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是<code>BinderProxy</code>, 因此我们的<code>Proxy</code>类里面的<code>mRemote</code>实际类型应该是<code>BinderProxy</code>；我们看看<code>BinderProxy</code>的<code>transact</code>方法：(Binder.java的内部类)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transactNative</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></p>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这段不用看</span></span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//把java对象解析为C++对象</span></span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把java对象解析为C++对象</span></span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*这部分得说明一下，这是个坑，有兴趣的可以挖：在获取Service Manager远程接口时，在JNI层中，创建了一个BpBinder对象，它的句柄值为0，它的地址保存在gBinderProxyOffsets.mObject中，因此，这里通过下面语句得到这个BpBinder对象的IBinder接口：*/</span></span><br><span class="line">    IBinder* target = (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been finalized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印LOG，忽略</span></span><br><span class="line">    ALOGV(<span class="string">"Java code calling transact on %p in Java object %p with code %"</span> PRId32 <span class="string">"\n"</span>,</span><br><span class="line">            target, obj, code);</span><br><span class="line"><span class="comment">//干扰视线的宏，忽略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_BINDER_SAMPLE</span></span><br><span class="line">    <span class="comment">// Only log the binder call duration for things on the Java-level main thread.</span></span><br><span class="line">    <span class="comment">// But if we don't</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> time_binder_calls = should_time_binder_calls();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> start_millis;</span><br><span class="line">    <span class="keyword">if</span> (time_binder_calls) &#123;</span><br><span class="line">        start_millis = uptimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">//这段才是重点</span></span><br><span class="line">    <span class="comment">//printf("Transact from Java code to %p sending: ", target); data-&gt;print();</span></span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    <span class="comment">//if (reply) printf("Transact from Java code to %p received: ", target); reply-&gt;print();</span></span><br><span class="line"><span class="comment">//下面都可以忽略了    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_BINDER_SAMPLE</span></span><br><span class="line">    <span class="keyword">if</span> (time_binder_calls) &#123;</span><br><span class="line">        conditionally_log_binder_call(start_millis, target, code);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>);</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我在注释中说这儿有个坑，有兴趣的就去挖吧，就是在获取Service Manager远程接口时，在JNI层中，创建了一个<code>BpBinder</code>对象，它的句柄值为0，它的地址保存在<code>gBinderProxyOffsets.mObject</code>中，因此，还得去找<code>BpBinder</code>的<code>transact</code>方法，<code>BpBinder</code>的位置在framework\native\libs\binder\BpBinder.cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">	    <span class="comment">//唉，又是个坑，继续挖IPCThreadState</span></span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 继续挖IPCThreadState，位于framework\native\libs\binder\IPCThreadState.cpp(这个self函数就不贴了，就是个单例写法):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"> </span><br><span class="line">    flags |= TF_ACCEPT_FDS;    </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//调用writeTransactionData 发送数据</span></span><br><span class="line">		err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; </span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">      ....等回复</span><br><span class="line"></span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   ....    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">再进一步，瞧瞧这个...</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面把命令数据封装成binder_transaction_data，然后写到mOut中，mOut是命令的缓冲区，也是一个Parcel</span></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"><span class="comment">//仅仅写到了Parcel中，Parcel好像没和/dev/binder设备有什么关联啊？</span></span><br><span class="line"><span class="comment">//恩，那只能在另外一个地方写到binder设备中去了。难道是在？</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说对了，就是在waitForResponse中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//talkWithDriver，哈哈，应该是这里了</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//看见没？这里开始操作mIn了，看来talkWithDriver中</span></span><br><span class="line"><span class="comment">//把mOut发出去，然后从driver中读到数据放到mIn中了。</span></span><br><span class="line">        cmd = mIn.readInt32(); </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">binder_write_read bwr;</span><br><span class="line">   <span class="comment">//中间东西太复杂了，不就是把mOut数据和mIn接收数据的处理后赋值给bwr吗？</span></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//用ioctl来读写</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">  &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"><span class="comment">//到这里，回复数据就在bwr中了，bmr接收回复数据的buffer就是mIn提供的</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 里面进行了一系列的函数调用，确实是个巨恶心的过程；要知道的是它最终调用到了talkWithDriver函数；看这个函数的名字就知道，通信过程要交给驱动完成了（驱动调用是个更恶心的过程，感觉真不是人看的。。。。。）；<br>&#160; &#160; &#160; &#160; （以下过程限于篇幅和巨恶心的过程，所以简要概括，有兴趣的可以自己去挖坑=。=）<br>&#160; &#160; &#160; &#160; 这个函数最后通过ioctl系统调用，Client进程陷入内核态，Client调用add方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的onTransact函数（实际上由Server端线程池完成）。我们再看Binder本地对象的onTransact方法（这里就是Stub类里面的此方法）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span><br><span class="line">		android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">		<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">	<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">		reply.writeString(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">		data.enforceInterface(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">int</span> _arg0;</span><br><span class="line">		_arg0 = data.readInt();</span><br><span class="line">		<span class="keyword">int</span> _arg1;</span><br><span class="line">		_arg1 = data.readInt();</span><br><span class="line">		<span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">		reply.writeNoException();</span><br><span class="line">		reply.writeInt(_result);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 在Server进程里面，<code>onTransact</code>根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的<code>add</code>方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。</p>
<p>&#160; &#160; &#160; &#160; 至此，你应该对AIDL这种通信方式里面的各个类以及各个角色有了一定的了解；它总是那么一种固定的模式：一个需要跨进程传递的对象一定继承自IBinder，如果是Binder本地对象，那么一定继承Binder实现IInterface，如果是代理对象，那么就实现了IInterface并持有了IBinder引用；</p>
<p>&#160; &#160; &#160; &#160; Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。如果把这个过程做一个类比，在封建社会，Stub好比皇帝，可以号令天下，他生而具有这个权利（不要说宣扬封建迷信。。）如果一个人也想号令天下，可以，“挟天子以令诸侯”。为什么不自己去当皇帝，其一，一般情况没必要，当了皇帝其实限制也蛮多的是不是？我现在既能掌管天下，又能不受约束（Java单继承）；其二，名不正言不顺啊，我本来特么就不是（Binder），你非要我是说不过去，搞不好还会造反。最后呢，如果想当皇帝也可以，那就是asBinder了。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>&#160; &#160; &#160; &#160; 再去翻阅系统的ActivityManagerServer的源码，就知道哪一个类是什么角色了：IActivityManager是一个IInterface，它代表远程Service具有什么能力，ActivityManagerNative指的是Binder本地对象（类似AIDL工具生成的Stub类），这个类是抽象类，它的实现是ActivityManagerService；因此对于AMS的最终操作都会进入ActivityManagerService这个真正实现；同时如果仔细观察，ActivityManagerNative.java里面有一个非公开类ActivityManagerProxy, 它代表的就是Binder代理对象；是不是跟AIDL模型一模一样呢？那么ActivityManager是什么？他不过是一个管理类而已，可以看到真正的操作都是转发给ActivityManagerNative进而交给他的实现ActivityManagerService 完成的。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160; 至此分析Binder就告一段落了，也是一个越往下挖越恶心的东西。等以后有机会系统学一下Linux内核的知识。虽然兴趣是最好的老师，但是学习也是个循序渐进的过程，不可能一口吃成大胖子。知识的积累也是需要脚踏实地，一步一个脚印。量变引起质变，见多识广之后才能厚积薄发，逐渐形成自己的思维，使自己成长的更强大。同时，积累过程最忌浮躁，不可因外界环境干扰心境，要始终勿忘初心，心态保持平静，不随波逐流，上善若水。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[移动直播技术秒开优化经验]]></title>
      <url>http://windrunnerlihuan.com/2016/06/06/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;以下内容来自<code>@高可用架构</code>，这次当一回技术的搬运工，为大家分享七牛创始人之一————徐立的<code>移动直播技术秒开优化经验</code>。<br><a id="more"></a></p>
<hr>
<blockquote>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/head.jpg" title="徐立"></div><br>&#160; &#160; &#160; &#160;徐立，七牛创始合伙人兼产品副总裁，负责七牛直播云的整体研发，是国内 Go / Docker / Container 技术早期布道者，&gt;Go / Containers / Distributed Systems 技术的忠实爱好者和实践者。曾合著国内第一本 Go 语言图书《Go 语言编程》，翻译《Go 语言程序设计》。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;现今移动直播技术上的挑战要远远难于传统设备或电脑直播，其完整的处理环节包括但不限于：音视频采集、美颜/滤镜/特效处理、编码、封包、推流、转码、分发、解码/渲染/播放等。</p>
<p>直播常见的问题包括：</p>
<ul>
<li>主播在不稳定的网络环境下如何稳定推流？</li>
<li>偏远地区的观众如何高清流畅观看直播？</li>
<li>直播卡顿时如何智能切换线路？</li>
<li>如何精确度量直播质量指标并实时调整？</li>
<li>移动设备上不同的芯片平台如何高性能编码和渲染视频？</li>
<li>美颜等滤镜特效处理怎么做？</li>
<li>如何实现播放秒开？</li>
<li>如何保障直播持续播放流畅不卡顿？</li>
</ul>
<p>本次分享将为大家揭开移动直播核心技术的神秘面纱。</p>
<h1 id="视频、直播等基础知识"><a href="#视频、直播等基础知识" class="headerlink" title="视频、直播等基础知识"></a>视频、直播等基础知识</h1><h2 id="什么是视频？"><a href="#什么是视频？" class="headerlink" title="什么是视频？"></a>什么是视频？</h2><p>&#160; &#160; &#160; &#160;首先我们需要理解一个最基本的概念：视频。从感性的角度来看，视频就是一部充满趣味的影片，可以是电影，可以是短片，是一连贯的视觉冲击力表现丰富的画面和音频。但从理性的角度来看，视频是一种有结构的数据，用工程的语言解释，我们可以把视频剖析成如下结构：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whatisav.jpg" alt=""><br>内容元素 ( Content )</p>
<ul>
<li>图像 ( Image )</li>
<li>音频 ( Audio )</li>
<li>元信息 ( Metadata )</li>
</ul>
<p>编码格式 ( Codec )</p>
<ul>
<li>Video : H.264，H.265, …</li>
<li>Audio : AAC， HE-AAC, …</li>
</ul>
<p>容器封装 (Container)</p>
<ul>
<li>MP4，MOV，FLV，RM，RMVB，AVI，…</li>
</ul>
<p>任何一个视频 Video 文件，从结构上讲，都是这样一种组成方式：</p>
<ul>
<li>由图像和音频构成最基本的内容元素；</li>
<li>图像经过视频编码压缩格式处理（通常是 H.264）；</li>
<li>音频经过音频编码压缩格式处理（例如 AAC）；</li>
<li>注明相应的元信息（Metadata）；</li>
</ul>
<p>最后经过一遍容器（Container）封装打包（例如 MP4），构成一个完整的视频文件。</p>
<p>&#160; &#160; &#160; &#160;如果觉得难以理解，可以想象成一瓶番茄酱。最外层的瓶子好比这个容器封装（Container），瓶子上注明的原材料和加工厂地等信息好比元信息（Metadata），瓶盖打开（解封装）后，番茄酱本身好比经过压缩处理过后的编码内容，番茄和调料加工成番茄酱的过程就好比编码（Codec），而原材料番茄和调料则好比最原本的内容元素（Content）。</p>
<h2 id="视频的实时传输"><a href="#视频的实时传输" class="headerlink" title="视频的实时传输"></a>视频的实时传输</h2><p>&#160; &#160; &#160; &#160;简而言之，理性的认知视频的结构后，有助于我们理解视频直播。如果视频是一种“有结构的数据”，那么视频直播无疑是<strong>实时传输</strong>这种“有结构的数据”（视频）的方式。</p>
<p>&#160; &#160; &#160; &#160;那么一个显而易见的问题是：如何实时（Real-Time）传输这种“有结构的数据”（视频）呢？</p>
<p>&#160; &#160; &#160; &#160;这里边一个悖论是：一个经过容器（Container）封装后的视频，一定是不可变的 ( Immutable ) 视频文件，不可变的 ( Immutable ) 的视频文件已经是一个生产结果，根据“相对论”，而这个生产结果显然不可能精确到实时的程度，它已经是一段时空的记忆。</p>
<p>&#160; &#160; &#160; &#160;因此视频直播，一定是一个 “边生产，边传输，边消费” 的过程。这意味着，我们需要更近一步了解视频从原始的内容元素 ( 图像和音频 ) 到成品 ( 视频文件 ) 之前的中间过程 ( 编码 )。</p>
<h2 id="视频编码压缩"><a href="#视频编码压缩" class="headerlink" title="视频编码压缩"></a>视频编码压缩</h2><p>&#160; &#160; &#160; &#160;不妨让我们来深入浅出理解视频编码压缩技术。</p>
<p>&#160; &#160; &#160; &#160;为了便于视频内容的存储和传输，通常需要减少视频内容的体积，也就是需要将原始的内容元素(图像和音频)经过压缩，压缩算法也简称编码格式。例如视频里边的原始图像数据会采用 H.264 编码格式进行压缩，音频采样数据会采用 AAC 编码格式进行压缩。</p>
<p>&#160; &#160; &#160; &#160;视频内容经过编码压缩后，确实有利于存储和传输; 不过当要观看播放时，相应地也需要解码过程。因此编码和解码之间，显然需要约定一种编码器和解码器都可以理解的约定。就视频图像编码和解码而言，这种约定很简单：</p>
<p><strong>编码器将多张图像进行编码后生产成一段一段的 GOP ( Group of Pictures ) ， 解码器在播放时则是读取一段一段的 GOP 进行解码后读取画面再渲染显示。</strong><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whathappend1.jpg" alt=""><br>&#160; &#160; &#160; &#160;GOP ( Group of Pictures ) 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whathappend2.jpg" alt=""><br>&#160; &#160; &#160; &#160;I 帧是内部编码帧（也称为关键帧），P 帧是前向预测帧（前向参考帧），B 帧是双向内插帧（双向参考帧）。简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。</p>
<p><strong>如果没有 I 帧，P 帧和 B 帧就无法解码。</strong><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/mainvsref.jpg" alt=""><br>&#160; &#160; &#160; &#160;小结一下，一个视频 ( Video ) ，其图像部分的数据是一组 GOP 的集合, 而单个 GOP 则是一组 I / P / B 帧图像的集合。</p>
<p>&#160; &#160; &#160; &#160;在这样的一种几何关系中，Video 好比一个 “物体”，GOP 好比 “分子”，I / P / B 帧的图像则好比 “原子”。</p>
<p>&#160; &#160; &#160; &#160;想象一下，如果我们把传输一个 “物体”，改成传输一个一个的 “原子”，将最小颗粒以光速传送，那么以人的生物肉眼来感知，将是一种怎样的体验？</p>
<h2 id="什么是视频直播？"><a href="#什么是视频直播？" class="headerlink" title="什么是视频直播？"></a>什么是视频直播？</h2><p>&#160; &#160; &#160; &#160;不难脑洞大开一下，直播就是这样的一种体验。视频直播技术，就是将视频内容的最小颗粒 ( I / P / B 帧，…)，基于时间序列，以光速进行传送的一种技术。</p>
<p>&#160; &#160; &#160; &#160;简而言之，直播就是将每一帧数据 ( Video / Audio / Data Frame )，打上时序标签 ( Timestamp ) 后进行流式传输的过程。发送端源源不断的采集音视频数据，经过编码、封包、推流，再经过中继分发网络进行扩散传播，播放端再源源不断地下载数据并按时序进行解码播放。如此就实现了 “边生产、边传输、边消费” 的直播过程。</p>
<p>&#160; &#160; &#160; &#160;理解以上两个关于<code>视频</code>和<code>直播</code>两个基础概念后，接下来我们就可以一窥直播的业务逻辑了。</p>
<h2 id="直播的业务逻辑"><a href="#直播的业务逻辑" class="headerlink" title="直播的业务逻辑"></a>直播的业务逻辑</h2><p>如下是一个最精简的一对多直播业务模型，以及各个层级之间的协议。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/liveprotocol.jpg" alt=""><br>各协议差异对比如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/protocoldiff1.jpg" alt=""><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/protocoldiff2.jpg" alt=""><br>以上就是关于直播技术的一些基础概念。下面我们进一步了解下影响人们视觉体验的直播性能指标。</p>
<h1 id="影响视觉体验的直播性能指标"><a href="#影响视觉体验的直播性能指标" class="headerlink" title="影响视觉体验的直播性能指标"></a>影响视觉体验的直播性能指标</h1><p>&#160; &#160; &#160; &#160;<strong>直播第一个性能指标是延迟</strong>，延迟是数据从信息源发送到目的地所需的时间。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay1.jpg" alt=""><br>根据爱因斯坦的狭义相对论，光速是所有能量、物质和信息运动所能达到的最高速度，这个结论给传播速度设定了上限。因此，即便我们肉眼感觉到的实时，实际上也是有一定的延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay2.jpg" alt=""><br>由于 RTMP/HLS 是基于 TCP 之上的应用层协议，TCP 三次握手，四次挥手，慢启动过程中的每一次往返来回，都会加上一次往返耗时 ( RTT )，这些交互过程都会增加延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay3.jpg" alt=""><br>其次根据 TCP 丢包重传特性，网络抖动可能导致丢包重传，也会间接导致延迟加大。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/jitter.jpg" alt=""><br>&#160; &#160; &#160; &#160;一个完整的直播过程，包括但不限于以下环节：<strong>采集、处理、编码、封包、推流、传输、转码、分发、拉流、解码、播放</strong>。从推流到播放，再经过中间转发环节，延迟越低，则用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;<strong>第二个直播性能指标卡顿</strong>，是指视频播放过程中出现画面滞帧，让人们明显感觉到“卡”。单位时间内的播放卡顿次数统计称之为卡顿率。</p>
<p>&#160; &#160; &#160; &#160;造成卡顿的因素有可能是推流端发送数据中断，也有可能是公网传输拥塞或网络抖动异常，也有可能是终端设备的解码性能太差。卡顿频次越少或没有，则说明用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;<strong>第三个直播性能指标首屏耗时</strong>，指第一次点击播放后，肉眼看到画面所等待的时间。技术上指播放器解码第一帧渲染显示画面所花的耗时。通常说的 “秒开”，指点击播放后，一秒内即可看到播放画面。首屏打开越快，说明用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;如上三个直播性能指标，分别对应一个低延迟、高清流畅、极速秒开 的用户体验诉求。了解这三个性能指标，对优化移动直播 APP 的用户体验至关重要。</p>
<p>&#160; &#160; &#160; &#160;那么移动直播场景下具体而言有哪些常见的坑呢？</p>
<p>&#160; &#160; &#160; &#160;根据实践总结下来的经验，移动平台上视频直播的坑主要可以总结为两方面：设备差异，以及网络环境这些场景下带来的技术考验。</p>
<h1 id="移动直播场景的坑与规避措施"><a href="#移动直播场景的坑与规避措施" class="headerlink" title="移动直播场景的坑与规避措施"></a>移动直播场景的坑与规避措施</h1><h2 id="不同芯片平台上的编码差异"><a href="#不同芯片平台上的编码差异" class="headerlink" title="不同芯片平台上的编码差异"></a>不同芯片平台上的编码差异</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay2.jpg" alt=""><br><strong>iOS 平台上无论硬编还是软编，由于是 Apple 一家公司出厂，几乎不存在因为芯片平台不同而导致的编码差异</strong>。</p>
<p>&#160; &#160; &#160; &#160;然而，在 Android 平台上，Android Framework SDK 提供的 MediaCodec 编码器，在不同的芯片平台上，差异表现很大， 不同的厂家使用不同的芯片，而不同的芯片平台上 Android MediaCodec 表现略有差异，通常实现全平台兼容的成本不低。</p>
<p>&#160; &#160; &#160; &#160;另外就是 Android MediaCodec 硬编层面的 H.264 编码画质参数是固定的 baseline，所以画质通常也一般。因此，在 Android 平台下，<strong>推荐是用软编，好处是画质可调控，兼容性也更好</strong>。</p>
<h2 id="低端设备如何上高性能地采集和编码？"><a href="#低端设备如何上高性能地采集和编码？" class="headerlink" title="低端设备如何上高性能地采集和编码？"></a>低端设备如何上高性能地采集和编码？</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/gether.jpg" alt=""><br>&#160; &#160; &#160; &#160;例如 Camera 采集输出的可能是图片，一张图的体积并不会小，如果采集的频次很高，编码的帧率很高，每张图都经过编码器，那么编码器又可能会出现过载。</p>
<p>&#160; &#160; &#160; &#160;这个时候，可以考虑在编码前，不影响画质的前提下（前面我们讲过帧率的微观意义），进行<strong>选择性丢帧</strong>，以此降低编码环节的功耗开销。</p>
<h2 id="弱网下如何保障高清流畅推流"><a href="#弱网下如何保障高清流畅推流" class="headerlink" title="弱网下如何保障高清流畅推流"></a>弱网下如何保障高清流畅推流</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/resource.jpg" alt=""><br>&#160; &#160; &#160; &#160;移动网络下，通常容易遇到网络不稳定，连接被重置，断线重连，一方面频繁重连，建立连接需要开销。另一方面尤其是发生 GPRS / 2G / 3G / 4G 切换时，带宽可能出现瓶颈。当带宽不够，帧率较高/码率较高的内容较难发送出去，这个时候就需要可变码率支持。</p>
<p>&#160; &#160; &#160; &#160;即在推流端，可检测网络状态和简单测速，动态来切换码率，以保障网络切换时的推流流畅。</p>
<p>&#160; &#160; &#160; &#160;其次编码、封包、推流 这一部分的逻辑也可以做微调，可以尝试选择性丢帧，比如优先丢视频参考帧（不丢 I 帧和音频帧 )，这样也可以减少要传输的数据内容，但同时又达到了不影响画质和版视听流畅的目的。</p>
<h2 id="需要区分直播流的状态和业务状态"><a href="#需要区分直播流的状态和业务状态" class="headerlink" title="需要区分直播流的状态和业务状态"></a>需要区分直播流的状态和业务状态</h2><p>&#160; &#160; &#160; &#160;直播是媒体流、APP 的交互是 API 信令流，两者的状态不能混为一谈。尤其是不能基于 APP 的交互的 API 状态来判断直播流的状态。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/seeproduct.jpg" alt=""><br>以上是移动直播场景下常见的几个坑和规避措施。</p>
<h1 id="移动直播场景其他优化措施"><a href="#移动直播场景其他优化措施" class="headerlink" title="移动直播场景其他优化措施"></a>移动直播场景其他优化措施</h1><h2 id="一、怎么优化打开速度，达到传说中的-“秒开”？"><a href="#一、怎么优化打开速度，达到传说中的-“秒开”？" class="headerlink" title="一、怎么优化打开速度，达到传说中的 “秒开”？"></a>一、怎么优化打开速度，达到传说中的 “秒开”？</h2><p>一、怎么优化打开速度，达到传说中的 “秒开”？</p>
<p>&#160; &#160; &#160; &#160;大家可能会看到，市面上某些手机直播 APP 的打开速度非常快，一点就开。而某些手机直播 APP，点击播放后要等好几秒以后才能播放。是什么原因导致如此的天壤之别呢？</p>
<p>&#160; &#160; &#160; &#160;大部分播放器都是拿到一个完成的 GOP 后才能解码播放，基于 FFmpeg 移植的播放器甚至需要等待音画时间戳同步后才能播放（如果一个直播里边没有音频只有视频相当于要等待音频超时后才能播放画面）。</p>
<p>“秒开”可以从以下几个方面考虑：</p>
<h3 id="1-改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。"><a href="#1-改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。" class="headerlink" title="1. 改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。"></a>1. 改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。</h3><p>&#160; &#160; &#160; &#160;GOP 的第一帧通常都是关键帧，由于加载的数据较少，可以达到 “首帧秒开”。</p>
<p>&#160; &#160; &#160; &#160;如果直播服务器支持 GOP 缓存，意味着播放器在和服务器建立连接后可立即拿到数据，从而省却跨地域和跨运营商的回源传输时间。</p>
<p>&#160; &#160; &#160; &#160;GOP 体现了关键帧的周期，也就是两个关键帧之间的距离，即一个帧组的最大帧数。假设一个视频的恒定帧率是 24fps（即1秒24帧图像），关键帧周期为 2s，那么一个 GOP 就是 48 张图像。一般而言，每一秒视频至少需要使用一个关键帧。</p>
<p>&#160; &#160; &#160; &#160;<strong>增加关键帧个数可改善画质（GOP 通常为 FPS 的倍数），但是同时增加了带宽和网络负载</strong>。这意味着，客户端播放器下载一个 GOP，毕竟该 GOP 存在一定的数据体积，如果播放端网络不佳，有可能不是能够快速在秒级以内下载完该 GOP，进而影响观感体验。</p>
<p>&#160; &#160; &#160; &#160;如果不能更改播放器行为逻辑为首帧秒开，直播服务器也可以做一些取巧处理，比如<strong>从缓存 GOP 改成缓存双关键帧</strong>（减少图像数量），这样可以极大程度地减少播放器加载 GOP 要传输的内容体积。</p>
<h3 id="2-在-APP-业务逻辑层面方面优化。"><a href="#2-在-APP-业务逻辑层面方面优化。" class="headerlink" title="2. 在 APP 业务逻辑层面方面优化。"></a>2. 在 APP 业务逻辑层面方面优化。</h3><p>&#160; &#160; &#160; &#160;比如提前做好 DNS 解析（省却几十毫秒），和提前做好测速选线（择取最优线路）。经过这样的预处理后，在点击播放按钮时，将极大提高下载性能。</p>
<p>&#160; &#160; &#160; &#160;一方面，可以围绕传输层面做性能优化；另一方面，可以围绕客户播放行为做业务逻辑优化。两者可以有效的互为补充，作为秒开的优化空间。</p>
<h2 id="二、美颜等滤镜如何处理？"><a href="#二、美颜等滤镜如何处理？" class="headerlink" title="二、美颜等滤镜如何处理？"></a>二、美颜等滤镜如何处理？</h2><p>&#160; &#160; &#160; &#160;在手机直播场景下，这就是一个刚需。没有美颜功能的手机直播 APP，主播基本不爱用。可以在采集画面后，将数据送给编码器之前，将数据源回调给滤镜处理程序，原始数据经过滤镜处理完后，再送回给编码器进行编码即可。</p>
<p>&#160; &#160; &#160; &#160;除了移动端可以做体验优化之外，直播流媒体服务端架构也可以降低延迟。例如收流服务器主动推送 GOP 至边缘节点，边缘节点缓存 GOP，播放端则可以快速加载，减少回源延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/push.jpg" alt=""><br>其次，可以贴近终端就近处理和分发<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/deliver.jpg" alt=""></p>
<h2 id="三、如何保障直播持续播放流畅不卡顿？"><a href="#三、如何保障直播持续播放流畅不卡顿？" class="headerlink" title="三、如何保障直播持续播放流畅不卡顿？"></a>三、如何保障直播持续播放流畅不卡顿？</h2><p>&#160; &#160; &#160; &#160;“秒开”解决的是直播首次加载的播放体验，如何保障直播持续播放过程中的画面和声音视听流畅呢？因为，一个直播毕竟不是一个 HTTP 一样的一次性请求，而是一个 Socket 层面的长连接维持，直到直到主播主动终止推流。</p>
<p>&#160; &#160; &#160; &#160;上述我们讲过卡顿的定义：即播放时画面滞帧，触发了人们的视觉感受。在不考虑终端设备性能差异的情况下，针对网络传输层面的原因，我们看看如何保障一个持续的直播不卡顿。</p>
<p>&#160; &#160; &#160; &#160;这其实是一个直播过程中传输网络不可靠时的容错问题。例如，播放端临时断网了，但又快速恢复了，针对这种场景，播放端如果不做容错处理，很难不出现黑屏或是重新加载播放的现象。</p>
<p>&#160; &#160; &#160; &#160;为了容忍这种网络错误，并达到让终端用户无感知，<strong>客户端播放器可以考虑构建一个FIFO（先进先出）的缓冲队列</strong>，解码器从播放缓存队列读取数据，缓存队列从直播服务器源源不断的下载数据。通常，缓存队列的容量是以时间为单位（比如3s），在播放端网络不可靠时，客户端缓存区可以起到“断网无感”的过渡作用。</p>
<p>&#160; &#160; &#160; &#160;显然，这只是一个“缓兵之计”，如果直播服务器边缘节点出现故障，而此时客户端播放器又是长连接，在无法收到对端的连接断开信号，客户端的缓冲区容量再大也不管用了，这个时候就需要结合客户端业务逻辑来做调度。</p>
<p>&#160; &#160; &#160; &#160;重要的是客户端结合服务端，可以做精准调度。在初始化直播推流之前，例如基于 IP 地理位置和运营商的精确调度，分配线路质量最优的边缘接入节点。在直播推流的过程中，可以实时监测帧率反馈等质量数据，基于直播流的质量动态调整线路。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>1. 关键帧设置频率一般是多少？有没有根据接入动态设置？过长首屏秒会很难做到。</strong></p>
<p>徐立：关键帧间隔越长，也就是 GOP 越长，理论上画面越高清。但是生成 HLS 直播时，最小切割粒度也是一个 GOP，所以针对交互直播，通常不建议 GOP 设置太长。直播一般 2 个关键帧间隔即可。比如帧率是 24fps， 那么 2 个关键帧的间隔就是 48fps ，这个 GOP 就是2s。</p>
<p><strong>2. 七牛这个直播是用的网宿加速？有遇到什么坑没？</strong></p>
<p>徐立：七牛在直播方面主要是自建节点，也支持融合众多第三方 CDN 服务商，多样化的线路组合为客户提供更优质的服务。在和第三方 CDN 合作的过程中遇到的问题等有机会再做更细粒度的交流和分享。</p>
<p><strong>3. RTMP 直播流除了优化线路外，还有什么加速手段吗？</strong></p>
<p>徐立：物理上优化线路，逻辑上优化策略，比如选择性丢帧，不影响编码画质的前提下减轻传输体积。</p>
<p><strong>4. OBS 推流，播放端 HLS 出现视/音频不同步是哪个环节的问题？怎么优化？</strong></p>
<p>徐立：有可能是采集端的问题，如果是采集端编码环节就出现音画不同步，可以在收流服务器上做音画时间戳同步，这样是全局的校对。如果是播放端解码性能问题，那么需要调节播放逻辑，比如保证音画时间戳强一致性的前提下，选择性丢一部帧。</p>
<p><strong>5. PPT 前几页中一个概念好像错了，I 帧不是关键帧，IDR 帧才是。IDR 帧是 I 帧，但是 I 帧不一定是 IDR 帧。只有 IDR 帧才是可重入的。</strong></p>
<p>徐立：中文都把 I 帧翻译成关键帧了，不过既然提到了 IDR 帧，可以展开说明一下。所有的 IDR 帧都是 I 帧，但是并不是所有 I 帧都是 IDR 帧，IDR 帧是 I 帧的子集。I 帧严格定义是帧内编码帧，由于是一个全帧压缩编码帧，通常用 I 帧表示 “关键帧”。IDR 是基于 I 帧的一个 “扩展”，带了控制逻辑，IDR 图像都是 I 帧图像，当解码器解码到 IDR 图像时，会立即将参考帧队列清空，将已解码的数据全部输出或抛弃。重新查找参数集，开始一个新的序列。这样如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR 图像之后的图像永远不会使用 IDR 之前的图像的数据来解码。</p>
<p><strong>6. 有没有调研过 nginx rtmp module，为什么没有用，对它有什么评价？</strong></p>
<p>徐立：有调研过，nginx_rtmp_module 是单进程多线程，非 go 这种轻量级线程/协程用并发自然语义的方式编写流业务。nginx 原本的代码量较大（约 16 万行，但和直播业务相关的功能并不是很多）。且主要靠写 nginx.conf 做配置租户，通常单租户可以，但业务可扩展性方面不是很灵活，可满足基本需求，不满足高级功能。</p>
<p><strong>7. 用到了那些开源软件？编码用的是 x264 吗？直播服务器你们自己开发还是开源的？</strong></p>
<p>徐立：直播服务器用 go 开发的，移动端编码优先硬编，软编用 x264</p>
<p><strong>8. 请教一下用 OBS 推流到 nginx_rtmp_module 的时候是已经做了视频压缩了还是需要基于 OBS 再开发？</strong></p>
<p>徐立：OBS 把编码压缩都做了，不需要再开发。</p>
<p><strong>9. 视频直播想在 HLS 流中无缝插入一段广告的 ts 文件，有问题想请教一下：1、这段 ts 的分辨率是否一定要和之前的视频流一致？2、pts 时间戳是否要和上一个 ts 递增？</strong></p>
<p>徐立：<br>1、可以不一致。这种情况两段视频完全是独立状态，可以没有任何关系，只需要插入 discontinue 标记，播放器在识别到这个标记之后重置解码器参数就可以无缝播放，画面会很平滑的切换。<br>2、不需要递增。举个例子，视频 A 正在直播，播放到 pts 在 5s 的时候，插入一个视频 B，需要先插入一个 discontinue，再插入 B，等 B 播放完之后，再插入一个 discontinue，再插入 A，这个时候 A 的 pts 可以和之前递增，也可以按照中间插入的 B 的时长做偏移，一般做点播和时移的时候 pts 会连续递增，直播的话会算上 B 的时长。</p>
<p>由于移动直播在实践上还有非常多细节，本文未能全部覆盖，感兴趣的朋友欢迎在文章最后留言讨论。</p>
<h1 id="PPT-下载地址"><a href="#PPT-下载地址" class="headerlink" title="PPT 下载地址"></a>PPT 下载地址</h1><p>我备份了一分pdf，下载点<a href="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/pili_technology_sharing.pdf" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客搭建历程————————Github和Hexo]]></title>
      <url>http://windrunnerlihuan.com/2016/05/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>我的博客搭建历程，使用github pages + hexo，域名解析，配置插件<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;其实从去年开始我就想搭建一个自己的个人网站了，主要用于记录自己的技术积累和重点知识。但由于自己太懒，能力也太渣，所以就一直没有行动。直到今年，突然发现随着知识积累的增加，有好多重要的内容脑袋都记不下了，有的网页就直接存个标签，但是标签越存越多，但却很少再次去浏览，最后知识还是会淡忘，所以今天痛下决心，还是自己搭个博客吧，以挽回知识的流失，同时也可以向外部分享自己的一些见解。<br>&#160; &#160; &#160; &#160;博客搭建过程也是一波三折，遇到各种坑爹问题，还好我没那么轻易放弃，最终在无数次失败之后终于成功了。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-github配置"><a href="#1-github配置" class="headerlink" title="1. github配置"></a>1. github配置</h2><p>1）首先需要有一个github账号，没有的话就得申请一个。<br>然后新建一个代码仓库，注意，仓库名一定要是：<strong>你的github账号名字.github.io</strong>，比如我的是windrunnerlihuan.github.io。<br>2）clone到本地，比如我的就是如下命令：<br>git clone <a href="https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git" target="_blank" rel="external">https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</a><br>cd 进文件夹，我们先建个index.html用于测试：<br>cd windrunnerlihuan.github.io<br>vi index.html<br>然后编辑：<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>github pages测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后按esc，再输入“:wq”回车保存。然后提交上去：<br>git add .<br>git commit -m “测试github pages”<br>git push<br>此时需要输入你的github账号和密码，输入就是了，成功后我们验证一下。<br>然后打开浏览器，输入地址，比如我的就是：<a href="http://windrunnerlihuan.github.io" target="_blank" rel="external">http://windrunnerlihuan.github.io</a><br>如果能正确显示“<strong>github pages测试</strong>”字样，说明我们成功了。</p>
<hr>
<h2 id="2-hexo安装"><a href="#2-hexo安装" class="headerlink" title="2. hexo安装"></a>2. hexo安装</h2><p>&#160; &#160; &#160; &#160;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。</p>
<p>Hexo的官方网站：<a href="http://hexo.io/" target="_blank" rel="external">http://hexo.io/</a> ，也是基于Github构建的网站。</p>
<p>&#160; &#160; &#160; &#160;不过要使用hexo必须装node.js，这个easy，直接在官网<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a> 上下一个，首页就是下载页面，选一个你自己电脑平台对应的，比如我的是windows x64。如果不想看英文呢，还有个中文网站<a href="http://nodejs.cn/" target="_blank" rel="external">http://nodejs.cn/</a> ，几乎是把英文网站翻译了一遍，套路都一样。下载下来之后文件名叫<strong>node-v4.4.4-x64.msi</strong>，双击，一路next，傻瓜式安装。</p>
<p>接着安装hexo：<br>1）打开控制台（按下win + r，输入cmd，回车）或者直接在git bash界面。<br>输入 npm install -g hexo，然后开始安装hexo。<br>成功后再输入 npm install hexo-deployer-git –save，安装发布工具。</p>
<p>2）接着进入我们从github上克隆下来的windrunnerlihuan.github.io文件，再次git bash here。<br>输入 hexo init，初始化hexo。<br>完成后我们测试一下：<br>输入hexo server<br>bash控制台会打印出 “[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>. Press Ctrl+C to stop.”<br>这时端口4000被打开了，我们能过浏览器打开地址，<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/home.png" alt="hexo首页默认图片"></p>
<p>出现了默认的网页界面，是不是很容易呢！！</p>
<hr>
<h2 id="3-hexo配置"><a href="#3-hexo配置" class="headerlink" title="3. hexo配置"></a>3. hexo配置</h2><p>我们先看一下文件结构</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/file.png" alt="hexo文件结构图图片"></p>
<ul>
<li>scaffolds 脚手架，也就是一个工具模板</li>
<li>scripts 写文件的js，扩展hexo的功能</li>
<li>source 存放博客正文内容</li>
<li>source/_drafts 草稿箱</li>
<li>source/_posts 文件箱</li>
<li>themes 存放皮肤的目录</li>
<li>themes/landscape 默认的皮肤</li>
<li>_config.yml 全局的配置文件</li>
<li>db.json 静态常量</li>
</ul>
<p>在这里，我们每次用到的就是_posts目录里的文件，而_config.yml文件和themes目录是第一次配置好就行了。</p>
<p>_posts目录：Hexo是一个静态博客框架，因此没有数据库。文章内容都是以文本文件方式进行存储的，直接存储在_posts的目录。Hexo天生集成了markdown，我们可以直接使用markdown语法格式写博客，例如:hello-world.md。新增加一篇文章，就在_posts目录，新建一个xxx.md的文件。</p>
<p>themes目录：是存放皮肤的，包括一套Javascript+CSS样式和基于EJS的模板设置。通过在themes目录下，新建一个子目录，就可以创建一套新的皮肤，当然我们也可以直接在landscape上面修改。</p>
<p>我们主要改的就是_config.yml全局配置文件，以及新建文章时要增加或者修改文章在source/-posts/目录下的md文件。</p>
<p>1）修改_config.yml全局配置文件</p>
<p>_config.yml是全局的配置文件：很多的网站配置都在这个文件中定义。</p>
<ul>
<li>站点信息: 定义标题，作者，语言</li>
<li>URL: URL访问路径</li>
<li>文件目录: 正文的存储目录</li>
<li>写博客配置：文章标题，文章类型，外部链接等</li>
<li>目录和标签：默认分类，分类图，标签图</li>
<li>归档设置：归档的类型</li>
<li>服务器设置：IP，访问端口，日志输出</li>
<li>时间和日期格式： 时间显示格式，日期显示格式</li>
<li>分页设置：每页显示数量</li>
<li>评论：外挂的Disqus评论系统</li>
<li>插件和皮肤：换皮肤，安装插件</li>
<li>Markdown语言：markdown的标准</li>
<li>CSS的stylus格式：是否允许压缩</li>
<li>部署配置：github发布</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Hexo Configuration</span></span><br><span class="line"><span class="section">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="section">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="section"># Site 站点信息</span></span><br><span class="line">title: this way, little boy</span><br><span class="line">subtitle: 無限大な夢のあとの 何もない世の中じゃ</span><br><span class="line">description:</span><br><span class="line">author: Huan Li</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"><span class="section"># URL</span></span><br><span class="line"><span class="section">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line">url: http://windrunnerlihuan.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"><span class="section"># Directory 文件目录</span></span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"><span class="section"># Writing 写博客配置</span></span><br><span class="line">new<span class="emphasis">_post_</span>name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post<span class="emphasis">_asset_</span>folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="section"># Category &amp; Tag 目录和标签</span></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"><span class="section"># Date / Time format 时间和日期</span></span><br><span class="line"><span class="section">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="section">## You can customize the date format as defined in</span></span><br><span class="line"><span class="section">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="section"># Pagination 分页设置</span></span><br><span class="line"><span class="section">## Set per_page to 0 to disable pagination</span></span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"><span class="section"># Markdown Markdown语法</span></span><br><span class="line"><span class="section">## https://github.com/chjj/marked</span></span><br><span class="line">markdown:</span><br><span class="line">  gfm: true</span><br><span class="line">  pedantic: false</span><br><span class="line">  sanitize: false</span><br><span class="line">  tables: true</span><br><span class="line">  breaks: true</span><br><span class="line">  smartLists: true</span><br><span class="line">  smartypants: true</span><br><span class="line"></span><br><span class="line"><span class="section"># Deployment 部署配置</span></span><br><span class="line"><span class="section">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;其他没啥改动的，就改个<strong>Site 站点信息</strong>，<strong>URL</strong>，还有<strong>Deployment 部署配置</strong>，前两个没啥难度，这个<strong>Deployment 部署配置</strong>很重要：</p>
<ul>
<li>其中<strong>type</strong>一定要填git，因为以前低版本的hexo是github，不过现在早就废弃了。</li>
<li>其次<strong>repo</strong>填你github项目的clone地址，http/https/ssh类型都行，我的是<br><a href="https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git" target="_blank" rel="external">https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</a> 和git@github.com:windrunnerlihuan/windrunnerlihuan.github.io.git ，我填的是第一个，因为填第二个后期发布时会验证公钥，需要用git bash生成公钥，然后贴到项目的Deploy keys里，比较麻烦，所以为了省事，我填了第一个。</li>
</ul>
<p>2） 新建博客</p>
<p>接下来，我们开始新博客了，创建第一篇博客文章。Hexo建议通过命令行操作，当然你也可以直接在_posts目录下创建文件。</p>
<p>通过命令创建新文章，在bash 里输入 hexo new “新的开始”<br>在source/_posts目录下就会生成文件：”新的开始.md”。</p>
<p>然后我们编辑 <strong>新的开始.md</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 新的开始</span><br><span class="line">date: 2016-05-27 18:44:12</span><br><span class="line">tags:</span><br><span class="line">- 开始</span><br><span class="line">categories: 日志</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是**新的开始**，我用hexo创建了第一篇文章。</span><br><span class="line"></span><br><span class="line">## 引用</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">&gt; Every interaction is both precious and an opportunity to delight.</span><br><span class="line"></span><br><span class="line">## 链接</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% link gank日志 http://gank.io/ true 粉丝日志 %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">[gank日志](http://gank.io/)</span><br><span class="line"></span><br><span class="line">## 图片</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% img /images/新的开始/meizi.jpg 400 600 这是一张图片 %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">![这是一张图片](http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/meizi.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 公式</span><br><span class="line">$$J\_\alpha(x)=\sum _&#123;m=0&#125;^\infty \frac&#123;(-1)^ m&#125;&#123;m! \, \Gamma (m + \alpha + 1)&#125;&#123;\left(&#123;\frac&#123;x&#125;&#123;2&#125;&#125;\right)&#125;^&#123;2 m + \alpha &#125;$$</span><br><span class="line">感觉非常好。</span><br></pre></td></tr></table></figure>
<p>文章使用markedonw语法写的，还有很多普通或者高级的语法，这个可以问度娘或者谷歌，找找别人的帖子学学。</p>
<p>用命令行启动本地server：hexo server<br>通过浏览器打开， <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，就出现了我们新写的文章。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/newstart.png" alt="新的开始文章预览图"></p>
<hr>
<h2 id="4-发布到Github"><a href="#4-发布到Github" class="headerlink" title="4. 发布到Github"></a>4. 发布到Github</h2><p>1)  静态化处理<br>&#160; &#160; &#160; &#160;写完了文章，我们就可以发布了。要说明的一点是hexo的静态博客框架，那什么是静态博客呢？静态博客，是只包含html, javascript, css文件的网站，没有动态的脚本。虽然我们是用Node进行的开发，但博客的发布后就与Node无关了。在发布之前，我们要通过一条命令，把所有的文章都做静态化处理，就是生成对应的html, javascript, css，使得所有的文章都是由静态文件组成的。</p>
<p>输入静态化命令 ：hexo generate<br>在本地目录下，会生成一个public的目录，里面包括了所有静态化的文件。</p>
<p>2) 发布到github<br>接下来，我们把这个博客发布到github。<br>现在检查我们上次填好的_config.yml文件，找到deploy的部分，设置github的项目地址。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>然后执行部署命令：hexo deploy<br>中间过程会让你再次输入github账号和密码，输入就行了<br>成功后验证，浏览器里输入上次的地址：<a href="http://windrunnerlihuan.github.io" target="_blank" rel="external">http://windrunnerlihuan.github.io</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/newstart.png" alt="新的开始文章预览图"><br>说明我们成功了</p>
<hr>
<h2 id="5-独立购买域名与绑定"><a href="#5-独立购买域名与绑定" class="headerlink" title="5. 独立购买域名与绑定"></a>5. 独立购买域名与绑定</h2><p>&#160; &#160; &#160; &#160;有时候我们想做个人博客，想让自己的博客拥有自己的域名，那就得去买个域名了。这里我们可以通过万网申请购买：<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">https://wanwang.aliyun.com/</a>  。流程很简单，基本上一路next。<br>我也斥资45块买了个.com结尾的域名 <strong>windrunnerlihuan.com</strong> 。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/yulist.png" alt="域名列表图片"></p>
<p>然后就是解析域名了，不过解析之前你得知道你的gihub pages个人主页的ip：<br>首先ping 一下个人主页地址 ，控制台里输入 ping www.windrunnerlihuan.github.io，然后会返回一个ip，然后用这个ip设置我们刚才买的域名解析，也是轻车熟路</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/yudecode.png" alt="域名解析图片"></p>
<p>最后最重要的是：<br>1）在github项目中，新建一个文件CNAME，文件中写出你要绑定的域名windrunnerlihuan.com。通过浏览器，访问<a href="http://windrunnerlihuan.com，就打开了我们建好的博客站点。" target="_blank" rel="external">http://windrunnerlihuan.com，就打开了我们建好的博客站点。</a><br>2）由于每次执行deploy的时候，github代码仓库所有的文件都会被覆盖，所以我们最好在source目录下创建这个CNAME文件，这样每次部署就不用动手创建了。</p>
<hr>
<h2 id="6-个性化功能配置"><a href="#6-个性化功能配置" class="headerlink" title="6. 个性化功能配置"></a>6. 个性化功能配置</h2><p>1） 替换皮肤<br>博客系统流行的原因，是因为他的个人性，而皮肤正式个性化的一种体现。<br>利用hexo替换皮肤，还是比较简单的，3步完成。</p>
<p><strong>No.1</strong>  找到一个皮肤或者自己开发一个皮肤<br>打开hexo的皮肤列表页面，你可以找到很多的皮肤，网页地址： <a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/tommy351/hexo/wiki/Themes</a> 。 </p>
<p><strong>No.2</strong>放到themes目录下<br>比如，我觉得pacman( <a href="https://github.com/A-limon/pacman" target="_blank" rel="external">https://github.com/A-limon/pacman</a> )这个皮肤还不错，我就可以下载皮肤到themes目录下面。<br>通过git命令下载皮肤<br>git clone <a href="https://github.com/A-limon/pacman.git" target="_blank" rel="external">https://github.com/A-limon/pacman.git</a> themes/pacman</p>
<p><strong>No.3</strong>在_config.yml指定皮肤<br>编辑文件_config.yml，找到theme一行，改成 theme: pacman<br>本地启动hexo服务器，打开浏览器 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/pifu.png" alt="替换了皮肤的博客"></p>
<p>新皮肤的效果还不错吧，然后静态化处理，再发布到github，就完成了站点的改版。</p>
<p>这里只介绍换皮肤，当然还有其他很多功能，不过对于我来说暂时没多大卵用，如果其他人有需求可以再google或者baidu搜，也都不难，很easy。</p>
<hr>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;因为这是我第一次搭建个人博客，水平实在比较差，流程写的很粗燥，很多细节都没有涉及，望大家体谅，以后我会努力完善的，将后续文章做的更好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>http://windrunnerlihuan.com/2016/05/27/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>这是<strong>新的开始</strong>，我用hexo创建了第一篇文章。</p>
<p>通过下面的命令，就可以创建新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\javascript\nodejs-hexo&gt;hexo new 新的开始</span><br><span class="line">[info] File created at D:\workspace\javascript\nodejs-hexo\source\_posts\新的开始.md</span><br></pre></td></tr></table></figure></p>
<p>感觉非常好。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h1 id="Swig语法"><a href="#Swig语法" class="headerlink" title="Swig语法"></a>Swig语法</h1><blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote>
<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><blockquote>
<p>Every interaction is both precious and an opportunity to delight.</p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h1 id="Swig语法-1"><a href="#Swig语法-1" class="headerlink" title="Swig语法"></a>Swig语法</h1><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h1 id="Markdown语法-1"><a href="#Markdown语法-1" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h1 id="Swig语法-2"><a href="#Swig语法-2" class="headerlink" title="Swig语法"></a>Swig语法</h1><a href="http://gank.io/" title="粉丝日志" target="_blank">gank日志</a>
<h1 id="Markdown语法-2"><a href="#Markdown语法-2" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><a href="http://gank.io/" target="_blank" rel="external">gank日志</a><br><a href="404html">测试404页面</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h1 id="Swig语法-3"><a href="#Swig语法-3" class="headerlink" title="Swig语法"></a>Swig语法</h1><img src="http://static.hdslb.com/images/favicon.ico" width="100" height="100" title="这是一张图片">
<h1 id="Markdown语法-3"><a href="#Markdown语法-3" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><img src="http://static.hdslb.com/images/favicon.ico" alt="这是一张图片"></p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p>
<hr>
]]></content>
    </entry>
    
  
  
</search>
