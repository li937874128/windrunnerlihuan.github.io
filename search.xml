<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[浅析Bitmap占据内存大小]]></title>
      <url>http://windrunnerlihuan.com/2016/07/12/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160; Bitmap的使用是开发时绕不过的坑，使用时要处处留意内存问题，稍有不慎就会报OOM（out of memory）。所以这次我们就研究研究程序中Bitmap到底占据多少内存。<br><a id="more"></a></p>
<h1 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h1><p>&#160; &#160; &#160; &#160; 比如我们使用一张图片，将其放入到工程目录中，想当然的会以为为这张图片建立的bitmap使用内存大小为：宽×高×像素大小。为了验证这个猜想，我在度娘上随便找了幅图：</p>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/picture.jpg" title="素材"></div><br>&#160; &#160; &#160; &#160; 规格是768×1152，大小为153.3KB，格式为支持ARGB四阶的32位色的JPG图片。<br>&#160; &#160; &#160; &#160; 我们猜想，如果按照内存大小计算公式，所占内存应为：<strong>768×1152×4=3538944</strong>，字节。因为JPG格式是有损压缩格式，所以存储大小比内存大小小多了。<br>&#160; &#160; &#160; &#160; 然后将这张图片放到<strong>res/drawable-xhdpi</strong>下，通过如下代码计算内存大小：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> density = <span class="keyword">this</span>.getResources().getDisplayMetrics().density;</span><br><span class="line"><span class="keyword">int</span> dpi = <span class="keyword">this</span>.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">Log.e(TAG, <span class="string">"density = "</span> + density + <span class="string">"------"</span> + <span class="string">"dpi = "</span> + dpi);</span><br><span class="line"></span><br><span class="line">Bitmap b = BitmapFactory.decodeResource(getResources(), R.drawable.picture);</span><br><span class="line"><span class="keyword">int</span> w = b.getWidth();</span><br><span class="line"><span class="keyword">int</span> h = b.getHeight();</span><br><span class="line"><span class="keyword">int</span> size = b.getByteCount();</span><br><span class="line"><span class="keyword">int</span> config = b.getConfig().ordinal();</span><br><span class="line"></span><br><span class="line">Log.e(TAG, <span class="string">"w = "</span> + w + <span class="string">";"</span> + <span class="string">"h = "</span> + h + <span class="string">";"</span> + <span class="string">"size = "</span> + size + <span class="string">";"</span> + <span class="string">"config = "</span> + config);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;测试机器规格为：<strong>Google Nexus 5 - 5.1.0 - API 22 - 1080×1920(480dpi)</strong>。<br>&#160; &#160; &#160; &#160;打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 1152;h = 1728;size = 7962624;config = 3</p>
</blockquote>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/excuse.jpg" title="excuse me"></div><br>&#160; &#160; &#160; &#160;Why？How did you do it？这个不按套路出牌啊，宽高明显被拉伸了啊。。。。。。然后我又试了下将这张图片放到了<strong>res/drawable-xxhdpi</strong>下，打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 768;h = 1152;size = 3538944;config = 3</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;这次倒是和理论计算的大小一样了，我们大概猜到了什么。。。。。接着我又把这张图片放到了<strong>assets</strong>目录下，然后修改了一下获取图片的代码，打印log如下：</p>
<blockquote>
<p>density = 3.0——dpi = 480<br>w = 768;h = 1152;size = 3538944;config = 3</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;这次也是和理论值一样的，因为放到assets目录下的图片是不会被压缩的。</p>
<p>&#160; &#160; &#160; &#160;如果多试几次，把图片放入不同目录下再运行几遍，我们也能够总结出规律的。但这些都是现象，我们组的老大也曾经说过：开发人员不要轻易根据现象得出结论…….所以我们也要分析一下本质原因。</p>
<h1 id="求证"><a href="#求证" class="headerlink" title="求证"></a>求证</h1><p>&#160; &#160; &#160; &#160;做适配的同学要经常和density、densityDpi搞好关系，简单来说，可以理解为 density 的数值是 1dp=density px；densityDpi 是屏幕每英寸对应多少个点（不是像素点），在 DisplayMetrics 当中，这两个的关系是线性的：</p>
<table>
<thead>
<tr>
<th style="text-align:left">density</th>
<th style="text-align:right">0.75</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1.5</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">3.5</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">densityDpi</td>
<td style="text-align:right">120</td>
<td style="text-align:center">160</td>
<td style="text-align:center">240</td>
<td style="text-align:center">320</td>
<td style="text-align:center">480</td>
<td style="text-align:center">560</td>
<td style="text-align:center">640</td>
</tr>
<tr>
<td style="text-align:left">DpiFolder</td>
<td style="text-align:right">ldpi</td>
<td style="text-align:center">mdpi</td>
<td style="text-align:center">hdpi</td>
<td style="text-align:center">xhdpi</td>
<td style="text-align:center">xxhdpi</td>
<td style="text-align:center">xxxhdpi</td>
<td style="text-align:center">xxxxhdpi</td>
</tr>
</tbody>
</table>
<p>&#160; &#160; &#160; &#160;这些内容每个人应该都知道，先放到这里，方便后面查表。</p>
<h2 id="非压缩计算"><a href="#非压缩计算" class="headerlink" title="非压缩计算"></a>非压缩计算</h2><p>&#160; &#160; &#160; &#160;如果图片不被压缩，按照常规计算内存大小方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bitmap的getByteCount方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getByteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// int result permits bitmaps up to 46,340 x 46,340</span></span><br><span class="line">       <span class="keyword">return</span> getRowBytes() * getHeight();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Bitmap的getRowBytes方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getRowBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nativeRowBytes(mNativeBitmap);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">nativeRowBytes</span><span class="params">(<span class="keyword">long</span> nativeBitmap)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;getHeight 就是图片的高度（单位：px），getRowBytes 从字面意思看应该是行字节大小。我们往下看，找找JNI实现，查看 frameworks/base/core/jni/android/graphics/Bitmap.cpp文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">Bitmap_rowBytes</span><span class="params">(JNIEnv* env, jobject, jlong bitmapHandle)</span> </span>&#123;</span><br><span class="line">    SkBitmap* bitmap = <span class="keyword">reinterpret_cast</span>&lt;SkBitmap*&gt;(bitmapHandle);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;jint&gt;(bitmap-&gt;rowBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;（reinterpret_cast和static_cast是C++经常用到的用来处理无关类型之间转换的强制类型转换符，建议有时间可以研究研究，或者把C++回顾一下，毕竟挺重要的。这里先给个<a href="http://www.cnblogs.com/jerry19880126/archive/2012/08/14/2638192.html" target="_blank" rel="external">科普文章</a>）<br>&#160; &#160; &#160; &#160;上一篇关于的弹幕文章提到过，java层的Bitmap对应native层是由skia图形引擎创建的SkBitmap，关于<a href="https://skia.org/" target="_blank" rel="external">skia</a>这玩意儿东西比较多，不是专业的一时半会儿也玩不转。所以我们还是简单看看，继续往下找SkBitmap：(/external/skia/include/core/SkBitmap.h)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Return the number of bytes between subsequent rows of the bitmap. */</span></span><br><span class="line"><span class="keyword">size_t</span> rowBytes() <span class="keyword">const</span> &#123; <span class="keyword">return</span> fRowBytes; &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;得到上述fRowBytes的大小会在SkBitmap.cpp文件里计算：（/external/skia/src/core/SkBitmap.cpp）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算fRowBytes大小</span></span><br><span class="line"><span class="keyword">size_t</span> SkBitmap::ComputeRowBytes(Config c, <span class="keyword">int</span> width) &#123;</span><br><span class="line">    <span class="keyword">return</span> SkColorTypeMinRowBytes(SkBitmapConfigToColorType(c), width);<span class="comment">//SkColorTypeMinRowBytes是/SkImageInfo.h的方法；SkBitmapConfigToColorType是SkImagePriv.cpp的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkImageInfo.h的SkColorTypeMinRowBytes方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">SkColorTypeMinRowBytes</span><span class="params">(SkColorType ct, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> width * SkColorTypeBytesPerPixel(ct);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkImageInfo.h的SkColorTypeBytesPerPixel方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SkColorTypeBytesPerPixel</span><span class="params">(SkColorType ct)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint8_t</span> gSize[] = &#123;</span><br><span class="line">        <span class="number">0</span>,  <span class="comment">// Unknown</span></span><br><span class="line">        <span class="number">1</span>,  <span class="comment">// Alpha_8</span></span><br><span class="line">        <span class="number">2</span>,  <span class="comment">// RGB_565</span></span><br><span class="line">        <span class="number">2</span>,  <span class="comment">// ARGB_4444</span></span><br><span class="line">        <span class="number">4</span>,  <span class="comment">// RGBA_8888</span></span><br><span class="line">        <span class="number">4</span>,  <span class="comment">// BGRA_8888</span></span><br><span class="line">        <span class="number">1</span>,  <span class="comment">// kIndex_8</span></span><br><span class="line">    &#125;;</span><br><span class="line">	...省略障眼法的宏...</span><br><span class="line">    <span class="keyword">return</span> gSize[ct];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkBitmapConfigToColorType是SkImagePriv.cpp的方法</span></span><br><span class="line"><span class="function">SkColorType <span class="title">SkBitmapConfigToColorType</span><span class="params">(SkBitmap::Config config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SkColorType gCT[] = &#123;</span><br><span class="line">        kUnknown_SkColorType,   <span class="comment">// kNo_Config</span></span><br><span class="line">        kAlpha_8_SkColorType,   <span class="comment">// kA8_Config</span></span><br><span class="line">        kIndex_8_SkColorType,   <span class="comment">// kIndex8_Config</span></span><br><span class="line">        kRGB_565_SkColorType,   <span class="comment">// kRGB_565_Config</span></span><br><span class="line">        kARGB_4444_SkColorType, <span class="comment">// kARGB_4444_Config</span></span><br><span class="line">        kN32_SkColorType,   <span class="comment">// kARGB_8888_Config</span></span><br><span class="line">    &#125;;</span><br><span class="line">    SkASSERT((<span class="keyword">unsigned</span>)config &lt; SK_ARRAY_COUNT(gCT));</span><br><span class="line">    <span class="keyword">return</span> gCT[config];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;跟踪到这里，还记得我们上面大log的地方么。int config = b.getConfig().ordinal()返回的是3，那么在Bitmap.Config里面索引第4个枚举变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Config &#123;</span><br><span class="line">    ALPHA_8     (<span class="number">1</span>),</span><br><span class="line">    RGB_565     (<span class="number">3</span>),</span><br><span class="line">    ARGB_4444   (<span class="number">4</span>),</span><br><span class="line">    ARGB_8888   (<span class="number">5</span>);<span class="comment">//索引第四个是这个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> nativeInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从这个列表可以看出它与skia支持的图片格式一一对应，但是Android只支持上面4种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Config sConfigs[] = &#123;</span><br><span class="line">        <span class="keyword">null</span>, ALPHA_8, <span class="keyword">null</span>, RGB_565, ARGB_4444, ARGB_8888</span><br><span class="line">    &#125;;       </span><br><span class="line">    Config(<span class="keyword">int</span> ni) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nativeInt = ni;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Config <span class="title">nativeToConfig</span><span class="params">(<span class="keyword">int</span> ni)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sConfigs[ni];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;依照上面C++文件，我们发现 ARGB_8888（也就是我们最常用的 Bitmap 的格式）的一个像素占用 4byte，那么 rowBytes 实际上就是 4<em>width bytes。则理论上 ARGB_8888 的 Bitmap 占用内存的计算公式为：<br><em>*bitmapInRam = bitmapWidth × bitmapHeight × 4 bytes</em></em></p>
<h2 id="压缩计算"><a href="#压缩计算" class="headerlink" title="压缩计算"></a>压缩计算</h2><p>&#160; &#160; &#160; &#160;如果我们不将图片放到assets目录下，内存大小计算方式就和上面完全不同了。我们读取的是 drawable 目录下面的图片，用的是 decodeResource 方法,该方法本质上就两步：</p>
<ul>
<li>读取原始资源，这个调用了 <strong>Resource.openRawResource</strong> 方法，这个方法调用完成之后会对 TypedValue 进行赋值，其中包含了原始资源的 density 等信息；</li>
<li>调用 <strong>decodeResourceStream</strong> 对原始资源进行解码和适配。这个过程实际上就是原始资源的 density 到屏幕 density 的一个映射。<br>&#160; &#160; &#160; &#160;原始资源的 density 其实取决于资源存放的目录（比如 xxhdpi 对应的是480），而屏幕 density 的赋值，请看下面这段代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> decodeResource(res, id, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id, Options opts)</span> </span>&#123;</span><br><span class="line">      Bitmap bm = <span class="keyword">null</span>;</span><br><span class="line">      InputStream is = <span class="keyword">null</span>; </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> TypedValue value = <span class="keyword">new</span> TypedValue();</span><br><span class="line">          is = res.openRawResource(id, value);<span class="comment">//对 TypedValue 进行赋值，其中包含了原始资源的 density 等信息</span></span><br><span class="line"></span><br><span class="line">          bm = decodeResourceStream(res, value, is, <span class="keyword">null</span>, opts);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResourceStream</span><span class="params">(Resources res, TypedValue value,</span><br><span class="line">          InputStream is, Rect pad, Options opts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (opts == <span class="keyword">null</span>) &#123;<span class="comment">//opt为null</span></span><br><span class="line">          opts = <span class="keyword">new</span> Options();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (opts.inDensity == <span class="number">0</span> &amp;&amp; value != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> density = value.density;</span><br><span class="line">          <span class="keyword">if</span> (density == TypedValue.DENSITY_DEFAULT) &#123;</span><br><span class="line">              opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (density != TypedValue.DENSITY_NONE) &#123;</span><br><span class="line">              opts.inDensity = density;<span class="comment">//这里density的值如果对应资源目录为xhdpi的话，就是320</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//请注意，inTargetDensity就是当前的显示密度，比如Google Nexus 5就是480</span></span><br><span class="line">          opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> decodeStream(is, pad, opts);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeStream</span><span class="params">(InputStream is, Rect outPadding, Options opts)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      bm = decodeStreamInternal(is, outPadding, opts);</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> bm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">decodeStreamInternal</span><span class="params">(InputStream is, Rect outPadding, Options opts)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> nativeDecodeStream(is, tempStorage, outPadding, opts);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">nativeDecodeStream</span><span class="params">(InputStream is, <span class="keyword">byte</span>[] storage,</span><br><span class="line">          Rect padding, Options opts)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们看到 opts 这个值被初始化，而它的构造居然如此简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Options</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inDither = <span class="keyword">false</span>;</span><br><span class="line">    inScaled = <span class="keyword">true</span>;</span><br><span class="line">    inPremultiplied = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;所以我们就很容易的看到，Option.inScreenDensity 这个值没有被初始化，而实际上后面我们也会看到这个值根本不会用到；我们最应该关心的是什么呢？是 inDensity 和 inTargetDensity，这两个值与下面 cpp 文件里面的 density 和 targetDensity 相对应——重复一下，inDensity 就是原始资源的 density，inTargetDensity 就是屏幕的 density。<br>&#160; &#160; &#160; &#160;紧接着，用到了 nativeDecodeStream 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">nativeDecodeStream</span><span class="params">(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage,</span><br><span class="line">        jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jobject bitmap = NULL;</span><br><span class="line">		......</span><br><span class="line">        bitmap = doDecode(env, bufferedStream, padding, options);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">doDecode</span><span class="params">(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> density = env-&gt;GetIntField(options, gOptions_densityFieldID);<span class="comment">//对应xhdpi的时候，是320</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID);<span class="comment">//Google Nexus 5为480</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID);</span><br><span class="line">        <span class="keyword">if</span> (density != <span class="number">0</span> &amp;&amp; targetDensity != <span class="number">0</span> &amp;&amp; density != screenDensity) &#123;</span><br><span class="line">            scale = (<span class="keyword">float</span>) targetDensity / density;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> bool willScale = scale != <span class="number">1.0f</span>;</span><br><span class="line">......</span><br><span class="line">SkBitmap decodingBitmap;</span><br><span class="line"><span class="keyword">if</span> (!decoder-&gt;decode(stream, &amp;decodingBitmap, prefColorType,decodeMode)) &#123;</span><br><span class="line">   <span class="keyword">return</span> nullObjectReturn(<span class="string">"decoder-&gt;decode returned false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里这个deodingBitmap就是解码出来的bitmap，大小是图片原始的大小</span></span><br><span class="line"><span class="keyword">int</span> scaledWidth = decodingBitmap.width();</span><br><span class="line"><span class="keyword">int</span> scaledHeight = decodingBitmap.height();</span><br><span class="line"><span class="keyword">if</span> (willScale &amp;&amp; decodeMode != SkImageDecoder::kDecodeBounds_Mode) &#123;</span><br><span class="line">    scaledWidth = <span class="keyword">int</span>(scaledWidth * scale + <span class="number">0.5f</span>);</span><br><span class="line">    scaledHeight = <span class="keyword">int</span>(scaledHeight * scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> sx = scaledWidth / <span class="keyword">float</span>(decodingBitmap.width());</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> sy = scaledHeight / <span class="keyword">float</span>(decodingBitmap.height());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> avoid copying when scaled size equals decodingBitmap size</span></span><br><span class="line">    SkColorType colorType = colorTypeForScaledOutput(decodingBitmap.colorType());</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> If the alphaType is kUnpremul and the image has alpha, the</span></span><br><span class="line">    <span class="comment">// colors may not be correct, since Skia does not yet support drawing</span></span><br><span class="line">    <span class="comment">// to/from unpremultiplied bitmaps.</span></span><br><span class="line">    outputBitmap-&gt;setInfo(SkImageInfo::Make(scaledWidth, scaledHeight,</span><br><span class="line">            colorType, decodingBitmap.alphaType()));</span><br><span class="line">    <span class="keyword">if</span> (!outputBitmap-&gt;allocPixels(outputAllocator, NULL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nullObjectReturn(<span class="string">"allocation failed for scaled bitmap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If outputBitmap's pixels are newly allocated by Java, there is no need</span></span><br><span class="line">    <span class="comment">// to erase to 0, since the pixels were initialized to 0.</span></span><br><span class="line">    <span class="keyword">if</span> (outputAllocator != &amp;javaAllocator) &#123;</span><br><span class="line">        outputBitmap-&gt;eraseColor(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    SkPaint paint;</span><br><span class="line">    paint.setFilterLevel(SkPaint::kLow_FilterLevel);</span><br><span class="line"> </span><br><span class="line">    <span class="function">SkCanvas <span class="title">canvas</span><span class="params">(*outputBitmap)</span></span>;</span><br><span class="line">    canvas.scale(sx, sy);</span><br><span class="line">    canvas.drawBitmap(decodingBitmap, <span class="number">0.0f</span>, <span class="number">0.0f</span>, &amp;paint);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;注意到其中有个 density 和 targetDensity，前者是 decodingBitmap 的 density，这个值跟这张图片的放置的目录有关（比如 xhdpi 是320，xxhdpi 是480），这部分代码我跟了一下，太长了，就不列出来了；targetDensity 实际上是我们加载图片的目标 density，这个值的来源我们已经在前面给出了，就是 DisplayMetrics 的 densityDpi，如果是Google Nexus 5那么这个数值就是480。sx 和sy 实际上是约等于 scale 的，因为 scaledWidth 和 scaledHeight 是由 width 和 height 乘以 scale 得到的。我们看到 Canvas 放大了 scale 倍，然后又把读到内存的这张 bitmap 画上去，相当于把这张 bitmap 放大了 scale 倍。</p>
<p>&#160; &#160; &#160; &#160;然后我们再次验证上面打log的地方，win + r ，输入calc呼出计算器。<strong>这里千万不要忘了了精度</strong>：</p>
<p><strong>float scale = 480/320f = 1.5</strong><br><strong>int scaledWidth = int(768 * 1.5 + 0.5f) = 1152</strong><br><strong>int scaledHeight = int(1152 * 1.5 + 0.5f) = 1728</strong></p>
<p><strong>size = 1152 <em> 1728 </em> 4 = 7962624</strong></p>
<p>&#160; &#160; &#160; &#160;果然和上面log打印的一模一样！因此我们可以得出结论。Bitmap在内存中大小取决于：</p>
<ul>
<li>色彩格式，前面我们已经提到，如果是 ARG_B8888 那么就是一个像素4个字节，如果是 RGB_565 那就是2个字节</li>
<li>原始文件存放的资源目录(是 hdpi 还是 xxhdpi 等等)</li>
<li>目标屏幕的密度（所以同等条件下，红米在资源方面消耗的内存肯定是要小于三星S6的）</li>
</ul>
<p>&#160; &#160; &#160; &#160;内存大小计算公式大概为（压缩计算情况下）（已忽略精度）：</p>
<blockquote>
<p><strong>内存大小 = （设备屏幕dpi / 资源所在目录dpi）^ 2 × 图片原始宽 × 图片原始高 × 像素大小</strong></p>
</blockquote>
<h1 id="瞎猜"><a href="#瞎猜" class="headerlink" title="瞎猜"></a>瞎猜</h1><p>&#160; &#160; &#160; &#160;上面分析Bitmap.Config时发现Android官方并不完全支持skia图形引擎的所有像素格式，供java层设置的Config只有这么4个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Config &#123;</span><br><span class="line">    <span class="comment">// these native values must match up with the enum in SkBitmap.h</span></span><br><span class="line"> </span><br><span class="line">    ALPHA_8     (<span class="number">1</span>),</span><br><span class="line">    RGB_565     (<span class="number">3</span>),</span><br><span class="line">    ARGB_4444   (<span class="number">4</span>),</span><br><span class="line">    ARGB_8888   (<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    inal <span class="keyword">int</span> nativeInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其实 Java 层的枚举变量的 nativeInt 对应的就是 Skia 库当中枚举的索引值；而skia却支持这么多：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Skbitmap.h文件</span></span><br><span class="line">    <span class="keyword">enum</span> Config &#123;</span><br><span class="line">        kNo_Config,         <span class="comment">//!&lt; bitmap has not been configured</span></span><br><span class="line">        kA8_Config,         <span class="comment">//!&lt; 8-bits per pixel, with only alpha specified (0 is transparent, 0xFF is opaque)</span></span><br><span class="line">        kIndex8_Config,     <span class="comment">//!&lt; 8-bits per pixel, using SkColorTable to specify the colors</span></span><br><span class="line">        kRGB_565_Config,    <span class="comment">//!&lt; 16-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">        kARGB_4444_Config,  <span class="comment">//!&lt; 16-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">        kARGB_8888_Config,  <span class="comment">//!&lt; 32-bits per pixel, (see SkColorPriv.h for packing)</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述枚举中第三个类型为<strong>索引图</strong>类型。<a href="http://www.tulaoshi.com/n/20160128/1466750.html" target="_blank" rel="external">索引位图</a>，每个像素只占 1 Byte，不仅支持 RGB，还支持 alpha。微软画图工具应该都玩过吧（win + r，输入mspaint），里面的调色板就是索引色盘。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%B5%85%E6%9E%90Bitmap%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/huatu.jpg" alt="画图工具"><br>&#160; &#160; &#160; &#160;而Android其他的config类型一个像素点占的字节比这个大多了，所以我们有时候能不能也用索引色去悄悄替换原来格式呢？<br>&#160; &#160; &#160; &#160;我的猜想是，反射构造一个Bitmap.Config枚举对象，然后反射设置nativeInt字段的值为2，猜想代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options op = <span class="keyword">new</span> Options();</span><br><span class="line">op.inPreferredConfig = ...反射构建Bitmap.Config相关内容...</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.drawable.picture, op);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;不过我没有实践过，也是瞎猜的，不知道能不能行的通。。。。。。</p>
<p>&#160; &#160; &#160; &#160;但是我对上一篇文章种调skia生成弹幕bitmap处的代码做了修改，修改了DanmakuFlameMaster工程里的NativeBitmapFactory.java文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">createNativeBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Config config, <span class="keyword">boolean</span> hasAlpha)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int nativeConfig = getNativeConfig(config);</span></span><br><span class="line">        <span class="keyword">int</span> nativeConfig = <span class="number">2</span>;<span class="comment">//直接改为索引色</span></span><br><span class="line">        <span class="keyword">return</span> android.os.Build.VERSION.SDK_INT == <span class="number">19</span> ? createBitmap19(width, height,</span><br><span class="line">                nativeConfig, hasAlpha) : createBitmap(width, height, nativeConfig, hasAlpha);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;将色彩格式改为索引色，然后重新编译运行。。。。。。然而弹幕压根没出来。。。。。等以后有机会问问<code>ctiao</code>吧，请教一下为何。<br>&#160; &#160; &#160; &#160;这些瞎猜只能暂时放着，等以后有机会再验证吧。。。。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[弹幕框架DanmakuFlameMaster简单分析]]></title>
      <url>http://windrunnerlihuan.com/2016/07/02/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160;随着B站逐渐崛起，其开源弹幕项目<a href="https://github.com/Bilibili/DanmakuFlameMaster" target="_blank" rel="external">DanmakuFlameMaster</a>应用场景也越来越多。我也是在一次偶然机会下发现了这个项目，被其惊艳的效果震撼。以前我就对弹幕技术很感兴趣，可能是因为B站动漫看多，几乎每一部番都是漫天的弹幕乱飞，如果哪部剧没有弹幕反而觉得不适应；久而久之就愈发倾向钻研其原理。<br>&#160; &#160; &#160; &#160;看到效果后，我猜想<strong>绘制原理</strong>应该是创建一个定时器作为全部弹幕的时间参考，然后每条弹幕出现的位置都以这个定时器去计算x、y值，然后定时任务定期postInvalidate，弹幕画布重新绘制onDraw；弹幕如此之多，应该有<strong>缓存机制</strong>，也许建立了一个弹幕池让出现过的弹幕缓存起来，新弹幕可以复用旧弹幕item。<br>&#160; &#160; &#160; &#160;先这么假设吧，然后验证我们的猜想，看看有哪些坑。<br><a id="more"></a></p>
<hr>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>&#160; &#160; &#160; &#160;首先是添加控件，项目里提供了三个控件：DanmakuSurfaceView、DanmakuTextureView和DanmakuView，使用其中三个任意一个都可以。我们选个DanmakuView方便分析。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span>	</span><br><span class="line">    </span><br><span class="line">	省略一些布局...</span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">master.flame.danmaku.ui.widget.DanmakuView</span></span><br><span class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/sv_danmaku"</span></span><br><span class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">    省略一些布局...  </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后是代码配置，先看一下初始化相关：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_main);</span><br><span class="line">      findViews();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">省略一些代码...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// DanmakuView</span></span><br><span class="line">mDanmakuView = (IDanmakuView) findViewById(R.id.sv_danmaku);</span><br><span class="line">      <span class="comment">// 设置最大显示行数</span></span><br><span class="line">      HashMap&lt;Integer, Integer&gt; maxLinesPair = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">      maxLinesPair.put(BaseDanmaku.TYPE_SCROLL_RL, <span class="number">5</span>); <span class="comment">// 滚动弹幕最大显示5行</span></span><br><span class="line">      <span class="comment">// 设置是否禁止重叠</span></span><br><span class="line">      HashMap&lt;Integer, Boolean&gt; overlappingEnablePair = <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();</span><br><span class="line">      overlappingEnablePair.put(BaseDanmaku.TYPE_SCROLL_RL, <span class="keyword">true</span>);</span><br><span class="line">      overlappingEnablePair.put(BaseDanmaku.TYPE_FIX_TOP, <span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">//创建弹幕控件上下文，类似Context，里面可以进行一系列配置</span></span><br><span class="line">      mContext = DanmakuContext.create();</span><br><span class="line">mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, <span class="number">3</span>)<span class="comment">//设置描边样式</span></span><br><span class="line">.setDuplicateMergingEnabled(<span class="keyword">false</span>) <span class="comment">//设置不合并相同内容弹幕</span></span><br><span class="line">.setScrollSpeedFactor(<span class="number">1.2f</span>) <span class="comment">//设置弹幕滚动速度缩放比例，越大速度越慢</span></span><br><span class="line">.setScaleTextSize(<span class="number">1.2f</span>) <span class="comment">//设置字体缩放比例</span></span><br><span class="line">   .setCacheStuffer(<span class="keyword">new</span> SpannedCacheStuffer(), mCacheStufferAdapter) <span class="comment">// 图文混排使用SpannedCacheStuffer  </span></span><br><span class="line"><span class="comment">//.setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</span></span><br><span class="line">      .setMaximumLines(maxLinesPair) <span class="comment">//设置最大行数策略</span></span><br><span class="line">      .preventOverlapping(overlappingEnablePair); <span class="comment">//设置禁止重叠策略</span></span><br><span class="line">      	       </span><br><span class="line">省略一些代码...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuContext设置setCacheStuffer(CacheStuffer, Proxy)时，如果不设置此方法，则CacheStuffer默认为SimpleTextCacheStuffer，proxy默认为null；第一个参数，项目例子中提供了BackgroundCacheStuffer和SpannedCacheStuffer，其实也可以自己扩展，第二个参数例子中也写了一个mCacheStufferAdapter，同理也可以自己扩展。这个sample中注释也写得比较明确，我们往下分析原理时会解释。<br>&#160; &#160; &#160; &#160;然后设置数据源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">			<span class="comment">//替换为A站弹幕数据源，因为A站弹幕数据是json，B站是xml，为了方便分析因此替换为A站源</span></span><br><span class="line">            <span class="comment">//mParser = createParser(this.getResources().openRawResource(R.raw.comments));</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mParser = createParser(<span class="keyword">this</span>.getAssets().open(<span class="string">"comment.json"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BaseDanmakuParser <span class="title">createParser</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BaseDanmakuParser() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> Danmakus <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Danmakus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_BILI);</span></span><br><span class="line">        ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader.load(stream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalDataException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        BaseDanmakuParser parser = new BiliDanmukuParser();</span></span><br><span class="line">        BaseDanmakuParser parser = <span class="keyword">new</span> AcFunDanmakuParser();</span><br><span class="line">        IDataSource&lt;?&gt; dataSource = loader.getDataSource();</span><br><span class="line">        parser.load(dataSource);</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后启动弹幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置弹幕view相关回调</span></span><br><span class="line">mDanmakuView.setCallback(<span class="keyword">new</span> DrawHandler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTimer</span><span class="params">(DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawingFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">danmakuShown</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//Log.d("DFM", "danmakuShown(): text=" + danmaku.text);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"DFM"</span>, <span class="string">"MainActivity inline callback's method prepared"</span>);</span><br><span class="line">            mDanmakuView.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    mDanmakuView.prepare(mParser, mContext);</span><br><span class="line">    mDanmakuView.showFPS(<span class="keyword">true</span>);</span><br><span class="line">    mDanmakuView.enableDanmakuDrawingCache(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;基本使用在项目的例子中都写的很清楚，这些应该难度不大。接下来应该是分析流程了。</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160;DanmakuFlameMaster流程确实十分复杂，因为变量实在太多了，所以分析时推荐先整体看个大概，然后一步一步打断点确认细节。</p>
<h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><p>&#160; &#160; &#160; &#160;上面写基本使用法，第一步是初始配置，我们看看到底初始化了哪些参数。对比上面的调用顺序，首先进入DanmakuContext看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">//相关配置如下，主要初始化一下变量</span></span><br><span class="line">		mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, <span class="number">3</span>)<span class="comment">//设置描边样式</span></span><br><span class="line">		.setDuplicateMergingEnabled(<span class="keyword">false</span>) <span class="comment">//设置不合并相同内容弹幕</span></span><br><span class="line">		.setScrollSpeedFactor(<span class="number">1.2f</span>) <span class="comment">//设置弹幕滚动速度缩放比例，越大速度越慢</span></span><br><span class="line">		.setScaleTextSize(<span class="number">1.2f</span>) <span class="comment">//设置字体缩放比例</span></span><br><span class="line">	    .setCacheStuffer(<span class="keyword">new</span> SpannedCacheStuffer(), mCacheStufferAdapter) <span class="comment">// 图文混排使用SpannedCacheStuffer  </span></span><br><span class="line">		<span class="comment">//.setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</span></span><br><span class="line">        .setMaximumLines(maxLinesPair) <span class="comment">//设置最大行数策略</span></span><br><span class="line">        .preventOverlapping(overlappingEnablePair); <span class="comment">//设置禁止重叠策略</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//DanmakuContext 类重要方法</span></span><br><span class="line">		<span class="comment">/*------------DanmakuContext STAET-----------*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbsDisplayer mDisplayer = <span class="keyword">new</span> AndroidDisplayer();<span class="comment">//创建DanmakuContext 对象时直接new了个mDisplayer 全局变量</span></span><br><span class="line">	 <span class="comment">/**</span><br><span class="line">     * 设置缓存绘制填充器，默认使用SimpleTextCacheStuffer只支持纯文字显示, 如果需要图文混排请设置SpannedCacheStuffer </span><br><span class="line">     * 如果需要定制其他样式请扩展SimpleTextCacheStuffer或者SpannedCacheStuffer</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DanmakuContext <span class="title">setCacheStuffer</span><span class="params">(BaseCacheStuffer cacheStuffer, BaseCacheStuffer.Proxy cacheStufferAdapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mCacheStuffer = cacheStuffer;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCacheStuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCacheStuffer.setProxy(cacheStufferAdapter);</span><br><span class="line">            mDisplayer.setCacheStuffer(<span class="keyword">this</span>.mCacheStuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*------------DanmakuContext END-----------*/</span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;以上配置主要配置一些常规参数，记不住也没关系，我们可以打断点一一查看。</p>
<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><p>&#160; &#160; &#160; &#160;然后就是加载弹幕源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> BaseDanmakuParser <span class="title">createParser</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建A站弹幕加载器</span></span><br><span class="line">      ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//将数据流载入加载器里</span></span><br><span class="line">          loader.load(stream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalDataException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建弹幕解析器</span></span><br><span class="line">      BaseDanmakuParser parser = <span class="keyword">new</span> AcFunDanmakuParser();</span><br><span class="line">      <span class="comment">//取出数据源</span></span><br><span class="line">      IDataSource&lt;?&gt; dataSource = loader.getDataSource();</span><br><span class="line">      <span class="comment">//解析器放入数据源</span></span><br><span class="line">      parser.load(dataSource);</span><br><span class="line">      <span class="keyword">return</span> parser;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们一步一步来，先创建A站弹幕加载器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据不同标签创建不同加载器，可以根据不同业务自己扩展定制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ILoader <span class="title">create</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (TAG_BILI.equalsIgnoreCase(tag)) &#123;</span><br><span class="line">           <span class="keyword">return</span> BiliDanmakuLoader.instance();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(TAG_ACFUN.equalsIgnoreCase(tag))<span class="comment">//我们到了这里</span></span><br><span class="line">       	<span class="keyword">return</span> AcFunDanmakuLoader.instance();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入数据流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IllegalDataException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		dataSource = <span class="keyword">new</span> JSONSource(in);<span class="comment">//这里创建了一个JSONSource</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalDataException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSONSource构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JSONSource</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> JSONException</span>&#123;</span><br><span class="line">	init(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	mInput = in;</span><br><span class="line">	String json = IOUtils.getString(mInput);<span class="comment">//将流转成字符串</span></span><br><span class="line">	init(json);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String json)</span> <span class="keyword">throws</span> JSONException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!TextUtils.isEmpty(json))&#123;</span><br><span class="line">		mJSONArray = <span class="keyword">new</span> JSONArray(json);<span class="comment">//将json字符串保存到一个JSONArray全局变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出JSONSource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;载入数据流就是读取弹幕数据文件流，然后转成字符串，最后保存到一个JSONArray变量里存起来。<br>&#160; &#160; &#160; &#160;继续往下分析创建弹幕解析器、取出数据源、解析器放入数据源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AcFunDanmakuParser的load方法，将上一步得到的JSONSource放入到AcFunDanmakuParser中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseDanmakuParser <span class="title">load</span><span class="params">(IDataSource&lt;?&gt; source)</span> </span>&#123;</span><br><span class="line">      mDataSource = source;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里数据就载入到解析器里了，parser里有弹幕源数据了。</p>
<h2 id="启动弹幕"><a href="#启动弹幕" class="headerlink" title="启动弹幕"></a>启动弹幕</h2><p>&#160; &#160; &#160; &#160;启动弹幕重要的就是这一句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDanmakuView.prepare(mParser, mContext);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;此时mParser和mContext都已经初始化完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(BaseDanmakuParser parser, DanmakuContext config)</span> </span>&#123;</span><br><span class="line">     prepare();<span class="comment">///创建一个 DrawHandler</span></span><br><span class="line">     handler.setConfig(config);</span><br><span class="line">     handler.setParser(parser);</span><br><span class="line">     handler.setCallback(mCallback);</span><br><span class="line">     handler.prepare();<span class="comment">//然后调用DrawHandler的prepare方法</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//创建一个 DrawHandler</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (handler == <span class="keyword">null</span>)</span><br><span class="line">         handler = <span class="keyword">new</span> DrawHandler(getLooper(mDrawingThreadType), <span class="keyword">this</span>, mDanmakuVisible);<span class="comment">//mDanmakuVisible为true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;设置一些全局变量后，会调用DrawHandler的prepare方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sendEmptyMessage(DrawHandler.PREPARE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> what = msg.what;</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> PREPARE:</span><br><span class="line">            mTimeBase = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (mParser == <span class="keyword">null</span> || !mDanmakuView.isViewReady()) &#123;<span class="comment">// false || false</span></span><br><span class="line">                sendEmptyMessageDelayed(PREPARE, <span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prepare(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//会继续调用prepare重载方法</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pausedPosition = <span class="number">0</span>;</span><br><span class="line">                        mReady = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mCallback.prepared();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> DanmakuTimer timer = <span class="keyword">new</span> DanmakuTimer();<span class="comment">//已经初始化timer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (drawTask == <span class="keyword">null</span>) &#123;<span class="comment">//会继续调用createDrawTask方法</span></span><br><span class="line">        drawTask = createDrawTask(mDanmakuView.isDanmakuDrawingCacheEnabled(), timer,</span><br><span class="line">                mDanmakuView.getContext(), mDanmakuView.getWidth(), mDanmakuView.getHeight(),</span><br><span class="line">                mDanmakuView.isHardwareAccelerated(), <span class="keyword">new</span> IDrawTask.TaskListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        initRenderingConfigs();</span><br><span class="line">                        runnable.run();</span><br><span class="line">                    &#125;</span><br><span class="line">		......</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续调用createDrawTask(true, timer, context, width, height, true, listener)方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> IDrawTask <span class="title">createDrawTask</span><span class="params">(<span class="keyword">boolean</span> useDrwaingCache, DanmakuTimer timer,</span><br><span class="line">                                 Context context,</span><br><span class="line">                                 <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span><br><span class="line">                                 <span class="keyword">boolean</span> isHardwareAccelerated,</span><br><span class="line">                                 IDrawTask.TaskListener taskListener)</span> </span>&#123;</span><br><span class="line">    mDisp = mContext.getDisplayer();<span class="comment">//AndroidDisplayer赋给它，顾名思义，Displayer就是显示器</span></span><br><span class="line">    mDisp.setSize(width, height);<span class="comment">//设置弹幕视图宽高</span></span><br><span class="line">    DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();</span><br><span class="line">    mDisp.setDensities(displayMetrics.density, displayMetrics.densityDpi,</span><br><span class="line">            displayMetrics.scaledDensity);<span class="comment">//设置密度先关</span></span><br><span class="line">    mDisp.resetSlopPixel(mContext.scaleTextSize);<span class="comment">//设置字体缩放比例，之前设过了1.2</span></span><br><span class="line">    mDisp.setHardwareAccelerated(isHardwareAccelerated);<span class="comment">//硬件加速，true</span></span><br><span class="line">    <span class="comment">//useDrwaingCache 为true</span></span><br><span class="line">    IDrawTask task = useDrwaingCache ?</span><br><span class="line">            <span class="keyword">new</span> CacheManagingDrawTask(timer, mContext, taskListener, <span class="number">1024</span> * <span class="number">1024</span> * AndroidUtils.getMemoryClass(context) / <span class="number">3</span>)</span><br><span class="line">            : <span class="keyword">new</span> DrawTask(timer, mContext, taskListener);</span><br><span class="line">    task.setParser(mParser);<span class="comment">//把存放数据源的mParser放入CacheManagingDrawTask中</span></span><br><span class="line">    task.prepare();<span class="comment">//这个才是重点，调用CacheManagingDrawTask的prepare方法</span></span><br><span class="line">    obtainMessage(NOTIFY_DISP_SIZE_CHANGED, <span class="keyword">false</span>).sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述过程最后一个调用了createDrawTask方法，这里先初始化了一下AndroidDisplayer配置，就把他当做显示器吧，我猜<code>ctiao</code>当初设计时也是这么比喻的吧。<br>&#160; &#160; &#160; &#160;设置好弹幕显示相关的参数，然后就是创建绘制任务IDrawTask 了。这里有两个选择，如果使用缓存就创建CacheManagingDrawTask，不使用就创建DrawTask。不过CacheManagingDrawTask比DrawTask复杂很多。</p>
<h3 id="CacheManagingDrawTask绘制任务"><a href="#CacheManagingDrawTask绘制任务" class="headerlink" title="CacheManagingDrawTask绘制任务"></a>CacheManagingDrawTask绘制任务</h3><p>&#160; &#160; &#160; &#160;我们的useDrwaingCache为true（<code>其实把它改为false也没关系，并且这样就用不上那些so库了</code>），则创建CacheManagingDrawTask绘制任务，然后调用prepare方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheManagingDrawTask</span><span class="params">(DanmakuTimer timer, DanmakuContext config, TaskListener taskListener, <span class="keyword">int</span> maxCacheSize)</span> </span>&#123;<span class="comment">//传入定时器timer，config，listener，还有三分一应用分配内存大小的maxCacheSize</span></span><br><span class="line">      <span class="keyword">super</span>(timer, config, taskListener);<span class="comment">//会调用父类DrawTask的构造方法</span></span><br><span class="line">      NativeBitmapFactory.loadLibs();<span class="comment">//加载so库，用于创建bitmap，同时测试时候加载成功</span></span><br><span class="line">      mMaxCacheSize = maxCacheSize;</span><br><span class="line">      <span class="keyword">if</span> (NativeBitmapFactory.isInNativeAlloc()) &#123;<span class="comment">//true,将最大内存扩大到2倍</span></span><br><span class="line">          mMaxCacheSize = maxCacheSize * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mCacheManager = <span class="keyword">new</span> CacheManager(maxCacheSize, MAX_CACHE_SCREEN_SIZE);</span><br><span class="line">      mRenderer.setCacheManager(mCacheManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//看看父类的构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawTask</span><span class="params">(DanmakuTimer timer, DanmakuContext context,</span><br><span class="line">          TaskListener taskListener)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mContext = context;</span><br><span class="line">      mDisp = context.getDisplayer();</span><br><span class="line">      mTaskListener = taskListener;</span><br><span class="line">      mRenderer = <span class="keyword">new</span> DanmakuRenderer(context);</span><br><span class="line">......</span><br><span class="line">      initTimer(timer);<span class="comment">//初始化相关定时器</span></span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initTimer</span><span class="params">(DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">      mTimer = timer;</span><br><span class="line">      mCacheTimer = <span class="keyword">new</span> DanmakuTimer();</span><br><span class="line">      mCacheTimer.update(timer.currMillisecond);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;CacheManagingDrawTask的构造方法设置了一些变量。其中NativeBitmapFactory.loadLibs()加载了用于创建bitmap的so文件，就是用skia图形处理库直接创建bitmap，Android对2D图形处理采用的就是skia，3D图形处理用的是OpenGL ES。这样通过native层创建bitmap直接跳过Dalvik，毕竟java层内存用多了很容易oom。因为以前我就对native层比较感兴趣，所以我要任性的跟一遍源码 ^O.O^。为了怕跟完后自己晕了，找不到现在分析的地方了，所以在这里打个标签，mark一下。如不感兴趣，可以跳过= 。=<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/meizi.jpg" alt="标签"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NativeBitmapFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        System.loadLibrary(<span class="string">"ndkbitmap"</span>);<span class="comment">//载入so</span></span><br><span class="line">		......</span><br><span class="line">        <span class="comment">//测试功能</span></span><br><span class="line">        <span class="keyword">if</span> (nativeLibLoaded) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> libInit = init();<span class="comment">//这是一个native方法</span></span><br><span class="line">            <span class="keyword">if</span> (!libInit) &#123;</span><br><span class="line">                release();</span><br><span class="line">                notLoadAgain = <span class="keyword">true</span>;</span><br><span class="line">                nativeLibLoaded = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始化成功后</span></span><br><span class="line">                initField();<span class="comment">//反射Bitmap.Config的nativeInt字段</span></span><br><span class="line">                <span class="keyword">boolean</span> confirm = testLib();<span class="comment">//测试例子</span></span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(<span class="string">"NativeBitmapFactory"</span>, <span class="string">"loaded"</span> + nativeLibLoaded);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反射Bitmap.Config的nativeInt字段</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nativeIntField = Bitmap.Config.class.getDeclaredField(<span class="string">"nativeInt"</span>);</span><br><span class="line">            nativeIntField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            nativeIntField = <span class="keyword">null</span>;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里会调用测试方法testLib：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">testLib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nativeIntField == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">     Canvas canvas = <span class="keyword">null</span>;</span><br><span class="line">     ......</span><br><span class="line">      <span class="comment">//用native方法创建一个bitmap</span></span><br><span class="line">         bitmap = createNativeBitmap(<span class="number">2</span>, <span class="number">2</span>, Bitmap.Config.ARGB_8888, <span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">boolean</span> result = (bitmap != <span class="keyword">null</span> &amp;&amp; bitmap.getWidth() == <span class="number">2</span> &amp;&amp; bitmap.getHeight() == <span class="number">2</span>);</span><br><span class="line">......</span><br><span class="line">             canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">             Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">             paint.setColor(Color.RED);</span><br><span class="line">             paint.setTextSize(<span class="number">20f</span>);</span><br><span class="line">             canvas.drawRect(<span class="number">0f</span>, <span class="number">0f</span>, (<span class="keyword">float</span>) bitmap.getWidth(), (<span class="keyword">float</span>) bitmap.getHeight(),</span><br><span class="line">                     paint);</span><br><span class="line">             canvas.drawText(<span class="string">"TestLib"</span>, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bitmap <span class="title">createNativeBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, Config config, <span class="keyword">boolean</span> hasAlpha)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> nativeConfig = getNativeConfig(config);<span class="comment">//反射设置Bitmap.Config.ARGB_8888</span></span><br><span class="line">     <span class="keyword">return</span> android.os.Build.VERSION.SDK_INT == <span class="number">19</span> ? createBitmap19(width, height,</span><br><span class="line">             nativeConfig, hasAlpha) : createBitmap(width, height, nativeConfig, hasAlpha);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNativeConfig</span><span class="params">(Bitmap.Config config)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (nativeIntField == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nativeIntField.getInt(config);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">createBitmap</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> nativeConfig,</span><br><span class="line">         <span class="keyword">boolean</span> hasAlpha)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Bitmap <span class="title">createBitmap19</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> nativeConfig,</span><br><span class="line">         <span class="keyword">boolean</span> hasAlpha)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述最终用native方法创建bitmap，C++文件地址为 <a href="https://github.com/Bilibili/NativeBitmapFactory" target="_blank" rel="external">https://github.com/Bilibili/NativeBitmapFactory</a> ，接着继续查看native方法具体实现NativeBitmapFactory.cpp。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看java层init方法对应的本地方法</span></span><br><span class="line"><span class="function">jboolean <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_init</span><span class="params">(JNIEnv *env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//继续看Start方法</span></span><br><span class="line">    <span class="keyword">int</span> r = Start();</span><br><span class="line">    <span class="keyword">return</span> r == SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Start</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类型为ndkbitmap_obj 的结构体指针</span></span><br><span class="line">    ndkbitmap_obj = (<span class="keyword">ndkbitmap_object_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*ndkbitmap_obj));</span><br><span class="line">    <span class="keyword">int</span> r = Open(ndkbitmap_obj);</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Open</span><span class="params">(<span class="keyword">ndkbitmap_object_t</span> *obj)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个类型为skbitmap_sys_t 的结构体指针</span></span><br><span class="line">    <span class="keyword">skbitmap_sys_t</span> *sys = (<span class="keyword">skbitmap_sys_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (*sys));</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//打开libskia.so动态链接库，初始化一些参数并返回动态链接库的句柄</span></span><br><span class="line">    sys-&gt;libskia = InitLibrary(sys);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//打开libandroid_runtime.so动态链接库，初始化一些参数并返回动态链接库的句柄</span></span><br><span class="line">    sys-&gt;libjnigraphics = InitLibrary2(sys);</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//将初始化过后的结构指针sys赋给结构体obj的sys成员</span></span><br><span class="line">    obj-&gt;sys = sys;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;init方法主要是打开和skia相关的动态链接库，并初始化一些配置。(InitLibrary和InitLibrary2方法的细节我没有贴，里面实现需要一些专业知识，有兴趣的可以找资料钻研)然后就是createBitmap：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_createBitmap</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, obj, w, h, config, hasAlpha, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">Java_tv_cjump_jni_NativeBitmapFactory_createBitmap19</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createBitmap(env, obj, w, h, config, hasAlpha, <span class="number">0x3</span>, <span class="number">19</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">createBitmap</span><span class="params">(JNIEnv *env , jobject  obj, jint w, jint h, jint config, jboolean hasAlpha, <span class="keyword">int</span> isMuttable, <span class="keyword">int</span> api)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bm = createSkBitmap(ndkbitmap_obj, config, w, h);<span class="comment">//调用重载方法创建bitmap指针</span></span><br><span class="line">    <span class="keyword">if</span> (bm == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    jobject result = NULL;</span><br><span class="line">    skbitmap_sys_t *p_sys = ndkbitmap_obj-&gt;sys;</span><br><span class="line">    <span class="keyword">if</span>(p_sys-&gt;libjnigraphics) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p_sys-&gt;gjni_createBitmap) </span><br><span class="line">        &#123;<span class="comment">//SDK版本小于19</span></span><br><span class="line">	        <span class="comment">//通过这个函数指针把JNI层bitmap的转换对象return给java层</span></span><br><span class="line">            result = p_sys-&gt;gjni_createBitmap(env, bm, isMuttable, NULL, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p_sys-&gt;gjni_createBitmap_19later) &#123;<span class="comment">//SDK版本19以后返回值</span></span><br><span class="line">            result = p_sys-&gt;gjni_createBitmap_19later(env, bm, NULL, isMuttable, NULL, NULL, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建bitmap指针，并通过相关指针函数设置bitmap参数</span></span><br><span class="line">inline <span class="keyword">void</span> *createSkBitmap(ndkbitmap_object_t *obj, <span class="keyword">int</span> config, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span><br><span class="line">&#123;</span><br><span class="line">    skbitmap_sys_t *p_sys = obj-&gt;sys;</span><br><span class="line">    <span class="keyword">if</span> (p_sys == NULL || p_sys-&gt;libskia == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请内存，创建skBitmap 指针</span></span><br><span class="line">    <span class="keyword">void</span> *skBitmap = malloc(SIZE_OF_SKBITMAP);</span><br><span class="line">    <span class="keyword">if</span> (!skBitmap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    *((uint32_t *) ((uint32_t)skBitmap + SIZE_OF_SKBITMAP - <span class="number">4</span>)) = <span class="number">0xbaadbaad</span>;</span><br><span class="line">    <span class="comment">//ctor   </span></span><br><span class="line">    p_sys-&gt;sk_ctor(skBitmap);</span><br><span class="line">    <span class="keyword">if</span> (p_sys-&gt;sk_setConfig)</span><br><span class="line">    &#123;</span><br><span class="line">        p_sys-&gt;sk_setConfig(skBitmap, config, w, h, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p_sys-&gt;sk_setConfig_19later)</span><br><span class="line">    &#123;</span><br><span class="line">        p_sys-&gt;sk_setConfig_19later(skBitmap, config, w, h, <span class="number">0</span>, (uint8_t)kPremul_SkAlphaType);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p_sys-&gt;sk_setInfo) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> imageInfo[<span class="number">4</span>] = &#123;w, h, SkBitmapConfigToColorType(config), kPremul_SkAlphaType&#125;;</span><br><span class="line">        p_sys-&gt;sk_setInfo(skBitmap, imageInfo, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p_sys-&gt;sk_allocPixels(skBitmap, NULL, NULL);</span><br><span class="line">    p_sys-&gt;sk_eraseARGB(skBitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(*((uint32_t *) ((uint32_t)skBitmap + SIZE_OF_SKBITMAP - <span class="number">4</span>)) == <span class="number">0xbaadbaad</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        free(skBitmap);</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;通过skia图形库创建bitmap流程大概就是这些，其实skia的东西也是巨多无比，如果是从事这一方面工作应该都轻车熟路，我是完全的小白，能力有限，只能先到这儿。</p>
<p>&#160; &#160; &#160; &#160;好了，继续回到上次打标签的地方。接着该调用CacheManagingDrawTask的prepare方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (mParser != <span class="keyword">null</span>);</span><br><span class="line">    loadDanmakus(mParser);</span><br><span class="line">    mCacheManager.begin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先调用loadDanmakus方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> IDanmakus danmakuList;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadDanmakus</span><span class="params">(BaseDanmakuParser parser)</span> </span>&#123;</span><br><span class="line">        danmakuList = parser.setConfig(mContext)</span><br><span class="line">                            .setDisplayer(mDisp)</span><br><span class="line">                            .setTimer(mTimer)</span><br><span class="line">                            .getDanmakus();<span class="comment">//从parser中取出弹幕数据,做出相关处理</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(danmakuList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLastDanmaku = danmakuList.last();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;parser设置完DanmakuContext，AndroidDisplayer，DanmakuTimer之后，再调用getDanmakus取出弹幕信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IDanmakus <span class="title">getDanmakus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDanmakus != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> mDanmakus;</span><br><span class="line">    mContext.mDanmakuFactory.resetDurationsData();<span class="comment">//重庆内置一些变量为null</span></span><br><span class="line">    mDanmakus = parse();<span class="comment">//解析弹幕</span></span><br><span class="line">    releaseDataSource();<span class="comment">//关闭JSONSource</span></span><br><span class="line">    mContext.mDanmakuFactory.updateMaxDanmakuDuration();<span class="comment">//修正弹幕最大时长</span></span><br><span class="line">    <span class="keyword">return</span> mDanmakus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;进入AcFunDanmakuParser的parse方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Danmakus <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDataSource != <span class="keyword">null</span> &amp;&amp; mDataSource <span class="keyword">instanceof</span> JSONSource) &#123;</span><br><span class="line">            JSONSource jsonSource = (JSONSource) mDataSource;</span><br><span class="line">            <span class="keyword">return</span> doParse(jsonSource.data());<span class="comment">//go on</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Danmakus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Danmakus <span class="title">doParse</span><span class="params">(JSONArray danmakuListData)</span> </span>&#123;</span><br><span class="line">        Danmakus danmakus = <span class="keyword">new</span> Danmakus();</span><br><span class="line">        <span class="keyword">if</span> (danmakuListData == <span class="keyword">null</span> || danmakuListData.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> danmakus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; danmakuListData.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JSONObject danmakuArray = danmakuListData.getJSONObject(i);</span><br><span class="line">                <span class="keyword">if</span> (danmakuArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    danmakus = _parse(danmakuArray, danmakus);<span class="comment">//解析每一条弹幕</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> danmakus;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span><br><span class="line">     * &#123;"c":"19.408,16777215,1,25,178252,1376325904","m":"金刚如来！"&#125;</span><br><span class="line">     // 0:时间(弹幕出现时间)</span><br><span class="line">     // 1:颜色</span><br><span class="line">     // 2:类型(1从右往左滚动弹幕|6从右至左滚动弹幕|5顶端固定弹幕|4底端固定弹幕|7高级弹幕|8脚本弹幕)</span><br><span class="line">     // 3:字号</span><br><span class="line">     // 4:用户id ?</span><br><span class="line">     // 5:时间戳 ?</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Danmakus <span class="title">_parse</span><span class="params">(JSONObject jsonObject, Danmakus danmakus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (danmakus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            danmakus = <span class="keyword">new</span> Danmakus();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jsonObject == <span class="keyword">null</span> || jsonObject.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> danmakus;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonObject.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                JSONObject obj = jsonObject;</span><br><span class="line">                String c = obj.getString(<span class="string">"c"</span>);<span class="comment">//弹幕配置信息</span></span><br><span class="line">                String[] values = c.split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">if</span> (values.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> type = Integer.parseInt(values[<span class="number">2</span>]); <span class="comment">// 弹幕类型</span></span><br><span class="line">                    <span class="keyword">if</span> (type == <span class="number">7</span>)</span><br><span class="line">                        <span class="comment">// FIXME : hard code</span></span><br><span class="line">                        <span class="comment">// TODO : parse advance danmaku json</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">long</span> time = (<span class="keyword">long</span>) (Float.parseFloat(values[<span class="number">0</span>]) * <span class="number">1000</span>); <span class="comment">// 出现时间</span></span><br><span class="line">                    <span class="keyword">int</span> color = Integer.parseInt(values[<span class="number">1</span>]) | <span class="number">0xFF000000</span>; <span class="comment">// 颜色</span></span><br><span class="line">                    <span class="keyword">float</span> textSize = Float.parseFloat(values[<span class="number">3</span>]); <span class="comment">// 字体大小</span></span><br><span class="line">                    <span class="comment">//使用弹幕工厂创建一条弹幕</span></span><br><span class="line">                    BaseDanmaku item = mContext.mDanmakuFactory.createDanmaku(type, mContext);</span><br><span class="line">                    <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        item.time = time;</span><br><span class="line">                        item.textSize = textSize * (mDispDensity - <span class="number">0.6f</span>);</span><br><span class="line">                        item.textColor = color;</span><br><span class="line">                        item.textShadowColor = color &lt;= Color.BLACK ? Color.WHITE : Color.BLACK;</span><br><span class="line">                        <span class="comment">//弹幕文字内容，如果多行文本会拆分内容</span></span><br><span class="line">                        DanmakuUtils.fillText(item, obj.optString(<span class="string">"m"</span>, <span class="string">"...."</span>));</span><br><span class="line">                        item.index = i;</span><br><span class="line">                        item.setTimer(mTimer);<span class="comment">//将定时器设置给每一条弹幕</span></span><br><span class="line">                        danmakus.addItem(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> danmakus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DanmakuUtilsdefillText方法，多行文本会拆分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillText</span><span class="params">(BaseDanmaku danmaku, CharSequence text)</span> </span>&#123;</span><br><span class="line">        danmaku.text = text;</span><br><span class="line">        <span class="comment">//如果文本没有换行符则不用拆分</span></span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(text) || !text.toString().contains(BaseDanmaku.DANMAKU_BR_CHAR)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果有换行符则拆分，然后将拆分的数组付给lines 属性</span></span><br><span class="line">        String[] lines = String.valueOf(danmaku.text).split(BaseDanmaku.DANMAKU_BR_CHAR, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lines.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            danmaku.lines = lines;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从JSONSource里解析每一条弹幕，接着我们看看弹幕工厂DanmakuFactory创建弹幕的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, DanmakuContext context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      sLastConfig = context;</span><br><span class="line">      sLastDisp = context.getDisplayer();</span><br><span class="line">      <span class="keyword">return</span> createDanmaku(type, sLastDisp.getWidth(), sLastDisp.getHeight(), CURRENT_DISP_SIZE_FACTOR, context.scrollSpeedFactor);<span class="comment">// go on overload method</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> viewportWidth, <span class="keyword">int</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportScale, <span class="keyword">float</span> scrollSpeedFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createDanmaku(type, (<span class="keyword">float</span>) viewportWidth, (<span class="keyword">float</span>) viewportHeight, viewportScale, scrollSpeedFactor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseDanmaku <span class="title">createDanmaku</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> viewportWidth, <span class="keyword">float</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportSizeFactor, <span class="keyword">float</span> scrollSpeedFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> oldDispWidth = CURRENT_DISP_WIDTH; <span class="comment">// 默认是0</span></span><br><span class="line">      <span class="keyword">int</span> oldDispHeight = CURRENT_DISP_HEIGHT; <span class="comment">// 默认是0</span></span><br><span class="line">      <span class="comment">//修正试图宽高，缩放比，弹幕时长</span></span><br><span class="line">      <span class="keyword">boolean</span> sizeChanged = updateViewportState(viewportWidth, viewportHeight, viewportSizeFactor);</span><br><span class="line">      <span class="comment">//滚动弹幕的Duration赋值</span></span><br><span class="line">      <span class="keyword">if</span> (MAX_Duration_Scroll_Danmaku == <span class="keyword">null</span>) &#123;</span><br><span class="line">          MAX_Duration_Scroll_Danmaku = <span class="keyword">new</span> Duration(REAL_DANMAKU_DURATION);</span><br><span class="line">          MAX_Duration_Scroll_Danmaku.setFactor(scrollSpeedFactor);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">          MAX_Duration_Scroll_Danmaku.setValue(REAL_DANMAKU_DURATION);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//固定位置弹幕的Duration赋值</span></span><br><span class="line">      <span class="keyword">if</span> (MAX_Duration_Fix_Danmaku == <span class="keyword">null</span>) &#123;</span><br><span class="line">          MAX_Duration_Fix_Danmaku = <span class="keyword">new</span> Duration(COMMON_DANMAKU_DURATION);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sizeChanged &amp;&amp; viewportWidth &gt; <span class="number">0</span>) &#123;<span class="comment">// true &amp;&amp; true</span></span><br><span class="line">          updateMaxDanmakuDuration();<span class="comment">// 修正弹幕最长时长</span></span><br><span class="line">	......</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BaseDanmaku instance = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 从右往左滚动</span></span><br><span class="line">              instance = <span class="keyword">new</span> R2LDanmaku(MAX_Duration_Scroll_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 底端固定</span></span><br><span class="line">              instance = <span class="keyword">new</span> FBDanmaku(MAX_Duration_Fix_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 顶端固定</span></span><br><span class="line">              instance = <span class="keyword">new</span> FTDanmaku(MAX_Duration_Fix_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// 从左往右滚动</span></span><br><span class="line">              instance = <span class="keyword">new</span> L2RDanmaku(MAX_Duration_Scroll_Danmaku);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// 特殊弹幕</span></span><br><span class="line">              instance = <span class="keyword">new</span> SpecialDanmaku();</span><br><span class="line">              sSpecialDanmakus.addItem(instance);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修正试图宽高，缩放比，弹幕时长</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateViewportState</span><span class="params">(<span class="keyword">float</span> viewportWidth, <span class="keyword">float</span> viewportHeight,</span><br><span class="line">          <span class="keyword">float</span> viewportSizeFactor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> sizeChanged = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (CURRENT_DISP_WIDTH != (<span class="keyword">int</span>) viewportWidth</span><br><span class="line">              || CURRENT_DISP_HEIGHT != (<span class="keyword">int</span>) viewportHeight</span><br><span class="line">              || CURRENT_DISP_SIZE_FACTOR != viewportSizeFactor) &#123;</span><br><span class="line">          sizeChanged = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//弹幕时长 t = 3800 * (1.2 * 视图宽 / 682)</span></span><br><span class="line">          REAL_DANMAKU_DURATION = (<span class="keyword">long</span>) (COMMON_DANMAKU_DURATION * (viewportSizeFactor</span><br><span class="line">                  * viewportWidth / BILI_PLAYER_WIDTH));</span><br><span class="line">          <span class="comment">// t = min(t, 9000)</span></span><br><span class="line">          REAL_DANMAKU_DURATION = Math.min(MAX_DANMAKU_DURATION_HIGH_DENSITY,</span><br><span class="line">                  REAL_DANMAKU_DURATION);</span><br><span class="line">          <span class="comment">// t = max(t, 4000)        </span></span><br><span class="line">          REAL_DANMAKU_DURATION = Math.max(MIN_DANMAKU_DURATION, REAL_DANMAKU_DURATION);</span><br><span class="line">          </span><br><span class="line">          CURRENT_DISP_WIDTH = (<span class="keyword">int</span>) viewportWidth;</span><br><span class="line">          CURRENT_DISP_HEIGHT = (<span class="keyword">int</span>) viewportHeight;</span><br><span class="line">          CURRENT_DISP_SIZE_FACTOR = viewportSizeFactor;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sizeChanged;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//修正弹幕最长时长</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMaxDanmakuDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> maxScrollDuration = (MAX_Duration_Scroll_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span>: MAX_Duration_Scroll_Danmaku.value), </span><br><span class="line">            maxFixDuration = (MAX_Duration_Fix_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span> : MAX_Duration_Fix_Danmaku.value), </span><br><span class="line">            maxSpecialDuration = (MAX_Duration_Special_Danmaku == <span class="keyword">null</span> ? <span class="number">0</span>: MAX_Duration_Special_Danmaku.value);</span><br><span class="line"></span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(maxScrollDuration, maxFixDuration);</span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(MAX_DANMAKU_DURATION, maxSpecialDuration);</span><br><span class="line"></span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(COMMON_DANMAKU_DURATION, MAX_DANMAKU_DURATION);</span><br><span class="line">      MAX_DANMAKU_DURATION = Math.max(REAL_DANMAKU_DURATION, MAX_DANMAKU_DURATION);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuFactory创建弹幕主要是计算了弹幕时长，然后根据不同类型创建不同的弹幕。</p>
<p>&#160; &#160; &#160; &#160;到此CacheManagingDrawTask的loadDanmakus方法走完了。loadDanmakus方法主要从 mParser里的JSONSource解析弹幕数据源，根据不同类型的type用DanmakuFactory创建不同的Danmaku，分别计算Duration，最后存放到一个Danmakus对象里。</p>
<p>&#160; &#160; &#160; &#160; 继续回到刚才的prepare方法，往下继续执行:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> (mParser != <span class="keyword">null</span>);</span><br><span class="line">     loadDanmakus(mParser);<span class="comment">//走完了</span></span><br><span class="line">     mCacheManager.begin();<span class="comment">//走这个</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//CacheManager的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         mEndFlag = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//创建一个HandlerThread用于在工作线程处理事务</span></span><br><span class="line">         <span class="keyword">if</span> (mThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">             mThread = <span class="keyword">new</span> HandlerThread(<span class="string">"DFM Cache-Building Thread"</span>);</span><br><span class="line">             mThread.start();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//创建一个Handler和HandlerThread搭配用</span></span><br><span class="line">         <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>)</span><br><span class="line">             mHandler = <span class="keyword">new</span> CacheHandler(mThread.getLooper());</span><br><span class="line">         mHandler.begin();<span class="comment">// 走到这里</span></span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//HandlerThread的begin方法 </span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             sendEmptyMessage(PREPARE);</span><br><span class="line">	......</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到创建了一个HandlerThread，然后创建了一个CacheHandler，所以CacheHandler发送消息后，处理消息内容都是在子线程。<br>&#160; &#160; &#160; &#160;然后发送了PREPARE消息，然后就是回调handleMessage方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">     DrawingCachePoolManager mCachePoolManager = <span class="keyword">new</span> DrawingCachePoolManager();</span><br><span class="line">     <span class="comment">//创建一个缓存个数上限为800的FinitePool池</span></span><br><span class="line">        Pool&lt;DrawingCache&gt; mCachePool = Pools.finitePool(mCachePoolManager, <span class="number">800</span>);</span><br><span class="line">        <span class="comment">//Pools的finitePool方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Poolable&lt;T&gt;&gt; <span class="function">Pool&lt;T&gt; <span class="title">finitePool</span><span class="params">(PoolableManager&lt;T&gt; manager, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinitePool&lt;T&gt;(manager, limit);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> what = msg.what;</span><br><span class="line">               <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">                   <span class="keyword">case</span> PREPARE:</span><br><span class="line">                       evictAllNotInScreen();<span class="comment">//清除所有不在屏幕内的缓存，此时还没有缓存</span></span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;<span class="comment">//在池里放300个预留缓存，以链式存储方式存放</span></span><br><span class="line">                           mCachePool.release(<span class="keyword">new</span> DrawingCache());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//FinitePool的release方法：回收缓存对象，并且用头插法，以链式存储（类似链表）	</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!element.isPooled()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mInfinite || mPoolCount &lt; mLimit) &#123;</span><br><span class="line">               mPoolCount++;</span><br><span class="line">               element.setNextPoolable(mRoot);</span><br><span class="line">               element.setPooled(<span class="keyword">true</span>);</span><br><span class="line">               mRoot = element;</span><br><span class="line">           &#125;</span><br><span class="line">           mManager.onReleased(element);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.print(<span class="string">"[FinitePool] Element is already in pool: "</span> + element);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;处理完PREPARE消息后，会继续进入DISPATCH_ACTIONS逻辑处理中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	......</span><br><span class="line">          <span class="keyword">case</span> DISPATCH_ACTIONS:</span><br><span class="line">              <span class="keyword">long</span> delayed = dispatchAction();<span class="comment">//走到这里</span></span><br><span class="line">              <span class="keyword">if</span> (delayed &lt;= <span class="number">0</span>) &#123;<span class="comment">// true</span></span><br><span class="line">               <span class="comment">//会没隔半条弹幕时间发送一次DISPATCH_ACTIONS消息</span></span><br><span class="line">                  delayed = mContext.mDanmakuFactory.MAX_DANMAKU_DURATION / <span class="number">2</span>;</span><br><span class="line">              &#125;</span><br><span class="line">           sendEmptyMessageDelayed(DISPATCH_ACTIONS, delayed);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          ......</span><br><span class="line">    <span class="comment">/*----------dispatchAction方法START----------*/</span>        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">dispatchAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">...省略一些第一次不会执行的逻辑...</span><br><span class="line">            </span><br><span class="line">            removeMessages(BUILD_CACHES);</span><br><span class="line">            sendEmptyMessage(BUILD_CACHES);<span class="comment">//发送BUILD_CACHES消息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*----------dispatchAction方法END----------*/</span></span><br><span class="line">          ......</span><br><span class="line">                <span class="keyword">case</span> BUILD_CACHES:</span><br><span class="line">                    removeMessages(BUILD_CACHES);</span><br><span class="line">                    <span class="keyword">boolean</span> repositioned = ((mTaskListener != <span class="keyword">null</span> </span><br><span class="line">                    &amp;&amp; mReadyState == <span class="keyword">false</span>) || mSeekedFlag);<span class="comment">// 为true</span></span><br><span class="line">                    prepareCaches(repositioned);<span class="comment">//调用prepareCaches方法</span></span><br><span class="line">                    <span class="keyword">if</span> (repositioned)</span><br><span class="line">                        mSeekedFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mTaskListener != <span class="keyword">null</span> &amp;&amp; mReadyState == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        mTaskListener.ready();<span class="comment">//然后回到mTaskListener监听ready方法</span></span><br><span class="line">                        mReadyState = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们发现，处理接着处理DISPATCH_ACTIONS消息时，会每隔半条弹幕时间发送一次DISPATCH_ACTIONS消息。<br>&#160; &#160; &#160; &#160;处理DISPATCH_ACTIONS消息内会执行dispatchAction方法，这个方法内逻辑情况比较多，我们先挖个坑，先把刚开始时会走的逻辑执行了，其他逻辑以后用时会填上。（挖坑 ^O_O^）<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/DanmakuFlameMaster%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/wakeng.jpg" alt="挖坑"><br>&#160; &#160; &#160; &#160;首次调用dispatchAction方法内发送了BUILD_CACHES消息消息，会先调用prepareCaches(true)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">prepareCaches</span><span class="params">(<span class="keyword">boolean</span> repositioned)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> curr = mCacheTimer.currMillisecond;<span class="comment">// 0</span></span><br><span class="line">                <span class="comment">//3条弹幕时间</span></span><br><span class="line">                <span class="keyword">long</span> end = curr + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION * mScreenSize;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; mTimer.currMillisecond) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">                IDanmakus danmakus = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> tryCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                do &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">	                    <span class="comment">//截取三条弹幕时间中所有的弹幕</span></span><br><span class="line">                        danmakus = danmakuList.subnew(curr, end);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        hasException = <span class="keyword">true</span>;</span><br><span class="line">                        SystemClock.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (++tryCount &lt; <span class="number">3</span> &amp;&amp; danmakus == <span class="keyword">null</span> &amp;&amp; hasException);<span class="comment">//截取成功后跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (danmakus == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCacheTimer.update(end);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				......</span><br><span class="line">                IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">                BaseDanmaku item = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">int</span> sizeInScreen = danmakus.size();</span><br><span class="line">                <span class="keyword">while</span> (!mPause &amp;&amp; !mCancelFlag) &#123;<span class="comment">//</span></span><br><span class="line">                    <span class="keyword">boolean</span> hasNext = itr.hasNext();</span><br><span class="line">                    <span class="keyword">if</span> (!hasNext) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    item = itr.next();</span><br><span class="line"></span><br><span class="line">					 ......</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// build cache ，省略了一些障眼法,这才是重点，建立缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (buildCache(item, <span class="keyword">false</span>) == RESULT_FAILED) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					......</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;<span class="comment">//截取的最后一条弹幕,更新缓存定时器时间</span></span><br><span class="line">                    mCacheTimer.update(item.time);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCacheTimer.update(end);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> consumingTime;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;为截取的每一条弹幕建立缓存会调用buildCache(item, false)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// measure ,先测量每一条弹幕的宽高</span></span><br><span class="line">           <span class="keyword">if</span> (!item.isMeasured()) &#123;</span><br><span class="line">               item.measure(mDisp, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           DrawingCache cache = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// try to find reuseable cache, 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</span></span><br><span class="line">               BaseDanmaku danmaku = findReuseableCache(item, <span class="keyword">true</span>, <span class="number">20</span>);</span><br><span class="line">               <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">//如果查找出了这样的弹幕</span></span><br><span class="line">                   cache = (DrawingCache) danmaku.cache;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                   cache.increaseReference();<span class="comment">//则将引用计数 +1</span></span><br><span class="line">                   item.cache = cache;<span class="comment">//将目标弹幕缓存的引用指向查找出来的弹幕缓存，即多个引用指向同一个对象</span></span><br><span class="line">                   <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                   mCacheManager.push(item, <span class="number">0</span>, forceInsert);</span><br><span class="line">                   <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// try to find reuseable cache from timeout || no-refrerence caches</span></span><br><span class="line">               <span class="comment">//如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的</span></span><br><span class="line">               <span class="comment">//，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)</span></span><br><span class="line">               <span class="comment">//，而且宽高和目标弹幕差值在规定范围内的弹幕</span></span><br><span class="line">               danmaku = findReuseableCache(item, <span class="keyword">false</span>, <span class="number">50</span>);</span><br><span class="line">               <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到了这样的弹幕</span></span><br><span class="line">                   cache = (DrawingCache) danmaku.cache;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                   danmaku.cache = <span class="keyword">null</span>;<span class="comment">//先清除过时弹幕的缓存</span></span><br><span class="line">                   <span class="comment">//再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</span></span><br><span class="line">                   cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);  <span class="comment">//redraw</span></span><br><span class="line">                   item.cache = cache;<span class="comment">//将缓存应用赋给目标弹幕</span></span><br><span class="line">                   mCacheManager.push(item, <span class="number">0</span>, forceInsert);<span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                   <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上述两次查找缓存都没找到，则进入下面逻辑</span></span><br><span class="line">               <span class="comment">// guess cache size</span></span><br><span class="line">               <span class="keyword">if</span> (!forceInsert) &#123;<span class="comment">//如果forceInsert为false，则表示不检测内存超出</span></span><br><span class="line">                <span class="comment">//计算此弹幕bitmap的大小，width * height * 4</span></span><br><span class="line">                <span class="comment">//(因为用native创建的Bitmap的Config为ARGB_8888，所以一个像素占4个字节)</span></span><br><span class="line">                   <span class="keyword">int</span> cacheSize = DanmakuUtils.getCacheSize((<span class="keyword">int</span>) item.paintWidth,</span><br><span class="line">                           (<span class="keyword">int</span>) item.paintHeight);</span><br><span class="line">                   <span class="comment">//如果当前已经使用大小 + 此弹幕缓存大小 &gt; 设置的最大内存（2/3 应用内存）        </span></span><br><span class="line">                   <span class="keyword">if</span> (mRealSize + cacheSize &gt; mMaxSize) &#123;<span class="comment">//没有超</span></span><br><span class="line">                       <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">//从FinitePool中的300个DrawingCache对象中取出来一个</span></span><br><span class="line">               cache = mCachePool.acquire();</span><br><span class="line">               <span class="comment">//如果从上面的FinitePool取完了，则会直接new一个DrawingCache，配置DrawingCache</span></span><br><span class="line">               cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);</span><br><span class="line">               item.cache = cache;</span><br><span class="line">               <span class="comment">//将item存入mCaches缓存，同时更新已使用大小mRealSize</span></span><br><span class="line">               <span class="keyword">boolean</span> pushed = mCacheManager.push(item, sizeOf(item), forceInsert);</span><br><span class="line">               <span class="keyword">if</span> (!pushed) &#123;<span class="comment">//如果item存放失败(使用内存超出规定大小)</span></span><br><span class="line">                   releaseDanmakuCache(item, cache);<span class="comment">//释放DrawingCache</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> pushed ? RESULT_SUCCESS : RESULT_FAILED;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">               releaseDanmakuCache(item, cache);</span><br><span class="line">               <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               releaseDanmakuCache(item, cache);</span><br><span class="line">               <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;buildCache(item, false)为每一条弹幕建立缓存，其中有几处：</p>
<ul>
<li>先测量弹幕的宽高</li>
<li>在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</li>
<li>如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的 ，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)，而且宽高和目标弹幕差值在规定范围内的弹幕，再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</li>
<li>如果上述两次查找缓存都没找到，则从FinitePool中取出一个，没有就new一个，然后同上配置DrawingCache</li>
</ul>
<p>&#160; &#160; &#160; &#160;1）我们一个一个来，先测量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弹幕的基类都是BaseDanmaku,只有子类R2LDanmaku重写了measure方法</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//R2LDanmaku的measure方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(IDisplayer displayer, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.measure(displayer, fromWorkerThread);<span class="comment">//调用了父类的方法</span></span><br><span class="line">        mDistance = (<span class="keyword">int</span>) (displayer.getWidth() + paintWidth);<span class="comment">//滚动弹幕的距离都是 视图宽度+弹幕宽度，很好理解</span></span><br><span class="line">        mStepX = mDistance / (<span class="keyword">float</span>) duration.value; <span class="comment">//每秒步长就是总滚动距离除以弹幕时长</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类BaseDanmaku的measure方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(IDisplayer displayer, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">        displayer.measure(<span class="keyword">this</span>, fromWorkerThread);<span class="comment">//AndroidDisplayer的measure方法</span></span><br><span class="line">        <span class="keyword">this</span>.measureResetFlag = flags.MEASURE_RESET_FLAG;<span class="comment">//设置已经测量过了的标签</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着会调用AndroidDisplayer的measure方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">	...设置画笔style,color,alpha,省略...</span><br><span class="line">       calcPaintWH(danmaku, paint, fromWorkerThread);<span class="comment">//计算宽高</span></span><br><span class="line">	...设置画笔style,color,alpha,省略...</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span> BaseCacheStuffer sStuffer = <span class="keyword">new</span> SimpleTextCacheStuffer();<span class="comment">//默认是SimpleTextCacheStuffer</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calcPaintWH</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       sStuffer.measure(danmaku, paint, fromWorkerThread);<span class="comment">//sStuffer就是我们在MainActivity里配置DanmakuContext时设置的，默认是SimpleTextCacheStuffer</span></span><br><span class="line">       </span><br><span class="line">       ...加上描边，padding等额外值，省略...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;还记得在MainActivity里配置DanmakuContext吗？当时是这么写的：<br>                .setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter) // 图文混排使用SpannedCacheStuffer<br>//              .setCacheStuffer(new BackgroundCacheStuffer())  // 绘制背景使用BackgroundCacheStuffer</p>
<p>&#160; &#160; &#160; &#160;比如SpannedCacheStuffer的measure方法是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//SpannedCacheStuffer的measure方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (danmaku.text <span class="keyword">instanceof</span> Spanned) &#123;</span><br><span class="line">          CharSequence text = danmaku.text;</span><br><span class="line">          <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//可看到将弹幕的宽高，文字等信息包在了一个StaticLayout对象中，然后付给danmaku的obj对象</span></span><br><span class="line">              StaticLayout staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) Math.ceil(StaticLayout.getDesiredWidth(danmaku.text, paint)), Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">              danmaku.paintWidth = staticLayout.getWidth();</span><br><span class="line">              danmaku.paintHeight = staticLayout.getHeight();</span><br><span class="line">              danmaku.obj = <span class="keyword">new</span> SoftReference&lt;&gt;(staticLayout);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">super</span>.measure(danmaku, paint, fromWorkerThread);<span class="comment">//如果不是图文混排类型，则调用父类SimpleTextCacheStuffer的方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>可以看到measure方法创建了一个StaticLayout对象，并将它的软引用赋给了danmaku的obj属性；如果是图文混排类型弹幕，则danmaku.obj不为空；如果是普通弹幕则danmaku.obj为空</strong>。<br>&#160; &#160; &#160; &#160;BackgroundCacheStuffer也差不多，都是对弹幕样式的一些改造。</p>
<p>&#160; &#160; &#160; &#160;然后我们看SimpleTextCacheStuffer的measure方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的measure方法   </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(BaseDanmaku danmaku, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mProxy != <span class="keyword">null</span>) &#123;<span class="comment">//这个mProxy 是BaseCacheStuffer.Proxy类型的对象，也是初始化DanmakuContext调用setCacheStuffer(cacheStuffer, proxy)时设置的</span></span><br><span class="line">           mProxy.prepareDrawing(danmaku, fromWorkerThread);<span class="comment">//根据你的条件检查是否需要需要更新弹幕</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">float</span> w = <span class="number">0</span>;</span><br><span class="line">       Float textHeight = <span class="number">0f</span>;</span><br><span class="line">       <span class="keyword">if</span> (danmaku.lines == <span class="keyword">null</span>) &#123;<span class="comment">//不是多行文本</span></span><br><span class="line">           <span class="keyword">if</span> (danmaku.text == <span class="keyword">null</span>) &#123;</span><br><span class="line">               w = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               w = paint.measureText(danmaku.text.toString());<span class="comment">//测量出文字宽度</span></span><br><span class="line">               textHeight = getCacheHeight(danmaku, paint);<span class="comment">//计算出文字高度</span></span><br><span class="line">           &#125;</span><br><span class="line">           danmaku.paintWidth = w;</span><br><span class="line">           danmaku.paintHeight = textHeight;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是多行文本</span></span><br><span class="line">           textHeight = getCacheHeight(danmaku, paint);<span class="comment">//计算出单行文字高度</span></span><br><span class="line">           <span class="keyword">for</span> (String tempStr : danmaku.lines) &#123;<span class="comment">//计算出多行文本总宽高</span></span><br><span class="line">               <span class="keyword">if</span> (tempStr.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">float</span> tr = paint.measureText(tempStr);</span><br><span class="line">                   w = Math.max(tr, w);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           danmaku.paintWidth = w;</span><br><span class="line">           danmaku.paintHeight = danmaku.lines.length * textHeight;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Float, Float&gt; sTextHeightCache = <span class="keyword">new</span> HashMap&lt;Float, Float&gt;();<span class="comment">//key是字号大小，value是字体高度</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Float <span class="title">getCacheHeight</span><span class="params">(BaseDanmaku danmaku, Paint paint)</span> </span>&#123;</span><br><span class="line">       Float textSize = paint.getTextSize();</span><br><span class="line">       Float textHeight = sTextHeightCache.get(textSize);</span><br><span class="line">       <span class="keyword">if</span> (textHeight == <span class="keyword">null</span>) &#123;</span><br><span class="line">           Paint.FontMetrics fontMetrics = paint.getFontMetrics();</span><br><span class="line">           <span class="comment">//Android对文字绘制有些特殊，基准点是baseline，也就是例如canvas.drawText(text, baseX, baseY, textPaint)中写入的baseY大小</span></span><br><span class="line">           <span class="comment">//Ascent是baseline之上字符最高处的y值；</span></span><br><span class="line">		<span class="comment">//Descent是baseline之下字符最低处的y值；</span></span><br><span class="line">		<span class="comment">//Leading其实是上一行字符的descent到下一行的ascent之间的距离。</span></span><br><span class="line">		<span class="comment">//所以文本高度就是descent - ascent + leading </span></span><br><span class="line">           textHeight = fontMetrics.descent - fontMetrics.ascent + fontMetrics.leading;</span><br><span class="line">           sTextHeightCache.put(textSize, textHeight);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> textHeight;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就计算完了每一条弹幕的宽高，完成了测量。</p>
<p>&#160; &#160; &#160; &#160;2） 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)：<br>&#160; &#160; &#160; &#160;先回到buildCache方法中这个位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line"></span><br><span class="line">	...测量已经完成...</span><br><span class="line">             DrawingCache cache = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// try to find reuseable cache, 在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)</span></span><br><span class="line">                 BaseDanmaku danmaku = findReuseableCache(item, <span class="keyword">true</span>, <span class="number">20</span>);</span><br><span class="line">                 <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">//如果查找出了这样的弹幕</span></span><br><span class="line">                     cache = (DrawingCache) danmaku.cache;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                     cache.increaseReference();<span class="comment">//则将引用计数 +1</span></span><br><span class="line">                     item.cache = cache;<span class="comment">//将目标弹幕缓存的引用指向查找出来的弹幕缓存，即多个引用指向同一个对象</span></span><br><span class="line">                     <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                     mCacheManager.push(item, <span class="number">0</span>, forceInsert);</span><br><span class="line">                     <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">                 &#125;</span><br><span class="line">             ......    </span><br><span class="line">   &#125; </span><br><span class="line">     <span class="comment">//在mCaches缓存的20条内查找和目标弹幕样式完全一样的弹幕(文字、大小、边框、下划线、颜色完全相同)             </span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> BaseDanmaku <span class="title">findReuseableCache</span><span class="params">(BaseDanmaku refDanmaku,</span><br><span class="line">                                            <span class="keyword">boolean</span> strictMode,</span><br><span class="line">                                            <span class="keyword">int</span> maximumTimes)</span> </span>&#123;<span class="comment">//item， true， 20</span></span><br><span class="line">         IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">......</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (it.hasNext() &amp;&amp; count++ &lt; maximumTimes) &#123;  <span class="comment">// limit maximum times 20</span></span><br><span class="line">             BaseDanmaku danmaku = it.next();</span><br><span class="line">             IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">             <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//对比mCaches中的弹幕和目标的内幕文字、大小、边框、下划线、颜色是否完全相同</span></span><br><span class="line">             <span class="keyword">if</span> (danmaku.paintWidth == refDanmaku.paintWidth</span><br><span class="line">                     &amp;&amp; danmaku.paintHeight == refDanmaku.paintHeight</span><br><span class="line">                     &amp;&amp; danmaku.underlineColor == refDanmaku.underlineColor</span><br><span class="line">                     &amp;&amp; danmaku.borderColor == refDanmaku.borderColor</span><br><span class="line">                     &amp;&amp; danmaku.textColor == refDanmaku.textColor</span><br><span class="line">                     &amp;&amp; danmaku.text.equals(refDanmaku.text)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> danmaku;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (strictMode) &#123;<span class="comment">//true</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">	......</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//CacheManagingDrawTask.CacheManager的push方法</span></span><br><span class="line">     <span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(BaseDanmaku item, <span class="keyword">int</span> itemSize, <span class="keyword">boolean</span> forcePush)</span> </span>&#123;<span class="comment">//item，0，false</span></span><br><span class="line">         <span class="keyword">int</span> size = itemSize; <span class="comment">//0</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//这里注意mCaches是Danmakus类型，addItem方法里面实现其实是类型为TreeSet的集合去添加，如果是同一个对象，则不会添加</span></span><br><span class="line">         <span class="keyword">this</span>.mCaches.addItem(item);</span><br><span class="line">         mRealSize += size;<span class="comment">//因为已经存在相同的缓存，因此已经使用缓存总大小不再增加</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">//Danmakus的addItem方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addItem</span><span class="params">(BaseDanmaku item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (items != <span class="keyword">null</span>) &#123;<span class="comment">//items 类型为TreeSet</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (items.add(item)) &#123;<span class="comment">//如果是相同对象，则返回false，mSize个数不会增加</span></span><br><span class="line">                 mSize++;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述情况仅仅在相同样式，大小，颜色等都相同的弹幕第二次和以后的才会进入这段逻辑。对于不同的弹幕不会进入这个逻辑。（<strong>而且即使是相同弹幕，mCaches也只会存一个对象的，因为内部TreeSet的特性</strong>）<br>&#160; &#160; &#160; &#160;所以我们继续看下一种逻辑。</p>
<p>&#160; &#160; &#160; &#160;3）在前50条缓存中查找对比当前时间已经过时的 ，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)，而且宽高和目标弹幕差值在规定范围内的弹幕，再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)：<br>&#160; &#160; &#160; &#160;继续回到buildCache方法这个位置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line">		...测量过了...</span><br><span class="line">		...第一策略已经pass...</span><br><span class="line">			<span class="comment">// try to find reuseable cache from timeout || no-refrerence caches</span></span><br><span class="line">                  <span class="comment">//如果上述的查找样式完全相同的弹幕没有找到，则在前50条缓存中查找对比当前时间已经过时的</span></span><br><span class="line">                  <span class="comment">//，没有被重复引用的(只有上面那种情况才会增加引用计数，其他情况都不会)</span></span><br><span class="line">                  <span class="comment">//，而且宽高和目标弹幕差值在规定范围内的弹幕</span></span><br><span class="line">                  danmaku = findReuseableCache(item, <span class="keyword">false</span>, <span class="number">50</span>);</span><br><span class="line">                  <span class="keyword">if</span> (danmaku != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到了这样的弹幕</span></span><br><span class="line">                      cache = (DrawingCache) danmaku.cache;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果找到的弹幕有缓存</span></span><br><span class="line">                      danmaku.cache = <span class="keyword">null</span>;<span class="comment">//先清除过时弹幕的缓存</span></span><br><span class="line">                      <span class="comment">//再根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)</span></span><br><span class="line">                      cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);  <span class="comment">//redraw</span></span><br><span class="line">                      item.cache = cache;<span class="comment">//将缓存应用赋给目标弹幕</span></span><br><span class="line">                      mCacheManager.push(item, <span class="number">0</span>, forceInsert);<span class="comment">//将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize</span></span><br><span class="line">                      <span class="keyword">return</span> RESULT_SUCCESS;</span><br><span class="line">                  &#125;</span><br><span class="line">              ......    </span><br><span class="line">&#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> BaseDanmaku <span class="title">findReuseableCache</span><span class="params">(BaseDanmaku refDanmaku,</span><br><span class="line">                                             <span class="keyword">boolean</span> strictMode,</span><br><span class="line">                                             <span class="keyword">int</span> maximumTimes)</span> </span>&#123;<span class="comment">//item,false,50</span></span><br><span class="line">          IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">          <span class="keyword">int</span> slopPixel = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (!strictMode) &#123;<span class="comment">//进入逻辑，非严苛模式</span></span><br><span class="line">              slopPixel = mDisp.getSlopPixel() * <span class="number">2</span>;<span class="comment">//允许目标弹幕与mCaches中找到的弹幕宽高偏差</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (it.hasNext() &amp;&amp; count++ &lt; maximumTimes) &#123;  <span class="comment">// limit maximum times 20</span></span><br><span class="line">              BaseDanmaku danmaku = it.next();</span><br><span class="line">              IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">              <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//在这种第二策略中这段逻辑根本不会执行，因为以已经被上面的第一策略拦截了</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.paintWidth == refDanmaku.paintWidth</span><br><span class="line">                      &amp;&amp; danmaku.paintHeight == refDanmaku.paintHeight</span><br><span class="line">                      &amp;&amp; danmaku.underlineColor == refDanmaku.underlineColor</span><br><span class="line">                      &amp;&amp; danmaku.borderColor == refDanmaku.borderColor</span><br><span class="line">                      &amp;&amp; danmaku.textColor == refDanmaku.textColor</span><br><span class="line">                      &amp;&amp; danmaku.text.equals(refDanmaku.text)) &#123;</span><br><span class="line">                  <span class="keyword">return</span> danmaku;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (strictMode) &#123;<span class="comment">//false</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!danmaku.isTimeOut()) &#123;<span class="comment">//还必须在mCaches中过时的弹幕中查找</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (cache.hasReferences()) &#123;<span class="comment">//如果是相同弹幕被重新引用的，第二策略没有这样的</span></span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//所以会走到这里，比较mCaches中过时的弹幕和目标弹幕宽高在不在允许的偏差内，如果在就返回查找出的这个弹幕</span></span><br><span class="line">              <span class="keyword">float</span> widthGap = cache.width() - refDanmaku.paintWidth;</span><br><span class="line">              <span class="keyword">float</span> heightGap = cache.height() - refDanmaku.paintHeight;</span><br><span class="line">              <span class="keyword">if</span> (widthGap &gt;= <span class="number">0</span> &amp;&amp; widthGap &lt;= slopPixel &amp;&amp;</span><br><span class="line">                      heightGap &gt;= <span class="number">0</span> &amp;&amp; heightGap &lt;= slopPixel) &#123;</span><br><span class="line">                  <span class="keyword">return</span> danmaku;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果在上述第二策略中，在过时的缓存中找到了和目标弹幕宽高差不多的缓存项，则根据目标弹幕样式，重新设置缓存(为每条弹幕创建一个bitmap和canvas，然后画出边框、下划线、文字等等)，调用DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DrawingCache <span class="title">buildDanmakuDrawingCache</span><span class="params">(BaseDanmaku danmaku, IDisplayer disp,</span><br><span class="line">          DrawingCache cache)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>)</span><br><span class="line">          cache = <span class="keyword">new</span> DrawingCache();</span><br><span class="line"><span class="comment">//组建弹幕缓存(bitmap,canvas)</span></span><br><span class="line">      cache.build((<span class="keyword">int</span>) Math.ceil(danmaku.paintWidth), (<span class="keyword">int</span>) Math.ceil(danmaku.paintHeight), disp.getDensityDpi(), <span class="keyword">false</span>);</span><br><span class="line">      DrawingCacheHolder holder = cache.get();</span><br><span class="line">      <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//绘制弹幕内容</span></span><br><span class="line">          ((AbsDisplayer) disp).drawDanmaku(danmaku, holder.canvas, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">if</span>(disp.isHardwareAccelerated()) &#123;<span class="comment">//如果有硬件加速</span></span><br><span class="line">           <span class="comment">//超过一屏的弹幕要切割</span></span><br><span class="line">              holder.splitWith(disp.getWidth(), disp.getHeight(), disp.getMaximumCacheWidth(),</span><br><span class="line">                      disp.getMaximumCacheHeight());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;重新设置缓存分三步：1.组建弹幕缓存,2.绘制弹幕内容,3.切割超过一屏的弹幕。</p>
<p>&#160; &#160; &#160; &#160;No.1 组建弹幕缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawingCache的build方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> density, <span class="keyword">boolean</span> checkSizeEquals)</span> </span>&#123;<span class="comment">//checkSizeEquals为false</span></span><br><span class="line">       <span class="keyword">final</span> DrawingCacheHolder holder = mHolder;</span><br><span class="line">       <span class="comment">//每个DrawingCache都有一个DrawingCacheHolder</span></span><br><span class="line">       holder.buildCache(w, h, density, checkSizeEquals);<span class="comment">//DrawingCacheHolder的buildCache方法</span></span><br><span class="line">       mSize = mHolder.bitmap.getRowBytes() * mHolder.bitmap.getHeight();<span class="comment">//返回创建的bitmap的大小</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawingCacheHolder的buildCache方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCache</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> density, <span class="keyword">boolean</span> checkSizeEquals)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> reuse = checkSizeEquals ? (w == width &amp;&amp; h == height) : (w &lt;= width &amp;&amp; h &lt;= height);<span class="comment">//检测大小 ？ 宽高相等 ： 小于已经缓存的bitmap宽高</span></span><br><span class="line">       <span class="keyword">if</span> (reuse &amp;&amp; bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果能够复用bitmap</span></span><br><span class="line">           bitmap.eraseColor(Color.TRANSPARENT);<span class="comment">//擦出之前的颜色</span></span><br><span class="line">           canvas.setBitmap(bitmap);<span class="comment">//给Canvas重新预设bitmap</span></span><br><span class="line">           recycleBitmapArray();<span class="comment">//回收超过一屏弹幕切割后的bitmap数组，这个接下来会讲</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;<span class="comment">//如果不能复用，则回收旧的缓存bitmap</span></span><br><span class="line">           recycle();</span><br><span class="line">       &#125;</span><br><span class="line">       width = w;</span><br><span class="line">       height = h;</span><br><span class="line">       bitmap = NativeBitmapFactory.createBitmap(w, h, Bitmap.Config.ARGB_8888);<span class="comment">//用native方法创建一个bitmap</span></span><br><span class="line">       <span class="keyword">if</span> (density &gt; <span class="number">0</span>) &#123;<span class="comment">//设置density</span></span><br><span class="line">           mDensity = density;</span><br><span class="line">           bitmap.setDensity(density);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置canvas</span></span><br><span class="line">       <span class="keyword">if</span> (canvas == <span class="keyword">null</span>)&#123;</span><br><span class="line">           canvas = <span class="keyword">new</span> Canvas(bitmap);</span><br><span class="line">           canvas.setDensity(density);</span><br><span class="line">       &#125;<span class="keyword">else</span></span><br><span class="line">           canvas.setBitmap(bitmap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;组建弹幕缓存就是为个DrawingCache根据目标弹幕大小创建bitmap和canvas。</p>
<p>&#160; &#160; &#160; &#160;No.2 绘制弹幕内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">drawDanmaku</span><span class="params">(BaseDanmaku danmaku, Canvas canvas, </span><br><span class="line">  <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;<span class="comment">//danmaku, holder.canvas, 0, 0, true</span></span><br><span class="line">      <span class="keyword">float</span> _left = left;</span><br><span class="line">      <span class="keyword">float</span> _top = top;</span><br><span class="line">      </span><br><span class="line">...一些杂项，忽略...</span><br><span class="line"></span><br><span class="line">      TextPaint paint = getPaint(danmaku, fromWorkerThread);<span class="comment">//获取画笔</span></span><br><span class="line">      <span class="comment">//绘制背景，sStuffer可以自己设置，默认是SimpleTextCacheStuffer,默认drawBackground为空</span></span><br><span class="line">      <span class="comment">//这个可以自己扩展，上面讲过</span></span><br><span class="line">      sStuffer.drawBackground(danmaku, canvas, _left, _top);</span><br><span class="line">      <span class="keyword">if</span> (danmaku.lines != <span class="keyword">null</span>) &#123;<span class="comment">//如果是多行文本</span></span><br><span class="line">          String[] lines = danmaku.lines;</span><br><span class="line">          <span class="keyword">if</span> (lines.length == <span class="number">1</span>) &#123;<span class="comment">//多行文本行数为1</span></span><br><span class="line">              <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">               <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">                  applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">                  <span class="keyword">float</span> strokeTop = top - paint.ascent();</span><br><span class="line">                  ......</span><br><span class="line">                  <span class="comment">//绘制描边</span></span><br><span class="line">                  sStuffer.drawStroke(danmaku, lines[<span class="number">0</span>], canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">              applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">              <span class="comment">//绘制文字</span></span><br><span class="line">              sStuffer.drawText(danmaku, lines[<span class="number">0</span>], canvas, left, top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//多行文本行数大于1</span></span><br><span class="line">           <span class="comment">//先计算每行文本的高度</span></span><br><span class="line">              <span class="keyword">float</span> textHeight = (danmaku.paintHeight - <span class="number">2</span> * danmaku.padding) / lines.length;</span><br><span class="line">              <span class="comment">//循环绘制每一行文本</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; lines.length; t++) &#123;</span><br><span class="line">                  ......</span><br><span class="line">                  <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">                   <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">                      applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">                      <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">                      <span class="keyword">float</span> strokeTop = t * textHeight + top - paint.ascent();</span><br><span class="line">				......</span><br><span class="line">                      <span class="comment">//绘制描边</span></span><br><span class="line">                      sStuffer.drawStroke(danmaku, lines[t], canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">                  applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="comment">//绘制文字</span></span><br><span class="line">                  sStuffer.drawText(danmaku, lines[t], canvas, left, t * textHeight + top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是单行文本</span></span><br><span class="line">          <span class="keyword">if</span> (hasStroke(danmaku)) &#123;<span class="comment">//如果有描边，则绘制描边</span></span><br><span class="line">           <span class="comment">//重设画笔（绘制描边）</span></span><br><span class="line">              applyPaintConfig(danmaku, paint, <span class="keyword">true</span>);</span><br><span class="line">              <span class="keyword">float</span> strokeLeft = left;</span><br><span class="line">              <span class="keyword">float</span> strokeTop = top - paint.ascent();</span><br><span class="line">		......</span><br><span class="line">              <span class="comment">//绘制描边</span></span><br><span class="line">              sStuffer.drawStroke(danmaku, <span class="keyword">null</span>, canvas, strokeLeft, strokeTop, paint);</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//再次重设画笔（绘制文字）</span></span><br><span class="line">          applyPaintConfig(danmaku, paint, <span class="keyword">false</span>);</span><br><span class="line">          <span class="comment">//绘制文字</span></span><br><span class="line">          sStuffer.drawText(danmaku, <span class="keyword">null</span>, canvas, left, top - paint.ascent(), paint, fromWorkerThread);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// draw underline</span></span><br><span class="line">      <span class="keyword">if</span> (danmaku.underlineColor != <span class="number">0</span>) &#123;<span class="comment">//绘制下划线（if）</span></span><br><span class="line">          Paint linePaint = getUnderlinePaint(danmaku);</span><br><span class="line">          <span class="keyword">float</span> bottom = _top + danmaku.paintHeight - UNDERLINE_HEIGHT;</span><br><span class="line">          canvas.drawLine(_left, bottom, _left + danmaku.paintWidth, bottom, linePaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//draw border</span></span><br><span class="line">      <span class="keyword">if</span> (danmaku.borderColor != <span class="number">0</span>) &#123;<span class="comment">//绘制外框</span></span><br><span class="line">          Paint borderPaint = getBorderPaint(danmaku);</span><br><span class="line">          canvas.drawRect(_left, _top, _left + danmaku.paintWidth, _top + danmaku.paintHeight,</span><br><span class="line">                  borderPaint);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置画笔</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyPaintConfig</span><span class="params">(BaseDanmaku danmaku, Paint paint, <span class="keyword">boolean</span> stroke)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">          <span class="keyword">if</span> (stroke) &#123;</span><br><span class="line">              paint.setStyle(HAS_PROJECTION ? Style.FILL : Style.STROKE);</span><br><span class="line">              paint.setColor(danmaku.textShadowColor &amp; <span class="number">0x00FFFFFF</span>);</span><br><span class="line">              <span class="keyword">int</span> alpha = HAS_PROJECTION ? sProjectionAlpha : AlphaValue.MAX;</span><br><span class="line">              paint.setAlpha(alpha);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              paint.setStyle(Style.FILL);</span><br><span class="line">              paint.setColor(danmaku.textColor &amp; <span class="number">0x00FFFFFF</span>);</span><br><span class="line">              paint.setAlpha(AlphaValue.MAX);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述就是绘制弹幕内容过程，主要就是sStuffer的drawStroke，drawText方法。如果你在DanmakuContext中没有设置CacheStuffer，则上述drawDanmaku方法中的sStuffer为默认的SimpleTextCacheStuffer。<br>&#160; &#160; &#160; &#160;drawStroke方法及其扩展都一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的drawStroke方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawStroke</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, Paint paint)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lineText != <span class="keyword">null</span>) &#123;</span><br><span class="line">           canvas.drawText(lineText, left, top, paint);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           canvas.drawText(danmaku.text.toString(), left, top, paint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们设了SpannedCacheStuffer, drawText方法有些区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleTextCacheStuffer的drawText方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (lineText != <span class="keyword">null</span>) &#123;</span><br><span class="line">           canvas.drawText(lineText, left, top, paint);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           canvas.drawText(danmaku.text.toString(), left, top, paint);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//SpannedCacheStuffer的drawText方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(BaseDanmaku danmaku, String lineText, Canvas canvas, <span class="keyword">float</span> left, <span class="keyword">float</span> top, TextPaint paint, <span class="keyword">boolean</span> fromWorkerThread)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (danmaku.obj == <span class="keyword">null</span>) &#123;<span class="comment">//普通弹幕</span></span><br><span class="line">           <span class="keyword">super</span>.drawText(danmaku, lineText, canvas, left, top, paint, fromWorkerThread);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果是图文混排弹幕</span></span><br><span class="line">       SoftReference&lt;StaticLayout&gt; reference = (SoftReference&lt;StaticLayout&gt;) danmaku.obj;</span><br><span class="line">       StaticLayout staticLayout = reference.get();</span><br><span class="line">       <span class="comment">//按位与，判断标志位是否有效。这里判断是否请求重新测量</span></span><br><span class="line">       <span class="keyword">boolean</span> requestRemeasure = <span class="number">0</span> != (danmaku.requestFlags &amp; BaseDanmaku.FLAG_REQUEST_REMEASURE);</span><br><span class="line">       <span class="comment">//判断是否请求重绘</span></span><br><span class="line">       <span class="keyword">boolean</span> requestInvalidate = <span class="number">0</span> != (danmaku.requestFlags &amp; BaseDanmaku.FLAG_REQUEST_INVALIDATE);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (requestInvalidate || staticLayout == <span class="keyword">null</span>) &#123;<span class="comment">//如果请求重绘或者staticLayout 软引用被回收了</span></span><br><span class="line">           <span class="keyword">if</span> (requestInvalidate) &#123;</span><br><span class="line">            <span class="comment">//与非操作，清除标志位。清除请求重绘标志位</span></span><br><span class="line">               danmaku.requestFlags &amp;= ~BaseDanmaku.FLAG_REQUEST_INVALIDATE;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mProxy != <span class="keyword">null</span>) &#123;<span class="comment">//这个在设置DanmakuContext时设置，上面讲过，可以自己扩展</span></span><br><span class="line">               mProxy.prepareDrawing(danmaku, fromWorkerThread);</span><br><span class="line">           &#125;</span><br><span class="line">           CharSequence text = danmaku.text;</span><br><span class="line">           <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (requestRemeasure) &#123;<span class="comment">//重新测量</span></span><br><span class="line">                   staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) Math.ceil(StaticLayout.getDesiredWidth(danmaku.text, paint)), Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">                   danmaku.paintWidth = staticLayout.getWidth();</span><br><span class="line">                   danmaku.paintHeight = staticLayout.getHeight();</span><br><span class="line">                   danmaku.requestFlags &amp;= ~BaseDanmaku.FLAG_REQUEST_REMEASURE;<span class="comment">//清除标志位</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="comment">//不用重新测量</span></span><br><span class="line">                   staticLayout = <span class="keyword">new</span> StaticLayout(text, paint, (<span class="keyword">int</span>) danmaku.paintWidth, Layout.Alignment.ALIGN_NORMAL, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="keyword">true</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               danmaku.obj = <span class="keyword">new</span> SoftReference&lt;&gt;(staticLayout);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//staticLayout可以继续用</span></span><br><span class="line">       <span class="keyword">boolean</span> needRestore = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="number">0</span> &amp;&amp; top != <span class="number">0</span>) &#123;</span><br><span class="line">           canvas.save();</span><br><span class="line">           canvas.translate(left, top + paint.ascent());</span><br><span class="line">           needRestore = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//绘制弹幕内容</span></span><br><span class="line">       staticLayout.draw(canvas);</span><br><span class="line">       <span class="keyword">if</span> (needRestore) &#123;</span><br><span class="line">           canvas.restore();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;绘制弹幕内容就完了，主要是绘制描边，绘制文字，绘制下划线，边框等等。</p>
<p>&#160; &#160; &#160; &#160;No.3 切割超过一屏的弹幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawingCacheHolder的splitWith方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">splitWith</span><span class="params">(<span class="keyword">int</span> dispWidth, <span class="keyword">int</span> dispHeight, <span class="keyword">int</span> maximumCacheWidth, <span class="keyword">int</span> maximumCacheHeight)</span> </span>&#123;</span><br><span class="line">       recycleBitmapArray();<span class="comment">//回收已存的bitmapArray数组</span></span><br><span class="line">       <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> || bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果弹幕的宽高都没有超过屏幕宽高，则不切割bitmap</span></span><br><span class="line">       <span class="keyword">if</span> (width &lt;= maximumCacheWidth &amp;&amp; height &lt;= maximumCacheHeight) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//切割超过一屏的弹幕</span></span><br><span class="line">       maximumCacheWidth = Math.min(maximumCacheWidth, dispWidth);</span><br><span class="line">       maximumCacheHeight = Math.min(maximumCacheHeight, dispHeight);</span><br><span class="line">       <span class="comment">//计算弹幕宽高是屏幕宽高的倍数，然后决定切割成多少块</span></span><br><span class="line">       <span class="keyword">int</span> xCount = width / maximumCacheWidth + (width % maximumCacheWidth == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> yCount = height / maximumCacheHeight + (height % maximumCacheHeight == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后求切割后弹幕每一块宽和高的平均值</span></span><br><span class="line">       <span class="keyword">int</span> averageWidth = width / xCount;</span><br><span class="line">       <span class="keyword">int</span> averageHeight = height / yCount;</span><br><span class="line">       <span class="comment">//建立二位bitmap数组，用于存放切割碎片</span></span><br><span class="line">       <span class="keyword">final</span> Bitmap[][] bmpArray = <span class="keyword">new</span> Bitmap[yCount][xCount];</span><br><span class="line">       <span class="keyword">if</span> (canvas == <span class="keyword">null</span>)&#123;</span><br><span class="line">           canvas = <span class="keyword">new</span> Canvas();</span><br><span class="line">           <span class="keyword">if</span> (mDensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               canvas.setDensity(mDensity);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Rect rectSrc = <span class="keyword">new</span> Rect();</span><br><span class="line">       Rect rectDst = <span class="keyword">new</span> Rect();</span><br><span class="line">       <span class="comment">//切割bitmap到bitmapArray中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> yIndex = <span class="number">0</span>; yIndex &lt; yCount; yIndex++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> xIndex = <span class="number">0</span>; xIndex &lt; xCount; xIndex++) &#123;</span><br><span class="line">            <span class="comment">//创建每一块小块bitmap</span></span><br><span class="line">               Bitmap bmp = bmpArray[yIndex][xIndex] = NativeBitmapFactory.createBitmap(</span><br><span class="line">                       averageWidth, averageHeight, Bitmap.Config.ARGB_8888);</span><br><span class="line">               <span class="keyword">if</span> (mDensity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   bmp.setDensity(mDensity);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//将弹幕的大bitmap绘制进每个小块bitmap中</span></span><br><span class="line">               canvas.setBitmap(bmp);</span><br><span class="line">               <span class="keyword">int</span> left = xIndex * averageWidth, top = yIndex * averageHeight;</span><br><span class="line">               rectSrc.set(left, top, left + averageWidth, top + averageHeight);</span><br><span class="line">               rectDst.set(<span class="number">0</span>, <span class="number">0</span>, bmp.getWidth(), bmp.getHeight());</span><br><span class="line">               canvas.drawBitmap(bitmap, rectSrc, rectDst, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       canvas.setBitmap(bitmap);</span><br><span class="line">       bitmapArray = bmpArray;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;切割超过一屏的弹幕，<strong>就像玩切田字格游戏一样</strong>，完成后保存了一个bitmapArray数组。</p>
<p>&#160; &#160; &#160; &#160;到这里我们buildCache(item, false)的策略二中的重新设置缓存DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache)就走完了。然后将这个目标弹幕的引用放入缓存Danmakus中(mCaches)，同时更新已使用大小mRealSize。同时注意mCaches内部成员items是TreeSet类型，不能添加相同的对象。</p>
<p>&#160; &#160; &#160; &#160;策略二设计的挺复杂的，我们可以看到这个策略应该是弹幕已经播放时不断执行的，对过时弹幕缓存的重复利用。不过我们刚开始，这一策略还未起作用，所以跳过，进入下一阶段：</p>
<p> &#160; &#160; &#160; &#160;4）如果上述两次查找缓存都没找到，则从FinitePool中取出一个，没有就new一个，然后同上配置DrawingCache：<br> &#160; &#160; &#160; &#160;继续回到buildCache方法这个位置： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">byte</span> <span class="title">buildCache</span><span class="params">(BaseDanmaku item, <span class="keyword">boolean</span> forceInsert)</span> </span>&#123;<span class="comment">//item, false</span></span><br><span class="line">		...测量过了...</span><br><span class="line">		...第一策略已经pass...</span><br><span class="line">		...第二策略已经pass...</span><br><span class="line">                  <span class="comment">//如果上述两次查找缓存都没找到，则进入下面逻辑</span></span><br><span class="line">                  <span class="comment">// guess cache size</span></span><br><span class="line">                  <span class="keyword">if</span> (!forceInsert) &#123;<span class="comment">//如果forceInsert为false，则表示不检测内存超出</span></span><br><span class="line">                      <span class="comment">//计算此弹幕bitmap的大小，width * height * 4</span></span><br><span class="line">                      <span class="comment">//(因为用native创建的Bitmap的Config为ARGB_8888，所以一个像素占4个字节)</span></span><br><span class="line">                      <span class="keyword">int</span> cacheSize = DanmakuUtils.getCacheSize((<span class="keyword">int</span>) item.paintWidth,</span><br><span class="line">                              (<span class="keyword">int</span>) item.paintHeight);</span><br><span class="line">                      <span class="comment">//如果当前已经使用大小 + 此弹幕缓存大小 &gt; 设置的最大内存（2/3 应用内存）        </span></span><br><span class="line">                      <span class="keyword">if</span> (mRealSize + cacheSize &gt; mMaxSize) &#123;<span class="comment">//没有超</span></span><br><span class="line">                          <span class="keyword">return</span> RESULT_FAILED;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//从FinitePool中的300个DrawingCache对象中取出来一个</span></span><br><span class="line">                  cache = mCachePool.acquire();</span><br><span class="line">                  <span class="comment">//如果从上面的FinitePool取完了，则会直接new一个DrawingCache，配置DrawingCache</span></span><br><span class="line">                  cache = DanmakuUtils.buildDanmakuDrawingCache(item, mDisp, cache);</span><br><span class="line">                  item.cache = cache;</span><br><span class="line">                  <span class="comment">//将item存入mCaches缓存，同时更新已使用大小mRealSize</span></span><br><span class="line">                  <span class="keyword">boolean</span> pushed = mCacheManager.push(item, sizeOf(item), forceInsert);</span><br><span class="line">                  <span class="keyword">if</span> (!pushed) &#123;<span class="comment">//如果item存放失败(使用内存超出规定大小)</span></span><br><span class="line">                      releaseDanmakuCache(item, cache);<span class="comment">//释放DrawingCache</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> pushed ? RESULT_SUCCESS : RESULT_FAILED;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//FinitePool的acquire方法，从缓存链表头取出一个对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T element;</span><br><span class="line">		<span class="comment">//mRoot 就是缓存链表表头指向的对象</span></span><br><span class="line">        <span class="keyword">if</span> (mRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            element = mRoot;</span><br><span class="line">            mRoot = element.getNextPoolable();</span><br><span class="line">            mPoolCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element = mManager.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">	        <span class="keyword">if</span> (element != <span class="keyword">null</span>) &#123;</span><br><span class="line">            element.setNextPoolable(<span class="keyword">null</span>);</span><br><span class="line">            element.setPooled(<span class="keyword">false</span>);</span><br><span class="line">            mManager.onAcquired(element);</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上述策略三是直接新建一个缓存DrawingCache，然后根据目标弹幕样式等配置它然后将它付给目标弹幕，再将目标弹幕放入缓存mCaches中。<br>&#160; &#160; &#160; &#160;刚开始时会执行策略三，因为刚开始时还没有缓存供我们使用，所以只能新建。</p>
<p>&#160; &#160; &#160; &#160;到此buildCache方法就走完了。我们可以看到buildCache主要截取了从当前时间开始的3倍弹幕时间内所有弹幕，然后为每一条弹幕建立缓存（创建DrawingCache对象，然后测量弹幕大小，再绘制弹幕内容，最后将信息保存到DrawingCache中，然后将它赋给目标弹幕的cache属性），并将这些弹幕保存到缓存mCaches中。</p>
<p>&#160; &#160; &#160; &#160;再次回顾一下上面的逻辑：</p>
<ul>
<li>子线程从发送PREPARE消息开始，然后接着发送了DISPATCH_ACTIONS消息；</li>
<li>DISPATCH_ACTIONS消息处理逻辑内部又会发送DISPATCH_ACTIONS消息，时间间隔为半条弹幕时间就这样不断循环发送；</li>
<li>DISPATCH_ACTIONS消息处理会调用dispatchAction方法，dispatchAction方法会发送BUILD_CACHES消息；</li>
<li>BUILD_CACHES消息处理会调用prepareCaches方法，prepareCaches方法内部会调用buildCache方法为从当前时间开始的3倍弹幕时间内所有的弹幕做缓存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;buildCache走完后，赶紧回到它之前调用方法的地方，不要把自己搞晕了= 。=<br>&#160; &#160; &#160; &#160;回到CacheManagingDrawTask的prepareCaches方法中，<strong>最后更新一下缓存定时器的时间，到缓存的最后一条弹幕的出现时间</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">prepareCaches</span><span class="params">(<span class="keyword">boolean</span> repositioned)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...截取三倍弹幕时间内所有弹幕，并为他们一一建立缓存...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;<span class="comment">//截取的最后一条弹幕,更新缓存定时器时间到它的出现时间</span></span><br><span class="line">        mCacheTimer.update(item.time);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCacheTimer.update(end);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;prepareCaches方法走完后，回到处理原先处理BUILD_CACHES消息的逻辑中，继续执行剩余部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">case</span> BUILD_CACHES:</span><br><span class="line">        removeMessages(BUILD_CACHES);</span><br><span class="line">        <span class="keyword">boolean</span> repositioned = ((mTaskListener != <span class="keyword">null</span> </span><br><span class="line">         &amp;&amp; mReadyState == <span class="keyword">false</span>) || mSeekedFlag);<span class="comment">// 为true</span></span><br><span class="line">        prepareCaches(repositioned);<span class="comment">//首次建立缓存已经完毕</span></span><br><span class="line">        <span class="keyword">if</span> (repositioned)</span><br><span class="line">         mSeekedFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTaskListener != <span class="keyword">null</span> &amp;&amp; mReadyState == <span class="keyword">false</span>) &#123;</span><br><span class="line">         mTaskListener.ready();<span class="comment">//然后回到mTaskListener监听ready方法</span></span><br><span class="line">         mReadyState = <span class="keyword">true</span>;<span class="comment">//将mReadyState标志位置为true，下次BUILD_CACHES不会进入这段逻辑了</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">       ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;执行mTaskListener.ready()方法，得回到上层逻辑DrawHandler的prepare(runnable)方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的prepare方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (drawTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">           drawTask = createDrawTask(mDanmakuView.isDanmakuDrawingCacheEnabled(), timer,</span><br><span class="line">                   mDanmakuView.getContext(), mDanmakuView.getWidth(), mDanmakuView.getHeight(),</span><br><span class="line">                   mDanmakuView.isHardwareAccelerated(), <span class="keyword">new</span> IDrawTask.TaskListener() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           initRenderingConfigs();<span class="comment">//初始化一些渲染参数</span></span><br><span class="line">                           runnable.run();<span class="comment">//执行runnable的run方法，继续追踪</span></span><br><span class="line">                       &#125;</span><br><span class="line">				......</span><br><span class="line">                   &#125;);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           runnable.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawHandler的initRenderingConfigs方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRenderingConfigs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> averageFrameConsumingTime = <span class="number">16</span>;<span class="comment">//平均每帧渲染间隔</span></span><br><span class="line">       mCordonTime = Math.max(<span class="number">33</span>, (<span class="keyword">long</span>) (averageFrameConsumingTime * <span class="number">2.5f</span>));<span class="comment">//40，警戒值1</span></span><br><span class="line">       mCordonTime2 = (<span class="keyword">long</span>) (mCordonTime * <span class="number">2.5f</span>);<span class="comment">//100，警戒值2</span></span><br><span class="line">       mFrameUpdateRate = Math.max(<span class="number">16</span>, averageFrameConsumingTime / <span class="number">15</span> * <span class="number">15</span>);<span class="comment">//16，每帧渲染间隔</span></span><br><span class="line">       mThresholdTime = mFrameUpdateRate + <span class="number">3</span>;<span class="comment">//19，渲染间隔阀值</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;初始化一些渲染参数，主要就是计算一下警戒时间和渲染频率。然后继续追踪runnable.run()方法，这个得回到DrawHandler的handleMessage方法中处理DrawHandler.PREPARE逻辑处：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> what = msg.what;</span><br><span class="line">       <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">           <span class="keyword">case</span> PREPARE:</span><br><span class="line">		......</span><br><span class="line">                   prepare(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//会回调到这里</span></span><br><span class="line">                           pausedPosition = <span class="number">0</span>;</span><br><span class="line">                           mReady = <span class="keyword">true</span>;<span class="comment">//将mReady 标志位置为true</span></span><br><span class="line">                           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               mCallback.prepared();<span class="comment">//回调callback监听</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               ......</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续追踪mCallback.prepared()，会回到MainActivity当中我们设置DanmakuView的地方：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity中设置mDanmakuView</span></span><br><span class="line">   mDanmakuView.setCallback(<span class="keyword">new</span> master.flame.danmaku.controller.DrawHandler.Callback() &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepared</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">    mDanmakuView.start();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//继续产看DanmaKuView的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       start(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">long</span> postion)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       handler.obtainMessage(DrawHandler.START, postion).sendToTarget();<span class="comment">//DrawHandler发送START消息</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后就是DrawHandler发送START消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		......</span><br><span class="line">        <span class="keyword">case</span> START:</span><br><span class="line">               Long startTime = (Long) msg.obj;<span class="comment">//0</span></span><br><span class="line">               <span class="keyword">if</span> (startTime != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   pausedPosition = startTime;<span class="comment">//0</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   pausedPosition = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">case</span> SEEK_POS:</span><br><span class="line">			......</span><br><span class="line">           <span class="keyword">case</span> RESUME:</span><br><span class="line">               quitFlag = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (mReady) &#123;<span class="comment">//true</span></span><br><span class="line">				......</span><br><span class="line">                   mTimeBase = SystemClock.uptimeMillis() - pausedPosition;<span class="comment">//将时间基线设为当前时间</span></span><br><span class="line">                   timer.update(pausedPosition);<span class="comment">//更新主定时器时间到初始位置，为0</span></span><br><span class="line">                   removeMessages(RESUME);</span><br><span class="line">                   sendEmptyMessage(UPDATE);<span class="comment">//发送UPDATE消息</span></span><br><span class="line">                   drawTask.start();<span class="comment">//CacheManagingDrawTask的start方法</span></span><br><span class="line">				......</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  ......</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> UPDATE:</span><br><span class="line">               <span class="keyword">if</span> (mUpdateInNewThread) &#123;<span class="comment">//在DrawHandler构造方法里赋值的变量，只有当可用CPU个数大于3时才为true</span></span><br><span class="line">                   updateInNewThread();<span class="comment">//四核，八核的请进</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   updateInCurrentThread();<span class="comment">//单核，双核的请进</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述逻辑最后会进入RESUME消息处理中，先调用CacheManagingDrawTask的start方法，然后处理UPDATE消息。我们先看看CacheManagingDrawTask的start方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheManagingDrawTask的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       mCacheManager.resume();<span class="comment">//CacheManager的resume方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//继续跟CacheManager的resume方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ......</span><br><span class="line">           mHandler.resume();<span class="comment">//CacheManagingDrawTask的resume方法</span></span><br><span class="line">		......</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//继续跟CacheManagingDrawTask的resume方法   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           mCancelFlag = <span class="keyword">false</span>;</span><br><span class="line">           mPause = <span class="keyword">false</span>;</span><br><span class="line">           removeMessages(DISPATCH_ACTIONS);</span><br><span class="line">           sendEmptyMessage(DISPATCH_ACTIONS);<span class="comment">//发送DISPATCH_ACTIONS消息，我们上面分析过，就是建立缓存</span></span><br><span class="line">           sendEmptyMessageDelayed(CLEAR_TIMEOUT_CACHES, mContext.mDanmakuFactory.MAX_DANMAKU_DURATION);<span class="comment">//延时发送CLEAR_TIMEOUT_CACHES消息</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到CacheManagingDrawTask的start方法最终做了两件事，一件是发送DISPATCH_ACTIONS再次建立缓存，这个流程我们上面分析过；第二件是<code>延时发送</code>CLEAR_TIMEOUT_CACHES消息。</p>
<p>&#160; &#160; &#160; &#160;所以我们看看CLEAR_TIMEOUT_CACHES消息处理逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	 .......</span><br><span class="line">	 <span class="keyword">case</span> CLEAR_TIMEOUT_CACHES:</span><br><span class="line">            clearTimeOutCaches();<span class="comment">//继续跟这个</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ......    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 clearTimeOutCaches方法</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearTimeOutCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          clearTimeOutCaches(mTimer.currMillisecond);<span class="comment">//调用重载方法，参数为主定时器当前时间</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用重载方法，参数为主定时器当前时间</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearTimeOutCaches</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">          IDanmakuIterator it = mCaches.iterator();<span class="comment">//从之前buildCache中建立的缓存中一一遍历</span></span><br><span class="line">          <span class="keyword">while</span> (it.hasNext() &amp;&amp; !mEndFlag) &#123;<span class="comment">//mEndFlag = false</span></span><br><span class="line">              BaseDanmaku val = it.next();</span><br><span class="line">              <span class="keyword">if</span> (val.isTimeOut()) &#123;<span class="comment">//如果缓存的弹幕已经超时</span></span><br><span class="line">			......</span><br><span class="line">                  entryRemoved(<span class="keyword">false</span>, val, <span class="keyword">null</span>);<span class="comment">//销毁缓存</span></span><br><span class="line">                  it.remove();<span class="comment">//从缓存mCaches中移除此引用</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;顺着逻辑看看entryRemoved(false, val, null)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">entryRemoved</span><span class="params">(<span class="keyword">boolean</span> evicted, BaseDanmaku oldValue, BaseDanmaku newValue)</span> </span>&#123;<span class="comment">//第1个和第3个参数没用到</span></span><br><span class="line">    IDrawingCache&lt;?&gt; cache = oldValue.getDrawingCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> releasedSize = clearCache(oldValue);<span class="comment">//调用了clearCache方法</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue.isTimeOut()) &#123;</span><br><span class="line">         <span class="comment">//这个方法最终会调用我们最初设置DanmakuContext.setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter)</span></span><br><span class="line">         <span class="comment">//中第二个参数类型为BaseCacheStuffer.Proxy的releaseResource方法,</span></span><br><span class="line">         <span class="comment">//方法注释是这么写的 TODO 重要:清理含有ImageSpan的text中的一些占用内存的资源 例如drawable</span></span><br><span class="line">            mContext.getDisplayer().getCacheStuffer().releaseResource(oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (releasedSize &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        mRealSize -= releasedSize;<span class="comment">//真正缓存大小减去需要释放的缓存大小</span></span><br><span class="line">        mCachePool.release((DrawingCache) cache);<span class="comment">//将Drawingcache放回到FinitePool中，已供下次取出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//往下看，看看clearCache方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">clearCache</span><span class="params">(BaseDanmaku oldValue)</span> </span>&#123;</span><br><span class="line">    IDrawingCache&lt;?&gt; cache = oldValue.cache;</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache.hasReferences()) &#123;<span class="comment">//如果DrawingCache缓存还被重复引用</span></span><br><span class="line">        cache.decreaseReference();<span class="comment">//则将引用计数-1</span></span><br><span class="line">        oldValue.cache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不销毁缓存(bitmap,canvas等)，只有等到引用计数为0时才会销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> size = sizeOf(oldValue);<span class="comment">//计算缓存的bitmap大小</span></span><br><span class="line">    cache.destroy();<span class="comment">//同时销毁bitmap等</span></span><br><span class="line">    oldValue.cache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存的bitmap的大小</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(BaseDanmaku value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value.cache != <span class="keyword">null</span> &amp;&amp; !value.cache.hasReferences()) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.cache.size();<span class="comment">//返回的是Drawing中bitmap对象的大小，上面讲过的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;CLEAR_TIMEOUT_CACHES消息处理就分析完了，就是移除缓存弹幕mCache中过时的弹幕，并且销毁他们持有的DrawingCache，同时销毁内部的bitmap、canvas等。</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>&#160; &#160; &#160; &#160;现在重点来了！还记得我们之前挖的一个大坑么？就是妹子图那个地方。那是CacheHandler给工作线程发送DISPATCH_ACTIONS消息时调用的dispatchAction方法。因为CacheHandler每个半条弹幕时间就会发DISPATCH_ACTIONS消息，所以我们得仔细分析一下dispatchAction方法的各种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">dispatchAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//如果上一次buildCache完成后得到的缓存弹幕末尾项的时间（上面分析过，这个值存在mCacheTimer.currMillisecond中）</span></span><br><span class="line">         <span class="comment">//和主定时器当前时间之间的时间差值已经大于一条弹幕时间,</span></span><br><span class="line">         <span class="comment">//则会清除所有不在屏幕内的缓存，然后重新buildCache建立缓存</span></span><br><span class="line">            <span class="keyword">if</span> (mCacheTimer.currMillisecond &lt;= mTimer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                evictAllNotInScreen();<span class="comment">//则会清除所有不在屏幕内的缓存</span></span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//重新建立缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> level = getPoolPercent();<span class="comment">//获得缓存实际大小占设置最大内存的百分比</span></span><br><span class="line">            BaseDanmaku firstCache = mCaches.first();</span><br><span class="line">            <span class="comment">//TODO 如果firstcache大于当前时间超过半屏并且水位在0.5f以下,就要往里蓄水</span></span><br><span class="line">            <span class="keyword">long</span> gapTime = firstCache != <span class="keyword">null</span> ? firstCache.time - mTimer.currMillisecond : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> doubleScreenDuration = mContext.mDanmakuFactory.MAX_DANMAKU_DURATION * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (level &lt; <span class="number">0.6f</span> &amp;&amp; gapTime &gt; mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                removeMessages(BUILD_CACHES);</span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//重新建立缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level &gt; <span class="number">0.4f</span> &amp;&amp; gapTime &lt; -doubleScreenDuration) &#123;<span class="comment">//如果水位在0.5以上，并且上一次蓄水距离现在已经超过两条弹幕时间了，就要开闸放水</span></span><br><span class="line">                <span class="comment">// clear timeout caches</span></span><br><span class="line">                removeMessages(CLEAR_TIMEOUT_CACHES);</span><br><span class="line">                sendEmptyMessage(CLEAR_TIMEOUT_CACHES);<span class="comment">//CLEAR_TIMEOUT_CACHES消息刚分析过了，清除过时缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (level &gt;= <span class="number">0.9f</span>) &#123;<span class="comment">//水位快满了，等待下次放水</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check cache time</span></span><br><span class="line">            <span class="keyword">long</span> deltaTime = mCacheTimer.currMillisecond - mTimer.currMillisecond;</span><br><span class="line">            <span class="comment">//缓存的第一条弹幕已经过时了，并且缓存弹幕末尾时间和现在时间差值已经超过一条弹幕时间了</span></span><br><span class="line">            <span class="keyword">if</span> (firstCache != <span class="keyword">null</span> &amp;&amp; firstCache.isTimeOut() &amp;&amp; deltaTime &lt; -mContext.mDanmakuFactory.MAX_DANMAKU_DURATION) &#123;</span><br><span class="line">                mCacheTimer.update(mTimer.currMillisecond);</span><br><span class="line">                sendEmptyMessage(CLEAR_OUTSIDE_CACHES);<span class="comment">//先清除过时缓存</span></span><br><span class="line">                sendEmptyMessage(BUILD_CACHES);<span class="comment">//再重组缓存</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deltaTime &gt; doubleScreenDuration) &#123;<span class="comment">//如果缓存的最后一条弹幕时间距离现在还有双倍弹幕时间多，则啥都不做</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//剩余情况组建缓存</span></span><br><span class="line">            removeMessages(BUILD_CACHES);</span><br><span class="line">            sendEmptyMessage(BUILD_CACHES);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//则会清除所有不在屏幕内的缓存    </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictAllNotInScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        evictAllNotInScreen(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evictAllNotInScreen</span><span class="params">(<span class="keyword">boolean</span> removeAllReferences)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCaches != <span class="keyword">null</span>) &#123;</span><br><span class="line">            IDanmakuIterator it = mCaches.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                BaseDanmaku danmaku = it.next();</span><br><span class="line">	......</span><br><span class="line">                <span class="keyword">if</span> (danmaku.isOutside()) &#123;<span class="comment">//如果弹幕已经走完了，超过屏幕</span></span><br><span class="line">                    entryRemoved(<span class="keyword">true</span>, danmaku, <span class="keyword">null</span>);<span class="comment">//回收缓存</span></span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">        mRealSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得缓存实际大小占设置最大内存的百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPoolPercent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMaxSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mRealSize / (<span class="keyword">float</span>) mMaxSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;dispatchAction方法主要分为以下几种规则：</p>
<ul>
<li>如果上一次buildCache完成后得到的缓存弹幕末尾项的时间（上面分析过，这个值存在mCacheTimer.currMillisecond中）和主定时器当前时间之间的时间差值已经大于一条弹幕时间, 则会清除所有不在屏幕内的缓存，然后重新buildCache建立缓存；</li>
<li>如果缓存弹幕的第一项出现时间大于当前时间超过半屏，并且总缓存大小在规定最大值一半以下, 就要重新建立缓存；</li>
<li>如果总缓存大小在规定最大值一半以上，并且上一次建立缓存距离现在已经超过两条弹幕时间了，就要清除超时缓存；</li>
<li>如果总缓存大小快达到规定最大值，就等待下一次清除超时缓存；</li>
<li>缓存的第一条弹幕已经过时了，并且缓存弹幕末尾时间和现在时间差值已经超过一条弹幕时间了，先清除过时缓存，再重组缓存；</li>
<li>如果缓存的最后一条弹幕时间距离现在还有双倍弹幕时间多，则啥都不做;</li>
<li>剩余情况就是重组缓存。</li>
</ul>
<p>&#160; &#160; &#160; &#160;因为DISPATCH_ACTIONS消息是每隔半条弹幕时间发送一次，所以会不断执行dispatchAction方法。然后根据上述出现的情况不断BUILD_CACHES和CLEAR_TIMEOUT_CACHES,这样工作线程就形成了一套缓存机制。</p>
<h3 id="绘制弹幕界面"><a href="#绘制弹幕界面" class="headerlink" title="绘制弹幕界面"></a>绘制弹幕界面</h3><p>&#160; &#160; &#160; &#160;到此CacheManagingDrawTask的start方法就分析完了，继续回到DrawHandler的handleMessage方法，接着处理UPDATE消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DrawHandler的handleMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">case</span> UPDATE:</span><br><span class="line">               <span class="keyword">if</span> (mUpdateInNewThread) &#123;<span class="comment">//在DrawHandler构造方法里赋值的变量，只有当可用CPU个数大于3时才为true</span></span><br><span class="line">                   updateInNewThread();<span class="comment">//四核，八核的请进</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   updateInCurrentThread();<span class="comment">//单核，双核的请进</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           ...... 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;到这里，我们应该能猜到接下要进行应该就是绘制工作了。其实updateInNewThread和updateInCurrentThread做的事情是一样的，只不过其中一个新开了子线程去做这些事情。两者的工作原理都是更新定时器，然后postInvalidate，使DanmakuView重绘，然后再发UPDATE消息，重复上述过程。</p>
<p>&#160; &#160; &#160; &#160;鉴于目前四核手机已经烂大街了，我们也就挑个多核的方法进去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInNewThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mThread = <span class="keyword">new</span> UpdateThread(<span class="string">"DFM Update"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> lastTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> dTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isQuited() &amp;&amp; !quitFlag) &#123;</span><br><span class="line">                <span class="keyword">long</span> startMS = SystemClock.uptimeMillis();</span><br><span class="line">                dTime = SystemClock.uptimeMillis() - lastTime;</span><br><span class="line">                <span class="keyword">long</span> diffTime = mFrameUpdateRate - dTime;<span class="comment">//mFrameUpdateRate 为16，之前计算过</span></span><br><span class="line">                <span class="keyword">if</span> (diffTime &gt; <span class="number">1</span>) &#123;<span class="comment">//如果间隔时间太短，则会延时，一定要等够16毫秒，达到绘制时间间隔</span></span><br><span class="line">                    SystemClock.sleep(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;d</span><br><span class="line">                <span class="comment">//上面逻辑是为了延时，稳定帧率</span></span><br><span class="line">                lastTime = startMS;</span><br><span class="line">                <span class="keyword">long</span> d = syncTimer(startMS);<span class="comment">//同步主定时器时间</span></span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">                d = mDanmakuView.drawDanmakus();<span class="comment">//开始postInvalidate，绘制弹幕，同时返回绘制时间</span></span><br><span class="line">                <span class="comment">//这种情况出现在绘制时间内，绘制时子线程在wait，等待绘制结束，然后返回差值必定大于警戒值100</span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; mCordonTime2) &#123;  <span class="comment">// this situation may be cuased by ui-thread waiting of DanmakuView, so we sync-timer at once</span></span><br><span class="line">                    timer.add(d);<span class="comment">//绘制完成后更新主定时器时间</span></span><br><span class="line">                    mDrawTimes.clear();</span><br><span class="line">                &#125;</span><br><span class="line">	......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    mThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;updateInNewThread主要做了两件事：延时然后同步主定时器时间，然后通知DanmakuView重绘。</p>
<p>&#160; &#160; &#160; &#160;我们先看同步主定时器时间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">syncTimer</span><span class="params">(<span class="keyword">long</span> startMS)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">long</span> d = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> time = startMS - mTimeBase;<span class="comment">//当前时间到初始时间的时间差</span></span><br><span class="line">       ......</span><br><span class="line">          <span class="keyword">long</span> gapTime = time - timer.currMillisecond;<span class="comment">//总时间差减去上一次绘制完成时间，得到绘制间隙时间</span></span><br><span class="line">          <span class="keyword">long</span> averageTime = Math.max(mFrameUpdateRate, getAverageRenderingTime());<span class="comment">//计算绘制间隙平均时间，大于等于16（getAverageRenderingTime方法是计算加入mDrawTimes队列的已经绘制过的时间总和除以帧数，得到平均时间，这个下面会讲到）</span></span><br><span class="line">          <span class="comment">//若果距离上次间隙时间过长||上次渲染时间大于第一警戒时间（40 ms）||上一步计算的绘制间隙平均时间大于第一警戒时间</span></span><br><span class="line">          <span class="keyword">if</span> (gapTime &gt; <span class="number">2000</span> || mRenderingState.consumingTime &gt; mCordonTime || averageTime &gt; mCordonTime) &#123;</span><br><span class="line">              d = gapTime;</span><br><span class="line">              gapTime = <span class="number">0</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是普通情况</span></span><br><span class="line">              d = averageTime + gapTime / mFrameUpdateRate;<span class="comment">//将绘制间隙平均时间赋给d，后面的项值不大，可以忽略</span></span><br><span class="line">              d = Math.max(mFrameUpdateRate, d);<span class="comment">//大于等于固定绘制间隔16</span></span><br><span class="line">              d = Math.min(mCordonTime, d);<span class="comment">//小于第一警戒时间40</span></span><br><span class="line">       </span><br><span class="line">		......</span><br><span class="line">          &#125;</span><br><span class="line">          ......</span><br><span class="line">          timer.add(d);<span class="comment">//更新主定时器时间，加上计算的时间间隔</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算平均绘制间隔时间</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getAverageRenderingTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> frames = mDrawTimes.size();</span><br><span class="line">      <span class="keyword">if</span>(frames &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> dtime = mDrawTimes.getLast() - mDrawTimes.getFirst();</span><br><span class="line">      <span class="keyword">return</span> dtime / frames;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;syncTimer主要是计算了一下绘制间隔时间，然后同步一下主定时器。</p>
<p>&#160; &#160; &#160; &#160;然后我们看看通知DanmakuView重绘部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuView的drawDanmakus方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">drawDanmakus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> stime = SystemClock.uptimeMillis();</span><br><span class="line">       lockCanvas();<span class="comment">//再看看lockCanvas</span></span><br><span class="line">       <span class="keyword">return</span> SystemClock.uptimeMillis() - stime;<span class="comment">//返回等待时间差</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DanmakuView的lockCanvas方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       postInvalidateCompat();<span class="comment">//通知view重绘</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mDrawMonitor) &#123;</span><br><span class="line">           <span class="keyword">while</span> ((!mDrawFinished) &amp;&amp; (handler != <span class="keyword">null</span>)) &#123;<span class="comment">//mDrawFinished标志位为false，所以会进入循环。只有onDraw方法的绘制走完了才会将他置为true，才会跳出循环</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   mDrawMonitor.wait(<span class="number">200</span>);<span class="comment">//onDraw没走完就会一直循环等待</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (mDanmakuVisible == <span class="keyword">false</span> || handler == <span class="keyword">null</span> || handler.isStop()) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       Thread.currentThread().interrupt();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mDrawFinished = <span class="keyword">false</span>;<span class="comment">//绘制结束后，将标志位置为false，一边下次进入方法后再次进入上述等待逻辑</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postInvalidateCompat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mRequestRender = <span class="keyword">true</span>;<span class="comment">//将mRequestRender 标志位置为true，一遍onDraw方法逻辑执行</span></span><br><span class="line">       <span class="comment">//通知view重绘</span></span><br><span class="line">       <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.postInvalidateOnAnimation();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.postInvalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样就能保证保证每隔一定时间（这个时间通过syncTimer计算），更新主定时器（就是从0开始，往后每次加上（间隔时间 + 绘制时间）），然后执行postInvalidate通知DanmakuView重绘。</p>
<p>&#160; &#160; &#160; &#160;postInvalidate后，View重绘，会重走onDraw方法，所以我们进入DanmakuView的onDraw方法看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuView的onDraw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((!mDanmakuVisible) &amp;&amp; (!mRequestRender)) &#123;<span class="comment">//如果没有请求重绘则mRequestRender为false，不会绘制弹幕</span></span><br><span class="line">           <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	......</span><br><span class="line">           <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">               RenderingState rs = handler.draw(canvas);<span class="comment">//DrawHandler的draw方法</span></span><br><span class="line">			......</span><br><span class="line">           &#125;</span><br><span class="line">      ......</span><br><span class="line">       <span class="comment">//绘制结束后将mRequestRender 标志位重新设为false，</span></span><br><span class="line">       <span class="comment">//以便下一次发绘制消息时进入等待逻辑等候绘制结束，这个上面DanmakuView的drawDanmakus方法提到过</span></span><br><span class="line">       mRequestRender = <span class="keyword">false</span>;</span><br><span class="line">       unlockCanvasAndPost();<span class="comment">//通知UpdateThread绘制完成</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (mDrawMonitor) &#123;</span><br><span class="line">           mDrawFinished = <span class="keyword">true</span>;<span class="comment">//将mDrawFinished 置为true，以便DanmakuView的lockCanvas方法跳出循环，这个上面也提到过</span></span><br><span class="line">           mDrawMonitor.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DanmakuView的onDraw回调逻辑会执行DrawHandler的draw方法，我们继续跟进去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">      mDisp.setExtraData(canvas);<span class="comment">//将canvas一些信息设置给AndroidDisplayer</span></span><br><span class="line">      mRenderingState.set(drawTask.draw(mDisp));<span class="comment">//绘制部分是drawTask.draw(mDisp)</span></span><br><span class="line">      recordRenderingTime();<span class="comment">//记录绘制结束时间</span></span><br><span class="line">      <span class="keyword">return</span> mRenderingState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//还记得上面的DrawHandler的syncTimer方法吗？里面调用了getAverageRenderingTime计算绘制平均间隔时间，</span></span><br><span class="line">  <span class="comment">//其中用到的mDrawTimes变量就是在这里添加元素的</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recordRenderingTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> lastTime = SystemClock.uptimeMillis();</span><br><span class="line">      mDrawTimes.addLast(lastTime);<span class="comment">//将绘制结束时间加入到类型为LinkedList的mDrawTimes集合中</span></span><br><span class="line">      <span class="keyword">int</span> frames = mDrawTimes.size();</span><br><span class="line">      <span class="keyword">if</span> (frames &gt; MAX_RECORD_SIZE) &#123;<span class="comment">//最大容量为500个绘制时间，超出了则移除第一个</span></span><br><span class="line">          mDrawTimes.removeFirst();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述逻辑中，我的注释部分先分析了记录绘制结束时间部分，填了上边syncTimer时的坑。<br>&#160; &#160; &#160; &#160;然后应该进入主要绘制部分了drawTask.draw(mDisp)，也就是CacheManagingDrawTask的draw方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheManagingDrawTask的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(AbsDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       RenderingState result = <span class="keyword">super</span>.draw(displayer);<span class="comment">//会调用父类的draw方法</span></span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawTask的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> RenderingState <span class="title">draw</span><span class="params">(AbsDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> drawDanmakus(displayer,mTimer);<span class="comment">//又调用了drawDanmakus方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//DrawTask的drawDanmakus方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> RenderingState <span class="title">drawDanmakus</span><span class="params">(AbsDisplayer disp, DanmakuTimer timer)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">if</span> (danmakuList != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Canvas canvas = (Canvas) disp.getExtraData();<span class="comment">//取出DanmakuView的canvas</span></span><br><span class="line">		<span class="comment">//当前时间 - 1屏弹幕时间 -100 （多减100是为了下次重新截取弹幕组时让绘制边界做到无缝衔接）</span></span><br><span class="line">           <span class="keyword">long</span> beginMills = timer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - <span class="number">100</span>;</span><br><span class="line">           <span class="comment">//当前时间 + 1屏弹幕时间</span></span><br><span class="line">           <span class="keyword">long</span> endMills = timer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;</span><br><span class="line">           <span class="comment">//每过了一屏的弹幕时间，就会进入如下if逻辑，截取以当前时间为基准的前后两屏弹幕；</span></span><br><span class="line">           <span class="comment">//如果距离上次截取时间不到一屏弹幕时间，则不会进入if的逻辑</span></span><br><span class="line">           <span class="keyword">if</span>(mLastBeginMills &gt; beginMills || timer.currMillisecond &gt; mLastEndMills) &#123;</span><br><span class="line">               IDanmakus subDanmakus = danmakuList.sub(beginMills, endMills);</span><br><span class="line">               <span class="keyword">if</span>(subDanmakus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   danmakus = subDanmakus;</span><br><span class="line">               &#125;</span><br><span class="line">               mLastBeginMills = beginMills;</span><br><span class="line">               mLastEndMills = endMills;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//距离上次截取时间不到一屏时间</span></span><br><span class="line">		......</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (danmakus != <span class="keyword">null</span> &amp;&amp; !danmakus.isEmpty()) &#123;<span class="comment">//开始绘制弹幕</span></span><br><span class="line">               RenderingState renderingState = mRenderingState = mRenderer.draw(mDisp, danmakus, mStartRenderTime);</span><br><span class="line">		......</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们可以看到第一次进入会截取以当前时间为基准的前后两屏弹幕。以后每过一屏弹幕时间，会重新截取当时时间为基准的前后两屏弹幕，如果不到一屏时间则不截取，还是以前的弹幕数据。</p>
<p>&#160; &#160; &#160; &#160;截取完弹幕数据后，就是绘制了，继续执行下面逻辑(mRenderer.draw(mDisp, danmakus, mStartRenderTime))，开始绘制工作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuRenderer的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(IDisplayer disp, IDanmakus danmakus, <span class="keyword">long</span> startRenderTime)</span> </span>&#123;</span><br><span class="line">       ......       </span><br><span class="line">       IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">       ......      </span><br><span class="line"></span><br><span class="line">       BaseDanmaku drawItem = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">           drawItem = itr.next();</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">		<span class="comment">//如果弹幕还没有到出现时间，则检查它有没有缓存，如果没有则为它建立缓存</span></span><br><span class="line">           <span class="keyword">if</span> (drawItem.isLate()) &#123;</span><br><span class="line">               IDrawingCache&lt;?&gt; cache = drawItem.getDrawingCache();</span><br><span class="line">               <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span> &amp;&amp; (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                   mCacheManager.addDanmaku(drawItem);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">           <span class="comment">// measure 测量，我们之前prepareCache已经为他们在buildCache是测量过了</span></span><br><span class="line">           <span class="keyword">if</span> (!drawItem.isMeasured()) &#123;</span><br><span class="line">               drawItem.measure(disp, <span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// layout 布局，计算弹幕在屏幕上应该显示的位置</span></span><br><span class="line">           mDanmakusRetainer.fix(drawItem, disp, mVerifier);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// draw //绘制弹幕</span></span><br><span class="line">           <span class="keyword">if</span> (!drawItem.isOutside() &amp;&amp; drawItem.isShown()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (drawItem.lines == <span class="keyword">null</span> &amp;&amp; drawItem.getBottom() &gt; disp.getHeight()) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;    <span class="comment">// skip bottom outside danmaku ，忽略超过视图底部的弹幕</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//开始绘制</span></span><br><span class="line">               <span class="keyword">int</span> renderingType = drawItem.draw(disp);</span><br><span class="line">               <span class="keyword">if</span>(renderingType == IRenderer.CACHE_RENDERING) &#123;<span class="comment">//如果是使用缓存bitmap绘制的</span></span><br><span class="line">                   ......</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderingType == IRenderer.TEXT_RENDERING) &#123;<span class="comment">//如果使用缓存绘制失败，则会使用原声方法Canvas去draw</span></span><br><span class="line">                   ......</span><br><span class="line">                   <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       mCacheManager.addDanmaku(drawItem);<span class="comment">//再次为词条弹幕构建缓存，以便下次使用缓存bitmap绘制</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">			......</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从截取的弹幕中遍历每一个，然后一一绘制。绘制步骤有如下几步：</p>
<ul>
<li>如果弹幕还没有到出现时间，则检查它有没有缓存，如果没有则为它建立缓存；</li>
<li>measure 测量，我们之前prepareCache已经为他们在buildCache时测量过了;</li>
<li>layout 布局，计算弹幕在屏幕上应该显示的位置；</li>
<li>draw 绘制弹幕。</li>
</ul>
<p>&#160; &#160; &#160; &#160;我们一步一步分析：<br>&#160; &#160; &#160; &#160;1）弹幕未到出现时间，检查是否建立缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用CacheManagingDrawTask的addDanmaku方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDanmaku</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//CacheHandler</span></span><br><span class="line">                  mHandler.obtainMessage(CacheHandler.ADD_DANMAKKU, danmaku).sendToTarget();</span><br><span class="line">            ......</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//CacheHandler</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">case</span> ADD_DANMAKKU:</span><br><span class="line">              BaseDanmaku item = (BaseDanmaku) msg.obj;</span><br><span class="line">              addDanmakuAndBuildCache(item);<span class="comment">//调用了addDanmakuAndBuildCache方法</span></span><br><span class="line">              <span class="keyword">break</span>;        </span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//调用了addDanmakuAndBuildCache方法</span></span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addDanmakuAndBuildCache</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//过时了 || 并且弹幕时间不在3屏弹幕时间内(因为mCaches只缓存了3屏时间内的所有弹幕，上面说过的),并且它不是直播弹幕。则不建立缓存</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.isTimeOut() || (danmaku.time &gt; mCacheTimer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION &amp;&amp; !danmaku.isLive)) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//优先级为0或者在过滤规则内，不建立缓存</span></span><br><span class="line">              <span class="keyword">if</span> (danmaku.priority == <span class="number">0</span> &amp;&amp; danmaku.isFiltered()) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">              <span class="keyword">if</span> (cache == <span class="keyword">null</span> || cache.get() == <span class="keyword">null</span>) &#123;<span class="comment">//如果弹幕没有缓存</span></span><br><span class="line">                  buildCache(danmaku, <span class="keyword">true</span>);<span class="comment">//建立缓存（buildCache方法我们上面分析过，就是用来建立缓存的）</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2）测量，这个我们上面再buildCache时分析过了，不再赘述；</p>
<p>&#160; &#160; &#160; &#160;3）布局：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用DanmakusRetainer的fix方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(BaseDanmaku danmaku, IDisplayer disp, Verifier verifier)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> type = danmaku.getType();</span><br><span class="line">       <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SCROLL_RL:</span><br><span class="line">               rldrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SCROLL_LR:</span><br><span class="line">               lrdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_FIX_TOP:</span><br><span class="line">               ftdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_FIX_BOTTOM:</span><br><span class="line">               fbdrInstance.fix(danmaku, disp, verifier);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BaseDanmaku.TYPE_SPECIAL:</span><br><span class="line">               danmaku.layout(disp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;类型太多了，我们只分析TYPE_SCROLL_RL类型弹幕其他的就不分析，有兴趣的可以自己分析一下其他的。接着会调用AlignTopRetainer的fix方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存需要显示的弹幕容器类（保存的一行只有一条弹幕，下面会说明的），内部持有一个以弹幕的y坐标排序的TreeSet集合，这个需要注意</span></span><br><span class="line"><span class="keyword">protected</span> Danmakus mVisibleDanmakus = <span class="keyword">new</span> Danmakus(Danmakus.ST_BY_YPOS);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//AlignTopRetainer的fix方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(BaseDanmaku drawItem, IDisplayer disp, Verifier verifier)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (drawItem.isOutside())<span class="comment">//如果弹幕已经滚动到视图边界外，则不会为它布局</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          <span class="keyword">float</span> topPos = <span class="number">0</span>;<span class="comment">//弹幕的y坐标</span></span><br><span class="line">          <span class="keyword">int</span> lines = <span class="number">0</span>;<span class="comment">//弹幕在第几行显示</span></span><br><span class="line">          <span class="keyword">boolean</span> shown = drawItem.isShown();<span class="comment">//弹幕是否已经显示</span></span><br><span class="line">          <span class="keyword">boolean</span> willHit = !shown &amp;&amp; !mVisibleDanmakus.isEmpty();<span class="comment">//是否会和其他弹幕碰撞</span></span><br><span class="line">          <span class="keyword">boolean</span> isOutOfVertialEdge = <span class="keyword">false</span>;<span class="comment">//弹幕y值是否超过试图高度</span></span><br><span class="line">          BaseDanmaku removeItem = <span class="keyword">null</span>;<span class="comment">//需要移除的弹幕</span></span><br><span class="line">          <span class="comment">//为即将显示的弹幕确认位置</span></span><br><span class="line">          <span class="keyword">if</span> (!shown) &#123;</span><br><span class="line">              mCancelFixingFlag = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 确定弹幕位置开始</span></span><br><span class="line">              IDanmakuIterator it = mVisibleDanmakus.iterator();</span><br><span class="line">              <span class="comment">//这四个变量分别为：</span></span><br><span class="line">              <span class="comment">//insertItem ---- 确认目标弹幕插入到哪一行的同行参考弹幕</span></span><br><span class="line">              <span class="comment">//firstItem ---- 已经布局过的弹幕保存容器中的第一项</span></span><br><span class="line">              <span class="comment">//lastItem ---- 已经布局过的弹幕保存容器中最后一项</span></span><br><span class="line">              <span class="comment">//minRightRow ---- 已经布局过弹幕中x值最小的弹幕，即最左边的弹幕</span></span><br><span class="line">              BaseDanmaku insertItem = <span class="keyword">null</span>, firstItem = <span class="keyword">null</span>, lastItem = <span class="keyword">null</span>, minRightRow = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">boolean</span> overwriteInsert = <span class="keyword">false</span>;<span class="comment">//是否超出插入范围</span></span><br><span class="line">              <span class="comment">//遍历已经绘制过的弹幕，因为mVisibleDanmakus 内弹幕以y值排序的，所以按y值从小到大遍历</span></span><br><span class="line">              <span class="keyword">while</span> (!mCancelFixingFlag &amp;&amp; it.hasNext()) &#123;</span><br><span class="line">                  lines++;<span class="comment">//每次循环都会将行号+1</span></span><br><span class="line">                  BaseDanmaku item = it.next();</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">if</span>(item == drawItem)&#123;<span class="comment">//如果已经布局过了，说明已经存在自己位置了</span></span><br><span class="line">                      insertItem = item;<span class="comment">//将布局过的弹幕复制给参考弹幕insertItem </span></span><br><span class="line">                      lastItem = <span class="keyword">null</span>;<span class="comment">//置空 lastItem </span></span><br><span class="line">                      shown = <span class="keyword">true</span>;<span class="comment">//shown 置为true，以便末尾不再执行加入mVisibleDanmakus逻辑</span></span><br><span class="line">                      willHit = <span class="keyword">false</span>;<span class="comment">//本身已经存在自己位置了，当然没有碰壁一说</span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//怕被下面干扰晕的可以跳出去继续看</span></span><br><span class="line">                  &#125;</span><br><span class="line">			</span><br><span class="line">                  <span class="keyword">if</span> (firstItem == <span class="keyword">null</span>)<span class="comment">//找到已经布局过的弹幕第一项</span></span><br><span class="line">                      firstItem = item;</span><br><span class="line">			<span class="comment">//如果插入目标弹幕后，y值超过了视图高度</span></span><br><span class="line">                  <span class="keyword">if</span> (drawItem.paintHeight + item.getTop() &gt; disp.getHeight()) &#123;</span><br><span class="line">                      overwriteInsert = <span class="keyword">true</span>;<span class="comment">//则将超出插入范围标签置为true</span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//怕晕的跳出循环</span></span><br><span class="line">                  &#125;</span><br><span class="line">			<span class="comment">//找出最左边的弹幕</span></span><br><span class="line">                  <span class="keyword">if</span> (minRightRow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      minRightRow = item;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (minRightRow.getRight() &gt;= item.getRight()) &#123;</span><br><span class="line">                          minRightRow = item;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 检查如果插入目标弹幕是否会和正在遍历的已经布局过的参考弹幕碰撞</span></span><br><span class="line">                  willHit = DanmakuUtils.willHitInDuration(disp, item, drawItem,</span><br><span class="line">                          drawItem.getDuration(), drawItem.getTimer().currMillisecond);</span><br><span class="line">                  <span class="keyword">if</span> (!willHit) &#123;<span class="comment">//如果没有碰撞</span></span><br><span class="line">                      insertItem = item;<span class="comment">//则将它复制给参考弹幕insertItem </span></span><br><span class="line">                      <span class="keyword">break</span>;<span class="comment">//然后跳出循环，下去确定位置</span></span><br><span class="line">                  &#125;<span class="comment">/*如果有碰撞，则继续弹幕缩小添加范围，寻找可以添加的条件，最后出while循环，下去布局*/</span></span><br><span class="line">                  </span><br><span class="line">			</span><br><span class="line">                  lastItem = item;<span class="comment">//暂时找到已经布局过的弹幕最后一项，然后继续循环</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">boolean</span> checkEdge = <span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">if</span> (insertItem != <span class="keyword">null</span>) &#123;<span class="comment">//已经布局过了||目标弹幕不会碰壁可以插入</span></span><br><span class="line">                  <span class="keyword">if</span> (lastItem != <span class="keyword">null</span>)<span class="comment">//目标弹幕插入，y值即为上一次遍历的弹幕的底部</span></span><br><span class="line">                      topPos = lastItem.getBottom();</span><br><span class="line">                  <span class="keyword">else</span><span class="comment">//已经布局过了，则y的位置不变</span></span><br><span class="line">                      topPos = insertItem.getTop();</span><br><span class="line">                      </span><br><span class="line">                  <span class="keyword">if</span> (insertItem != drawItem)&#123;<span class="comment">//如果目标弹幕可以插入</span></span><br><span class="line">                   <span class="comment">//这里需要注意，因为一行可以放n多条弹幕，只要前后不碰撞就行；</span></span><br><span class="line">                   <span class="comment">//所以下次我们在同一行插入弹幕判断碰壁时，当然要和这行最后一条弹幕去判断；</span></span><br><span class="line">                   <span class="comment">//因此我们移除前一条弹幕，放入插入的目标弹幕，下次添加弹幕判断时就和目标弹幕判断，然后这么循环下去</span></span><br><span class="line">                      removeItem = insertItem;</span><br><span class="line">                      </span><br><span class="line">                      shown = <span class="keyword">false</span>;<span class="comment">//置为false，以便mVisibleDanmakus 添加还未布局的新弹幕</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overwriteInsert &amp;&amp; minRightRow != <span class="keyword">null</span>) &#123;<span class="comment">//没有空行可以插入</span></span><br><span class="line">                  topPos = minRightRow.getTop();<span class="comment">//暂时放到最最左边的弹幕那一行（excuse me ？？？）</span></span><br><span class="line">                  checkEdge = <span class="keyword">false</span>;<span class="comment">//不做范围检查</span></span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastItem != <span class="keyword">null</span>) &#123;<span class="comment">//找不到插入的位置</span></span><br><span class="line">                  topPos = lastItem.getBottom();<span class="comment">//暂时放到最低位置的弹幕下面，下面检测边界时会酌情河蟹</span></span><br><span class="line">                  willHit = <span class="keyword">false</span>;<span class="comment">//置false碰壁标志</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstItem != <span class="keyword">null</span>) &#123;<span class="comment">////mVisibleDanmakus只有第一条数据，截取弹幕集的第二条弹幕没有和第一条碰壁时</span></span><br><span class="line">                  topPos = firstItem.getTop();<span class="comment">//此时第二条弹幕和第一条在同一行</span></span><br><span class="line">                  removeItem = firstItem;</span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;<span class="comment">//mVisibleDanmakus 没有数据，截取弹幕集的第一条弹幕</span></span><br><span class="line">                  topPos = <span class="number">0</span>;<span class="comment">//第一条弹幕当然在最上面</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (checkEdge) &#123;<span class="comment">//如果检查范围</span></span><br><span class="line">               <span class="comment">//检查是否超出布局范围</span></span><br><span class="line">                  isOutOfVertialEdge = isOutVerticalEdge(overwriteInsert, drawItem, disp, topPos, firstItem,</span><br><span class="line">                          lastItem);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (isOutOfVertialEdge) &#123;<span class="comment">//如果超出布局范围，等待河蟹</span></span><br><span class="line">                  topPos = <span class="number">0</span>;</span><br><span class="line">                  willHit = <span class="keyword">true</span>;</span><br><span class="line">                  lines = <span class="number">1</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removeItem != <span class="keyword">null</span>) &#123;<span class="comment">//上面可以插入目标弹幕的逻辑用上了</span></span><br><span class="line">                  lines--;<span class="comment">//因为参考弹幕和目标弹幕在同一行，但是每进入while循环一次就将行号+1，所有要减回去和参考弹幕保持相同行号</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (topPos == <span class="number">0</span>) &#123;<span class="comment">//方便加入容器</span></span><br><span class="line">                  shown = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//这是河蟹规则，都是在设置DanmakuContext时指定的，比如最大行数限制，重复限制等等。</span></span><br><span class="line">	<span class="comment">//这里限于篇幅已经太长了，也实在写不动了，就不再跟下去了。内部逻辑也不难，大家有兴趣可以自己看看。</span></span><br><span class="line">          <span class="keyword">if</span> (verifier != <span class="keyword">null</span> &amp;&amp; verifier.skipLayout(drawItem, topPos, lines, willHit)) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (isOutOfVertialEdge) &#123;<span class="comment">//mVisibleDanmakus中所有弹幕绘制出来都超出范围了</span></span><br><span class="line">              clear();</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//这才是真正确认弹幕位置的地方</span></span><br><span class="line">          drawItem.layout(disp, drawItem.getLeft(), topPos);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!shown) &#123;<span class="comment">//如果还未显示，则加入即将显示的容器中。可以看到，最终会把所有截取的弹幕加入到这个容器里</span></span><br><span class="line">              mVisibleDanmakus.removeItem(removeItem);<span class="comment">//移除同一行之前的参考弹幕，保持保存的一行只有一条弹幕，上面说明过</span></span><br><span class="line">              mVisibleDanmakus.addItem(drawItem);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//清除容器，重新放入新的内容</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          mCancelFixingFlag = <span class="keyword">true</span>;</span><br><span class="line">          mVisibleDanmakus.clear();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这绝对是我写的注释最多的方法了ToT。。。。。。其实思路挺好理解的，通俗地讲就是这样的过程：</p>
<ul>
<li><strong>先添往最第一行添加一条弹幕，把它存到一个容器里（这个容器会把新添加进来的弹幕按照y值从小到大排序，而且容器只保存每一行的最后一条弹幕）</strong>。</li>
<li><strong>然后添加第二条弹幕，从第一行开始添加，先判断和第一条弹幕会不会碰壁，如果不会碰壁则添加到这一行，然后容器内移除之前第一条的弹幕，保存这一条弹幕；如果会碰壁则添加到下一行，然后容器保存这条弹幕</strong>；</li>
<li><strong>然后添加第三条，继续从第一行开始添加，先判断和第一条……(重复第二条的逻辑)……</strong>；<br>。。。。。。</li>
</ul>
<p>&#160; &#160; &#160; &#160;就是这么个思路，但是写起来真心不是随意就能写出来的。即使先不说写，把这个思路想出来，让我去设计一套规则，估计都相当困难啊。唉，人与人之间的差距始终在思维。。。。。。</p>
<p>&#160; &#160; &#160; &#160;扯远了，我们继续回归正题，上面逻辑完成了弹幕定位规则(内部那个layout接下来再讲)，限于篇幅，我只挑一个检查碰撞的代码贴出来分析，其它的请有兴趣者自行跟踪。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">willHitInDuration</span><span class="params">(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2,</span><br><span class="line">          <span class="keyword">long</span> duration, <span class="keyword">long</span> currTime)</span> </span>&#123;<span class="comment">//disp, item, drawItem, drawItem.getDuration(), drawItem.getTimer().currMillisecond</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> type1 = d1.getType();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> type2 = d2.getType();</span><br><span class="line">      <span class="comment">// allow hit if different type 不同类型的弹幕允许碰撞</span></span><br><span class="line">      <span class="keyword">if</span>(type1 != type2)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(d1.isOutside())&#123;<span class="comment">//item已经跑出视图了，不存在碰撞问题</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> dTime = d2.time - d1.time;</span><br><span class="line">      <span class="keyword">if</span> (dTime &lt;= <span class="number">0</span>)<span class="comment">//drawItem在item前面，已经碰撞了</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//两者出现时间已经相差一条弹幕时间了 || item超时跑出去了 || drawItem超时 ，都不会碰撞    </span></span><br><span class="line">      <span class="keyword">if</span> (Math.abs(dTime) &gt;= duration || d1.isTimeOut() || d2.isTimeOut()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//item和drawItem都是顶部或者底部固定弹幕，因为在同一行，必定碰撞</span></span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_FIX_TOP || type1 == BaseDanmaku.TYPE_FIX_BOTTOM) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//调用checkHitAtTime方法</span></span><br><span class="line">      <span class="keyword">return</span> checkHitAtTime(disp, d1, d2, currTime) </span><br><span class="line">              || checkHitAtTime(disp, d1, d2,  d1.time + d1.getDuration());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用checkHitAtTime方法</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkHitAtTime</span><span class="params">(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2, <span class="keyword">long</span> time)</span></span>&#123;<span class="comment">//time = currTime || time = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span>[] rectArr1 = d1.getRectAtTime(disp, time);<span class="comment">//time获得item在视图的（l，t，r，b）</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">float</span>[] rectArr2 = d2.getRectAtTime(disp, time);<span class="comment">//time获得drawItem在视图的（l，t，r，b）</span></span><br><span class="line">      <span class="keyword">if</span> (rectArr1 == <span class="keyword">null</span> || rectArr2 == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> checkHit(d1.getType(), d2.getType(), rectArr1, rectArr2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用checkHit方法    </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkHit</span><span class="params">(<span class="keyword">int</span> type1, <span class="keyword">int</span> type2, <span class="keyword">float</span>[] rectArr1,</span><br><span class="line">          <span class="keyword">float</span>[] rectArr2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(type1 != type2)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_SCROLL_RL) &#123;<span class="comment">//只要drawItem的left小于item的right就碰撞了</span></span><br><span class="line">          <span class="comment">// hit if left2 &lt; right1</span></span><br><span class="line">          <span class="keyword">return</span> rectArr2[<span class="number">0</span>] &lt; rectArr1[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (type1 == BaseDanmaku.TYPE_SCROLL_LR)&#123;</span><br><span class="line">          <span class="comment">// hit if right2 &gt; left1</span></span><br><span class="line">          <span class="keyword">return</span> rectArr2[<span class="number">2</span>] &gt; rectArr1[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//R2LDanmaku的getRectAtTime方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">float</span>[] getRectAtTime(IDisplayer displayer, <span class="keyword">long</span> time) &#123;<span class="comment">//time = currTime || time = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">if</span> (!isMeasured())</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">float</span> left = getAccurateLeft(displayer, time);<span class="comment">//获得此时弹幕在视图的x坐标</span></span><br><span class="line">      <span class="keyword">if</span> (RECT == <span class="keyword">null</span>) &#123;</span><br><span class="line">          RECT = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">4</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      RECT[<span class="number">0</span>] = left;<span class="comment">//left</span></span><br><span class="line">      RECT[<span class="number">1</span>] = y;<span class="comment">//top</span></span><br><span class="line">      RECT[<span class="number">2</span>] = left + paintWidth;<span class="comment">//right</span></span><br><span class="line">      RECT[<span class="number">3</span>] = y + paintHeight;<span class="comment">//bottom</span></span><br><span class="line">      <span class="keyword">return</span> RECT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//R2LDanmaku的getAccurateLeft方法</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getAccurateLeft</span><span class="params">(IDisplayer displayer, <span class="keyword">long</span> currTime)</span> </span>&#123;<span class="comment">//currTime = timer.currTime || currTime = item.time + item.duration</span></span><br><span class="line">      <span class="keyword">long</span> elapsedTime = currTime - time;<span class="comment">//当前时间 - 弹幕出现时间</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">//因此返回弹幕位于视图的x坐标，即视图宽度 - 弹幕已经显示了多少秒 * 每秒移动步长</span></span><br><span class="line"><span class="keyword">return</span> displayer.getWidth() - elapsedTime * mStepX;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;检查碰撞逻辑比较简单，就是先根据当前时间就算出两条弹幕的位置（l1，t1，r1，b1），看看是否前面弹幕的 r1 小于后面弹幕的 l1；再根据前面弹幕的结束时间，计算出两条弹幕的位置（l2，t2，r2，b2）再次看看是否前面弹幕的 r2小于后面弹幕的 l2。只有两条都满足才不会碰撞。</p>
<p>&#160; &#160; &#160; &#160;好了检测碰撞就先到这里，然后继续回到AlignTopRetainer的fix方法，还有一个drawItem.layout(disp, drawItem.getLeft(), topPos);没讲呢，这才是真正确认弹幕位置的地方，继续查看L2RDanmaku的layout方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(IDisplayer displayer, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;<span class="comment">//disp, drawItem.getLeft(), topPos</span></span><br><span class="line">    <span class="keyword">if</span> (mTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> currMS = mTimer.currMillisecond;</span><br><span class="line">        <span class="keyword">long</span> deltaDuration = currMS - time;<span class="comment">//计算出出现时间和当前时间的时间差</span></span><br><span class="line">        <span class="keyword">if</span> (deltaDuration &gt; <span class="number">0</span> &amp;&amp; deltaDuration &lt; duration.value) &#123;<span class="comment">//如果还没有到出现时间或者超出弹幕时间</span></span><br><span class="line">            <span class="keyword">this</span>.x = getAccurateLeft(displayer, currMS);<span class="comment">//计算出当前时间弹幕的x坐标，上面刚讲过</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.isShown()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.y = y;<span class="comment">//把上面计算好的y值赋过来</span></span><br><span class="line">                <span class="keyword">this</span>.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mLastTime = currMS;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastTime = currMS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样弹幕的位置也就确定了，layout步骤就走完了。下一步就是draw步骤了。</p>
<p>&#160; &#160; &#160; &#160;4）绘制弹幕：<br>&#160; &#160; &#160; &#160;赶紧回到DanmakuRenderer的draw方法，这个时候千万不要把自己搞晕了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DanmakuRenderer的draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RenderingState <span class="title">draw</span><span class="params">(IDisplayer disp, IDanmakus danmakus, <span class="keyword">long</span> startRenderTime)</span> </span>&#123;</span><br><span class="line">        ......       </span><br><span class="line">        IDanmakuIterator itr = danmakus.iterator();</span><br><span class="line">        ......      </span><br><span class="line"></span><br><span class="line">        BaseDanmaku drawItem = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            drawItem = itr.next();</span><br><span class="line"></span><br><span class="line">			......</span><br><span class="line">			...检查是否建立缓存...            </span><br><span class="line">			......</span><br><span class="line"></span><br><span class="line">            ...是否测量...</span><br><span class="line"></span><br><span class="line">            ...layout布局...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// draw //绘制弹幕</span></span><br><span class="line">            <span class="keyword">if</span> (!drawItem.isOutside() &amp;&amp; drawItem.isShown()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (drawItem.lines == <span class="keyword">null</span> &amp;&amp; drawItem.getBottom() &gt; disp.getHeight()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;    <span class="comment">// skip bottom outside danmaku ，忽略超过视图底部的弹幕</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始绘制</span></span><br><span class="line">                <span class="keyword">int</span> renderingType = drawItem.draw(disp);</span><br><span class="line">                <span class="keyword">if</span>(renderingType == IRenderer.CACHE_RENDERING) &#123;<span class="comment">//如果是使用缓存bitmap绘制的</span></span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderingType == IRenderer.TEXT_RENDERING) &#123;<span class="comment">//如果使用缓存绘制失败，则会使用原声方法Canvas去draw</span></span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mCacheManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mCacheManager.addDanmaku(drawItem);<span class="comment">//再次为词条弹幕构建缓存，以便下次使用缓存bitmap绘制</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				......    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续跟踪int renderingType = drawItem.draw(disp) 这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseDanmaku的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">draw</span><span class="params">(IDisplayer displayer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> displayer.draw(<span class="keyword">this</span>);<span class="comment">//调用AndroidDisplayer的draw方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用AndroidDisplayer的draw方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">draw</span><span class="params">(BaseDanmaku danmaku)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">float</span> top = danmaku.getTop();<span class="comment">//弹幕在视图的y值</span></span><br><span class="line">       <span class="keyword">float</span> left = danmaku.getLeft();<span class="comment">//弹幕在视图的x值</span></span><br><span class="line">       <span class="keyword">if</span> (canvas != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">			</span><br><span class="line">           <span class="comment">// drawing cache</span></span><br><span class="line">           <span class="keyword">boolean</span> cacheDrawn = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">int</span> result = IRenderer.CACHE_RENDERING;</span><br><span class="line">           IDrawingCache&lt;?&gt; cache = danmaku.getDrawingCache();</span><br><span class="line">           <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果弹幕有缓存</span></span><br><span class="line">            <span class="comment">//取出缓存</span></span><br><span class="line">               DrawingCacheHolder holder = (DrawingCacheHolder) cache.get();</span><br><span class="line">               <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//DrawingCacheHolder的draw方法，我们在上面的buildCache时分析过了，将每一条弹幕的bitmap绘制到视图的canvas上</span></span><br><span class="line">                   cacheDrawn = holder.draw(canvas, left, top, alphaPaint);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!cacheDrawn) &#123;<span class="comment">//如果缓存绘制失败</span></span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//则使用Android原生的canvas.drawText等方法绘制，drawDanmaku方法我们上面buildCache时也分析过</span></span><br><span class="line">               drawDanmaku(danmaku, canvas, left, top, <span class="keyword">false</span>);</span><br><span class="line">               result = IRenderer.TEXT_RENDERING;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> IRenderer.NOTHING_RENDERING;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面逻辑比较简单，先查看弹幕有没有缓存，如果有，就使用缓存绘制。在上面的buildCache时我们知道，缓存绘制的每一条弹幕都是一条bitmap，所以这里用缓存也是将bitmap绘制到视图的Canvas中。如果使用缓存绘制失败，会调用drawDanmaku方法，这个方法我们在上面的buildCache也分析过，则使用Android原生的canvas.drawText等绘制。</p>
<p>&#160; &#160; &#160; &#160;这样弹幕就被绘制到视图界面上了。        </p>
<p>&#160; &#160; &#160; &#160;终于完了，以上就是DanmakuFlameMaster的流程分析过程了，分析的快吐学了ToT。。。。。。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>&#160; &#160; &#160; &#160;上面刚开始奖CacheManagingDrawTask时曾经说过，也可以不用CacheManagingDrawTask，直接使用DrawTask，只要将<strong>DanmakuView</strong>的<strong>mEnableDanmakuDrwaingCache</strong>变量改为false就可以了。这样改动之后就用不上工程里那些so库了，也就不用建立那么复杂的缓存机制。</p>
<p>&#160; &#160; &#160; &#160;还有一点区别就是使用CacheManagingDrawTask画出来的每一条弹幕都是bitmap，而用DrawTask的弹幕都是Canvas.drawText画出来的。</p>
<p>&#160; &#160; &#160; &#160;限于篇幅，DrawTask就不分析了，逻辑比CacheManagingDrawTask简单多了，大家有兴趣的自己看看。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;DanmakuFlameMaster到此就分析完全了，简单总结一下流程就是：</p>
<ul>
<li>加载弹幕资源</li>
<li>开启缓存机制，不断建立缓存和回收</li>
<li>开始绘制任务，根据定时器时间确定弹幕位置，绘制弹幕</li>
</ul>
<p>&#160; &#160; &#160; &#160;这篇文章写的过程中也是十分蛋疼的，写的我差点over了。因为DanmakuFlameMaster源码实在太复杂了，坑非常多，所以很多细节都没有顾及。下次我绝对不会再写这么长的文章了，身体和脑力真心伤不起啊。赶紧休息一下<del>~</del>~~~~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android属性动画流程分析]]></title>
      <url>http://windrunnerlihuan.com/2016/06/24/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<blockquote>
<p>&#160; &#160; &#160; &#160;<strong>摘要</strong>：Google在Android3.0之后给我们带来了属性动画，是真正意义上的改变属性。对比以前的Tween动画，只能作用于View，而且Tween动画改变的只是View的绘制效果，View真正的属性并没有改变。比如，一个按钮做平移的动画，虽然按钮的确做了平移，但按钮可点击的区域并没随着平移而改变，还是在原来的位置。而属性动画则可以改变真正的属性，从而实现按钮平移时点击区域也跟着平移。通俗点说，属性动画其实就是在一定时间内，按照一定规律来改变对象的属性，从而使对象展现出动画效果。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160; Google在Android3.0之后给我们带来了属性动画，是真正意义上的改变属性。对比以前的Tween动画，只能作用于View，而且Tween动画改变的只是View的绘制效果，View真正的属性并没有改变。比如，一个按钮做平移的动画，虽然按钮的确做了平移，但按钮可点击的区域并没随着平移而改变，还是在原来的位置。而属性动画则可以改变真正的属性，从而实现按钮平移时点击区域也跟着平移。通俗点说，属性动画其实就是在一定时间内，按照一定规律来改变对象的属性，从而使对象展现出动画效果。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>&#160; &#160; &#160; &#160;我们要了解属性动画的原理，首先要知道他的用法。先整一个比较大众的吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator  </span><br><span class="line">  .ofInt(target,propName,values[])  </span><br><span class="line">  .setInterpolator(LinearInterpolator)  </span><br><span class="line">  .setEvaluator(IntEvaluator)  </span><br><span class="line">  .setDuration(<span class="number">1000</span>)  </span><br><span class="line">  .start();</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个应该都会吧，设置目标view，作用的属性，动画时长；设置插值器、估值器，这两个玩意设置最多的应该是插值器，估值器设置的应该比较少。这两个东西我们下面会逐一跟踪其踪迹；（当然还有对动画过程的回调监听，比如addListener，然后监听onAnimationStart、onAnimationEnd等等回调。不过我们这里没设，下面篇幅为讲到此处功能）；最后start,动画开始。</p>
<h2 id="猜想与假设"><a href="#猜想与假设" class="headerlink" title="猜想与假设"></a>猜想与假设</h2><p>&#160; &#160; &#160; &#160; 一般的对象中的某个属性，如果要改变其值，要么是这个属性对外<strong>public</strong>，拿到对象后可以直接修改；要么这个对象的类有自己的<strong>get/set</strong>方法。但这都是理想的情况，如果不满足以上条件，如果想改变对象属性的值，就只能通过<strong>反射</strong>了。我们先这样假设，然后往下逐一验证。</p>
<p>&#160; &#160; &#160; &#160; 再者属性动画，我们断章取义一下，既然有动画这个词在内，就会有在规定时间内按固定规则对象属性的改变，就像函数一样，y=f(x)。属性动画也一样，y好比属性值property，x好比时间time，f关系就是插值器/估值器（Interpolator/TypeEvaluator）的作用。（先这么假设吧，是否合理我们往下深挖就知道了）</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160; 我们按着上述猜测，然后进入验证阶段，直接整源码吧。源码文件不难找，并且都在两个固定目录，frameworks\base\core\java\android\animation\ 和 frameworks\base\core\java\android\view\animation\ 下。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160; 阅读源码不一定要把 <a href="http://source.android.com/source/index.html" target="_blank" rel="external">源码</a> 整个下载下来，比如有的在SDK里本来就有的文件，用 AS 或者 Eclipse 都可以直接看。不过我推荐有时间还是把重要的源码都下载下来，用<strong>Source Insight</strong> 或者 <strong>Sublime Text</strong> 来查看。<br>&#160; &#160; &#160; &#160;其次，阅读源码一方面能让我们更清晰的理解Android SDK提供的API的流程原理，有助于开发人员更好的使用这些功能，遇到坑会有更好的解决方案。另一方面，也能够掌握其中的思想，因为一切业务都是思想的实体化，掌握了思想，才能在以后遇到问题或者需求的时候，能很快从脑中勾勒出解决思路，而不至于一脸懵逼无从下手。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; 根据上述例子，一步一步分析。</p>
<h2 id="主流程源码"><a href="#主流程源码" class="headerlink" title="主流程源码"></a>主流程源码</h2><h3 id="ofInt"><a href="#ofInt" class="headerlink" title="ofInt"></a>ofInt</h3><p>&#160; &#160; &#160; &#160;先从ofInt入手，例如这么用：.ofInt(view, “translationX”, 100)。挑一个简单明了的重载方法，其实其他的也是相同的道理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">ofInt</span><span class="params">(Object target, String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    ObjectAnimator anim = <span class="keyword">new</span> ObjectAnimator(target, propertyName);</span><br><span class="line">    anim.setIntValues(values);</span><br><span class="line">    <span class="keyword">return</span> anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;new了一个ObjectAnimator，构造方法传入target和propName，这么不难。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ObjectAnimator</span><span class="params">(Object target, String propertyName)</span> </span>&#123;</span><br><span class="line">       setTarget(target);</span><br><span class="line">       setPropertyName(propertyName);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//有两个方法，以此往下</span></span><br><span class="line"><span class="comment">//设置目标对象target赋给属性动画全局变量mTarget </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(@Nullable Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object oldTarget = getTarget();</span><br><span class="line">       <span class="keyword">if</span> (oldTarget != target) &#123;</span><br><span class="line">           mTarget = target == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> WeakReference&lt;Object&gt;(target);</span><br><span class="line">           <span class="comment">// New target should cause re-initialization prior to starting</span></span><br><span class="line">           mInitialized = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//同上，将propertyName赋给mPropertyName </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyName</span><span class="params">(@NonNull String propertyName)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// mValues could be null if this is being constructed piecemeal. Just record the</span></span><br><span class="line">       <span class="comment">// propertyName to be used later when setValues() is called if so.</span></span><br><span class="line">       <span class="comment">// 此时mValues为空，可以忽略判断逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (mValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">           PropertyValuesHolder valuesHolder = mValues[<span class="number">0</span>];</span><br><span class="line">           String oldName = valuesHolder.getPropertyName();</span><br><span class="line">           valuesHolder.setPropertyName(propertyName);</span><br><span class="line">           mValuesMap.remove(oldName);</span><br><span class="line">           mValuesMap.put(propertyName, valuesHolder);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//赋值给全局变量</span></span><br><span class="line">       mPropertyName = propertyName;</span><br><span class="line">       <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">       mInitialized = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;记录完target和propName，调用setIntValues。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 此时mValues为空</span></span><br><span class="line">    <span class="keyword">if</span> (mValues == <span class="keyword">null</span> || mValues.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No values yet - this animator is being constructed piecemeal. Init the values with</span></span><br><span class="line">        <span class="comment">// whatever the current propertyName is</span></span><br><span class="line">        <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123; <span class="comment">// mProperty 也为空</span></span><br><span class="line">            setValues(PropertyValuesHolder.ofInt(mProperty, values));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//因此会走到这里</span></span><br><span class="line">            setValues(PropertyValuesHolder.ofInt(mPropertyName, values));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setIntValues(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后会走到setValues(PropertyValuesHolder.ofInt(mPropertyName, values)); 这里把我们传入的propName和values作为参数，又调用了PropertyValuesHolder的ofInt方法，我们先看里面这个，外面的那个setValues待会儿再看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofInt</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntPropertyValuesHolder(propertyName, values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IntPropertyValuesHolder是PropertyValuesHolder的子类，也是个内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntPropertyValuesHolder</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(propertyName);<span class="comment">//这里会调用父类的构造</span></span><br><span class="line"> setIntValues(values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类一个参数构造方法如下，将propertyName赋给全局变量mPropertyName </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PropertyValuesHolder</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">    mPropertyName = propertyName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setIntValues(values);<span class="comment">//同样会调用父类的setIntValues方法</span></span><br><span class="line">    mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;<span class="comment">// 将父类方法得到的mKeyframes 再付给mIntKeyframes </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类setIntValues方法，为mValueType 赋值，同时为利用参数values调用KeyframeSet.ofInt(values)为mKeyframes赋值 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">    mKeyframes = KeyframeSet.ofInt(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我们可以看到，PropertyValuesHolder的ofInt方法让器内部存储了我们的propName，然后存储了我们的mValueType，即 int.class ，并且保存了一个新的变量 <strong>mIntKeyframes</strong>。<br> &#160; &#160; &#160; &#160; 这个<strong>mIntKeyframes</strong>由 KeyframeSet.ofInt(values) 得到，顾名思义，这玩意儿应该是关键帧之类的意思吧。我们联想一下关键帧，视频不就是一帧一帧的画面组成么，其中有参考帧和关键帧，且参考帧解码也依赖于关键帧，因此关键帧是视频图像流畅完整的保证（扯远了，我们先这么理解吧，然后再验证我们的猜测）。<br>  &#160; &#160; &#160; &#160; <strong>mIntKeyframes</strong>类型为Keyframes，是个接口，实现类型为KeyframeSet。看着名字应该是关键帧集合吧，每个关键帧应该保存动画time/value(时间/值)对。那么继续验证，找到KeyframeSet.ofInt(values)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyframeSet <span class="title">ofInt</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeyframes = values.length;</span><br><span class="line">    IntKeyframe keyframes[] = <span class="keyword">new</span> IntKeyframe[Math.max(numKeyframes,<span class="number">2</span>)];<span class="comment">//最少应该有2帧</span></span><br><span class="line">    <span class="keyword">if</span> (numKeyframes == <span class="number">1</span>) &#123;<span class="comment">//如果只传了一个参数，比如我们前面给"translationX"属性的values传入移动300            </span></span><br><span class="line">     keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>);<span class="comment">// 起始帧，属性保持原样</span></span><br><span class="line">        keyframes[<span class="number">1</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">1f</span>, values[<span class="number">0</span>]);<span class="comment">//结束帧，直接到达结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//可以设置某个属性的多个值，比如动态改变view的alpha值，例如1.0，0.8，0.4......</span></span><br><span class="line">        keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>, values[<span class="number">0</span>]);<span class="comment">//起始帧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numKeyframes; ++i) &#123;<span class="comment">//后续n帧</span></span><br><span class="line">         <span class="comment">//注意里面有个么一个片段:(float) i / (numKeyframes - 1)，这是按values个数等比例划分的</span></span><br><span class="line">            keyframes[i] =</span><br><span class="line">                    (IntKeyframe) Keyframe.ofInt((<span class="keyword">float</span>) i / (numKeyframes - <span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframeSet(keyframes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 这里应该看到KeyframeSet.ofInt(values)方法，根据values的长度构造keyframes数组，然后分别通过Keyframe的ofInt方法，去构造keyframe对象。老规矩，继续看Keyframe.ofInt如何构造Keyframe：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> mValue;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Keyframe <span class="title">ofInt</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframe(fraction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也就简单存了一下fraction，此时value默认值为0</span></span><br><span class="line">   IntKeyframe(<span class="keyword">float</span> fraction) &#123;</span><br><span class="line">       mFraction = fraction;</span><br><span class="line">       mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Keyframe <span class="title">ofInt</span><span class="params">(<span class="keyword">float</span> fraction, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframe(fraction, value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也就简单存了一下fraction，value等</span></span><br><span class="line">   IntKeyframe(<span class="keyword">float</span> fraction, <span class="keyword">int</span> value) &#123;</span><br><span class="line">       mFraction = fraction;</span><br><span class="line">       mValue = value;</span><br><span class="line">       mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">       mHasValue = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也就简单存了一下fraction和value，每个fraction对应相应的value。前面注释我特意写了个注意，这个fraction是按照帧的个数n存的，起始为0，结束为1，也就是个个数为n的等差数列an={0，1/(n-1), 2/(n-1), 3/(n-1)，……, (n-2)/(n-1), 1}。<br>&#160; &#160; &#160; &#160;然后我们看它的 return new IntKeyframeSet(keyframes);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IntKeyframeSet构造方法，调其父类KeyframeSet构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntKeyframeSet</span><span class="params">(IntKeyframe... keyframes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(keyframes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//KeyframeSet构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KeyframeSet</span><span class="params">(Keyframe... keyframes)</span> </span>&#123;</span><br><span class="line">    mNumKeyframes = keyframes.length;</span><br><span class="line">    mKeyframes = <span class="keyword">new</span> ArrayList&lt;Keyframe&gt;();</span><br><span class="line">    mKeyframes.addAll(Arrays.asList(keyframes));</span><br><span class="line">    mFirstKeyframe = mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    mLastKeyframe = mKeyframes.get(mNumKeyframes - <span class="number">1</span>);</span><br><span class="line">    mInterpolator = mLastKeyframe.getInterpolator();<span class="comment">//这个插值器是null，感觉没什么卵用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;存了有多少关键帧，开始帧，结束帧，以及插值器。</p>
<p>&#160; &#160; &#160; &#160;到这里PropertyValuesHolder.ofInt(mPropertyName, values)走完了，这个过程我们为PropertyValuesHolder对象赋了propName，valueType，keyframeSet，而keyframeSet中又存了Keyframe集合，keyframe中存储了（fraction , valuetype , value , hasValue）。</p>
<p>&#160; &#160; &#160; &#160;上面说过setValues(int… values) 会走setValues(PropertyValuesHolder.ofInt(mPropertyName, values));这一步，这是其父类ValueAnimator的方法，我们进入其父类看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PropertyValuesHolder... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numValues = values.length;</span><br><span class="line">    mValues = values;<span class="comment">//将刚才得到的PropertyValuesHolder存入</span></span><br><span class="line">    mValuesMap = <span class="keyword">new</span> HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">    <span class="comment">//再包装一层map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        PropertyValuesHolder valuesHolder = values[i];</span><br><span class="line">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">    mInitialized = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;首先记录了mValues，注意这里的values是PropertyValuesHolder类型的，然后通过一个mValueMap记录：key为属性的名称，值为PropertyValuesHolder 。</p>
<p>&#160; &#160; &#160; &#160;到此ofInt流程算是走完了，小结一下：<strong>ofInt记录了target,propName,values（是将我们传入的int型values，辗转转化成了PropertyValuesHolder）,以及一个mValueMap，这个map的key是propName，value是PropertyValuesHolder，在PropertyValuesHolder内部又存储了proprName, valueType , keyframeSet等等</strong>。</p>
<h3 id="setInterpolator"><a href="#setInterpolator" class="headerlink" title="setInterpolator"></a>setInterpolator</h3><p>&#160; &#160; &#160; &#160;设置插值器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterpolator</span><span class="params">(TimeInterpolator value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInterpolator = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = <span class="keyword">new</span> LinearInterpolator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也是父类ValueAnimator的方法，可以看到如果没有设置插值器，默认就是线性插值器LinearInterpolator。</p>
<h3 id="setEvaluator"><a href="#setEvaluator" class="headerlink" title="setEvaluator"></a>setEvaluator</h3><p>&#160; &#160; &#160; &#160;设置估值器，这东西用的不多。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; mValues != <span class="keyword">null</span> &amp;&amp; mValues.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          mValues[<span class="number">0</span>].setEvaluator(value);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mValues就是我们刚才ofInt里得到的PropertyValuesHolder对象，然后调用PropertyValuesHolder.setEvalutor：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">    mEvaluator = evaluator;<span class="comment">// 记录evaluator</span></span><br><span class="line">    mKeyframes.setEvaluator(evaluator);<span class="comment">// KeyframeSet再次记录evaluator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;KeyframeSet再次记录evaluator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">     mEvaluator = evaluator;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;setEvaluator这一步就完了，也就是把估值器evaluator分别交给PropertyValuesHolder和KeyframeSet。</p>
<h3 id="setDuration"><a href="#setDuration" class="headerlink" title="setDuration"></a>setDuration</h3><p>&#160; &#160; &#160; &#160; 设置动画时长。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ObjectAnimator 的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectAnimator <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setDuration(duration); <span class="comment">//父类实现</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//VauleAnimator的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ValueAnimator <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Animators cannot have negative duration: "</span> +</span><br><span class="line">                   duration);</span><br><span class="line">       &#125;</span><br><span class="line">       mUnscaledDuration = duration;</span><br><span class="line">       updateScaledDuration();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sDurationScale = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mDuration = (<span class="keyword">long</span>)(<span class="number">300</span> * sDurationScale);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> mUnscaledDuration = <span class="number">300</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateScaledDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mDuration = (<span class="keyword">long</span>)(mUnscaledDuration * sDurationScale);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 就是简单在mDuration中记录了一下动画的持续时间，这个sDurationScale默认为1，貌似是用于调整，观察动画的，比如你可以调整为10，动画就会慢10倍的播放。</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>&#160; &#160; &#160; &#160; 以上的都比较简单，那么我们猜测start方法一定是巨复杂的。休息一下~<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子图"><br>&#160; &#160; &#160; &#160;OK，我们继续，走start()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//省略干扰代码</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">super</span>.start(); <span class="comment">//最终会调用父类的方法</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//ValueAnimator的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       start(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mPlayingBackwards = playBackwards; <span class="comment">//动画是否reverse</span></span><br><span class="line">       mCurrentIteration = <span class="number">0</span>;<span class="comment">//记录当前的动画的执行次数（与setRepeatCount有关）</span></span><br><span class="line">       mPlayingState = STOPPED;<span class="comment">//动画的状态为STOPPED</span></span><br><span class="line">       mStarted = <span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">       mStartedDelay = <span class="keyword">false</span>;</span><br><span class="line">       mPaused = <span class="keyword">false</span>;<span class="comment">//标志位</span></span><br><span class="line">       updateScaledDuration(); <span class="comment">// in case the scale factor has changed since creation time</span></span><br><span class="line">       AnimationHandler animationHandler = getOrCreateAnimationHandler();<span class="comment">//生成一个AnimationHandler对象，getOrCreateAnimationHandler就是在当前线程变量ThreadLocal中取出来，没有的话，则创建一个，然后set进去。</span></span><br><span class="line">       animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);<span class="comment">//AnimationHandler中包含一些List集合用于存储各种状态的ValueAnimator，将当前ValueAnimator对象，加入  animationHandler.mPendingAnimations 集合</span></span><br><span class="line">       <span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) &#123; <span class="comment">//mStartDelay 默认为0，进入</span></span><br><span class="line">           <span class="comment">// This sets the initial value of the animation, prior to actually starting it running</span></span><br><span class="line">           setCurrentPlayTime(<span class="number">0</span>); <span class="comment">//这个接下来会说明</span></span><br><span class="line">           mPlayingState = STOPPED;<span class="comment">//动画的状态为STOPPED</span></span><br><span class="line">           mRunning = <span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">           notifyStartListeners();<span class="comment">//回调监听动画的接口AnimatorListener的onAnimationStart方法，如果你设置了回调监听，此时就会进行回调。</span></span><br><span class="line">       &#125;</span><br><span class="line">       animationHandler.start();<span class="comment">//最后调用，这个会细说</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> ThreadLocal&lt;AnimationHandler&gt; sAnimationHandler =</span><br><span class="line">           <span class="keyword">new</span> ThreadLocal&lt;AnimationHandler&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AnimationHandler <span class="title">getOrCreateAnimationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       AnimationHandler handler = sAnimationHandler.get();</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           handler = <span class="keyword">new</span> AnimationHandler();</span><br><span class="line">           sAnimationHandler.set(handler);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handler;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyStartListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mListeners != <span class="keyword">null</span> &amp;&amp; !mStartListenersCalled) &#123;</span><br><span class="line">           ArrayList&lt;AnimatorListener&gt; tmpListeners =</span><br><span class="line">                   (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();</span><br><span class="line">           <span class="keyword">int</span> numListeners = tmpListeners.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">               tmpListeners.get(i).onAnimationStart(<span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       mStartListenersCalled = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;start方法做了一些状态和变量初始化，其他的都很好理解，有两处方法要细说：setCurrentPlayTime(0)和animationHandler.start()，我们先看setCurrentPlayTime(0)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentPlayTime</span><span class="params">(<span class="keyword">long</span> playTime)</span> </span>&#123;</span><br><span class="line">    initAnimation();<span class="comment">//初始化动画，接下来看</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = AnimationUtils.currentAnimationTimeMillis();<span class="comment">//得到当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (mPlayingState != RUNNING) &#123; <span class="comment">//之前将mPlayingState设为了STOPPED</span></span><br><span class="line">        mSeekTime = playTime;<span class="comment">//为0</span></span><br><span class="line">        mPlayingState = SEEKED; <span class="comment">//将mPlayingState 改为SEEKED</span></span><br><span class="line">    &#125;</span><br><span class="line">    mStartTime = currentTime - playTime;<span class="comment">//起始时间为当前时间</span></span><br><span class="line">    doAnimationFrame(currentTime);<span class="comment">//接下来也会看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 先看initAnimation()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mInitialized) &#123;</span><br><span class="line">        <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].init(); <span class="comment">//mValues也就是之前ofInt方法得到的IntPropertyValueHolder对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        mInitialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 接着找IntPropertyValueHolder的init方法，在其父类发现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We already handle int and float automatically, but not their Object</span></span><br><span class="line">        <span class="comment">// equivalents</span></span><br><span class="line">        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator :</span><br><span class="line">                (mValueType == Float.class) ? sFloatEvaluator :</span><br><span class="line">                <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// KeyframeSet knows how to evaluate the common types - only give it a custom</span></span><br><span class="line">        <span class="comment">// evaluator if one has been set on this class</span></span><br><span class="line">        mKeyframes.setEvaluator(mEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 其实就是遍历设置PropertyValuesHolder中的mEvaluator属性，默认根据valueType进行判断，IntEvaluator或者FloatEvaluator。</p>
<p>&#160; &#160; &#160; &#160;initAnimation()完了，然后看doAnimationFrame(currentTime)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPlayingState == STOPPED) &#123; <span class="comment">//上面已赋为SEEKED，所以不进入下面逻辑</span></span><br><span class="line">        mPlayingState = RUNNING;</span><br><span class="line">        <span class="keyword">if</span> (mSeekTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mStartTime = frameTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStartTime = frameTime - mSeekTime;</span><br><span class="line">            <span class="comment">// Now that we're playing, reset the seek time</span></span><br><span class="line">            mSeekTime = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;<span class="comment">//mPaused上面已赋为false</span></span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = frameTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;<span class="comment">//默认是false</span></span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mStartTime += (frameTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The frame time might be before the start time during the first frame of</span></span><br><span class="line">    <span class="comment">// an animation.  The "current time" must always be on or after the start</span></span><br><span class="line">    <span class="comment">// time to avoid animating frames at negative time intervals.  In practice, this</span></span><br><span class="line">    <span class="comment">// is very rare and only happens when seeking backwards.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</span><br><span class="line">    <span class="keyword">return</span> animationFrame(currentTime);<span class="comment">//最后只走了这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 继续跟animationFrame(currentTime)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">switch</span> (mPlayingState) &#123;<span class="comment">//上面已赋为SEEKED</span></span><br><span class="line">     <span class="keyword">case</span> RUNNING:</span><br><span class="line">     <span class="keyword">case</span> SEEKED:</span><br><span class="line">         <span class="keyword">float</span> fraction = mDuration &gt; <span class="number">0</span> ? (<span class="keyword">float</span>)(currentTime - mStartTime) / mDuration : <span class="number">1f</span>;<span class="comment">//此时currentTime和mStartTime相等，fraction为0，刚开始嘛</span></span><br><span class="line">         <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//刚开始不会走这段逻辑</span></span><br><span class="line">             <span class="keyword">if</span> (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</span><br><span class="line">                 <span class="comment">// Time to repeat</span></span><br><span class="line">                 <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">int</span> numListeners = mListeners.size();</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                         mListeners.get(i).onAnimationRepeat(<span class="keyword">this</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (mRepeatMode == REVERSE) &#123;</span><br><span class="line">                     mPlayingBackwards = !mPlayingBackwards;</span><br><span class="line">                 &#125;</span><br><span class="line">                 mCurrentIteration += (<span class="keyword">int</span>)fraction;</span><br><span class="line">                 fraction = fraction % <span class="number">1f</span>;</span><br><span class="line">                 mStartTime += mDuration;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 done = <span class="keyword">true</span>;</span><br><span class="line">                 fraction = Math.min(fraction, <span class="number">1.0f</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (mPlayingBackwards) &#123;<span class="comment">//这个是false，因为没有设置reverse</span></span><br><span class="line">             fraction = <span class="number">1f</span> - fraction;</span><br><span class="line">         &#125;</span><br><span class="line">         animateValue(fraction);<span class="comment">//最后只会走这个，继续往下看</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> done;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 然后又到了这一步animateValue(fraction)，此时fraction是0，刚开始嘛。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里会调用子类ObjectAnimator的animateValue方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object target = getTarget();</span><br><span class="line">       <span class="keyword">if</span> (mTarget != <span class="keyword">null</span> &amp;&amp; target == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// We lost the target reference, cancel and clean up.</span></span><br><span class="line">           cancel();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">super</span>.animateValue(fraction);<span class="comment">//这里调用父类的方法</span></span><br><span class="line">       <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">           mValues[i].setAnimatedValue(target);<span class="comment">//设置属性，下面会分析</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//ValueAnimator的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       fraction = mInterpolator.getInterpolation(fraction);<span class="comment">//插值器处理一下fraction</span></span><br><span class="line">       mCurrentFraction = fraction;</span><br><span class="line">       <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">           mValues[i].calculateValue(fraction);<span class="comment">//之前ofInt得到的IntPropertyValueHolder对象的calculateValue方法</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//UpdateListener监听接口开始回调，比较简单</span></span><br><span class="line">       <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> numListeners = mUpdateListeners.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">               mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我们跟一下IntPropertyValueHolder的calculateValue方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;<span class="comment">//这个fraction是经过插值器处理过的fraction</span></span><br><span class="line">    mIntAnimatedValue = mIntKeyframes.getIntValue(fraction);<span class="comment">//这里注意是IntKeyFrameSet，千万不要看错方法了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;go on，IntKeyFrameSet的getIntValue方法，fraction是经过插值器处理过的fraction ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;<span class="comment">//raction是经过插值器处理过的fraction</span></span><br><span class="line">    <span class="keyword">if</span> (mNumKeyframes == <span class="number">2</span>) &#123;<span class="comment">//在ofInt里只设置了一个value，则只有两个关键帧，上面分析过</span></span><br><span class="line">        <span class="keyword">if</span> (firstTime) &#123;<span class="comment">//默认是true</span></span><br><span class="line">            firstTime = <span class="keyword">false</span>;</span><br><span class="line">            firstValue = ((IntKeyframe) mKeyframes.get(<span class="number">0</span>)).getIntValue();<span class="comment">//取起始帧的value，为0</span></span><br><span class="line">            lastValue = ((IntKeyframe) mKeyframes.get(<span class="number">1</span>)).getIntValue();<span class="comment">//结束帧的value，即我们设进去的值</span></span><br><span class="line">            deltaValue = lastValue - firstValue;<span class="comment">//计算delta值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInterpolator != <span class="keyword">null</span>) &#123;<span class="comment">//这玩意儿是null，他是IntKeyFrameSet的，不是ObjectAnimator的</span></span><br><span class="line">            fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;<span class="comment">//估值器，其实此处设与不设一样，实现都是firstValue + (int)(fraction * deltaValue)；这个很好看懂，想想函数y=f(X)之类，return的就是y</span></span><br><span class="line">            <span class="keyword">return</span> firstValue + (<span class="keyword">int</span>)(fraction * deltaValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//扒一下IntEvaluator和上面那个一样</span></span><br><span class="line">            <span class="keyword">return</span> ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面逻辑是ofInt设置了多个value的</span></span><br><span class="line">    <span class="keyword">if</span> (fraction &lt;= <span class="number">0f</span>) &#123;<span class="comment">//小于区间范围，将第0和第1帧作为参考</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);<span class="comment">//第1帧</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">1</span>);<span class="comment">//第2帧</span></span><br><span class="line">        <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();<span class="comment">//第1帧的属性值y1</span></span><br><span class="line">        <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();<span class="comment">//第2帧属性值y2</span></span><br><span class="line">        <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();<span class="comment">//第1帧的关系因子，x1</span></span><br><span class="line">        <span class="keyword">float</span> nextFraction = nextKeyframe.getFraction();<span class="comment">//第2帧的关系因子，x2</span></span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;<span class="comment">//null</span></span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(x-x1)/(x2-x1)</span></span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);</span><br><span class="line">        <span class="comment">//y=y1 + (x-x1)/(x2-x1)*(y2-y1),怎么样，直线方程既视感</span></span><br><span class="line">        <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                        intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//大于区间范围，将倒1和倒2帧作为参考，一下逻辑同上</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">        <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">        <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">float</span> nextFraction = nextKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);</span><br><span class="line">        <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常范围</span></span><br><span class="line">    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mNumKeyframes; ++i) &#123;<span class="comment">//循环遍历</span></span><br><span class="line">        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);</span><br><span class="line">        <span class="keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;<span class="comment">//这就比较好理解了，就进参考，往下逻辑同上</span></span><br><span class="line">            <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">            <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> intervalFraction = (fraction - prevKeyframe.getFraction()) /</span><br><span class="line">                (nextKeyframe.getFraction() - prevKeyframe.getFraction());</span><br><span class="line">            <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                    prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                            intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        prevKeyframe = nextKeyframe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// shouldn't get here</span></span><br><span class="line">    <span class="comment">//确实不该到这儿，google注释都这么说了</span></span><br><span class="line">    <span class="keyword">return</span> ((Number)mKeyframes.get(mNumKeyframes - <span class="number">1</span>).getValue()).intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;看注释是不是有种学霸附体的感觉^  。^至于第一种在ofInt里只设置了一个value，则只有两个关键帧，这个很好理解。可以比喻为：已知x和y成线性关系，公式为y=kx+b，告知其中一点x值为x1，求y1。一次函数的直视感。</p>
<p>&#160; &#160; &#160; &#160;第二种设置多个value也很好理解，因为动画是连续的，这是个连续函数，所以函数曲线是一条连续的线。每个关键帧都是连续函数上的固定点。虽然函数图像是连续的，但是他确是个分段函数，这些关键帧就是分段函数的拐点，而两个拐点之间的规则是一样的，就是我们定义的插值器interpolator 。<br>&#160; &#160; &#160; &#160;动画之间都是连续的，如果要求出某个时间段对象的属性值，一定要参考距离它最近两帧。所以问题就转为已知两点坐标（x1，y1），（x2，y2），和另一点的x值，求其y值。果断高一数学的直线方程整起：<br>$$    \dfrac{x-x1 }{x2-x1} = \dfrac{y-y1}{y2-y1} $$</p>
<p>$$    y=\dfrac{(x-x1) * (y2-y1) }{x2-x1} +y1 $$</p>
<p>&#160; &#160; &#160; &#160;IntKeyFrameSet的getIntValue方法就分析玩了，然后找到之前的逻辑。这样就求出属性值了，并把它赋给了ObjectAnimator的IntPropertyValueHolder类对象mValues的mIntAnimatedValue中。回到上面的子类animateValue(fraction)方法，还有一步mValues[i].setAnimatedValue(target)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIntProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mIntProperty.setValue(target, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProperty.set(target, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mJniSetter != <span class="number">0</span>) &#123;</span><br><span class="line">        nCallIntMethod(target, mJniSetter, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTmpValueArray[<span class="number">0</span>] = mIntAnimatedValue;</span><br><span class="line">            mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;果然有反射，看来我们的猜测八九不离十。这样就把刚才计算的属性值设置给目标对象了。</p>
<p>&#160; &#160; &#160; &#160;确实有点晕了。。。。。回一下神，赶紧回到ObjectAnimator父类ValueAnimator的start方法里，还要继续分析第二个重要地方animationHandler.start()。animationHandler我们上面已经介绍了，存储在当前线程的ThreadLocal里面，里面放了一些集合用于存储各种状态的ObjectAnimator，我们当前的ObjectAnimator对象也存储在其mPendingAnimations的集合中（上面提到过~~）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    scheduleAnimation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAnimationScheduled) &#123;<span class="comment">//mAnimationScheduled默认false</span></span><br><span class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, <span class="keyword">this</span>, <span class="keyword">null</span>);<span class="comment">//Choreographer.CALLBACK_ANIMATION为1</span></span><br><span class="line">        mAnimationScheduled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;要用到mChoreographer这个对象的postCallback方法，其中有一个参数是this；至于什么是Choreographer，暂时不用管；但是你需要知道一件事，其实我们的animationHandler是Runnable的子类，而 mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null);类似与handler发送消息，最终执行这个Runnable的run方法。<br>&#160; &#160; &#160; &#160;Choreographer这个类里面障眼法太多了，就不贴了。绕来绕去，其实就是一句话，这里调用了animationHandler的 run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">        doAnimationFrame(mChoreographer.getFrameTime());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mPendingAnimations holds any animations that have requested to be started</span></span><br><span class="line">        <span class="comment">// We're going to clear mPendingAnimations, but starting animation may</span></span><br><span class="line">        <span class="comment">// cause more to be added to the pending list (for example, if one animation</span></span><br><span class="line">        <span class="comment">// starting triggers another starting). So we loop until mPendingAnimations</span></span><br><span class="line">        <span class="comment">// is empty.</span></span><br><span class="line">        <span class="keyword">while</span> (mPendingAnimations.size() &gt; <span class="number">0</span>) &#123;<span class="comment">//while循环，遍历所有在mPendingAnimations中的ObjectAnimator，依次调用anim.startAnimation(this);</span></span><br><span class="line">            ArrayList&lt;ValueAnimator&gt; pendingCopy =</span><br><span class="line">                    (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone();</span><br><span class="line">            mPendingAnimations.clear();</span><br><span class="line">            <span class="keyword">int</span> count = pendingCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = pendingCopy.get(i);</span><br><span class="line">                <span class="comment">// If the animation has a startDelay, place it on the delayed list</span></span><br><span class="line">                <span class="keyword">if</span> (anim.mStartDelay == <span class="number">0</span>) &#123;<span class="comment">//不延时的直接start</span></span><br><span class="line">                    anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//延时的先加入mDelayedAnims队列</span></span><br><span class="line">                    mDelayedAnims.add(anim);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, process animations currently sitting on the delayed queue, adding</span></span><br><span class="line">        <span class="comment">// them to the active animations if they are ready</span></span><br><span class="line">        <span class="comment">//看有多少延时的，如果延时的时间到了就加入到准备队列mReadyAnims</span></span><br><span class="line">        <span class="keyword">int</span> numDelayedAnims = mDelayedAnims.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDelayedAnims; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = mDelayedAnims.get(i);</span><br><span class="line">            <span class="keyword">if</span> (anim.delayedAnimationFrame(frameTime)) &#123;<span class="comment">//看方法注释就是说如果延时到了就该加入动画准备集合</span></span><br><span class="line">                mReadyAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备队列的开始start</span></span><br><span class="line">        <span class="keyword">int</span> numReadyAnims = mReadyAnims.size();</span><br><span class="line">        <span class="keyword">if</span> (numReadyAnims &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numReadyAnims; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = mReadyAnims.get(i);</span><br><span class="line">                anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">                anim.mRunning = <span class="keyword">true</span>;</span><br><span class="line">                mDelayedAnims.remove(anim);</span><br><span class="line">            &#125;</span><br><span class="line">            mReadyAnims.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now process all active animations. The return value from animationFrame()</span></span><br><span class="line">        <span class="comment">// tells the handler whether it should now be ended</span></span><br><span class="line">        <span class="comment">//将animationHandler的mAnimations集合中的每个anim，加入到mTmpAnimations中；</span></span><br><span class="line">        <span class="keyword">int</span> numAnims = mAnimations.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">            mTmpAnimations.add(mAnimations.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次调用mTmpAnimations中的anim，anim.doAnimationFrame(frameTime)。doAnimationFrame（frameTime）上面已经分析过了，如果返回true，即doAnimationFrame的done为true，则将该动画加入到结束动画集合。 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = mTmpAnimations.get(i);</span><br><span class="line">            <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</span><br><span class="line">                mEndingAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mTmpAnimations.clear();</span><br><span class="line">        <span class="comment">//循环调用mEndingAnims， mEndingAnims.get(i).endAnimation(this);内部，会将动画移除mAnimations，回调动画监听接口onAnimationEnd；以及重置各种标志变量。</span></span><br><span class="line">        <span class="keyword">if</span> (mEndingAnims.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mEndingAnims.size(); ++i) &#123;</span><br><span class="line">                mEndingAnims.get(i).endAnimation(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mEndingAnims.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are still active or delayed animations, schedule a future call to</span></span><br><span class="line">        <span class="comment">// onAnimate to process the next frame of the animations.</span></span><br><span class="line">        <span class="comment">//如果mAnimations不为null，则再次调用scheduleAnimation();</span></span><br><span class="line">        <span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</span><br><span class="line">            scheduleAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * Internal function called to process an animation frame on an animation that is currently</span><br><span class="line"> * sleeping through its &lt;code&gt;startDelay&lt;/code&gt; phase. The return value indicates whether it</span><br><span class="line"> * should be woken up and put on the active animations queue.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> currentTime The current animation time, used to calculate whether the animation</span><br><span class="line"> * has exceeded its &lt;code&gt;startDelay&lt;/code&gt; and should be started.</span><br><span class="line"> * <span class="doctag">@return</span> True if the animation's &lt;code&gt;startDelay&lt;/code&gt; has been exceeded and the animation</span><br><span class="line"> * should be added to the set of active animations.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">delayedAnimationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStartedDelay) &#123;<span class="comment">//默认false</span></span><br><span class="line">        mStartedDelay = <span class="keyword">true</span>;</span><br><span class="line">        mDelayStartTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;<span class="comment">//默认false</span></span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;<span class="comment">//默认false</span></span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mDelayStartTime += (currentTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> deltaTime = currentTime - mDelayStartTime;<span class="comment">//延时间隔</span></span><br><span class="line">    <span class="keyword">if</span> (deltaTime &gt; mStartDelay) &#123;<span class="comment">//延时超了规定延时时间，应该执行了</span></span><br><span class="line">        <span class="comment">// startDelay ended - start the anim and record the</span></span><br><span class="line">        <span class="comment">// mStartTime appropriately</span></span><br><span class="line">        mStartTime = currentTime - (deltaTime - mStartDelay);</span><br><span class="line">        mPlayingState = RUNNING;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(AnimationHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</span><br><span class="line">        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, getNameForTrace(),</span><br><span class="line">                System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    initAnimation();</span><br><span class="line">    handler.mAnimations.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span> &amp;&amp; mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Listeners were already notified in start() if startDelay is 0; this is</span></span><br><span class="line">        <span class="comment">// just for delayed animations</span></span><br><span class="line">        notifyStartListeners();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;scheduleAnimation()一旦调用，就像Handler不停发消息一样，AnimationHandler的run方法就会一直调用，mChoreographer.getFrameTime()控制动画时间段，然后一直调用AnimationHandler的doAnimationFrame方法，这个方法里面又调用了ValueAnimator的doAnimationFrame方法，这个方法上面分析过了，就是计算属性应该的值，然后反射设置；再startAnimation通知回调。这样动画就一帧一帧的执行了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#160; &#160; &#160; &#160;ofInt中实例化了一个ObjectAnimator对象，然后设置了target，propName，values(PropertyValuesHolder) ；然后分别在setInterpolator，setDuration设置了Interpolator和duration。其中setEvaluator是给PropertyValuesHolder，以及keyframeSet设置估值算法。</p>
<p>&#160; &#160; &#160; &#160;PropertyValueHolder实际上是IntPropertyValueHolder类型对象，包含propName,valueType,keyframeSet .</p>
<p>&#160; &#160; &#160; &#160;keyframeset中存了Keyframe集合，keyframe中存储了（fraction , valuetype , value , hasValue）。</p>
<p>&#160; &#160; &#160; &#160;start()中：<br>&#160; &#160; &#160; &#160;首先更新动画各种状态，然后初步计算fraction为(currentTime - mStartTime) / mDuration；然后将这个fraction交给我们的插值器计算后得到新的fraction，再将新的fraction交给我们的估值算法，估值算法根据开始、结束、fraction得到当前属性（动画作用的属性）应该的值，最大调用反射进行设置；<br>&#160; &#160; &#160; &#160;start中还会根据动画的状态，如果没有结束，不断的调用AnimationHanlder的run方法;该方法内部利用mChoreographer不断的去重复第一步。</p>
<p>&#160; &#160; &#160; &#160;至此属性动画流程分析完了，也算马马虎虎，至少和我们的猜想八九不离十。看源码看的也快吐血了，这么长代码也只能了解个大概，以后有时间再好好整理一下思路。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android跨进程通信机制Binder简要分析]]></title>
      <url>http://windrunnerlihuan.com/2016/06/12/Binder%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160; 在Android系统中，每个应用都是由四大组件中之几组成，我们经常要去写一些Activity或者Service，这些Activity或者Service有时候会运行在不同的进程中，如果我们要让这些不同的Activity或者Service之间通信，就要用到Android提供的Binder机制了。</p>
<blockquote>
<p>&#160;&#160;&#160;&#160;Binder其实也不是Android提出来的一套新的进程间通信机制，它是基于<a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">OpenBinder</a>来实现的。OpenBinder最先是由<a href="https://en.wikipedia.org/wiki/Be_Inc." target="_blank" rel="external">Be Inc.</a>开发的，接着<a href="https://en.wikipedia.org/wiki/Palm,_Inc." target="_blank" rel="external">Palm Inc.</a>也着使用。现在OpenBinder的作者<a href="http://www.angryredplanet.com/~hackbod/" target="_blank" rel="external">Dianne Hackborn</a>就是在Google工作，负责Android平台的开发工作。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; Android系统是基于Linux内核的，Linux已经拥有管道，system V IPC，socket等IPC手段，比如pipe管道（有血缘关系的进程），fifo有名管道（无血缘关系的进程），mmap/munmap内存共享映射，Unix Domain Socket等等。但是Android却采用了Binder这种不同上述几种类型的特有机制，至于原因肯定有很多，比如安全，实现方式合理性，内存优化，性能等等。（这一块儿坑的很多，需要积累很多linux系统相关内容，我也是恶补了许多知识。并且Binder远远不是三言两语能够概括清楚的，所以很多底层细节无法为大家展现，比如内核部分代码细节。既然不幸入坑了，我们就一步一步往下挖吧=。=）<br><a id="more"></a></p>
<hr>
<h1 id="Binder通信模型"><a href="#Binder通信模型" class="headerlink" title="Binder通信模型"></a>Binder通信模型</h1><h2 id="Binder的优势"><a href="#Binder的优势" class="headerlink" title="Binder的优势"></a>Binder的优势</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>&#160; &#160; &#160; &#160; Binder使用Client-Server通信方式：一个进程作为Server提供诸如视频/音频解码，视频捕获，地址本查询，网络连接等服务；多个进程作为Client向Server发起服务请求，获得所需要的服务。要想实现Client-Server通信据必须实现以下两点：一是server必须有确定的访问接入点或者说地址来接受Client的请求，并且Client可以通过某种途径获知Server的地址；二是制定Command-Reply协议来传输数据。例如在网络通信中Server的访问接入点就是Server主机的IP地址+端口号，传输协议为TCP协议。对Binder而言，Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>&#160; &#160; &#160; &#160; 如果是传统的Linux IPC方式中，socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。</p>
<p>&#160; &#160; &#160; &#160; 举个例子如，Client要将一块内存数据传递给Server，一般的做法是，Client将这块数据从它的进程空间拷贝到内核空间中，然后内核再将这个数据从内核空间拷贝到Server的进程空间，这样，Server就可以访问这个数据了。但是在这种方法中，执行了两次内存拷贝操作。所以Binder设计时采用了折衷的方式，只需要把Client进程空间的数据拷贝一次到内核空间，然后Server与内核共享这个数据就可以了，整个过程只需要执行一次内存拷贝，提高了效率。同时这样更有C/S架构的模型，方便管理。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>&#160; &#160; &#160; &#160; Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</p>
<p>&#160; &#160; &#160; &#160; 基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式的安全性，这就是Binder。Binder为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。</p>
<h2 id="通信方式和引用"><a href="#通信方式和引用" class="headerlink" title="通信方式和引用"></a>通信方式和引用</h2><p>&#160; &#160; &#160; &#160; 与其它IPC不同，Binder使用了面向对象的思想来描述作为访问接入点的Binder及其在Client中的入口：Binder是一个实体位于Server中的对象，该对象提供了一套方法用以实现对服务的请求，就象类的成员函数。遍布于client中的入口可以看成指向这个binder对象的‘指针’，一旦获得了这个‘指针’就可以调用该对象的方法访问server。在Client看来，通过Binder‘指针’调用其提供的方法和通过指针调用其它任何本地对象的方法并无区别，尽管前者的实体位于远端Server中，而后者实体位于本地内存中。‘指针’是C/C++的术语，换成java的说法是引用，即Client通过Binder的引用访问Server。如果借用Windows系统开发的一个术语‘句柄’也可以用来表述Binder在Client中的存在方式。从通信的角度看，Client中的Binder也可以看作是Server Binder的<code>‘代理’</code>，在本地代表远端Server为Client提供服务。本文中会使用‘引用’或‘句柄’这个两广泛使用的术语。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160; 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。最诱人的是，这个引用和Java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; 当然面向对象只是针对应用程序而言，对于Binder驱动和内核其它模块一样使用C语言实现，没有类和对象的概念。Binder驱动为面向对象的进程间通信提供底层支持。</p>
<h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h2><p>&#160; &#160; &#160; &#160; 从英文字面上意思看，Binder具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户空间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了，其中，核心组件便是Binder驱动程序了，Service Manager提供了辅助管理的功能，Client和Server正是在Binder驱动和Service Manager提供的基础设施上，进行Client-Server之间的通信。这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，Service Manager是域名服务器（DNS），Binder驱动是路由器。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p>&#160; &#160; &#160; &#160; 和路由器一样，Binder驱动虽然默默无闻，却是通信的核心。尽管名叫‘驱动’，实际上和硬件设备没有任何关系，只是实现方式和设备驱动程序是一样的：它工作于内核态，提供open()，mmap()，poll()，ioctl()等标准文件操作，以字符驱动设备中的misc设备注册在设备目录/dev下，用户通过/dev/binder访问该它。驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。驱动和应用程序之间定义了一套接口协议，主要功能由ioctl()接口实现，不提供read()，write()接口，因为ioctl()灵活方便，且能够一次调用实现先写后读以满足同步交互，而不必分别调用write()和read()。Binder驱动的代码每个分支位置不一样，再加上我也没有下内核的代码，<a href="https://android.googlesource.com/kernel/common/+/android-4.4/drivers/android/binder.c" target="_blank" rel="external">这里</a>先给个4.4的<code>Binder.c</code>的地址,有兴趣的可以自己研究。</p>
<h3 id="ServiceManager-与实名Binder"><a href="#ServiceManager-与实名Binder" class="headerlink" title="ServiceManager 与实名Binder"></a>ServiceManager 与实名Binder</h3><p>&#160; &#160; &#160; &#160; 和DNS类似，ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。注册了名字的Binder叫实名Binder，就象每个网站除了有IP地址外还有自己的网址。Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名叫张三的Binder，它位于某个Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及ServiceManager对实体的引用，将名字及新建的引用打包传递给ServiceManager。ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。</p>
<p>&#160; &#160; &#160; &#160; 细心的读者可能会发现其中的蹊跷：ServiceManager是一个进程，Server是另一个进程，Server向ServiceManager注册Binder必然会涉及进程间通信。当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。Binder的实现比较巧妙：预先创造一只鸡来孵蛋：ServiceManager和其它进程同样采用Binder通信，ServiceManager是Server端，有自己的Binder对象（实体），其它进程都是Client，需要通过这个Binder的引用来实现Binder的注册，查询和获取。ServiceManager提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成ServiceManager（会用到ioctl(fd, cmd, arg)函数，cmd为BINDER_SET_CONTEXT_MGR）时Binder驱动会自动为它创建Binder实体（这就是那只预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。也就是说，一个Server若要向ServiceManager注册自己Binder就必需通过0（即NULL指针）这个引用号和ServiceManager的Binder通信。类比网络通信，0号引用就好比域名服务器的地址，你必须预先手工或动态配置好。要注意这里说的Client是相对ServiceManager而言的，一个应用程序可能是个提供服务的Server，但对ServiceManager来说它仍然是个Client。</p>
<h3 id="Client-获得实名Binder的引用"><a href="#Client-获得实名Binder的引用" class="headerlink" title="Client 获得实名Binder的引用"></a>Client 获得实名Binder的引用</h3><p>&#160; &#160; &#160; &#160; Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Client也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请获得名字叫张三的Binder的引用。ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder的引用，将该引用作为回复发送给发起请求的Client。从面向对象的角度，这个Binder对象现在有了两个引用：一个位于ServiceManager中，一个位于发起请求的Client中。如果接下来有更多的Client请求该Binder，系统中就会有更多的引用指向该Binder，就象java里一个对象存在多个引用一样。而且类似的这些指向Binder的引用是强类型，从而确保只要有引用Binder实体就不会被释放掉。通过以上过程可以看出，ServiceManager象个火车票代售点，收集了所有火车的车票，可以通过它购买到乘坐各趟火车的票-得到某个Binder的引用。</p>
<h3 id="匿名-Binder"><a href="#匿名-Binder" class="headerlink" title="匿名 Binder"></a>匿名 Binder</h3><p>&#160; &#160; &#160; &#160; 并不是所有Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。如果我们是从事application开发，跨进程的自己手写AIDL文件，或者相同进程的bindService自己添加一个继承Binder的子类，那么这个Binder没有向ServiceManager注册名字，所以是个匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。</p>
<hr>
<p>好了，理论性的科普先到这里，再继续下去估计要扑（pu）街（gai）了 =。=，先来美图放松放松。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6Binder%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子图"></p>
<h1 id="Binder机制跨进程原理"><a href="#Binder机制跨进程原理" class="headerlink" title="Binder机制跨进程原理"></a>Binder机制跨进程原理</h1><p>&#160; &#160; &#160; &#160; 上文给出了Binder的通信模型，指出了通信过程的四个角色: Client, Server, ServiceManager, driver; 但是我们仍然不清楚<code>Client到底是如何与Server完成通信的</code>,因为实现细节我们还没讲。</p>
<p>&#160; &#160; &#160; &#160; 虽然Binder用到了面向对象的思想，但并不限制应用程序一定要使用面向对象的语言，无论是C语言还是C++语言都可以很容易的使用Binder来通信。例如尽管Android主要使用java/C++，象ServiceManager这么重要的进程就是用C语言实现的。</p>
<p>&#160; &#160; &#160; &#160; Binder本质上只是一种底层通信方式，和具体服务没有关系。为了提供具体服务，Server必须提供一套接口函数以便Client通过远程访问使用各种服务。这时通常采用Proxy设计模式：将接口函数定义在一个抽象类中，Server和Client都会以该抽象类为基类实现所有接口函数，所不同的是Server端是真正的功能实现，而Client端是对这些函数远程调用请求的包装。如何将Binder和Proxy设计模式结合起来是应用程序实现面向对象Binder通信的根本问题。</p>
<h2 id="Binder-在Server端的表述-–-Binder实体"><a href="#Binder-在Server端的表述-–-Binder实体" class="headerlink" title="Binder 在Server端的表述 – Binder实体"></a>Binder 在Server端的表述 – Binder实体</h2><p>&#160; &#160; &#160; &#160; 做为Proxy设计模式的基础，首先定义一个抽象接口类封装Server所有功能，其中包含一系列纯虚函数留待Server和Proxy各自实现（如果是java层则为接口方法，或者是AIDL文件，编译后大同小异）。由于这些函数需要跨进程调用，须为其一一编号，从而Server可以根据收到的编号决定调用哪个函数。其次就要引入Binder了。Server端定义另一个Binder抽象类处理来自Client的Binder请求数据包，其中最重要的成员是虚函数onTransact()。该函数分析收到的数据包，调用相应的接口函数处理请求。</p>
<p>&#160; &#160; &#160; &#160; 接下来采用继承方式以接口类和Binder抽象类为基类构建Binder在Server中的实体，实现基类里所有的虚函数，包括公共接口函数以及数据包处理函数：onTransact()。这个函数的输入是来自Client的binder_transaction_data结构的数据包（java层为Parcel对象，对应native层还是这个结构体某一部分）。前面提到，该结构里有个成员code，包含这次请求的接口函数编号。onTransact()将case-by-case地解析code值，从数据包里取出函数参数，调用接口类中相应的，已经实现的公共接口函数。函数执行完毕，如果需要返回数据就再构建一个binder_transaction_data包将返回数据包填入其中。</p>
<p>&#160; &#160; &#160; &#160; 那么各个Binder实体的onTransact()又是什么时候调用呢？这就需要驱动参与了。前面说过，Binder实体须要以Binde传输结构flat_binder_object形式发送给其它进程才能建立Binder通信，而Binder实体指针就存放在该结构的handle域中。驱动根据Binder位置数组从传输数据中获取该Binder的传输结构，为它创建位于内核中的Binder节点，将Binder实体指针记录在该节点中。如果接下来有其它进程向该Binder发送数据，驱动会根据节点中记录的信息将Binder实体指针填入binder_transaction_data的target.ptr中返回给接收线程。接收线程从数据包中取出该指针，reinterpret_cast成Binder抽象类并调用onTransact()函数。由于这是个虚函数，不同的Binder实体中有各自的实现，从而可以调用到不同Binder实体提供的onTransact()。</p>
<h2 id="Binder-在Client端的表述-–-Binder引用"><a href="#Binder-在Client端的表述-–-Binder引用" class="headerlink" title="Binder 在Client端的表述 – Binder引用"></a>Binder 在Client端的表述 – Binder引用</h2><p>&#160; &#160; &#160; &#160; 做为Proxy设计模式的一部分，Client端的Binder同样要继承Server提供的公共接口类并实现公共函数。但这不是真正的实现，而是对远程函数调用的包装：将函数参数打包，通过Binder向Server发送申请并等待返回值。为此Client端的Binder还要知道Binder实体的相关信息，即对Binder实体的引用。该引用或是由ServiceManager转发过来的，对实名Binder的引用或是由另一个进程直接发送过来的，对匿名Binder的引用。</p>
<p>&#160; &#160; &#160; &#160; 由于继承了同样的公共接口类，Client Binder提供了与Server Binder一样的函数原型，使用户感觉不出Server是运行在本地还是远端。Client Binder中，公共接口函数的包装方式是：创建一个binder_transaction_data数据包，将其对应的编码填入code域，将调用该函数所需的参数填入data.buffer指向的缓存中，并指明数据包的目的地，那就是已经获得的对Binder实体的引用，填入数据包的target.handle中。注意这里和Server的区别：实际上target域是个联合体，包括ptr和handle两个成员，前者用于接收数据包的Server，指向 Binder实体对应的内存空间；后者用于作为请求方的Client，存放Binder实体的引用，告知驱动数据包将路由给哪个实体。数据包准备好后，通过驱动接口发送出去。经过BC_TRANSACTION/BC_REPLY回合完成函数的远程调用并得到返回值。</p>
<hr>
<p>&#160; &#160; &#160; &#160; 以上主要是C++层实现步骤，java层也相同原理，只不过最终还会通过JNI调用C++层实现方法。<br>&#160; &#160; &#160; &#160; 我们举个栗子来描述会更通俗易懂一些：</p>
<p>&#160; &#160; &#160; &#160; 假设Client进程想要调用Server进程的<code>object</code>对象的一个方法<code>add</code>;<br>&#160; &#160; &#160; &#160; 首先，Server进程要向ServiceManager注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉ServiceManager，它叫<code>zhangsan</code>，它有一个<code>object</code>对象，可以执行<code>add</code> 操作；于是ServiceManager建立了一张表：<code>zhangsan</code>这个名字对应进程Server; </p>
<p>&#160; &#160; &#160; &#160; 然后Client向ServiceManager查询：我需要联系一个名字叫做<code>zhangsan</code>的进程里面的<code>object</code>对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的<code>object</code>对象，而是返回一个看起来跟<code>object</code>一模一样的代理对象<code>objectProxy</code>，这个<code>objectProxy</code>也有一个<code>add</code>方法，但是这个<code>add</code>方法没有Server进程里面<code>object</code>对象的<code>add</code>方法那个能力；<code>objectProxy</code>的<code>add</code>只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了ServiceManager的流程)</p>
<p>&#160; &#160; &#160; &#160; 但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着<code>objectProxy</code>对象然后调用<code>add</code>方法；我们说过，这个<code>add</code>什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>&#160; &#160; &#160; &#160; 驱动收到这个消息，发现是这个<code>objectProxy</code>；一查表就明白了：我之前用<code>objectProxy</code>替换了<code>object</code>发送给Client了，它真正应该要访问的是<code>object</code>对象的<code>add</code>方法；于是Binder驱动通知Server进程，调用你的<code>object</code>对象的<code>add</code>方法，然后把结果发给我，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给Client进程；于是整个过程就完成了。</p>
<p>&#160; &#160; &#160; &#160; 由于驱动返回的<code>objectProxy</code>与Server进程里面原始的<code>object</code>是如此相似，给人感觉好像是<strong>直接把Server进程里面的对象<code>object</code>传递到了Client进程</strong> ；因此，我们可以说<strong>Binder对象是可以进行跨进程传递的对象</strong>。</p>
<p>&#160; &#160; &#160; &#160; 但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p>
<p>&#160; &#160; &#160; &#160; 理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是代理模式, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>&#160; &#160; &#160; &#160; 另外我们为了简化整个流程，隐藏了ServiceManager这一部分驱动进行的操作；实际上，由于ServiceManager与Server通常不在一个进程，Server进程向ServiceManager注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：ServiceManager中存在的Server端的对象实际上也是代理对象，后面Client向ServiceManager查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>&#160; &#160; &#160; &#160; 一句话总结就是：<strong>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信</strong>。</p>
<h1 id="分析Java层的Binder"><a href="#分析Java层的Binder" class="headerlink" title="分析Java层的Binder"></a>分析Java层的Binder</h1><p>&#160; &#160; &#160; &#160;  Android系统的很多服务都是由C++层的Binder实现，过程复杂先不说，主要是代码量巨多，分析起来篇幅远远不够，即使不分析完全，估计粘一半代码都快吐血了，所以就选了java层的Binder，会重点分析AIDL过程。</p>
<p>&#160; &#160; &#160; &#160;  我们使用AIDL接口的时候，经常会接触到这些类：<strong>IBinder/IInterface/Binder/BinderProxy/Stub</strong>，相关功能如下：</p>
<ul>
<li>IBinder是一个接口，它代表了<strong>一种跨进程传输的能力</strong>；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是<strong>Binder本地对象</strong>。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<h2 id="AIDL过程分析"><a href="#AIDL过程分析" class="headerlink" title="AIDL过程分析"></a>AIDL过程分析</h2><p>&#160; &#160; &#160; &#160; 现在我们通过一个AIDL的使用，分析一下整个通信过程中，各个角色到底做了什么，AIDL到底是如何完成通信的。<br>&#160; &#160; &#160; &#160; 首先定一个一个简单的aidl接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ITest.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.windrunnerlihuan;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后用编译工具编译之后，可以得到对应的ITest.java类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.windrunnerlihuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITest</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span></span><br><span class="line">			<span class="title">com</span>.<span class="title">windrunnerlihuan</span>.<span class="title">ITest</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.windrunnerlihuan.ITest"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * Cast an IBinder object into an com.windrunnerlihuan.ITest interface,</span><br><span class="line">		 * generating a proxy if needed.</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> com.windrunnerlihuan.<span class="function">ITest <span class="title">asInterface</span><span class="params">(</span><br><span class="line">				android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">			<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.windrunnerlihuan.ITest))) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((com.windrunnerlihuan.ITest) iin);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> com.windrunnerlihuan.ITest.Stub.Proxy(obj);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span><br><span class="line">				android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">				<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">			<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">			<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">				reply.writeString(DESCRIPTOR);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">				data.enforceInterface(DESCRIPTOR);</span><br><span class="line">				<span class="keyword">int</span> _arg0;</span><br><span class="line">				_arg0 = data.readInt();</span><br><span class="line">				<span class="keyword">int</span> _arg1;</span><br><span class="line">				_arg1 = data.readInt();</span><br><span class="line">				<span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">				reply.writeNoException();</span><br><span class="line">				reply.writeInt(_result);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">windrunnerlihuan</span>.<span class="title">ITest</span> </span>&#123;</span><br><span class="line">			<span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">			Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">				mRemote = remote;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> mRemote;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">				android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">				android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">				<span class="keyword">int</span> _result;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">					_data.writeInt(a);</span><br><span class="line">					_data.writeInt(b);</span><br><span class="line">					mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">					_reply.readException();</span><br><span class="line">					_result = _reply.readInt();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					_reply.recycle();</span><br><span class="line">					_data.recycle();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> _result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 系统帮我们生成了这个文件之后，我们只需要继承ITest.Stub这个抽象类，实现它的方法，然后在Service 的onBind方法里面返回就实现了AIDL。这个Stub类非常重要，具体看看它做了什么。</p>
<p>&#160; &#160; &#160; &#160; Stub类继承自Binder，意味着这个Stub其实自己是一个Binder本地对象，然后实现了ITest接口，ITest本身是一个IInterface，因此他携带某种客户端需要的能力（这里是方法<code>add</code>)。此类有一个内部类Proxy，也就是Binder代理对象；</p>
<p>&#160; &#160; &#160; &#160; 然后看看<code>asInterface</code>方法，我们在bind一个Service之后，在onServiceConnecttion的回调里面，就是通过这个方法拿到一个远程的service的，这个方法做了什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Cast an IBinder object into an com.windrunnerlihuan.ITest interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.windrunnerlihuan.<span class="function">ITest <span class="title">asInterface</span><span class="params">(</span><br><span class="line">		android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">	<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.windrunnerlihuan.ITest))) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((com.windrunnerlihuan.ITest) iin);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> com.windrunnerlihuan.ITest.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 首先看函数的参数<code>IBinder</code>类型的obj，这个对象是驱动给我们的，如果是Binder本地对象，那么它就是Binder类型，如果是Binder代理对象，那就是<code>BinderProxy</code>类型；然后，正如上面自动生成的文档所说，它会试着查找Binder本地对象，如果找到，说明Client和Server都在同一个进程，这个参数直接就是本地对象，直接强制类型转换然后返回，如果找不到，说明是远程对象（处于另外一个进程）那么就需要创建一个Binde代理对象，让这个Binder代理实现对于远程对象的访问。一般来说，如果是与一个远程Service对象进行通信，那么这里返回的一定是一个Binder代理对象，这个IBinder参数的实际上是BinderProxy;</p>
<p>&#160; &#160; &#160; &#160; 再看看我们对于aidl的<code>add</code> 方法的实现；在<code>Stub</code>类里面，add是一个抽象方法，我们需要继承这个类并实现它；如果Client和Server在同一个进程，那么直接就是调用这个方法；那么，如果是远程调用，这中间发生了什么呢？Client是如何调用到Server的方法的？</p>
<p>&#160; &#160; &#160; &#160; 我们知道，对于远程方法的调用，是通过Binder代理完成的，在这个例子里面就是<code>Proxy</code>类；<code>Proxy</code>对于<code>add</code>方法的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">	android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">	<span class="keyword">int</span> _result;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">		_data.writeInt(a);</span><br><span class="line">		_data.writeInt(b);</span><br><span class="line">		mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">		_reply.readException();</span><br><span class="line">		_result = _reply.readInt();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		_reply.recycle();</span><br><span class="line">		_data.recycle();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 它首先用<code>Parcel</code>把数据序列化了，然后调用了<code>transact</code>方法；这个<code>transact</code>到底做了什么呢？这个<code>Proxy</code>类在<code>asInterface</code>方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是<code>BinderProxy</code>, 因此我们的<code>Proxy</code>类里面的<code>mRemote</code>实际类型应该是<code>BinderProxy</code>；我们看看<code>BinderProxy</code>的<code>transact</code>方法：(Binder.java的内部类)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transactNative</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></p>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这段不用看</span></span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//把java对象解析为C++对象</span></span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把java对象解析为C++对象</span></span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*这部分得说明一下，这是个坑，有兴趣的可以挖：在获取Service Manager远程接口时，在JNI层中，创建了一个BpBinder对象，它的句柄值为0，它的地址保存在gBinderProxyOffsets.mObject中，因此，这里通过下面语句得到这个BpBinder对象的IBinder接口：*/</span></span><br><span class="line">    IBinder* target = (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been finalized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印LOG，忽略</span></span><br><span class="line">    ALOGV(<span class="string">"Java code calling transact on %p in Java object %p with code %"</span> PRId32 <span class="string">"\n"</span>,</span><br><span class="line">            target, obj, code);</span><br><span class="line"><span class="comment">//干扰视线的宏，忽略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_BINDER_SAMPLE</span></span><br><span class="line">    <span class="comment">// Only log the binder call duration for things on the Java-level main thread.</span></span><br><span class="line">    <span class="comment">// But if we don't</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> time_binder_calls = should_time_binder_calls();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> start_millis;</span><br><span class="line">    <span class="keyword">if</span> (time_binder_calls) &#123;</span><br><span class="line">        start_millis = uptimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">//这段才是重点</span></span><br><span class="line">    <span class="comment">//printf("Transact from Java code to %p sending: ", target); data-&gt;print();</span></span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    <span class="comment">//if (reply) printf("Transact from Java code to %p received: ", target); reply-&gt;print();</span></span><br><span class="line"><span class="comment">//下面都可以忽略了    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_BINDER_SAMPLE</span></span><br><span class="line">    <span class="keyword">if</span> (time_binder_calls) &#123;</span><br><span class="line">        conditionally_log_binder_call(start_millis, target, code);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>);</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我在注释中说这儿有个坑，有兴趣的就去挖吧，就是在获取Service Manager远程接口时，在JNI层中，创建了一个<code>BpBinder</code>对象，它的句柄值为0，它的地址保存在<code>gBinderProxyOffsets.mObject</code>中，因此，还得去找<code>BpBinder</code>的<code>transact</code>方法，<code>BpBinder</code>的位置在framework\native\libs\binder\BpBinder.cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">	    <span class="comment">//唉，又是个坑，继续挖IPCThreadState</span></span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 继续挖IPCThreadState，位于framework\native\libs\binder\IPCThreadState.cpp(这个self函数就不贴了，就是个单例写法):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"> </span><br><span class="line">    flags |= TF_ACCEPT_FDS;    </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//调用writeTransactionData 发送数据</span></span><br><span class="line">		err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; </span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">      ....等回复</span><br><span class="line"></span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   ....    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">再进一步，瞧瞧这个...</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面把命令数据封装成binder_transaction_data，然后写到mOut中，mOut是命令的缓冲区，也是一个Parcel</span></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"><span class="comment">//仅仅写到了Parcel中，Parcel好像没和/dev/binder设备有什么关联啊？</span></span><br><span class="line"><span class="comment">//恩，那只能在另外一个地方写到binder设备中去了。难道是在？</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说对了，就是在waitForResponse中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//talkWithDriver，哈哈，应该是这里了</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//看见没？这里开始操作mIn了，看来talkWithDriver中</span></span><br><span class="line"><span class="comment">//把mOut发出去，然后从driver中读到数据放到mIn中了。</span></span><br><span class="line">        cmd = mIn.readInt32(); </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">binder_write_read bwr;</span><br><span class="line">   <span class="comment">//中间东西太复杂了，不就是把mOut数据和mIn接收数据的处理后赋值给bwr吗？</span></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//用ioctl来读写</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">  &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"><span class="comment">//到这里，回复数据就在bwr中了，bmr接收回复数据的buffer就是mIn提供的</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 里面进行了一系列的函数调用，确实是个巨恶心的过程；要知道的是它最终调用到了talkWithDriver函数；看这个函数的名字就知道，通信过程要交给驱动完成了（驱动调用是个更恶心的过程，感觉真不是人看的。。。。。）；<br>&#160; &#160; &#160; &#160; （以下过程限于篇幅和巨恶心的过程，所以简要概括，有兴趣的可以自己去挖坑=。=）<br>&#160; &#160; &#160; &#160; 这个函数最后通过ioctl系统调用，Client进程陷入内核态，Client调用add方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的onTransact函数（实际上由Server端线程池完成）。我们再看Binder本地对象的onTransact方法（这里就是Stub类里面的此方法）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span><br><span class="line">		android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">		<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">	<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">		reply.writeString(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">		data.enforceInterface(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">int</span> _arg0;</span><br><span class="line">		_arg0 = data.readInt();</span><br><span class="line">		<span class="keyword">int</span> _arg1;</span><br><span class="line">		_arg1 = data.readInt();</span><br><span class="line">		<span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">		reply.writeNoException();</span><br><span class="line">		reply.writeInt(_result);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 在Server进程里面，<code>onTransact</code>根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的<code>add</code>方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。</p>
<p>&#160; &#160; &#160; &#160; 至此，你应该对AIDL这种通信方式里面的各个类以及各个角色有了一定的了解；它总是那么一种固定的模式：一个需要跨进程传递的对象一定继承自IBinder，如果是Binder本地对象，那么一定继承Binder实现IInterface，如果是代理对象，那么就实现了IInterface并持有了IBinder引用；</p>
<p>&#160; &#160; &#160; &#160; Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。如果把这个过程做一个类比，在封建社会，Stub好比皇帝，可以号令天下，他生而具有这个权利（不要说宣扬封建迷信。。）如果一个人也想号令天下，可以，“挟天子以令诸侯”。为什么不自己去当皇帝，其一，一般情况没必要，当了皇帝其实限制也蛮多的是不是？我现在既能掌管天下，又能不受约束（Java单继承）；其二，名不正言不顺啊，我本来特么就不是（Binder），你非要我是说不过去，搞不好还会造反。最后呢，如果想当皇帝也可以，那就是asBinder了。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>&#160; &#160; &#160; &#160; 再去翻阅系统的ActivityManagerServer的源码，就知道哪一个类是什么角色了：IActivityManager是一个IInterface，它代表远程Service具有什么能力，ActivityManagerNative指的是Binder本地对象（类似AIDL工具生成的Stub类），这个类是抽象类，它的实现是ActivityManagerService；因此对于AMS的最终操作都会进入ActivityManagerService这个真正实现；同时如果仔细观察，ActivityManagerNative.java里面有一个非公开类ActivityManagerProxy, 它代表的就是Binder代理对象；是不是跟AIDL模型一模一样呢？那么ActivityManager是什么？他不过是一个管理类而已，可以看到真正的操作都是转发给ActivityManagerNative进而交给他的实现ActivityManagerService 完成的。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160; 至此分析Binder就告一段落了，也是一个越往下挖越恶心的东西。等以后有机会系统学一下Linux内核的知识。虽然兴趣是最好的老师，但是学习也是个循序渐进的过程，不可能一口吃成大胖子。知识的积累也是需要脚踏实地，一步一个脚印。量变引起质变，见多识广之后才能厚积薄发，逐渐形成自己的思维，使自己成长的更强大。同时，积累过程最忌浮躁，不可因外界环境干扰心境，要始终勿忘初心，心态保持平静，不随波逐流，上善若水。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[移动直播技术秒开优化经验]]></title>
      <url>http://windrunnerlihuan.com/2016/06/06/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;以下内容来自<code>@高可用架构</code>，这次当一回技术的搬运工，为大家分享七牛创始人之一————徐立的<code>移动直播技术秒开优化经验</code>。<br><a id="more"></a></p>
<hr>
<blockquote>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/head.jpg" title="徐立"></div><br>&#160; &#160; &#160; &#160;徐立，七牛创始合伙人兼产品副总裁，负责七牛直播云的整体研发，是国内 Go / Docker / Container 技术早期布道者，&gt;Go / Containers / Distributed Systems 技术的忠实爱好者和实践者。曾合著国内第一本 Go 语言图书《Go 语言编程》，翻译《Go 语言程序设计》。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;现今移动直播技术上的挑战要远远难于传统设备或电脑直播，其完整的处理环节包括但不限于：音视频采集、美颜/滤镜/特效处理、编码、封包、推流、转码、分发、解码/渲染/播放等。</p>
<p>直播常见的问题包括：</p>
<ul>
<li>主播在不稳定的网络环境下如何稳定推流？</li>
<li>偏远地区的观众如何高清流畅观看直播？</li>
<li>直播卡顿时如何智能切换线路？</li>
<li>如何精确度量直播质量指标并实时调整？</li>
<li>移动设备上不同的芯片平台如何高性能编码和渲染视频？</li>
<li>美颜等滤镜特效处理怎么做？</li>
<li>如何实现播放秒开？</li>
<li>如何保障直播持续播放流畅不卡顿？</li>
</ul>
<p>本次分享将为大家揭开移动直播核心技术的神秘面纱。</p>
<h1 id="视频、直播等基础知识"><a href="#视频、直播等基础知识" class="headerlink" title="视频、直播等基础知识"></a>视频、直播等基础知识</h1><h2 id="什么是视频？"><a href="#什么是视频？" class="headerlink" title="什么是视频？"></a>什么是视频？</h2><p>&#160; &#160; &#160; &#160;首先我们需要理解一个最基本的概念：视频。从感性的角度来看，视频就是一部充满趣味的影片，可以是电影，可以是短片，是一连贯的视觉冲击力表现丰富的画面和音频。但从理性的角度来看，视频是一种有结构的数据，用工程的语言解释，我们可以把视频剖析成如下结构：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whatisav.jpg" alt=""><br>内容元素 ( Content )</p>
<ul>
<li>图像 ( Image )</li>
<li>音频 ( Audio )</li>
<li>元信息 ( Metadata )</li>
</ul>
<p>编码格式 ( Codec )</p>
<ul>
<li>Video : H.264，H.265, …</li>
<li>Audio : AAC， HE-AAC, …</li>
</ul>
<p>容器封装 (Container)</p>
<ul>
<li>MP4，MOV，FLV，RM，RMVB，AVI，…</li>
</ul>
<p>任何一个视频 Video 文件，从结构上讲，都是这样一种组成方式：</p>
<ul>
<li>由图像和音频构成最基本的内容元素；</li>
<li>图像经过视频编码压缩格式处理（通常是 H.264）；</li>
<li>音频经过音频编码压缩格式处理（例如 AAC）；</li>
<li>注明相应的元信息（Metadata）；</li>
</ul>
<p>最后经过一遍容器（Container）封装打包（例如 MP4），构成一个完整的视频文件。</p>
<p>&#160; &#160; &#160; &#160;如果觉得难以理解，可以想象成一瓶番茄酱。最外层的瓶子好比这个容器封装（Container），瓶子上注明的原材料和加工厂地等信息好比元信息（Metadata），瓶盖打开（解封装）后，番茄酱本身好比经过压缩处理过后的编码内容，番茄和调料加工成番茄酱的过程就好比编码（Codec），而原材料番茄和调料则好比最原本的内容元素（Content）。</p>
<h2 id="视频的实时传输"><a href="#视频的实时传输" class="headerlink" title="视频的实时传输"></a>视频的实时传输</h2><p>&#160; &#160; &#160; &#160;简而言之，理性的认知视频的结构后，有助于我们理解视频直播。如果视频是一种“有结构的数据”，那么视频直播无疑是<strong>实时传输</strong>这种“有结构的数据”（视频）的方式。</p>
<p>&#160; &#160; &#160; &#160;那么一个显而易见的问题是：如何实时（Real-Time）传输这种“有结构的数据”（视频）呢？</p>
<p>&#160; &#160; &#160; &#160;这里边一个悖论是：一个经过容器（Container）封装后的视频，一定是不可变的 ( Immutable ) 视频文件，不可变的 ( Immutable ) 的视频文件已经是一个生产结果，根据“相对论”，而这个生产结果显然不可能精确到实时的程度，它已经是一段时空的记忆。</p>
<p>&#160; &#160; &#160; &#160;因此视频直播，一定是一个 “边生产，边传输，边消费” 的过程。这意味着，我们需要更近一步了解视频从原始的内容元素 ( 图像和音频 ) 到成品 ( 视频文件 ) 之前的中间过程 ( 编码 )。</p>
<h2 id="视频编码压缩"><a href="#视频编码压缩" class="headerlink" title="视频编码压缩"></a>视频编码压缩</h2><p>&#160; &#160; &#160; &#160;不妨让我们来深入浅出理解视频编码压缩技术。</p>
<p>&#160; &#160; &#160; &#160;为了便于视频内容的存储和传输，通常需要减少视频内容的体积，也就是需要将原始的内容元素(图像和音频)经过压缩，压缩算法也简称编码格式。例如视频里边的原始图像数据会采用 H.264 编码格式进行压缩，音频采样数据会采用 AAC 编码格式进行压缩。</p>
<p>&#160; &#160; &#160; &#160;视频内容经过编码压缩后，确实有利于存储和传输; 不过当要观看播放时，相应地也需要解码过程。因此编码和解码之间，显然需要约定一种编码器和解码器都可以理解的约定。就视频图像编码和解码而言，这种约定很简单：</p>
<p><strong>编码器将多张图像进行编码后生产成一段一段的 GOP ( Group of Pictures ) ， 解码器在播放时则是读取一段一段的 GOP 进行解码后读取画面再渲染显示。</strong><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whathappend1.jpg" alt=""><br>&#160; &#160; &#160; &#160;GOP ( Group of Pictures ) 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whathappend2.jpg" alt=""><br>&#160; &#160; &#160; &#160;I 帧是内部编码帧（也称为关键帧），P 帧是前向预测帧（前向参考帧），B 帧是双向内插帧（双向参考帧）。简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。</p>
<p><strong>如果没有 I 帧，P 帧和 B 帧就无法解码。</strong><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/mainvsref.jpg" alt=""><br>&#160; &#160; &#160; &#160;小结一下，一个视频 ( Video ) ，其图像部分的数据是一组 GOP 的集合, 而单个 GOP 则是一组 I / P / B 帧图像的集合。</p>
<p>&#160; &#160; &#160; &#160;在这样的一种几何关系中，Video 好比一个 “物体”，GOP 好比 “分子”，I / P / B 帧的图像则好比 “原子”。</p>
<p>&#160; &#160; &#160; &#160;想象一下，如果我们把传输一个 “物体”，改成传输一个一个的 “原子”，将最小颗粒以光速传送，那么以人的生物肉眼来感知，将是一种怎样的体验？</p>
<h2 id="什么是视频直播？"><a href="#什么是视频直播？" class="headerlink" title="什么是视频直播？"></a>什么是视频直播？</h2><p>&#160; &#160; &#160; &#160;不难脑洞大开一下，直播就是这样的一种体验。视频直播技术，就是将视频内容的最小颗粒 ( I / P / B 帧，…)，基于时间序列，以光速进行传送的一种技术。</p>
<p>&#160; &#160; &#160; &#160;简而言之，直播就是将每一帧数据 ( Video / Audio / Data Frame )，打上时序标签 ( Timestamp ) 后进行流式传输的过程。发送端源源不断的采集音视频数据，经过编码、封包、推流，再经过中继分发网络进行扩散传播，播放端再源源不断地下载数据并按时序进行解码播放。如此就实现了 “边生产、边传输、边消费” 的直播过程。</p>
<p>&#160; &#160; &#160; &#160;理解以上两个关于<code>视频</code>和<code>直播</code>两个基础概念后，接下来我们就可以一窥直播的业务逻辑了。</p>
<h2 id="直播的业务逻辑"><a href="#直播的业务逻辑" class="headerlink" title="直播的业务逻辑"></a>直播的业务逻辑</h2><p>如下是一个最精简的一对多直播业务模型，以及各个层级之间的协议。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/liveprotocol.jpg" alt=""><br>各协议差异对比如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/protocoldiff1.jpg" alt=""><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/protocoldiff2.jpg" alt=""><br>以上就是关于直播技术的一些基础概念。下面我们进一步了解下影响人们视觉体验的直播性能指标。</p>
<h1 id="影响视觉体验的直播性能指标"><a href="#影响视觉体验的直播性能指标" class="headerlink" title="影响视觉体验的直播性能指标"></a>影响视觉体验的直播性能指标</h1><p>&#160; &#160; &#160; &#160;<strong>直播第一个性能指标是延迟</strong>，延迟是数据从信息源发送到目的地所需的时间。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay1.jpg" alt=""><br>根据爱因斯坦的狭义相对论，光速是所有能量、物质和信息运动所能达到的最高速度，这个结论给传播速度设定了上限。因此，即便我们肉眼感觉到的实时，实际上也是有一定的延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay2.jpg" alt=""><br>由于 RTMP/HLS 是基于 TCP 之上的应用层协议，TCP 三次握手，四次挥手，慢启动过程中的每一次往返来回，都会加上一次往返耗时 ( RTT )，这些交互过程都会增加延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay3.jpg" alt=""><br>其次根据 TCP 丢包重传特性，网络抖动可能导致丢包重传，也会间接导致延迟加大。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/jitter.jpg" alt=""><br>&#160; &#160; &#160; &#160;一个完整的直播过程，包括但不限于以下环节：<strong>采集、处理、编码、封包、推流、传输、转码、分发、拉流、解码、播放</strong>。从推流到播放，再经过中间转发环节，延迟越低，则用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;<strong>第二个直播性能指标卡顿</strong>，是指视频播放过程中出现画面滞帧，让人们明显感觉到“卡”。单位时间内的播放卡顿次数统计称之为卡顿率。</p>
<p>&#160; &#160; &#160; &#160;造成卡顿的因素有可能是推流端发送数据中断，也有可能是公网传输拥塞或网络抖动异常，也有可能是终端设备的解码性能太差。卡顿频次越少或没有，则说明用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;<strong>第三个直播性能指标首屏耗时</strong>，指第一次点击播放后，肉眼看到画面所等待的时间。技术上指播放器解码第一帧渲染显示画面所花的耗时。通常说的 “秒开”，指点击播放后，一秒内即可看到播放画面。首屏打开越快，说明用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;如上三个直播性能指标，分别对应一个低延迟、高清流畅、极速秒开 的用户体验诉求。了解这三个性能指标，对优化移动直播 APP 的用户体验至关重要。</p>
<p>&#160; &#160; &#160; &#160;那么移动直播场景下具体而言有哪些常见的坑呢？</p>
<p>&#160; &#160; &#160; &#160;根据实践总结下来的经验，移动平台上视频直播的坑主要可以总结为两方面：设备差异，以及网络环境这些场景下带来的技术考验。</p>
<h1 id="移动直播场景的坑与规避措施"><a href="#移动直播场景的坑与规避措施" class="headerlink" title="移动直播场景的坑与规避措施"></a>移动直播场景的坑与规避措施</h1><h2 id="不同芯片平台上的编码差异"><a href="#不同芯片平台上的编码差异" class="headerlink" title="不同芯片平台上的编码差异"></a>不同芯片平台上的编码差异</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay2.jpg" alt=""><br><strong>iOS 平台上无论硬编还是软编，由于是 Apple 一家公司出厂，几乎不存在因为芯片平台不同而导致的编码差异</strong>。</p>
<p>&#160; &#160; &#160; &#160;然而，在 Android 平台上，Android Framework SDK 提供的 MediaCodec 编码器，在不同的芯片平台上，差异表现很大， 不同的厂家使用不同的芯片，而不同的芯片平台上 Android MediaCodec 表现略有差异，通常实现全平台兼容的成本不低。</p>
<p>&#160; &#160; &#160; &#160;另外就是 Android MediaCodec 硬编层面的 H.264 编码画质参数是固定的 baseline，所以画质通常也一般。因此，在 Android 平台下，<strong>推荐是用软编，好处是画质可调控，兼容性也更好</strong>。</p>
<h2 id="低端设备如何上高性能地采集和编码？"><a href="#低端设备如何上高性能地采集和编码？" class="headerlink" title="低端设备如何上高性能地采集和编码？"></a>低端设备如何上高性能地采集和编码？</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/gether.jpg" alt=""><br>&#160; &#160; &#160; &#160;例如 Camera 采集输出的可能是图片，一张图的体积并不会小，如果采集的频次很高，编码的帧率很高，每张图都经过编码器，那么编码器又可能会出现过载。</p>
<p>&#160; &#160; &#160; &#160;这个时候，可以考虑在编码前，不影响画质的前提下（前面我们讲过帧率的微观意义），进行<strong>选择性丢帧</strong>，以此降低编码环节的功耗开销。</p>
<h2 id="弱网下如何保障高清流畅推流"><a href="#弱网下如何保障高清流畅推流" class="headerlink" title="弱网下如何保障高清流畅推流"></a>弱网下如何保障高清流畅推流</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/resource.jpg" alt=""><br>&#160; &#160; &#160; &#160;移动网络下，通常容易遇到网络不稳定，连接被重置，断线重连，一方面频繁重连，建立连接需要开销。另一方面尤其是发生 GPRS / 2G / 3G / 4G 切换时，带宽可能出现瓶颈。当带宽不够，帧率较高/码率较高的内容较难发送出去，这个时候就需要可变码率支持。</p>
<p>&#160; &#160; &#160; &#160;即在推流端，可检测网络状态和简单测速，动态来切换码率，以保障网络切换时的推流流畅。</p>
<p>&#160; &#160; &#160; &#160;其次编码、封包、推流 这一部分的逻辑也可以做微调，可以尝试选择性丢帧，比如优先丢视频参考帧（不丢 I 帧和音频帧 )，这样也可以减少要传输的数据内容，但同时又达到了不影响画质和版视听流畅的目的。</p>
<h2 id="需要区分直播流的状态和业务状态"><a href="#需要区分直播流的状态和业务状态" class="headerlink" title="需要区分直播流的状态和业务状态"></a>需要区分直播流的状态和业务状态</h2><p>&#160; &#160; &#160; &#160;直播是媒体流、APP 的交互是 API 信令流，两者的状态不能混为一谈。尤其是不能基于 APP 的交互的 API 状态来判断直播流的状态。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/seeproduct.jpg" alt=""><br>以上是移动直播场景下常见的几个坑和规避措施。</p>
<h1 id="移动直播场景其他优化措施"><a href="#移动直播场景其他优化措施" class="headerlink" title="移动直播场景其他优化措施"></a>移动直播场景其他优化措施</h1><h2 id="一、怎么优化打开速度，达到传说中的-“秒开”？"><a href="#一、怎么优化打开速度，达到传说中的-“秒开”？" class="headerlink" title="一、怎么优化打开速度，达到传说中的 “秒开”？"></a>一、怎么优化打开速度，达到传说中的 “秒开”？</h2><p>一、怎么优化打开速度，达到传说中的 “秒开”？</p>
<p>&#160; &#160; &#160; &#160;大家可能会看到，市面上某些手机直播 APP 的打开速度非常快，一点就开。而某些手机直播 APP，点击播放后要等好几秒以后才能播放。是什么原因导致如此的天壤之别呢？</p>
<p>&#160; &#160; &#160; &#160;大部分播放器都是拿到一个完成的 GOP 后才能解码播放，基于 FFmpeg 移植的播放器甚至需要等待音画时间戳同步后才能播放（如果一个直播里边没有音频只有视频相当于要等待音频超时后才能播放画面）。</p>
<p>“秒开”可以从以下几个方面考虑：</p>
<h3 id="1-改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。"><a href="#1-改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。" class="headerlink" title="1. 改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。"></a>1. 改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。</h3><p>&#160; &#160; &#160; &#160;GOP 的第一帧通常都是关键帧，由于加载的数据较少，可以达到 “首帧秒开”。</p>
<p>&#160; &#160; &#160; &#160;如果直播服务器支持 GOP 缓存，意味着播放器在和服务器建立连接后可立即拿到数据，从而省却跨地域和跨运营商的回源传输时间。</p>
<p>&#160; &#160; &#160; &#160;GOP 体现了关键帧的周期，也就是两个关键帧之间的距离，即一个帧组的最大帧数。假设一个视频的恒定帧率是 24fps（即1秒24帧图像），关键帧周期为 2s，那么一个 GOP 就是 48 张图像。一般而言，每一秒视频至少需要使用一个关键帧。</p>
<p>&#160; &#160; &#160; &#160;<strong>增加关键帧个数可改善画质（GOP 通常为 FPS 的倍数），但是同时增加了带宽和网络负载</strong>。这意味着，客户端播放器下载一个 GOP，毕竟该 GOP 存在一定的数据体积，如果播放端网络不佳，有可能不是能够快速在秒级以内下载完该 GOP，进而影响观感体验。</p>
<p>&#160; &#160; &#160; &#160;如果不能更改播放器行为逻辑为首帧秒开，直播服务器也可以做一些取巧处理，比如<strong>从缓存 GOP 改成缓存双关键帧</strong>（减少图像数量），这样可以极大程度地减少播放器加载 GOP 要传输的内容体积。</p>
<h3 id="2-在-APP-业务逻辑层面方面优化。"><a href="#2-在-APP-业务逻辑层面方面优化。" class="headerlink" title="2. 在 APP 业务逻辑层面方面优化。"></a>2. 在 APP 业务逻辑层面方面优化。</h3><p>&#160; &#160; &#160; &#160;比如提前做好 DNS 解析（省却几十毫秒），和提前做好测速选线（择取最优线路）。经过这样的预处理后，在点击播放按钮时，将极大提高下载性能。</p>
<p>&#160; &#160; &#160; &#160;一方面，可以围绕传输层面做性能优化；另一方面，可以围绕客户播放行为做业务逻辑优化。两者可以有效的互为补充，作为秒开的优化空间。</p>
<h2 id="二、美颜等滤镜如何处理？"><a href="#二、美颜等滤镜如何处理？" class="headerlink" title="二、美颜等滤镜如何处理？"></a>二、美颜等滤镜如何处理？</h2><p>&#160; &#160; &#160; &#160;在手机直播场景下，这就是一个刚需。没有美颜功能的手机直播 APP，主播基本不爱用。可以在采集画面后，将数据送给编码器之前，将数据源回调给滤镜处理程序，原始数据经过滤镜处理完后，再送回给编码器进行编码即可。</p>
<p>&#160; &#160; &#160; &#160;除了移动端可以做体验优化之外，直播流媒体服务端架构也可以降低延迟。例如收流服务器主动推送 GOP 至边缘节点，边缘节点缓存 GOP，播放端则可以快速加载，减少回源延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/push.jpg" alt=""><br>其次，可以贴近终端就近处理和分发<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/deliver.jpg" alt=""></p>
<h2 id="三、如何保障直播持续播放流畅不卡顿？"><a href="#三、如何保障直播持续播放流畅不卡顿？" class="headerlink" title="三、如何保障直播持续播放流畅不卡顿？"></a>三、如何保障直播持续播放流畅不卡顿？</h2><p>&#160; &#160; &#160; &#160;“秒开”解决的是直播首次加载的播放体验，如何保障直播持续播放过程中的画面和声音视听流畅呢？因为，一个直播毕竟不是一个 HTTP 一样的一次性请求，而是一个 Socket 层面的长连接维持，直到直到主播主动终止推流。</p>
<p>&#160; &#160; &#160; &#160;上述我们讲过卡顿的定义：即播放时画面滞帧，触发了人们的视觉感受。在不考虑终端设备性能差异的情况下，针对网络传输层面的原因，我们看看如何保障一个持续的直播不卡顿。</p>
<p>&#160; &#160; &#160; &#160;这其实是一个直播过程中传输网络不可靠时的容错问题。例如，播放端临时断网了，但又快速恢复了，针对这种场景，播放端如果不做容错处理，很难不出现黑屏或是重新加载播放的现象。</p>
<p>&#160; &#160; &#160; &#160;为了容忍这种网络错误，并达到让终端用户无感知，<strong>客户端播放器可以考虑构建一个FIFO（先进先出）的缓冲队列</strong>，解码器从播放缓存队列读取数据，缓存队列从直播服务器源源不断的下载数据。通常，缓存队列的容量是以时间为单位（比如3s），在播放端网络不可靠时，客户端缓存区可以起到“断网无感”的过渡作用。</p>
<p>&#160; &#160; &#160; &#160;显然，这只是一个“缓兵之计”，如果直播服务器边缘节点出现故障，而此时客户端播放器又是长连接，在无法收到对端的连接断开信号，客户端的缓冲区容量再大也不管用了，这个时候就需要结合客户端业务逻辑来做调度。</p>
<p>&#160; &#160; &#160; &#160;重要的是客户端结合服务端，可以做精准调度。在初始化直播推流之前，例如基于 IP 地理位置和运营商的精确调度，分配线路质量最优的边缘接入节点。在直播推流的过程中，可以实时监测帧率反馈等质量数据，基于直播流的质量动态调整线路。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>1. 关键帧设置频率一般是多少？有没有根据接入动态设置？过长首屏秒会很难做到。</strong></p>
<p>徐立：关键帧间隔越长，也就是 GOP 越长，理论上画面越高清。但是生成 HLS 直播时，最小切割粒度也是一个 GOP，所以针对交互直播，通常不建议 GOP 设置太长。直播一般 2 个关键帧间隔即可。比如帧率是 24fps， 那么 2 个关键帧的间隔就是 48fps ，这个 GOP 就是2s。</p>
<p><strong>2. 七牛这个直播是用的网宿加速？有遇到什么坑没？</strong></p>
<p>徐立：七牛在直播方面主要是自建节点，也支持融合众多第三方 CDN 服务商，多样化的线路组合为客户提供更优质的服务。在和第三方 CDN 合作的过程中遇到的问题等有机会再做更细粒度的交流和分享。</p>
<p><strong>3. RTMP 直播流除了优化线路外，还有什么加速手段吗？</strong></p>
<p>徐立：物理上优化线路，逻辑上优化策略，比如选择性丢帧，不影响编码画质的前提下减轻传输体积。</p>
<p><strong>4. OBS 推流，播放端 HLS 出现视/音频不同步是哪个环节的问题？怎么优化？</strong></p>
<p>徐立：有可能是采集端的问题，如果是采集端编码环节就出现音画不同步，可以在收流服务器上做音画时间戳同步，这样是全局的校对。如果是播放端解码性能问题，那么需要调节播放逻辑，比如保证音画时间戳强一致性的前提下，选择性丢一部帧。</p>
<p><strong>5. PPT 前几页中一个概念好像错了，I 帧不是关键帧，IDR 帧才是。IDR 帧是 I 帧，但是 I 帧不一定是 IDR 帧。只有 IDR 帧才是可重入的。</strong></p>
<p>徐立：中文都把 I 帧翻译成关键帧了，不过既然提到了 IDR 帧，可以展开说明一下。所有的 IDR 帧都是 I 帧，但是并不是所有 I 帧都是 IDR 帧，IDR 帧是 I 帧的子集。I 帧严格定义是帧内编码帧，由于是一个全帧压缩编码帧，通常用 I 帧表示 “关键帧”。IDR 是基于 I 帧的一个 “扩展”，带了控制逻辑，IDR 图像都是 I 帧图像，当解码器解码到 IDR 图像时，会立即将参考帧队列清空，将已解码的数据全部输出或抛弃。重新查找参数集，开始一个新的序列。这样如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR 图像之后的图像永远不会使用 IDR 之前的图像的数据来解码。</p>
<p><strong>6. 有没有调研过 nginx rtmp module，为什么没有用，对它有什么评价？</strong></p>
<p>徐立：有调研过，nginx_rtmp_module 是单进程多线程，非 go 这种轻量级线程/协程用并发自然语义的方式编写流业务。nginx 原本的代码量较大（约 16 万行，但和直播业务相关的功能并不是很多）。且主要靠写 nginx.conf 做配置租户，通常单租户可以，但业务可扩展性方面不是很灵活，可满足基本需求，不满足高级功能。</p>
<p><strong>7. 用到了那些开源软件？编码用的是 x264 吗？直播服务器你们自己开发还是开源的？</strong></p>
<p>徐立：直播服务器用 go 开发的，移动端编码优先硬编，软编用 x264</p>
<p><strong>8. 请教一下用 OBS 推流到 nginx_rtmp_module 的时候是已经做了视频压缩了还是需要基于 OBS 再开发？</strong></p>
<p>徐立：OBS 把编码压缩都做了，不需要再开发。</p>
<p><strong>9. 视频直播想在 HLS 流中无缝插入一段广告的 ts 文件，有问题想请教一下：1、这段 ts 的分辨率是否一定要和之前的视频流一致？2、pts 时间戳是否要和上一个 ts 递增？</strong></p>
<p>徐立：<br>1、可以不一致。这种情况两段视频完全是独立状态，可以没有任何关系，只需要插入 discontinue 标记，播放器在识别到这个标记之后重置解码器参数就可以无缝播放，画面会很平滑的切换。<br>2、不需要递增。举个例子，视频 A 正在直播，播放到 pts 在 5s 的时候，插入一个视频 B，需要先插入一个 discontinue，再插入 B，等 B 播放完之后，再插入一个 discontinue，再插入 A，这个时候 A 的 pts 可以和之前递增，也可以按照中间插入的 B 的时长做偏移，一般做点播和时移的时候 pts 会连续递增，直播的话会算上 B 的时长。</p>
<p>由于移动直播在实践上还有非常多细节，本文未能全部覆盖，感兴趣的朋友欢迎在文章最后留言讨论。</p>
<h1 id="PPT-下载地址"><a href="#PPT-下载地址" class="headerlink" title="PPT 下载地址"></a>PPT 下载地址</h1><p>我备份了一分pdf，下载点<a href="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/pili_technology_sharing.pdf" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客搭建历程————————Github和Hexo]]></title>
      <url>http://windrunnerlihuan.com/2016/05/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>我的博客搭建历程，使用github pages + hexo，域名解析，配置插件<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;其实从去年开始我就想搭建一个自己的个人网站了，主要用于记录自己的技术积累和重点知识。但由于自己太懒，能力也太渣，所以就一直没有行动。直到今年，突然发现随着知识积累的增加，有好多重要的内容脑袋都记不下了，有的网页就直接存个标签，但是标签越存越多，但却很少再次去浏览，最后知识还是会淡忘，所以今天痛下决心，还是自己搭个博客吧，以挽回知识的流失，同时也可以向外部分享自己的一些见解。<br>&#160; &#160; &#160; &#160;博客搭建过程也是一波三折，遇到各种坑爹问题，还好我没那么轻易放弃，最终在无数次失败之后终于成功了。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-github配置"><a href="#1-github配置" class="headerlink" title="1. github配置"></a>1. github配置</h2><p>1）首先需要有一个github账号，没有的话就得申请一个。<br>然后新建一个代码仓库，注意，仓库名一定要是：<strong>你的github账号名字.github.io</strong>，比如我的是windrunnerlihuan.github.io。<br>2）clone到本地，比如我的就是如下命令：<br>git clone <a href="https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git" target="_blank" rel="external">https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</a><br>cd 进文件夹，我们先建个index.html用于测试：<br>cd windrunnerlihuan.github.io<br>vi index.html<br>然后编辑：<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;github pages测试&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后按esc，再输入“:wq”回车保存。然后提交上去：<br>git add .<br>git commit -m “测试github pages”<br>git push<br>此时需要输入你的github账号和密码，输入就是了，成功后我们验证一下。<br>然后打开浏览器，输入地址，比如我的就是：<a href="http://windrunnerlihuan.github.io" target="_blank" rel="external">http://windrunnerlihuan.github.io</a><br>如果能正确显示“<strong>github pages测试</strong>”字样，说明我们成功了。</p>
<hr>
<h2 id="2-hexo安装"><a href="#2-hexo安装" class="headerlink" title="2. hexo安装"></a>2. hexo安装</h2><p>&#160; &#160; &#160; &#160;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。</p>
<p>Hexo的官方网站：<a href="http://hexo.io/" target="_blank" rel="external">http://hexo.io/</a> ，也是基于Github构建的网站。</p>
<p>&#160; &#160; &#160; &#160;不过要使用hexo必须装node.js，这个easy，直接在官网<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a> 上下一个，首页就是下载页面，选一个你自己电脑平台对应的，比如我的是windows x64。如果不想看英文呢，还有个中文网站<a href="http://nodejs.cn/" target="_blank" rel="external">http://nodejs.cn/</a> ，几乎是把英文网站翻译了一遍，套路都一样。下载下来之后文件名叫<strong>node-v4.4.4-x64.msi</strong>，双击，一路next，傻瓜式安装。</p>
<p>接着安装hexo：<br>1）打开控制台（按下win + r，输入cmd，回车）或者直接在git bash界面。<br>输入 npm install -g hexo，然后开始安装hexo。<br>成功后再输入 npm install hexo-deployer-git –save，安装发布工具。</p>
<p>2）接着进入我们从github上克隆下来的windrunnerlihuan.github.io文件，再次git bash here。<br>输入 hexo init，初始化hexo。<br>完成后我们测试一下：<br>输入hexo server<br>bash控制台会打印出 “[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>. Press Ctrl+C to stop.”<br>这时端口4000被打开了，我们能过浏览器打开地址，<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/home.png" alt="hexo首页默认图片"></p>
<p>出现了默认的网页界面，是不是很容易呢！！</p>
<hr>
<h2 id="3-hexo配置"><a href="#3-hexo配置" class="headerlink" title="3. hexo配置"></a>3. hexo配置</h2><p>我们先看一下文件结构</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/file.png" alt="hexo文件结构图图片"></p>
<ul>
<li>scaffolds 脚手架，也就是一个工具模板</li>
<li>scripts 写文件的js，扩展hexo的功能</li>
<li>source 存放博客正文内容</li>
<li>source/_drafts 草稿箱</li>
<li>source/_posts 文件箱</li>
<li>themes 存放皮肤的目录</li>
<li>themes/landscape 默认的皮肤</li>
<li>_config.yml 全局的配置文件</li>
<li>db.json 静态常量</li>
</ul>
<p>在这里，我们每次用到的就是_posts目录里的文件，而_config.yml文件和themes目录是第一次配置好就行了。</p>
<p>_posts目录：Hexo是一个静态博客框架，因此没有数据库。文章内容都是以文本文件方式进行存储的，直接存储在_posts的目录。Hexo天生集成了markdown，我们可以直接使用markdown语法格式写博客，例如:hello-world.md。新增加一篇文章，就在_posts目录，新建一个xxx.md的文件。</p>
<p>themes目录：是存放皮肤的，包括一套Javascript+CSS样式和基于EJS的模板设置。通过在themes目录下，新建一个子目录，就可以创建一套新的皮肤，当然我们也可以直接在landscape上面修改。</p>
<p>我们主要改的就是_config.yml全局配置文件，以及新建文章时要增加或者修改文章在source/-posts/目录下的md文件。</p>
<p>1）修改_config.yml全局配置文件</p>
<p>_config.yml是全局的配置文件：很多的网站配置都在这个文件中定义。</p>
<ul>
<li>站点信息: 定义标题，作者，语言</li>
<li>URL: URL访问路径</li>
<li>文件目录: 正文的存储目录</li>
<li>写博客配置：文章标题，文章类型，外部链接等</li>
<li>目录和标签：默认分类，分类图，标签图</li>
<li>归档设置：归档的类型</li>
<li>服务器设置：IP，访问端口，日志输出</li>
<li>时间和日期格式： 时间显示格式，日期显示格式</li>
<li>分页设置：每页显示数量</li>
<li>评论：外挂的Disqus评论系统</li>
<li>插件和皮肤：换皮肤，安装插件</li>
<li>Markdown语言：markdown的标准</li>
<li>CSS的stylus格式：是否允许压缩</li>
<li>部署配置：github发布</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Hexo Configuration</span></span><br><span class="line"><span class="section">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="section">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="section"># Site 站点信息</span></span><br><span class="line">title: this way, little boy</span><br><span class="line">subtitle: 無限大な夢のあとの 何もない世の中じゃ</span><br><span class="line">description:</span><br><span class="line">author: Huan Li</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"><span class="section"># URL</span></span><br><span class="line"><span class="section">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line">url: http://windrunnerlihuan.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"><span class="section"># Directory 文件目录</span></span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"><span class="section"># Writing 写博客配置</span></span><br><span class="line">new<span class="emphasis">_post_</span>name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post<span class="emphasis">_asset_</span>folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="section"># Category &amp; Tag 目录和标签</span></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"><span class="section"># Date / Time format 时间和日期</span></span><br><span class="line"><span class="section">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="section">## You can customize the date format as defined in</span></span><br><span class="line"><span class="section">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="section"># Pagination 分页设置</span></span><br><span class="line"><span class="section">## Set per_page to 0 to disable pagination</span></span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"><span class="section"># Markdown Markdown语法</span></span><br><span class="line"><span class="section">## https://github.com/chjj/marked</span></span><br><span class="line">markdown:</span><br><span class="line">  gfm: true</span><br><span class="line">  pedantic: false</span><br><span class="line">  sanitize: false</span><br><span class="line">  tables: true</span><br><span class="line">  breaks: true</span><br><span class="line">  smartLists: true</span><br><span class="line">  smartypants: true</span><br><span class="line"></span><br><span class="line"><span class="section"># Deployment 部署配置</span></span><br><span class="line"><span class="section">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;其他没啥改动的，就改个<strong>Site 站点信息</strong>，<strong>URL</strong>，还有<strong>Deployment 部署配置</strong>，前两个没啥难度，这个<strong>Deployment 部署配置</strong>很重要：</p>
<ul>
<li>其中<strong>type</strong>一定要填git，因为以前低版本的hexo是github，不过现在早就废弃了。</li>
<li>其次<strong>repo</strong>填你github项目的clone地址，http/https/ssh类型都行，我的是<br><a href="https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git" target="_blank" rel="external">https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</a> 和git@github.com:windrunnerlihuan/windrunnerlihuan.github.io.git ，我填的是第一个，因为填第二个后期发布时会验证公钥，需要用git bash生成公钥，然后贴到项目的Deploy keys里，比较麻烦，所以为了省事，我填了第一个。</li>
</ul>
<p>2） 新建博客</p>
<p>接下来，我们开始新博客了，创建第一篇博客文章。Hexo建议通过命令行操作，当然你也可以直接在_posts目录下创建文件。</p>
<p>通过命令创建新文章，在bash 里输入 hexo new “新的开始”<br>在source/_posts目录下就会生成文件：”新的开始.md”。</p>
<p>然后我们编辑 <strong>新的开始.md</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 新的开始</span><br><span class="line">date: 2016-05-27 18:44:12</span><br><span class="line">tags:</span><br><span class="line">- 开始</span><br><span class="line">categories: 日志</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是**新的开始**，我用hexo创建了第一篇文章。</span><br><span class="line"></span><br><span class="line">## 引用</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">&gt; Every interaction is both precious and an opportunity to delight.</span><br><span class="line"></span><br><span class="line">## 链接</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% link gank日志 http://gank.io/ true 粉丝日志 %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">[gank日志](http://gank.io/)</span><br><span class="line"></span><br><span class="line">## 图片</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% img /images/新的开始/meizi.jpg 400 600 这是一张图片 %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">![这是一张图片](http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/meizi.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 公式</span><br><span class="line">$$J\_\alpha(x)=\sum _&#123;m=0&#125;^\infty \frac&#123;(-1)^ m&#125;&#123;m! \, \Gamma (m + \alpha + 1)&#125;&#123;\left(&#123;\frac&#123;x&#125;&#123;2&#125;&#125;\right)&#125;^&#123;2 m + \alpha &#125;$$</span><br><span class="line">感觉非常好。</span><br></pre></td></tr></table></figure>
<p>文章使用markedonw语法写的，还有很多普通或者高级的语法，这个可以问度娘或者谷歌，找找别人的帖子学学。</p>
<p>用命令行启动本地server：hexo server<br>通过浏览器打开， <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，就出现了我们新写的文章。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/newstart.png" alt="新的开始文章预览图"></p>
<hr>
<h2 id="4-发布到Github"><a href="#4-发布到Github" class="headerlink" title="4. 发布到Github"></a>4. 发布到Github</h2><p>1)  静态化处理<br>&#160; &#160; &#160; &#160;写完了文章，我们就可以发布了。要说明的一点是hexo的静态博客框架，那什么是静态博客呢？静态博客，是只包含html, javascript, css文件的网站，没有动态的脚本。虽然我们是用Node进行的开发，但博客的发布后就与Node无关了。在发布之前，我们要通过一条命令，把所有的文章都做静态化处理，就是生成对应的html, javascript, css，使得所有的文章都是由静态文件组成的。</p>
<p>输入静态化命令 ：hexo generate<br>在本地目录下，会生成一个public的目录，里面包括了所有静态化的文件。</p>
<p>2) 发布到github<br>接下来，我们把这个博客发布到github。<br>现在检查我们上次填好的_config.yml文件，找到deploy的部分，设置github的项目地址。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>然后执行部署命令：hexo deploy<br>中间过程会让你再次输入github账号和密码，输入就行了<br>成功后验证，浏览器里输入上次的地址：<a href="http://windrunnerlihuan.github.io" target="_blank" rel="external">http://windrunnerlihuan.github.io</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/newstart.png" alt="新的开始文章预览图"><br>说明我们成功了</p>
<hr>
<h2 id="5-独立购买域名与绑定"><a href="#5-独立购买域名与绑定" class="headerlink" title="5. 独立购买域名与绑定"></a>5. 独立购买域名与绑定</h2><p>&#160; &#160; &#160; &#160;有时候我们想做个人博客，想让自己的博客拥有自己的域名，那就得去买个域名了。这里我们可以通过万网申请购买：<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">https://wanwang.aliyun.com/</a>  。流程很简单，基本上一路next。<br>我也斥资45块买了个.com结尾的域名 <strong>windrunnerlihuan.com</strong> 。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/yulist.png" alt="域名列表图片"></p>
<p>然后就是解析域名了，不过解析之前你得知道你的gihub pages个人主页的ip：<br>首先ping 一下个人主页地址 ，控制台里输入 ping www.windrunnerlihuan.github.io，然后会返回一个ip，然后用这个ip设置我们刚才买的域名解析，也是轻车熟路</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/yudecode.png" alt="域名解析图片"></p>
<p>最后最重要的是：<br>1）在github项目中，新建一个文件CNAME，文件中写出你要绑定的域名windrunnerlihuan.com。通过浏览器，访问<a href="http://windrunnerlihuan.com，就打开了我们建好的博客站点。" target="_blank" rel="external">http://windrunnerlihuan.com，就打开了我们建好的博客站点。</a><br>2）由于每次执行deploy的时候，github代码仓库所有的文件都会被覆盖，所以我们最好在source目录下创建这个CNAME文件，这样每次部署就不用动手创建了。</p>
<hr>
<h2 id="6-个性化功能配置"><a href="#6-个性化功能配置" class="headerlink" title="6. 个性化功能配置"></a>6. 个性化功能配置</h2><p>1） 替换皮肤<br>博客系统流行的原因，是因为他的个人性，而皮肤正式个性化的一种体现。<br>利用hexo替换皮肤，还是比较简单的，3步完成。</p>
<p><strong>No.1</strong>  找到一个皮肤或者自己开发一个皮肤<br>打开hexo的皮肤列表页面，你可以找到很多的皮肤，网页地址： <a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/tommy351/hexo/wiki/Themes</a> 。 </p>
<p><strong>No.2</strong>放到themes目录下<br>比如，我觉得pacman( <a href="https://github.com/A-limon/pacman" target="_blank" rel="external">https://github.com/A-limon/pacman</a> )这个皮肤还不错，我就可以下载皮肤到themes目录下面。<br>通过git命令下载皮肤<br>git clone <a href="https://github.com/A-limon/pacman.git" target="_blank" rel="external">https://github.com/A-limon/pacman.git</a> themes/pacman</p>
<p><strong>No.3</strong>在_config.yml指定皮肤<br>编辑文件_config.yml，找到theme一行，改成 theme: pacman<br>本地启动hexo服务器，打开浏览器 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/pifu.png" alt="替换了皮肤的博客"></p>
<p>新皮肤的效果还不错吧，然后静态化处理，再发布到github，就完成了站点的改版。</p>
<p>这里只介绍换皮肤，当然还有其他很多功能，不过对于我来说暂时没多大卵用，如果其他人有需求可以再google或者baidu搜，也都不难，很easy。</p>
<hr>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;因为这是我第一次搭建个人博客，水平实在比较差，流程写的很粗燥，很多细节都没有涉及，望大家体谅，以后我会努力完善的，将后续文章做的更好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>http://windrunnerlihuan.com/2016/05/27/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>这是<strong>新的开始</strong>，我用hexo创建了第一篇文章。</p>
<p>通过下面的命令，就可以创建新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\javascript\nodejs-hexo&gt;hexo new 新的开始</span><br><span class="line">[info] File created at D:\workspace\javascript\nodejs-hexo\source\_posts\新的开始.md</span><br></pre></td></tr></table></figure></p>
<p>感觉非常好。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h1 id="Swig语法"><a href="#Swig语法" class="headerlink" title="Swig语法"></a>Swig语法</h1><blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote>
<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><blockquote>
<p>Every interaction is both precious and an opportunity to delight.</p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h1 id="Swig语法-1"><a href="#Swig语法-1" class="headerlink" title="Swig语法"></a>Swig语法</h1><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h1 id="Markdown语法-1"><a href="#Markdown语法-1" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h1 id="Swig语法-2"><a href="#Swig语法-2" class="headerlink" title="Swig语法"></a>Swig语法</h1><a href="http://gank.io/" title="粉丝日志" target="_blank">gank日志</a>
<h1 id="Markdown语法-2"><a href="#Markdown语法-2" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><a href="http://gank.io/" target="_blank" rel="external">gank日志</a><br><a href="404html">测试404页面</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h1 id="Swig语法-3"><a href="#Swig语法-3" class="headerlink" title="Swig语法"></a>Swig语法</h1><img src="http://static.hdslb.com/images/favicon.ico" width="100" height="100" title="这是一张图片">
<h1 id="Markdown语法-3"><a href="#Markdown语法-3" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><img src="http://static.hdslb.com/images/favicon.ico" alt="这是一张图片"></p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p>
<hr>
]]></content>
    </entry>
    
  
  
</search>
