<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android属性动画流程分析]]></title>
      <url>http://windrunnerlihuan.com/2016/06/24/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<blockquote>
<p>&#160; &#160; &#160; &#160;<strong>摘要</strong>：Google在Android3.0之后给我们带来了属性动画，是真正意义上的改变属性。对比以前的Tween动画，只能作用于View，而且Tween动画改变的只是View的绘制效果，View真正的属性并没有改变。比如，一个按钮做平移的动画，虽然按钮的确做了平移，但按钮可点击的区域并没随着平移而改变，还是在原来的位置。而属性动画则可以改变真正的属性，从而实现按钮平移时点击区域也跟着平移。通俗点说，属性动画其实就是在一定时间内，按照一定规律来改变对象的属性，从而使对象展现出动画效果。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160; Google在Android3.0之后给我们带来了属性动画，是真正意义上的改变属性。对比以前的Tween动画，只能作用于View，而且Tween动画改变的只是View的绘制效果，View真正的属性并没有改变。比如，一个按钮做平移的动画，虽然按钮的确做了平移，但按钮可点击的区域并没随着平移而改变，还是在原来的位置。而属性动画则可以改变真正的属性，从而实现按钮平移时点击区域也跟着平移。通俗点说，属性动画其实就是在一定时间内，按照一定规律来改变对象的属性，从而使对象展现出动画效果。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>&#160; &#160; &#160; &#160;我们要了解属性动画的原理，首先要知道他的用法。先整一个比较大众的吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator  </span><br><span class="line">  .ofInt(target,propName,values[])  </span><br><span class="line">  .setInterpolator(LinearInterpolator)  </span><br><span class="line">  .setEvaluator(IntEvaluator)  </span><br><span class="line">  .setDuration(<span class="number">1000</span>)  </span><br><span class="line">  .start();</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个应该都会吧，设置目标view，作用的属性，动画时长；设置插值器、估值器，这两个玩意设置最多的应该是插值器，估值器设置的应该比较少。这两个东西我们下面会逐一跟踪其踪迹；（当然还有对动画过程的回调监听，比如addListener，然后监听onAnimationStart、onAnimationEnd等等回调。不过我们这里没设，下面篇幅为讲到此处功能）；最后start,动画开始。</p>
<h2 id="猜想与假设"><a href="#猜想与假设" class="headerlink" title="猜想与假设"></a>猜想与假设</h2><p>&#160; &#160; &#160; &#160; 一般的对象中的某个属性，如果要改变其值，要么是这个属性对外<strong>public</strong>，拿到对象后可以直接修改；要么这个对象的类有自己的<strong>get/set</strong>方法。但这都是理想的情况，如果不满足以上条件，如果想改变对象属性的值，就只能通过<strong>反射</strong>了。我们先这样假设，然后往下逐一验证。</p>
<p>&#160; &#160; &#160; &#160; 再者属性动画，我们断章取义一下，既然有动画这个词在内，就会有在规定时间内按固定规则对象属性的改变，就像函数一样，y=f(x)。属性动画也一样，y好比属性值property，x好比时间time，f关系就是插值器/估值器（Interpolator/TypeEvaluator）的作用。（先这么假设吧，是否合理我们往下深挖就知道了）</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><p>&#160; &#160; &#160; &#160; 我们按着上述猜测，然后进入验证阶段，直接整源码吧。源码文件不难找，并且都在两个固定目录，frameworks\base\core\java\android\animation\ 和 frameworks\base\core\java\android\view\animation\ 下。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160; 阅读源码不一定要把 <a href="http://source.android.com/source/index.html" target="_blank" rel="external">源码</a> 整个下载下来，比如有的在SDK里本来就有的文件，用 AS 或者 Eclipse 都可以直接看。不过我推荐有时间还是把重要的源码都下载下来，用<strong>Source Insight</strong> 或者 <strong>Sublime Text</strong> 来查看。<br>&#160; &#160; &#160; &#160;其次，阅读源码一方面能让我们更清晰的理解Android SDK提供的API的流程原理，有助于开发人员更好的使用这些功能，遇到坑会有更好的解决方案。另一方面，也能够掌握其中的思想，因为一切业务都是思想的实体化，掌握了思想，才能在以后遇到问题或者需求的时候，能很快从脑中勾勒出解决思路，而不至于一脸懵逼无从下手。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; 根据上述例子，一步一步分析。</p>
<h2 id="主流程源码"><a href="#主流程源码" class="headerlink" title="主流程源码"></a>主流程源码</h2><h3 id="ofInt"><a href="#ofInt" class="headerlink" title="ofInt"></a>ofInt</h3><p>&#160; &#160; &#160; &#160;先从ofInt入手，例如这么用：.ofInt(view, “translationX”, 100)。挑一个简单明了的重载方法，其实其他的也是相同的道理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title">ofInt</span><span class="params">(Object target, String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    ObjectAnimator anim = <span class="keyword">new</span> ObjectAnimator(target, propertyName);</span><br><span class="line">    anim.setIntValues(values);</span><br><span class="line">    <span class="keyword">return</span> anim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;new了一个ObjectAnimator，构造方法传入target和propName，这么不难。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ObjectAnimator</span><span class="params">(Object target, String propertyName)</span> </span>&#123;</span><br><span class="line">       setTarget(target);</span><br><span class="line">       setPropertyName(propertyName);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//有两个方法，以此往下</span></span><br><span class="line"><span class="comment">//设置目标对象target赋给属性动画全局变量mTarget </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(@Nullable Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object oldTarget = getTarget();</span><br><span class="line">       <span class="keyword">if</span> (oldTarget != target) &#123;</span><br><span class="line">           mTarget = target == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> WeakReference&lt;Object&gt;(target);</span><br><span class="line">           <span class="comment">// New target should cause re-initialization prior to starting</span></span><br><span class="line">           mInitialized = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//同上，将propertyName赋给mPropertyName </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyName</span><span class="params">(@NonNull String propertyName)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// mValues could be null if this is being constructed piecemeal. Just record the</span></span><br><span class="line">       <span class="comment">// propertyName to be used later when setValues() is called if so.</span></span><br><span class="line">       <span class="comment">// 此时mValues为空，可以忽略判断逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (mValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">           PropertyValuesHolder valuesHolder = mValues[<span class="number">0</span>];</span><br><span class="line">           String oldName = valuesHolder.getPropertyName();</span><br><span class="line">           valuesHolder.setPropertyName(propertyName);</span><br><span class="line">           mValuesMap.remove(oldName);</span><br><span class="line">           mValuesMap.put(propertyName, valuesHolder);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//赋值给全局变量</span></span><br><span class="line">       mPropertyName = propertyName;</span><br><span class="line">       <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">       mInitialized = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;记录完target和propName，调用setIntValues。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 此时mValues为空</span></span><br><span class="line">    <span class="keyword">if</span> (mValues == <span class="keyword">null</span> || mValues.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// No values yet - this animator is being constructed piecemeal. Init the values with</span></span><br><span class="line">        <span class="comment">// whatever the current propertyName is</span></span><br><span class="line">        <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123; <span class="comment">// mProperty 也为空</span></span><br><span class="line">            setValues(PropertyValuesHolder.ofInt(mProperty, values));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//因此会走到这里</span></span><br><span class="line">            setValues(PropertyValuesHolder.ofInt(mPropertyName, values));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setIntValues(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后会走到setValues(PropertyValuesHolder.ofInt(mPropertyName, values)); 这里把我们传入的propName和values作为参数，又调用了PropertyValuesHolder的ofInt方法，我们先看里面这个，外面的那个setValues待会儿再看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertyValuesHolder <span class="title">ofInt</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntPropertyValuesHolder(propertyName, values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IntPropertyValuesHolder是PropertyValuesHolder的子类，也是个内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntPropertyValuesHolder</span><span class="params">(String propertyName, <span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(propertyName);<span class="comment">//这里会调用父类的构造</span></span><br><span class="line"> setIntValues(values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类一个参数构造方法如下，将propertyName赋给全局变量mPropertyName </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PropertyValuesHolder</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">    mPropertyName = propertyName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setIntValues(values);<span class="comment">//同样会调用父类的setIntValues方法</span></span><br><span class="line">    mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;<span class="comment">// 将父类方法得到的mKeyframes 再付给mIntKeyframes </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类setIntValues方法，为mValueType 赋值，同时为利用参数values调用KeyframeSet.ofInt(values)为mKeyframes赋值 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntValues</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">    mKeyframes = KeyframeSet.ofInt(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我们可以看到，PropertyValuesHolder的ofInt方法让器内部存储了我们的propName，然后存储了我们的mValueType，即 int.class ，并且保存了一个新的变量 <strong>mIntKeyframes</strong>。<br> &#160; &#160; &#160; &#160; 这个<strong>mIntKeyframes</strong>由 KeyframeSet.ofInt(values) 得到，顾名思义，这玩意儿应该是关键帧之类的意思吧。我们联想一下关键帧，视频不就是一帧一帧的画面组成么，其中有参考帧和关键帧，且参考帧解码也依赖于关键帧，因此关键帧是视频图像流畅完整的保证（扯远了，我们先这么理解吧，然后再验证我们的猜测）。<br>  &#160; &#160; &#160; &#160; <strong>mIntKeyframes</strong>类型为Keyframes，是个接口，实现类型为KeyframeSet。看着名字应该是关键帧集合吧，每个关键帧应该保存动画time/value(时间/值)对。那么继续验证，找到KeyframeSet.ofInt(values)方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyframeSet <span class="title">ofInt</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeyframes = values.length;</span><br><span class="line">    IntKeyframe keyframes[] = <span class="keyword">new</span> IntKeyframe[Math.max(numKeyframes,<span class="number">2</span>)];<span class="comment">//最少应该有2帧</span></span><br><span class="line">    <span class="keyword">if</span> (numKeyframes == <span class="number">1</span>) &#123;<span class="comment">//如果只传了一个参数，比如我们前面给"translationX"属性的values传入移动300            </span></span><br><span class="line">     keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>);<span class="comment">// 起始帧，属性保持原样</span></span><br><span class="line">        keyframes[<span class="number">1</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">1f</span>, values[<span class="number">0</span>]);<span class="comment">//结束帧，直接到达结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//可以设置某个属性的多个值，比如动态改变view的alpha值，例如1.0，0.8，0.4......</span></span><br><span class="line">        keyframes[<span class="number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="number">0f</span>, values[<span class="number">0</span>]);<span class="comment">//起始帧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numKeyframes; ++i) &#123;<span class="comment">//后续n帧</span></span><br><span class="line">         <span class="comment">//注意里面有个么一个片段:(float) i / (numKeyframes - 1)，这是按values个数等比例划分的</span></span><br><span class="line">            keyframes[i] =</span><br><span class="line">                    (IntKeyframe) Keyframe.ofInt((<span class="keyword">float</span>) i / (numKeyframes - <span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframeSet(keyframes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 这里应该看到KeyframeSet.ofInt(values)方法，根据values的长度构造keyframes数组，然后分别通过Keyframe的ofInt方法，去构造keyframe对象。老规矩，继续看Keyframe.ofInt如何构造Keyframe：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> mValue;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Keyframe <span class="title">ofInt</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframe(fraction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也就简单存了一下fraction，此时value默认值为0</span></span><br><span class="line">   IntKeyframe(<span class="keyword">float</span> fraction) &#123;</span><br><span class="line">       mFraction = fraction;</span><br><span class="line">       mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Keyframe <span class="title">ofInt</span><span class="params">(<span class="keyword">float</span> fraction, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IntKeyframe(fraction, value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也就简单存了一下fraction，value等</span></span><br><span class="line">   IntKeyframe(<span class="keyword">float</span> fraction, <span class="keyword">int</span> value) &#123;</span><br><span class="line">       mFraction = fraction;</span><br><span class="line">       mValue = value;</span><br><span class="line">       mValueType = <span class="keyword">int</span>.class;</span><br><span class="line">       mHasValue = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也就简单存了一下fraction和value，每个fraction对应相应的value。前面注释我特意写了个注意，这个fraction是按照帧的个数n存的，起始为0，结束为1，也就是个个数为n的等差数列an={0，1/(n-1), 2/(n-1), 3/(n-1)，……, (n-2)/(n-1), 1}。<br>&#160; &#160; &#160; &#160;然后我们看它的 return new IntKeyframeSet(keyframes);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IntKeyframeSet构造方法，调其父类KeyframeSet构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntKeyframeSet</span><span class="params">(IntKeyframe... keyframes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(keyframes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//KeyframeSet构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KeyframeSet</span><span class="params">(Keyframe... keyframes)</span> </span>&#123;</span><br><span class="line">    mNumKeyframes = keyframes.length;</span><br><span class="line">    mKeyframes = <span class="keyword">new</span> ArrayList&lt;Keyframe&gt;();</span><br><span class="line">    mKeyframes.addAll(Arrays.asList(keyframes));</span><br><span class="line">    mFirstKeyframe = mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    mLastKeyframe = mKeyframes.get(mNumKeyframes - <span class="number">1</span>);</span><br><span class="line">    mInterpolator = mLastKeyframe.getInterpolator();<span class="comment">//这个插值器是null，感觉没什么卵用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;存了有多少关键帧，开始帧，结束帧，以及插值器。</p>
<p>&#160; &#160; &#160; &#160;到这里PropertyValuesHolder.ofInt(mPropertyName, values)走完了，这个过程我们为PropertyValuesHolder对象赋了propName，valueType，keyframeSet，而keyframeSet中又存了Keyframe集合，keyframe中存储了（fraction , valuetype , value , hasValue）。</p>
<p>&#160; &#160; &#160; &#160;上面说过setValues(int… values) 会走setValues(PropertyValuesHolder.ofInt(mPropertyName, values));这一步，这是其父类ValueAnimator的方法，我们进入其父类看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PropertyValuesHolder... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numValues = values.length;</span><br><span class="line">    mValues = values;<span class="comment">//将刚才得到的PropertyValuesHolder存入</span></span><br><span class="line">    mValuesMap = <span class="keyword">new</span> HashMap&lt;String, PropertyValuesHolder&gt;(numValues);</span><br><span class="line">    <span class="comment">//再包装一层map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">        PropertyValuesHolder valuesHolder = values[i];</span><br><span class="line">        mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// New property/values/target should cause re-initialization prior to starting</span></span><br><span class="line">    mInitialized = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;首先记录了mValues，注意这里的values是PropertyValuesHolder类型的，然后通过一个mValueMap记录：key为属性的名称，值为PropertyValuesHolder 。</p>
<p>&#160; &#160; &#160; &#160;到此ofInt流程算是走完了，小结一下：<strong>ofInt记录了target,propName,values（是将我们传入的int型values，辗转转化成了PropertyValuesHolder）,以及一个mValueMap，这个map的key是propName，value是PropertyValuesHolder，在PropertyValuesHolder内部又存储了proprName, valueType , keyframeSet等等</strong>。</p>
<h3 id="setInterpolator"><a href="#setInterpolator" class="headerlink" title="setInterpolator"></a>setInterpolator</h3><p>&#160; &#160; &#160; &#160;设置插值器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterpolator</span><span class="params">(TimeInterpolator value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInterpolator = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = <span class="keyword">new</span> LinearInterpolator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也是父类ValueAnimator的方法，可以看到如果没有设置插值器，默认就是线性插值器LinearInterpolator。</p>
<h3 id="setEvaluator"><a href="#setEvaluator" class="headerlink" title="setEvaluator"></a>setEvaluator</h3><p>&#160; &#160; &#160; &#160;设置估值器，这东西用的不多。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; mValues != <span class="keyword">null</span> &amp;&amp; mValues.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          mValues[<span class="number">0</span>].setEvaluator(value);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mValues就是我们刚才ofInt里得到的PropertyValuesHolder对象，然后调用PropertyValuesHolder.setEvalutor：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">    mEvaluator = evaluator;<span class="comment">// 记录evaluator</span></span><br><span class="line">    mKeyframes.setEvaluator(evaluator);<span class="comment">// KeyframeSet再次记录evaluator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;KeyframeSet再次记录evaluator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvaluator</span><span class="params">(TypeEvaluator evaluator)</span> </span>&#123;</span><br><span class="line">     mEvaluator = evaluator;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;setEvaluator这一步就完了，也就是把估值器evaluator分别交给PropertyValuesHolder和KeyframeSet。</p>
<h3 id="setDuration"><a href="#setDuration" class="headerlink" title="setDuration"></a>setDuration</h3><p>&#160; &#160; &#160; &#160; 设置动画时长。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ObjectAnimator 的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectAnimator <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setDuration(duration); <span class="comment">//父类实现</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//VauleAnimator的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ValueAnimator <span class="title">setDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Animators cannot have negative duration: "</span> +</span><br><span class="line">                   duration);</span><br><span class="line">       &#125;</span><br><span class="line">       mUnscaledDuration = duration;</span><br><span class="line">       updateScaledDuration();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sDurationScale = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mDuration = (<span class="keyword">long</span>)(<span class="number">300</span> * sDurationScale);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> mUnscaledDuration = <span class="number">300</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateScaledDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mDuration = (<span class="keyword">long</span>)(mUnscaledDuration * sDurationScale);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 就是简单在mDuration中记录了一下动画的持续时间，这个sDurationScale默认为1，貌似是用于调整，观察动画的，比如你可以调整为10，动画就会慢10倍的播放。</p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>&#160; &#160; &#160; &#160; 以上的都比较简单，那么我们猜测start方法一定是巨复杂的。休息一下~<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子图"><br>&#160; &#160; &#160; &#160;OK，我们继续，走start()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//省略干扰代码</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">super</span>.start(); <span class="comment">//最终会调用父类的方法</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//ValueAnimator的start方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       start(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> playBackwards)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Looper.myLooper() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Animators may only be run on Looper threads"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mPlayingBackwards = playBackwards; <span class="comment">//动画是否reverse</span></span><br><span class="line">       mCurrentIteration = <span class="number">0</span>;<span class="comment">//记录当前的动画的执行次数（与setRepeatCount有关）</span></span><br><span class="line">       mPlayingState = STOPPED;<span class="comment">//动画的状态为STOPPED</span></span><br><span class="line">       mStarted = <span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">       mStartedDelay = <span class="keyword">false</span>;</span><br><span class="line">       mPaused = <span class="keyword">false</span>;<span class="comment">//标志位</span></span><br><span class="line">       updateScaledDuration(); <span class="comment">// in case the scale factor has changed since creation time</span></span><br><span class="line">       AnimationHandler animationHandler = getOrCreateAnimationHandler();<span class="comment">//生成一个AnimationHandler对象，getOrCreateAnimationHandler就是在当前线程变量ThreadLocal中取出来，没有的话，则创建一个，然后set进去。</span></span><br><span class="line">       animationHandler.mPendingAnimations.add(<span class="keyword">this</span>);<span class="comment">//AnimationHandler中包含一些List集合用于存储各种状态的ValueAnimator，将当前ValueAnimator对象，加入  animationHandler.mPendingAnimations 集合</span></span><br><span class="line">       <span class="keyword">if</span> (mStartDelay == <span class="number">0</span>) &#123; <span class="comment">//mStartDelay 默认为0，进入</span></span><br><span class="line">           <span class="comment">// This sets the initial value of the animation, prior to actually starting it running</span></span><br><span class="line">           setCurrentPlayTime(<span class="number">0</span>); <span class="comment">//这个接下来会说明</span></span><br><span class="line">           mPlayingState = STOPPED;<span class="comment">//动画的状态为STOPPED</span></span><br><span class="line">           mRunning = <span class="keyword">true</span>;<span class="comment">//标志位</span></span><br><span class="line">           notifyStartListeners();<span class="comment">//回调监听动画的接口AnimatorListener的onAnimationStart方法，如果你设置了回调监听，此时就会进行回调。</span></span><br><span class="line">       &#125;</span><br><span class="line">       animationHandler.start();<span class="comment">//最后调用，这个会细说</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> ThreadLocal&lt;AnimationHandler&gt; sAnimationHandler =</span><br><span class="line">           <span class="keyword">new</span> ThreadLocal&lt;AnimationHandler&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AnimationHandler <span class="title">getOrCreateAnimationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       AnimationHandler handler = sAnimationHandler.get();</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           handler = <span class="keyword">new</span> AnimationHandler();</span><br><span class="line">           sAnimationHandler.set(handler);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handler;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyStartListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mListeners != <span class="keyword">null</span> &amp;&amp; !mStartListenersCalled) &#123;</span><br><span class="line">           ArrayList&lt;AnimatorListener&gt; tmpListeners =</span><br><span class="line">                   (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();</span><br><span class="line">           <span class="keyword">int</span> numListeners = tmpListeners.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">               tmpListeners.get(i).onAnimationStart(<span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       mStartListenersCalled = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;start方法做了一些状态和变量初始化，其他的都很好理解，有两处方法要细说：setCurrentPlayTime(0)和animationHandler.start()，我们先看setCurrentPlayTime(0)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentPlayTime</span><span class="params">(<span class="keyword">long</span> playTime)</span> </span>&#123;</span><br><span class="line">    initAnimation();<span class="comment">//初始化动画，接下来看</span></span><br><span class="line">    <span class="keyword">long</span> currentTime = AnimationUtils.currentAnimationTimeMillis();<span class="comment">//得到当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (mPlayingState != RUNNING) &#123; <span class="comment">//之前将mPlayingState设为了STOPPED</span></span><br><span class="line">        mSeekTime = playTime;<span class="comment">//为0</span></span><br><span class="line">        mPlayingState = SEEKED; <span class="comment">//将mPlayingState 改为SEEKED</span></span><br><span class="line">    &#125;</span><br><span class="line">    mStartTime = currentTime - playTime;<span class="comment">//起始时间为当前时间</span></span><br><span class="line">    doAnimationFrame(currentTime);<span class="comment">//接下来也会看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 先看initAnimation()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mInitialized) &#123;</span><br><span class="line">        <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">            mValues[i].init(); <span class="comment">//mValues也就是之前ofInt方法得到的IntPropertyValueHolder对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        mInitialized = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 接着找IntPropertyValueHolder的init方法，在其父类发现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We already handle int and float automatically, but not their Object</span></span><br><span class="line">        <span class="comment">// equivalents</span></span><br><span class="line">        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator :</span><br><span class="line">                (mValueType == Float.class) ? sFloatEvaluator :</span><br><span class="line">                <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mEvaluator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// KeyframeSet knows how to evaluate the common types - only give it a custom</span></span><br><span class="line">        <span class="comment">// evaluator if one has been set on this class</span></span><br><span class="line">        mKeyframes.setEvaluator(mEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 其实就是遍历设置PropertyValuesHolder中的mEvaluator属性，默认根据valueType进行判断，IntEvaluator或者FloatEvaluator。</p>
<p>&#160; &#160; &#160; &#160;initAnimation()完了，然后看doAnimationFrame(currentTime)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPlayingState == STOPPED) &#123; <span class="comment">//上面已赋为SEEKED，所以不进入下面逻辑</span></span><br><span class="line">        mPlayingState = RUNNING;</span><br><span class="line">        <span class="keyword">if</span> (mSeekTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mStartTime = frameTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStartTime = frameTime - mSeekTime;</span><br><span class="line">            <span class="comment">// Now that we're playing, reset the seek time</span></span><br><span class="line">            mSeekTime = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;<span class="comment">//mPaused上面已赋为false</span></span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = frameTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;<span class="comment">//默认是false</span></span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mStartTime += (frameTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The frame time might be before the start time during the first frame of</span></span><br><span class="line">    <span class="comment">// an animation.  The "current time" must always be on or after the start</span></span><br><span class="line">    <span class="comment">// time to avoid animating frames at negative time intervals.  In practice, this</span></span><br><span class="line">    <span class="comment">// is very rare and only happens when seeking backwards.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = Math.max(frameTime, mStartTime);</span><br><span class="line">    <span class="keyword">return</span> animationFrame(currentTime);<span class="comment">//最后只走了这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 继续跟animationFrame(currentTime)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">animationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">switch</span> (mPlayingState) &#123;<span class="comment">//上面已赋为SEEKED</span></span><br><span class="line">     <span class="keyword">case</span> RUNNING:</span><br><span class="line">     <span class="keyword">case</span> SEEKED:</span><br><span class="line">         <span class="keyword">float</span> fraction = mDuration &gt; <span class="number">0</span> ? (<span class="keyword">float</span>)(currentTime - mStartTime) / mDuration : <span class="number">1f</span>;<span class="comment">//此时currentTime和mStartTime相等，fraction为0，刚开始嘛</span></span><br><span class="line">         <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//刚开始不会走这段逻辑</span></span><br><span class="line">             <span class="keyword">if</span> (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</span><br><span class="line">                 <span class="comment">// Time to repeat</span></span><br><span class="line">                 <span class="keyword">if</span> (mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">int</span> numListeners = mListeners.size();</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                         mListeners.get(i).onAnimationRepeat(<span class="keyword">this</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (mRepeatMode == REVERSE) &#123;</span><br><span class="line">                     mPlayingBackwards = !mPlayingBackwards;</span><br><span class="line">                 &#125;</span><br><span class="line">                 mCurrentIteration += (<span class="keyword">int</span>)fraction;</span><br><span class="line">                 fraction = fraction % <span class="number">1f</span>;</span><br><span class="line">                 mStartTime += mDuration;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 done = <span class="keyword">true</span>;</span><br><span class="line">                 fraction = Math.min(fraction, <span class="number">1.0f</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (mPlayingBackwards) &#123;<span class="comment">//这个是false，因为没有设置reverse</span></span><br><span class="line">             fraction = <span class="number">1f</span> - fraction;</span><br><span class="line">         &#125;</span><br><span class="line">         animateValue(fraction);<span class="comment">//最后只会走这个，继续往下看</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> done;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 然后又到了这一步animateValue(fraction)，此时fraction是0，刚开始嘛。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里会调用子类ObjectAnimator的animateValue方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Object target = getTarget();</span><br><span class="line">       <span class="keyword">if</span> (mTarget != <span class="keyword">null</span> &amp;&amp; target == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// We lost the target reference, cancel and clean up.</span></span><br><span class="line">           cancel();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">super</span>.animateValue(fraction);<span class="comment">//这里调用父类的方法</span></span><br><span class="line">       <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">           mValues[i].setAnimatedValue(target);<span class="comment">//设置属性，下面会分析</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//ValueAnimator的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">animateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;</span><br><span class="line">       fraction = mInterpolator.getInterpolation(fraction);<span class="comment">//插值器处理一下fraction</span></span><br><span class="line">       mCurrentFraction = fraction;</span><br><span class="line">       <span class="keyword">int</span> numValues = mValues.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValues; ++i) &#123;</span><br><span class="line">           mValues[i].calculateValue(fraction);<span class="comment">//之前ofInt得到的IntPropertyValueHolder对象的calculateValue方法</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//UpdateListener监听接口开始回调，比较简单</span></span><br><span class="line">       <span class="keyword">if</span> (mUpdateListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> numListeners = mUpdateListeners.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">               mUpdateListeners.get(i).onAnimationUpdate(<span class="keyword">this</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我们跟一下IntPropertyValueHolder的calculateValue方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;<span class="comment">//这个fraction是经过插值器处理过的fraction</span></span><br><span class="line">    mIntAnimatedValue = mIntKeyframes.getIntValue(fraction);<span class="comment">//这里注意是IntKeyFrameSet，千万不要看错方法了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;go on，IntKeyFrameSet的getIntValue方法，fraction是经过插值器处理过的fraction ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntValue</span><span class="params">(<span class="keyword">float</span> fraction)</span> </span>&#123;<span class="comment">//raction是经过插值器处理过的fraction</span></span><br><span class="line">    <span class="keyword">if</span> (mNumKeyframes == <span class="number">2</span>) &#123;<span class="comment">//在ofInt里只设置了一个value，则只有两个关键帧，上面分析过</span></span><br><span class="line">        <span class="keyword">if</span> (firstTime) &#123;<span class="comment">//默认是true</span></span><br><span class="line">            firstTime = <span class="keyword">false</span>;</span><br><span class="line">            firstValue = ((IntKeyframe) mKeyframes.get(<span class="number">0</span>)).getIntValue();<span class="comment">//取起始帧的value，为0</span></span><br><span class="line">            lastValue = ((IntKeyframe) mKeyframes.get(<span class="number">1</span>)).getIntValue();<span class="comment">//结束帧的value，即我们设进去的值</span></span><br><span class="line">            deltaValue = lastValue - firstValue;<span class="comment">//计算delta值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInterpolator != <span class="keyword">null</span>) &#123;<span class="comment">//这玩意儿是null，他是IntKeyFrameSet的，不是ObjectAnimator的</span></span><br><span class="line">            fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mEvaluator == <span class="keyword">null</span>) &#123;<span class="comment">//估值器，其实此处设与不设一样，实现都是firstValue + (int)(fraction * deltaValue)；这个很好看懂，想想函数y=f(X)之类，return的就是y</span></span><br><span class="line">            <span class="keyword">return</span> firstValue + (<span class="keyword">int</span>)(fraction * deltaValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//扒一下IntEvaluator和上面那个一样</span></span><br><span class="line">            <span class="keyword">return</span> ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面逻辑是ofInt设置了多个value的</span></span><br><span class="line">    <span class="keyword">if</span> (fraction &lt;= <span class="number">0f</span>) &#123;<span class="comment">//小于区间范围，将第0和第1帧作为参考</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);<span class="comment">//第1帧</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">1</span>);<span class="comment">//第2帧</span></span><br><span class="line">        <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();<span class="comment">//第1帧的属性值y1</span></span><br><span class="line">        <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();<span class="comment">//第2帧属性值y2</span></span><br><span class="line">        <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();<span class="comment">//第1帧的关系因子，x1</span></span><br><span class="line">        <span class="keyword">float</span> nextFraction = nextKeyframe.getFraction();<span class="comment">//第2帧的关系因子，x2</span></span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;<span class="comment">//null</span></span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(x-x1)/(x2-x1)</span></span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);</span><br><span class="line">        <span class="comment">//y=y1 + (x-x1)/(x2-x1)*(y2-y1),怎么样，直线方程既视感</span></span><br><span class="line">        <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                        intValue();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fraction &gt;= <span class="number">1f</span>) &#123;<span class="comment">//大于区间范围，将倒1和倒2帧作为参考，一下逻辑同上</span></span><br><span class="line">        <span class="keyword">final</span> IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">        <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">        <span class="keyword">float</span> prevFraction = prevKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">float</span> nextFraction = nextKeyframe.getFraction();</span><br><span class="line">        <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">        <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);</span><br><span class="line">        <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常范围</span></span><br><span class="line">    IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mNumKeyframes; ++i) &#123;<span class="comment">//循环遍历</span></span><br><span class="line">        IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);</span><br><span class="line">        <span class="keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;<span class="comment">//这就比较好理解了，就进参考，往下逻辑同上</span></span><br><span class="line">            <span class="keyword">final</span> TimeInterpolator interpolator = nextKeyframe.getInterpolator();</span><br><span class="line">            <span class="keyword">if</span> (interpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fraction = interpolator.getInterpolation(fraction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> intervalFraction = (fraction - prevKeyframe.getFraction()) /</span><br><span class="line">                (nextKeyframe.getFraction() - prevKeyframe.getFraction());</span><br><span class="line">            <span class="keyword">int</span> prevValue = prevKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">int</span> nextValue = nextKeyframe.getIntValue();</span><br><span class="line">            <span class="keyword">return</span> mEvaluator == <span class="keyword">null</span> ?</span><br><span class="line">                    prevValue + (<span class="keyword">int</span>)(intervalFraction * (nextValue - prevValue)) :</span><br><span class="line">                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).</span><br><span class="line">                            intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        prevKeyframe = nextKeyframe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// shouldn't get here</span></span><br><span class="line">    <span class="comment">//确实不该到这儿，google注释都这么说了</span></span><br><span class="line">    <span class="keyword">return</span> ((Number)mKeyframes.get(mNumKeyframes - <span class="number">1</span>).getValue()).intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;看注释是不是有种学霸附体的感觉^  。^至于第一种在ofInt里只设置了一个value，则只有两个关键帧，这个很好理解。可以比喻为：已知x和y成线性关系，公式为y=kx+b，告知其中一点x值为x1，求y1。一次函数的直视感。</p>
<p>&#160; &#160; &#160; &#160;第二种设置多个value也很好理解，因为动画是连续的，这是个连续函数，所以函数曲线是一条连续的线。每个关键帧都是连续函数上的固定点。虽然函数图像是连续的，但是他确是个分段函数，这些关键帧就是分段函数的拐点，而两个拐点之间的规则是一样的，就是我们定义的插值器interpolator 。<br>&#160; &#160; &#160; &#160;动画之间都是连续的，如果要求出某个时间段对象的属性值，一定要参考距离它最近两帧。所以问题就转为已知两点坐标（x1，y1），（x2，y2），和另一点的x值，求其y值。果断高一数学的直线方程整起：<br>$$    \dfrac{x-x1 }{x2-x1} = \dfrac{y-y1}{y2-y1} $$</p>
<p>$$    y=\dfrac{(x-x1) * (y2-y1) }{x2-x1} +y1 $$</p>
<p>&#160; &#160; &#160; &#160;IntKeyFrameSet的getIntValue方法就分析玩了，然后找到之前的逻辑。这样就求出属性值了，并把它赋给了ObjectAnimator的IntPropertyValueHolder类对象mValues的mIntAnimatedValue中。回到上面的子类animateValue(fraction)方法，还有一步mValues[i].setAnimatedValue(target)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAnimatedValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIntProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mIntProperty.setValue(target, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProperty.set(target, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mJniSetter != <span class="number">0</span>) &#123;</span><br><span class="line">        nCallIntMethod(target, mJniSetter, mIntAnimatedValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSetter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTmpValueArray[<span class="number">0</span>] = mIntAnimatedValue;</span><br><span class="line">            mSetter.invoke(target, mTmpValueArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"PropertyValuesHolder"</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;果然有反射，看来我们的猜测八九不离十。这样就把刚才计算的属性值设置给目标对象了。</p>
<p>&#160; &#160; &#160; &#160;确实有点晕了。。。。。回一下神，赶紧回到ObjectAnimator父类ValueAnimator的start方法里，还要继续分析第二个重要地方animationHandler.start()。animationHandler我们上面已经介绍了，存储在当前线程的ThreadLocal里面，里面放了一些集合用于存储各种状态的ObjectAnimator，我们当前的ObjectAnimator对象也存储在其mPendingAnimations的集合中（上面提到过~~）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    scheduleAnimation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAnimationScheduled) &#123;<span class="comment">//mAnimationScheduled默认false</span></span><br><span class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, <span class="keyword">this</span>, <span class="keyword">null</span>);<span class="comment">//Choreographer.CALLBACK_ANIMATION为1</span></span><br><span class="line">        mAnimationScheduled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;要用到mChoreographer这个对象的postCallback方法，其中有一个参数是this；至于什么是Choreographer，暂时不用管；但是你需要知道一件事，其实我们的animationHandler是Runnable的子类，而 mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null);类似与handler发送消息，最终执行这个Runnable的run方法。<br>&#160; &#160; &#160; &#160;Choreographer这个类里面障眼法太多了，就不贴了。绕来绕去，其实就是一句话，这里调用了animationHandler的 run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">        doAnimationFrame(mChoreographer.getFrameTime());</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAnimationFrame</span><span class="params">(<span class="keyword">long</span> frameTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mPendingAnimations holds any animations that have requested to be started</span></span><br><span class="line">        <span class="comment">// We're going to clear mPendingAnimations, but starting animation may</span></span><br><span class="line">        <span class="comment">// cause more to be added to the pending list (for example, if one animation</span></span><br><span class="line">        <span class="comment">// starting triggers another starting). So we loop until mPendingAnimations</span></span><br><span class="line">        <span class="comment">// is empty.</span></span><br><span class="line">        <span class="keyword">while</span> (mPendingAnimations.size() &gt; <span class="number">0</span>) &#123;<span class="comment">//while循环，遍历所有在mPendingAnimations中的ObjectAnimator，依次调用anim.startAnimation(this);</span></span><br><span class="line">            ArrayList&lt;ValueAnimator&gt; pendingCopy =</span><br><span class="line">                    (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone();</span><br><span class="line">            mPendingAnimations.clear();</span><br><span class="line">            <span class="keyword">int</span> count = pendingCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = pendingCopy.get(i);</span><br><span class="line">                <span class="comment">// If the animation has a startDelay, place it on the delayed list</span></span><br><span class="line">                <span class="keyword">if</span> (anim.mStartDelay == <span class="number">0</span>) &#123;<span class="comment">//不延时的直接start</span></span><br><span class="line">                    anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//延时的先加入mDelayedAnims队列</span></span><br><span class="line">                    mDelayedAnims.add(anim);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Next, process animations currently sitting on the delayed queue, adding</span></span><br><span class="line">        <span class="comment">// them to the active animations if they are ready</span></span><br><span class="line">        <span class="comment">//看有多少延时的，如果延时的时间到了就加入到准备队列mReadyAnims</span></span><br><span class="line">        <span class="keyword">int</span> numDelayedAnims = mDelayedAnims.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDelayedAnims; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = mDelayedAnims.get(i);</span><br><span class="line">            <span class="keyword">if</span> (anim.delayedAnimationFrame(frameTime)) &#123;<span class="comment">//看方法注释就是说如果延时到了就该加入动画准备集合</span></span><br><span class="line">                mReadyAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//准备队列的开始start</span></span><br><span class="line">        <span class="keyword">int</span> numReadyAnims = mReadyAnims.size();</span><br><span class="line">        <span class="keyword">if</span> (numReadyAnims &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numReadyAnims; ++i) &#123;</span><br><span class="line">                ValueAnimator anim = mReadyAnims.get(i);</span><br><span class="line">                anim.startAnimation(<span class="keyword">this</span>);</span><br><span class="line">                anim.mRunning = <span class="keyword">true</span>;</span><br><span class="line">                mDelayedAnims.remove(anim);</span><br><span class="line">            &#125;</span><br><span class="line">            mReadyAnims.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now process all active animations. The return value from animationFrame()</span></span><br><span class="line">        <span class="comment">// tells the handler whether it should now be ended</span></span><br><span class="line">        <span class="comment">//将animationHandler的mAnimations集合中的每个anim，加入到mTmpAnimations中；</span></span><br><span class="line">        <span class="keyword">int</span> numAnims = mAnimations.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">            mTmpAnimations.add(mAnimations.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次调用mTmpAnimations中的anim，anim.doAnimationFrame(frameTime)。doAnimationFrame（frameTime）上面已经分析过了，如果返回true，即doAnimationFrame的done为true，则将该动画加入到结束动画集合。 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnims; ++i) &#123;</span><br><span class="line">            ValueAnimator anim = mTmpAnimations.get(i);</span><br><span class="line">            <span class="keyword">if</span> (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</span><br><span class="line">                mEndingAnims.add(anim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mTmpAnimations.clear();</span><br><span class="line">        <span class="comment">//循环调用mEndingAnims， mEndingAnims.get(i).endAnimation(this);内部，会将动画移除mAnimations，回调动画监听接口onAnimationEnd；以及重置各种标志变量。</span></span><br><span class="line">        <span class="keyword">if</span> (mEndingAnims.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mEndingAnims.size(); ++i) &#123;</span><br><span class="line">                mEndingAnims.get(i).endAnimation(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mEndingAnims.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are still active or delayed animations, schedule a future call to</span></span><br><span class="line">        <span class="comment">// onAnimate to process the next frame of the animations.</span></span><br><span class="line">        <span class="comment">//如果mAnimations不为null，则再次调用scheduleAnimation();</span></span><br><span class="line">        <span class="keyword">if</span> (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</span><br><span class="line">            scheduleAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * Internal function called to process an animation frame on an animation that is currently</span><br><span class="line"> * sleeping through its &lt;code&gt;startDelay&lt;/code&gt; phase. The return value indicates whether it</span><br><span class="line"> * should be woken up and put on the active animations queue.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> currentTime The current animation time, used to calculate whether the animation</span><br><span class="line"> * has exceeded its &lt;code&gt;startDelay&lt;/code&gt; and should be started.</span><br><span class="line"> * <span class="doctag">@return</span> True if the animation's &lt;code&gt;startDelay&lt;/code&gt; has been exceeded and the animation</span><br><span class="line"> * should be added to the set of active animations.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">delayedAnimationFrame</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStartedDelay) &#123;<span class="comment">//默认false</span></span><br><span class="line">        mStartedDelay = <span class="keyword">true</span>;</span><br><span class="line">        mDelayStartTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;<span class="comment">//默认false</span></span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPauseTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumed) &#123;<span class="comment">//默认false</span></span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPauseTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Offset by the duration that the animation was paused</span></span><br><span class="line">            mDelayStartTime += (currentTime - mPauseTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> deltaTime = currentTime - mDelayStartTime;<span class="comment">//延时间隔</span></span><br><span class="line">    <span class="keyword">if</span> (deltaTime &gt; mStartDelay) &#123;<span class="comment">//延时超了规定延时时间，应该执行了</span></span><br><span class="line">        <span class="comment">// startDelay ended - start the anim and record the</span></span><br><span class="line">        <span class="comment">// mStartTime appropriately</span></span><br><span class="line">        mStartTime = currentTime - (deltaTime - mStartDelay);</span><br><span class="line">        mPlayingState = RUNNING;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(AnimationHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</span><br><span class="line">        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, getNameForTrace(),</span><br><span class="line">                System.identityHashCode(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    initAnimation();</span><br><span class="line">    handler.mAnimations.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mStartDelay &gt; <span class="number">0</span> &amp;&amp; mListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Listeners were already notified in start() if startDelay is 0; this is</span></span><br><span class="line">        <span class="comment">// just for delayed animations</span></span><br><span class="line">        notifyStartListeners();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;scheduleAnimation()一旦调用，就像Handler不停发消息一样，AnimationHandler的run方法就会一直调用，mChoreographer.getFrameTime()控制动画时间段，然后一直调用AnimationHandler的doAnimationFrame方法，这个方法里面又调用了ValueAnimator的doAnimationFrame方法，这个方法上面分析过了，就是计算属性应该的值，然后反射设置；再startAnimation通知回调。这样动画就一帧一帧的执行了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#160; &#160; &#160; &#160;ofInt中实例化了一个ObjectAnimator对象，然后设置了target，propName，values(PropertyValuesHolder) ；然后分别在setInterpolator，setDuration设置了Interpolator和duration。其中setEvaluator是给PropertyValuesHolder，以及keyframeSet设置估值算法。</p>
<p>&#160; &#160; &#160; &#160;PropertyValueHolder实际上是IntPropertyValueHolder类型对象，包含propName,valueType,keyframeSet .</p>
<p>&#160; &#160; &#160; &#160;keyframeset中存了Keyframe集合，keyframe中存储了（fraction , valuetype , value , hasValue）。</p>
<p>&#160; &#160; &#160; &#160;start()中：<br>&#160; &#160; &#160; &#160;首先更新动画各种状态，然后初步计算fraction为(currentTime - mStartTime) / mDuration；然后将这个fraction交给我们的插值器计算后得到新的fraction，再将新的fraction交给我们的估值算法，估值算法根据开始、结束、fraction得到当前属性（动画作用的属性）应该的值，最大调用反射进行设置；<br>&#160; &#160; &#160; &#160;start中还会根据动画的状态，如果没有结束，不断的调用AnimationHanlder的run方法;该方法内部利用mChoreographer不断的去重复第一步。</p>
<p>&#160; &#160; &#160; &#160;至此属性动画流程分析完了，也算马马虎虎，至少和我们的猜想八九不离十。看源码看的也快吐血了，这么长代码也只能了解个大概，以后有时间再好好整理一下思路。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android跨进程通信机制Binder简要分析]]></title>
      <url>http://windrunnerlihuan.com/2016/06/12/Binder%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr>
<p>&#160; &#160; &#160; &#160; 在Android系统中，每个应用都是由四大组件中之几组成，我们经常要去写一些Activity或者Service，这些Activity或者Service有时候会运行在不同的进程中，如果我们要让这些不同的Activity或者Service之间通信，就要用到Android提供的Binder机制了。</p>
<blockquote>
<p>&#160;&#160;&#160;&#160;Binder其实也不是Android提出来的一套新的进程间通信机制，它是基于<a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">OpenBinder</a>来实现的。OpenBinder最先是由<a href="https://en.wikipedia.org/wiki/Be_Inc." target="_blank" rel="external">Be Inc.</a>开发的，接着<a href="https://en.wikipedia.org/wiki/Palm,_Inc." target="_blank" rel="external">Palm Inc.</a>也着使用。现在OpenBinder的作者<a href="http://www.angryredplanet.com/~hackbod/" target="_blank" rel="external">Dianne Hackborn</a>就是在Google工作，负责Android平台的开发工作。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; Android系统是基于Linux内核的，Linux已经拥有管道，system V IPC，socket等IPC手段，比如pipe管道（有血缘关系的进程），fifo有名管道（无血缘关系的进程），mmap/munmap内存共享映射，Unix Domain Socket等等。但是Android却采用了Binder这种不同上述几种类型的特有机制，至于原因肯定有很多，比如安全，实现方式合理性，内存优化，性能等等。（这一块儿坑的很多，需要积累很多linux系统相关内容，我也是恶补了许多知识。并且Binder远远不是三言两语能够概括清楚的，所以很多底层细节无法为大家展现，比如内核部分代码细节。既然不幸入坑了，我们就一步一步往下挖吧=。=）<br><a id="more"></a></p>
<hr>
<h1 id="Binder通信模型"><a href="#Binder通信模型" class="headerlink" title="Binder通信模型"></a>Binder通信模型</h1><h2 id="Binder的优势"><a href="#Binder的优势" class="headerlink" title="Binder的优势"></a>Binder的优势</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>&#160; &#160; &#160; &#160; Binder使用Client-Server通信方式：一个进程作为Server提供诸如视频/音频解码，视频捕获，地址本查询，网络连接等服务；多个进程作为Client向Server发起服务请求，获得所需要的服务。要想实现Client-Server通信据必须实现以下两点：一是server必须有确定的访问接入点或者说地址来接受Client的请求，并且Client可以通过某种途径获知Server的地址；二是制定Command-Reply协议来传输数据。例如在网络通信中Server的访问接入点就是Server主机的IP地址+端口号，传输协议为TCP协议。对Binder而言，Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>&#160; &#160; &#160; &#160; 如果是传统的Linux IPC方式中，socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。</p>
<p>&#160; &#160; &#160; &#160; 举个例子如，Client要将一块内存数据传递给Server，一般的做法是，Client将这块数据从它的进程空间拷贝到内核空间中，然后内核再将这个数据从内核空间拷贝到Server的进程空间，这样，Server就可以访问这个数据了。但是在这种方法中，执行了两次内存拷贝操作。所以Binder设计时采用了折衷的方式，只需要把Client进程空间的数据拷贝一次到内核空间，然后Server与内核共享这个数据就可以了，整个过程只需要执行一次内存拷贝，提高了效率。同时这样更有C/S架构的模型，方便管理。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>&#160; &#160; &#160; &#160; Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</p>
<p>&#160; &#160; &#160; &#160; 基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式的安全性，这就是Binder。Binder为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。</p>
<h2 id="通信方式和引用"><a href="#通信方式和引用" class="headerlink" title="通信方式和引用"></a>通信方式和引用</h2><p>&#160; &#160; &#160; &#160; 与其它IPC不同，Binder使用了面向对象的思想来描述作为访问接入点的Binder及其在Client中的入口：Binder是一个实体位于Server中的对象，该对象提供了一套方法用以实现对服务的请求，就象类的成员函数。遍布于client中的入口可以看成指向这个binder对象的‘指针’，一旦获得了这个‘指针’就可以调用该对象的方法访问server。在Client看来，通过Binder‘指针’调用其提供的方法和通过指针调用其它任何本地对象的方法并无区别，尽管前者的实体位于远端Server中，而后者实体位于本地内存中。‘指针’是C/C++的术语，换成java的说法是引用，即Client通过Binder的引用访问Server。如果借用Windows系统开发的一个术语‘句柄’也可以用来表述Binder在Client中的存在方式。从通信的角度看，Client中的Binder也可以看作是Server Binder的<code>‘代理’</code>，在本地代表远端Server为Client提供服务。本文中会使用‘引用’或‘句柄’这个两广泛使用的术语。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160; 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。最诱人的是，这个引用和Java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; 当然面向对象只是针对应用程序而言，对于Binder驱动和内核其它模块一样使用C语言实现，没有类和对象的概念。Binder驱动为面向对象的进程间通信提供底层支持。</p>
<h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h2><p>&#160; &#160; &#160; &#160; 从英文字面上意思看，Binder具有粘结剂的意思，那么它把什么东西粘结在一起呢？在Android系统的Binder机制中，由一系统组件组成，分别是Client、Server、Service Manager和Binder驱动程序，其中Client、Server和Service Manager运行在用户空间，Binder驱动程序运行内核空间。Binder就是一种把这四个组件粘合在一起的粘结剂了，其中，核心组件便是Binder驱动程序了，Service Manager提供了辅助管理的功能，Client和Server正是在Binder驱动和Service Manager提供的基础设施上，进行Client-Server之间的通信。这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，Service Manager是域名服务器（DNS），Binder驱动是路由器。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p>&#160; &#160; &#160; &#160; 和路由器一样，Binder驱动虽然默默无闻，却是通信的核心。尽管名叫‘驱动’，实际上和硬件设备没有任何关系，只是实现方式和设备驱动程序是一样的：它工作于内核态，提供open()，mmap()，poll()，ioctl()等标准文件操作，以字符驱动设备中的misc设备注册在设备目录/dev下，用户通过/dev/binder访问该它。驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。驱动和应用程序之间定义了一套接口协议，主要功能由ioctl()接口实现，不提供read()，write()接口，因为ioctl()灵活方便，且能够一次调用实现先写后读以满足同步交互，而不必分别调用write()和read()。Binder驱动的代码每个分支位置不一样，再加上我也没有下内核的代码，<a href="https://android.googlesource.com/kernel/common/+/android-4.4/drivers/android/binder.c" target="_blank" rel="external">这里</a>先给个4.4的<code>Binder.c</code>的地址,有兴趣的可以自己研究。</p>
<h3 id="ServiceManager-与实名Binder"><a href="#ServiceManager-与实名Binder" class="headerlink" title="ServiceManager 与实名Binder"></a>ServiceManager 与实名Binder</h3><p>&#160; &#160; &#160; &#160; 和DNS类似，ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。注册了名字的Binder叫实名Binder，就象每个网站除了有IP地址外还有自己的网址。Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名叫张三的Binder，它位于某个Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及ServiceManager对实体的引用，将名字及新建的引用打包传递给ServiceManager。ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。</p>
<p>&#160; &#160; &#160; &#160; 细心的读者可能会发现其中的蹊跷：ServiceManager是一个进程，Server是另一个进程，Server向ServiceManager注册Binder必然会涉及进程间通信。当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。Binder的实现比较巧妙：预先创造一只鸡来孵蛋：ServiceManager和其它进程同样采用Binder通信，ServiceManager是Server端，有自己的Binder对象（实体），其它进程都是Client，需要通过这个Binder的引用来实现Binder的注册，查询和获取。ServiceManager提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成ServiceManager（会用到ioctl(fd, cmd, arg)函数，cmd为BINDER_SET_CONTEXT_MGR）时Binder驱动会自动为它创建Binder实体（这就是那只预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。也就是说，一个Server若要向ServiceManager注册自己Binder就必需通过0（即NULL指针）这个引用号和ServiceManager的Binder通信。类比网络通信，0号引用就好比域名服务器的地址，你必须预先手工或动态配置好。要注意这里说的Client是相对ServiceManager而言的，一个应用程序可能是个提供服务的Server，但对ServiceManager来说它仍然是个Client。</p>
<h3 id="Client-获得实名Binder的引用"><a href="#Client-获得实名Binder的引用" class="headerlink" title="Client 获得实名Binder的引用"></a>Client 获得实名Binder的引用</h3><p>&#160; &#160; &#160; &#160; Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Client也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请获得名字叫张三的Binder的引用。ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder的引用，将该引用作为回复发送给发起请求的Client。从面向对象的角度，这个Binder对象现在有了两个引用：一个位于ServiceManager中，一个位于发起请求的Client中。如果接下来有更多的Client请求该Binder，系统中就会有更多的引用指向该Binder，就象java里一个对象存在多个引用一样。而且类似的这些指向Binder的引用是强类型，从而确保只要有引用Binder实体就不会被释放掉。通过以上过程可以看出，ServiceManager象个火车票代售点，收集了所有火车的车票，可以通过它购买到乘坐各趟火车的票-得到某个Binder的引用。</p>
<h3 id="匿名-Binder"><a href="#匿名-Binder" class="headerlink" title="匿名 Binder"></a>匿名 Binder</h3><p>&#160; &#160; &#160; &#160; 并不是所有Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。如果我们是从事application开发，跨进程的自己手写AIDL文件，或者相同进程的bindService自己添加一个继承Binder的子类，那么这个Binder没有向ServiceManager注册名字，所以是个匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。</p>
<hr>
<p>好了，理论性的科普先到这里，再继续下去估计要扑（pu）街（gai）了 =。=，先来美图放松放松。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6Binder%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/meizi.jpg" alt="妹子图"></p>
<h1 id="Binder机制跨进程原理"><a href="#Binder机制跨进程原理" class="headerlink" title="Binder机制跨进程原理"></a>Binder机制跨进程原理</h1><p>&#160; &#160; &#160; &#160; 上文给出了Binder的通信模型，指出了通信过程的四个角色: Client, Server, ServiceManager, driver; 但是我们仍然不清楚<code>Client到底是如何与Server完成通信的</code>,因为实现细节我们还没讲。</p>
<p>&#160; &#160; &#160; &#160; 虽然Binder用到了面向对象的思想，但并不限制应用程序一定要使用面向对象的语言，无论是C语言还是C++语言都可以很容易的使用Binder来通信。例如尽管Android主要使用java/C++，象ServiceManager这么重要的进程就是用C语言实现的。</p>
<p>&#160; &#160; &#160; &#160; Binder本质上只是一种底层通信方式，和具体服务没有关系。为了提供具体服务，Server必须提供一套接口函数以便Client通过远程访问使用各种服务。这时通常采用Proxy设计模式：将接口函数定义在一个抽象类中，Server和Client都会以该抽象类为基类实现所有接口函数，所不同的是Server端是真正的功能实现，而Client端是对这些函数远程调用请求的包装。如何将Binder和Proxy设计模式结合起来是应用程序实现面向对象Binder通信的根本问题。</p>
<h2 id="Binder-在Server端的表述-–-Binder实体"><a href="#Binder-在Server端的表述-–-Binder实体" class="headerlink" title="Binder 在Server端的表述 – Binder实体"></a>Binder 在Server端的表述 – Binder实体</h2><p>&#160; &#160; &#160; &#160; 做为Proxy设计模式的基础，首先定义一个抽象接口类封装Server所有功能，其中包含一系列纯虚函数留待Server和Proxy各自实现（如果是java层则为接口方法，或者是AIDL文件，编译后大同小异）。由于这些函数需要跨进程调用，须为其一一编号，从而Server可以根据收到的编号决定调用哪个函数。其次就要引入Binder了。Server端定义另一个Binder抽象类处理来自Client的Binder请求数据包，其中最重要的成员是虚函数onTransact()。该函数分析收到的数据包，调用相应的接口函数处理请求。</p>
<p>&#160; &#160; &#160; &#160; 接下来采用继承方式以接口类和Binder抽象类为基类构建Binder在Server中的实体，实现基类里所有的虚函数，包括公共接口函数以及数据包处理函数：onTransact()。这个函数的输入是来自Client的binder_transaction_data结构的数据包（java层为Parcel对象，对应native层还是这个结构体某一部分）。前面提到，该结构里有个成员code，包含这次请求的接口函数编号。onTransact()将case-by-case地解析code值，从数据包里取出函数参数，调用接口类中相应的，已经实现的公共接口函数。函数执行完毕，如果需要返回数据就再构建一个binder_transaction_data包将返回数据包填入其中。</p>
<p>&#160; &#160; &#160; &#160; 那么各个Binder实体的onTransact()又是什么时候调用呢？这就需要驱动参与了。前面说过，Binder实体须要以Binde传输结构flat_binder_object形式发送给其它进程才能建立Binder通信，而Binder实体指针就存放在该结构的handle域中。驱动根据Binder位置数组从传输数据中获取该Binder的传输结构，为它创建位于内核中的Binder节点，将Binder实体指针记录在该节点中。如果接下来有其它进程向该Binder发送数据，驱动会根据节点中记录的信息将Binder实体指针填入binder_transaction_data的target.ptr中返回给接收线程。接收线程从数据包中取出该指针，reinterpret_cast成Binder抽象类并调用onTransact()函数。由于这是个虚函数，不同的Binder实体中有各自的实现，从而可以调用到不同Binder实体提供的onTransact()。</p>
<h2 id="Binder-在Client端的表述-–-Binder引用"><a href="#Binder-在Client端的表述-–-Binder引用" class="headerlink" title="Binder 在Client端的表述 – Binder引用"></a>Binder 在Client端的表述 – Binder引用</h2><p>&#160; &#160; &#160; &#160; 做为Proxy设计模式的一部分，Client端的Binder同样要继承Server提供的公共接口类并实现公共函数。但这不是真正的实现，而是对远程函数调用的包装：将函数参数打包，通过Binder向Server发送申请并等待返回值。为此Client端的Binder还要知道Binder实体的相关信息，即对Binder实体的引用。该引用或是由ServiceManager转发过来的，对实名Binder的引用或是由另一个进程直接发送过来的，对匿名Binder的引用。</p>
<p>&#160; &#160; &#160; &#160; 由于继承了同样的公共接口类，Client Binder提供了与Server Binder一样的函数原型，使用户感觉不出Server是运行在本地还是远端。Client Binder中，公共接口函数的包装方式是：创建一个binder_transaction_data数据包，将其对应的编码填入code域，将调用该函数所需的参数填入data.buffer指向的缓存中，并指明数据包的目的地，那就是已经获得的对Binder实体的引用，填入数据包的target.handle中。注意这里和Server的区别：实际上target域是个联合体，包括ptr和handle两个成员，前者用于接收数据包的Server，指向 Binder实体对应的内存空间；后者用于作为请求方的Client，存放Binder实体的引用，告知驱动数据包将路由给哪个实体。数据包准备好后，通过驱动接口发送出去。经过BC_TRANSACTION/BC_REPLY回合完成函数的远程调用并得到返回值。</p>
<hr>
<p>&#160; &#160; &#160; &#160; 以上主要是C++层实现步骤，java层也相同原理，只不过最终还会通过JNI调用C++层实现方法。<br>&#160; &#160; &#160; &#160; 我们举个栗子来描述会更通俗易懂一些：</p>
<p>&#160; &#160; &#160; &#160; 假设Client进程想要调用Server进程的<code>object</code>对象的一个方法<code>add</code>;<br>&#160; &#160; &#160; &#160; 首先，Server进程要向ServiceManager注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉ServiceManager，它叫<code>zhangsan</code>，它有一个<code>object</code>对象，可以执行<code>add</code> 操作；于是ServiceManager建立了一张表：<code>zhangsan</code>这个名字对应进程Server; </p>
<p>&#160; &#160; &#160; &#160; 然后Client向ServiceManager查询：我需要联系一个名字叫做<code>zhangsan</code>的进程里面的<code>object</code>对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的<code>object</code>对象，而是返回一个看起来跟<code>object</code>一模一样的代理对象<code>objectProxy</code>，这个<code>objectProxy</code>也有一个<code>add</code>方法，但是这个<code>add</code>方法没有Server进程里面<code>object</code>对象的<code>add</code>方法那个能力；<code>objectProxy</code>的<code>add</code>只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了ServiceManager的流程)</p>
<p>&#160; &#160; &#160; &#160; 但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着<code>objectProxy</code>对象然后调用<code>add</code>方法；我们说过，这个<code>add</code>什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>&#160; &#160; &#160; &#160; 驱动收到这个消息，发现是这个<code>objectProxy</code>；一查表就明白了：我之前用<code>objectProxy</code>替换了<code>object</code>发送给Client了，它真正应该要访问的是<code>object</code>对象的<code>add</code>方法；于是Binder驱动通知Server进程，调用你的<code>object</code>对象的<code>add</code>方法，然后把结果发给我，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给Client进程；于是整个过程就完成了。</p>
<p>&#160; &#160; &#160; &#160; 由于驱动返回的<code>objectProxy</code>与Server进程里面原始的<code>object</code>是如此相似，给人感觉好像是<strong>直接把Server进程里面的对象<code>object</code>传递到了Client进程</strong> ；因此，我们可以说<strong>Binder对象是可以进行跨进程传递的对象</strong>。</p>
<p>&#160; &#160; &#160; &#160; 但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p>
<p>&#160; &#160; &#160; &#160; 理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是代理模式, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>&#160; &#160; &#160; &#160; 另外我们为了简化整个流程，隐藏了ServiceManager这一部分驱动进行的操作；实际上，由于ServiceManager与Server通常不在一个进程，Server进程向ServiceManager注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：ServiceManager中存在的Server端的对象实际上也是代理对象，后面Client向ServiceManager查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>&#160; &#160; &#160; &#160; 一句话总结就是：<strong>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信</strong>。</p>
<h1 id="分析Java层的Binder"><a href="#分析Java层的Binder" class="headerlink" title="分析Java层的Binder"></a>分析Java层的Binder</h1><p>&#160; &#160; &#160; &#160;  Android系统的很多服务都是由C++层的Binder实现，过程复杂先不说，主要是代码量巨多，分析起来篇幅远远不够，即使不分析完全，估计粘一半代码都快吐血了，所以就选了java层的Binder，会重点分析AIDL过程。</p>
<p>&#160; &#160; &#160; &#160;  我们使用AIDL接口的时候，经常会接触到这些类：<strong>IBinder/IInterface/Binder/BinderProxy/Stub</strong>，相关功能如下：</p>
<ul>
<li>IBinder是一个接口，它代表了<strong>一种跨进程传输的能力</strong>；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是<strong>Binder本地对象</strong>。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<h2 id="AIDL过程分析"><a href="#AIDL过程分析" class="headerlink" title="AIDL过程分析"></a>AIDL过程分析</h2><p>&#160; &#160; &#160; &#160; 现在我们通过一个AIDL的使用，分析一下整个通信过程中，各个角色到底做了什么，AIDL到底是如何完成通信的。<br>&#160; &#160; &#160; &#160; 首先定一个一个简单的aidl接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ITest.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.windrunnerlihuan;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后用编译工具编译之后，可以得到对应的ITest.java类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.windrunnerlihuan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITest</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span></span><br><span class="line">			<span class="title">com</span>.<span class="title">windrunnerlihuan</span>.<span class="title">ITest</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.windrunnerlihuan.ITest"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span><br><span class="line">		 * Cast an IBinder object into an com.windrunnerlihuan.ITest interface,</span><br><span class="line">		 * generating a proxy if needed.</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> com.windrunnerlihuan.<span class="function">ITest <span class="title">asInterface</span><span class="params">(</span><br><span class="line">				android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">			<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.windrunnerlihuan.ITest))) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((com.windrunnerlihuan.ITest) iin);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> com.windrunnerlihuan.ITest.Stub.Proxy(obj);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span><br><span class="line">				android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">				<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">			<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">			<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">				reply.writeString(DESCRIPTOR);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">				data.enforceInterface(DESCRIPTOR);</span><br><span class="line">				<span class="keyword">int</span> _arg0;</span><br><span class="line">				_arg0 = data.readInt();</span><br><span class="line">				<span class="keyword">int</span> _arg1;</span><br><span class="line">				_arg1 = data.readInt();</span><br><span class="line">				<span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">				reply.writeNoException();</span><br><span class="line">				reply.writeInt(_result);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">windrunnerlihuan</span>.<span class="title">ITest</span> </span>&#123;</span><br><span class="line">			<span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">			Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">				mRemote = remote;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> mRemote;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">				android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">				android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">				<span class="keyword">int</span> _result;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">					_data.writeInt(a);</span><br><span class="line">					_data.writeInt(b);</span><br><span class="line">					mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">					_reply.readException();</span><br><span class="line">					_result = _reply.readInt();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					_reply.recycle();</span><br><span class="line">					_data.recycle();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> _result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 系统帮我们生成了这个文件之后，我们只需要继承ITest.Stub这个抽象类，实现它的方法，然后在Service 的onBind方法里面返回就实现了AIDL。这个Stub类非常重要，具体看看它做了什么。</p>
<p>&#160; &#160; &#160; &#160; Stub类继承自Binder，意味着这个Stub其实自己是一个Binder本地对象，然后实现了ITest接口，ITest本身是一个IInterface，因此他携带某种客户端需要的能力（这里是方法<code>add</code>)。此类有一个内部类Proxy，也就是Binder代理对象；</p>
<p>&#160; &#160; &#160; &#160; 然后看看<code>asInterface</code>方法，我们在bind一个Service之后，在onServiceConnecttion的回调里面，就是通过这个方法拿到一个远程的service的，这个方法做了什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Cast an IBinder object into an com.windrunnerlihuan.ITest interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.windrunnerlihuan.<span class="function">ITest <span class="title">asInterface</span><span class="params">(</span><br><span class="line">		android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">	<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.windrunnerlihuan.ITest))) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((com.windrunnerlihuan.ITest) iin);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> com.windrunnerlihuan.ITest.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 首先看函数的参数<code>IBinder</code>类型的obj，这个对象是驱动给我们的，如果是Binder本地对象，那么它就是Binder类型，如果是Binder代理对象，那就是<code>BinderProxy</code>类型；然后，正如上面自动生成的文档所说，它会试着查找Binder本地对象，如果找到，说明Client和Server都在同一个进程，这个参数直接就是本地对象，直接强制类型转换然后返回，如果找不到，说明是远程对象（处于另外一个进程）那么就需要创建一个Binde代理对象，让这个Binder代理实现对于远程对象的访问。一般来说，如果是与一个远程Service对象进行通信，那么这里返回的一定是一个Binder代理对象，这个IBinder参数的实际上是BinderProxy;</p>
<p>&#160; &#160; &#160; &#160; 再看看我们对于aidl的<code>add</code> 方法的实现；在<code>Stub</code>类里面，add是一个抽象方法，我们需要继承这个类并实现它；如果Client和Server在同一个进程，那么直接就是调用这个方法；那么，如果是远程调用，这中间发生了什么呢？Client是如何调用到Server的方法的？</p>
<p>&#160; &#160; &#160; &#160; 我们知道，对于远程方法的调用，是通过Binder代理完成的，在这个例子里面就是<code>Proxy</code>类；<code>Proxy</code>对于<code>add</code>方法的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">	android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">	<span class="keyword">int</span> _result;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		_data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">		_data.writeInt(a);</span><br><span class="line">		_data.writeInt(b);</span><br><span class="line">		mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">		_reply.readException();</span><br><span class="line">		_result = _reply.readInt();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		_reply.recycle();</span><br><span class="line">		_data.recycle();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 它首先用<code>Parcel</code>把数据序列化了，然后调用了<code>transact</code>方法；这个<code>transact</code>到底做了什么呢？这个<code>Proxy</code>类在<code>asInterface</code>方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是<code>BinderProxy</code>, 因此我们的<code>Proxy</code>类里面的<code>mRemote</code>实际类型应该是<code>BinderProxy</code>；我们看看<code>BinderProxy</code>的<code>transact</code>方法：(Binder.java的内部类)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transactNative</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></p>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这段不用看</span></span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//把java对象解析为C++对象</span></span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把java对象解析为C++对象</span></span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*这部分得说明一下，这是个坑，有兴趣的可以挖：在获取Service Manager远程接口时，在JNI层中，创建了一个BpBinder对象，它的句柄值为0，它的地址保存在gBinderProxyOffsets.mObject中，因此，这里通过下面语句得到这个BpBinder对象的IBinder接口：*/</span></span><br><span class="line">    IBinder* target = (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been finalized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印LOG，忽略</span></span><br><span class="line">    ALOGV(<span class="string">"Java code calling transact on %p in Java object %p with code %"</span> PRId32 <span class="string">"\n"</span>,</span><br><span class="line">            target, obj, code);</span><br><span class="line"><span class="comment">//干扰视线的宏，忽略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_BINDER_SAMPLE</span></span><br><span class="line">    <span class="comment">// Only log the binder call duration for things on the Java-level main thread.</span></span><br><span class="line">    <span class="comment">// But if we don't</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> time_binder_calls = should_time_binder_calls();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> start_millis;</span><br><span class="line">    <span class="keyword">if</span> (time_binder_calls) &#123;</span><br><span class="line">        start_millis = uptimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">//这段才是重点</span></span><br><span class="line">    <span class="comment">//printf("Transact from Java code to %p sending: ", target); data-&gt;print();</span></span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    <span class="comment">//if (reply) printf("Transact from Java code to %p received: ", target); reply-&gt;print();</span></span><br><span class="line"><span class="comment">//下面都可以忽略了    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE_BINDER_SAMPLE</span></span><br><span class="line">    <span class="keyword">if</span> (time_binder_calls) &#123;</span><br><span class="line">        conditionally_log_binder_call(start_millis, target, code);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>);</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 我在注释中说这儿有个坑，有兴趣的就去挖吧，就是在获取Service Manager远程接口时，在JNI层中，创建了一个<code>BpBinder</code>对象，它的句柄值为0，它的地址保存在<code>gBinderProxyOffsets.mObject</code>中，因此，还得去找<code>BpBinder</code>的<code>transact</code>方法，<code>BpBinder</code>的位置在framework\native\libs\binder\BpBinder.cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">	    <span class="comment">//唉，又是个坑，继续挖IPCThreadState</span></span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 继续挖IPCThreadState，位于framework\native\libs\binder\IPCThreadState.cpp(这个self函数就不贴了，就是个单例写法):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"> </span><br><span class="line">    flags |= TF_ACCEPT_FDS;    </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//调用writeTransactionData 发送数据</span></span><br><span class="line">		err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; </span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">      ....等回复</span><br><span class="line"></span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   ....    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">再进一步，瞧瞧这个...</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面把命令数据封装成binder_transaction_data，然后写到mOut中，mOut是命令的缓冲区，也是一个Parcel</span></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"><span class="comment">//仅仅写到了Parcel中，Parcel好像没和/dev/binder设备有什么关联啊？</span></span><br><span class="line"><span class="comment">//恩，那只能在另外一个地方写到binder设备中去了。难道是在？</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说对了，就是在waitForResponse中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//talkWithDriver，哈哈，应该是这里了</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//看见没？这里开始操作mIn了，看来talkWithDriver中</span></span><br><span class="line"><span class="comment">//把mOut发出去，然后从driver中读到数据放到mIn中了。</span></span><br><span class="line">        cmd = mIn.readInt32(); </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">binder_write_read bwr;</span><br><span class="line">   <span class="comment">//中间东西太复杂了，不就是把mOut数据和mIn接收数据的处理后赋值给bwr吗？</span></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//用ioctl来读写</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">  &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"><span class="comment">//到这里，回复数据就在bwr中了，bmr接收回复数据的buffer就是mIn提供的</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 里面进行了一系列的函数调用，确实是个巨恶心的过程；要知道的是它最终调用到了talkWithDriver函数；看这个函数的名字就知道，通信过程要交给驱动完成了（驱动调用是个更恶心的过程，感觉真不是人看的。。。。。）；<br>&#160; &#160; &#160; &#160; （以下过程限于篇幅和巨恶心的过程，所以简要概括，有兴趣的可以自己去挖坑=。=）<br>&#160; &#160; &#160; &#160; 这个函数最后通过ioctl系统调用，Client进程陷入内核态，Client调用add方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的onTransact函数（实际上由Server端线程池完成）。我们再看Binder本地对象的onTransact方法（这里就是Stub类里面的此方法）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span><br><span class="line">		android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">		<span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">	<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">		reply.writeString(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">		data.enforceInterface(DESCRIPTOR);</span><br><span class="line">		<span class="keyword">int</span> _arg0;</span><br><span class="line">		_arg0 = data.readInt();</span><br><span class="line">		<span class="keyword">int</span> _arg1;</span><br><span class="line">		_arg1 = data.readInt();</span><br><span class="line">		<span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">		reply.writeNoException();</span><br><span class="line">		reply.writeInt(_result);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; 在Server进程里面，<code>onTransact</code>根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的<code>add</code>方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。</p>
<p>&#160; &#160; &#160; &#160; 至此，你应该对AIDL这种通信方式里面的各个类以及各个角色有了一定的了解；它总是那么一种固定的模式：一个需要跨进程传递的对象一定继承自IBinder，如果是Binder本地对象，那么一定继承Binder实现IInterface，如果是代理对象，那么就实现了IInterface并持有了IBinder引用；</p>
<p>&#160; &#160; &#160; &#160; Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。如果把这个过程做一个类比，在封建社会，Stub好比皇帝，可以号令天下，他生而具有这个权利（不要说宣扬封建迷信。。）如果一个人也想号令天下，可以，“挟天子以令诸侯”。为什么不自己去当皇帝，其一，一般情况没必要，当了皇帝其实限制也蛮多的是不是？我现在既能掌管天下，又能不受约束（Java单继承）；其二，名不正言不顺啊，我本来特么就不是（Binder），你非要我是说不过去，搞不好还会造反。最后呢，如果想当皇帝也可以，那就是asBinder了。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>&#160; &#160; &#160; &#160; 再去翻阅系统的ActivityManagerServer的源码，就知道哪一个类是什么角色了：IActivityManager是一个IInterface，它代表远程Service具有什么能力，ActivityManagerNative指的是Binder本地对象（类似AIDL工具生成的Stub类），这个类是抽象类，它的实现是ActivityManagerService；因此对于AMS的最终操作都会进入ActivityManagerService这个真正实现；同时如果仔细观察，ActivityManagerNative.java里面有一个非公开类ActivityManagerProxy, 它代表的就是Binder代理对象；是不是跟AIDL模型一模一样呢？那么ActivityManager是什么？他不过是一个管理类而已，可以看到真正的操作都是转发给ActivityManagerNative进而交给他的实现ActivityManagerService 完成的。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160; 至此分析Binder就告一段落了，也是一个越往下挖越恶心的东西。等以后有机会系统学一下Linux内核的知识。虽然兴趣是最好的老师，但是学习也是个循序渐进的过程，不可能一口吃成大胖子。知识的积累也是需要脚踏实地，一步一个脚印。量变引起质变，见多识广之后才能厚积薄发，逐渐形成自己的思维，使自己成长的更强大。同时，积累过程最忌浮躁，不可因外界环境干扰心境，要始终勿忘初心，心态保持平静，不随波逐流，上善若水。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[移动直播技术秒开优化经验]]></title>
      <url>http://windrunnerlihuan.com/2016/06/06/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;以下内容来自<code>@高可用架构</code>，这次当一回技术的搬运工，为大家分享七牛创始人之一————徐立的<code>移动直播技术秒开优化经验</code>。<br><a id="more"></a></p>
<hr>
<blockquote>
<p><div align="center"><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/head.jpg" title="徐立"></div><br>&#160; &#160; &#160; &#160;徐立，七牛创始合伙人兼产品副总裁，负责七牛直播云的整体研发，是国内 Go / Docker / Container 技术早期布道者，&gt;Go / Containers / Distributed Systems 技术的忠实爱好者和实践者。曾合著国内第一本 Go 语言图书《Go 语言编程》，翻译《Go 语言程序设计》。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;现今移动直播技术上的挑战要远远难于传统设备或电脑直播，其完整的处理环节包括但不限于：音视频采集、美颜/滤镜/特效处理、编码、封包、推流、转码、分发、解码/渲染/播放等。</p>
<p>直播常见的问题包括：</p>
<ul>
<li>主播在不稳定的网络环境下如何稳定推流？</li>
<li>偏远地区的观众如何高清流畅观看直播？</li>
<li>直播卡顿时如何智能切换线路？</li>
<li>如何精确度量直播质量指标并实时调整？</li>
<li>移动设备上不同的芯片平台如何高性能编码和渲染视频？</li>
<li>美颜等滤镜特效处理怎么做？</li>
<li>如何实现播放秒开？</li>
<li>如何保障直播持续播放流畅不卡顿？</li>
</ul>
<p>本次分享将为大家揭开移动直播核心技术的神秘面纱。</p>
<h1 id="视频、直播等基础知识"><a href="#视频、直播等基础知识" class="headerlink" title="视频、直播等基础知识"></a>视频、直播等基础知识</h1><h2 id="什么是视频？"><a href="#什么是视频？" class="headerlink" title="什么是视频？"></a>什么是视频？</h2><p>&#160; &#160; &#160; &#160;首先我们需要理解一个最基本的概念：视频。从感性的角度来看，视频就是一部充满趣味的影片，可以是电影，可以是短片，是一连贯的视觉冲击力表现丰富的画面和音频。但从理性的角度来看，视频是一种有结构的数据，用工程的语言解释，我们可以把视频剖析成如下结构：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whatisav.jpg" alt=""><br>内容元素 ( Content )</p>
<ul>
<li>图像 ( Image )</li>
<li>音频 ( Audio )</li>
<li>元信息 ( Metadata )</li>
</ul>
<p>编码格式 ( Codec )</p>
<ul>
<li>Video : H.264，H.265, …</li>
<li>Audio : AAC， HE-AAC, …</li>
</ul>
<p>容器封装 (Container)</p>
<ul>
<li>MP4，MOV，FLV，RM，RMVB，AVI，…</li>
</ul>
<p>任何一个视频 Video 文件，从结构上讲，都是这样一种组成方式：</p>
<ul>
<li>由图像和音频构成最基本的内容元素；</li>
<li>图像经过视频编码压缩格式处理（通常是 H.264）；</li>
<li>音频经过音频编码压缩格式处理（例如 AAC）；</li>
<li>注明相应的元信息（Metadata）；</li>
</ul>
<p>最后经过一遍容器（Container）封装打包（例如 MP4），构成一个完整的视频文件。</p>
<p>&#160; &#160; &#160; &#160;如果觉得难以理解，可以想象成一瓶番茄酱。最外层的瓶子好比这个容器封装（Container），瓶子上注明的原材料和加工厂地等信息好比元信息（Metadata），瓶盖打开（解封装）后，番茄酱本身好比经过压缩处理过后的编码内容，番茄和调料加工成番茄酱的过程就好比编码（Codec），而原材料番茄和调料则好比最原本的内容元素（Content）。</p>
<h2 id="视频的实时传输"><a href="#视频的实时传输" class="headerlink" title="视频的实时传输"></a>视频的实时传输</h2><p>&#160; &#160; &#160; &#160;简而言之，理性的认知视频的结构后，有助于我们理解视频直播。如果视频是一种“有结构的数据”，那么视频直播无疑是<strong>实时传输</strong>这种“有结构的数据”（视频）的方式。</p>
<p>&#160; &#160; &#160; &#160;那么一个显而易见的问题是：如何实时（Real-Time）传输这种“有结构的数据”（视频）呢？</p>
<p>&#160; &#160; &#160; &#160;这里边一个悖论是：一个经过容器（Container）封装后的视频，一定是不可变的 ( Immutable ) 视频文件，不可变的 ( Immutable ) 的视频文件已经是一个生产结果，根据“相对论”，而这个生产结果显然不可能精确到实时的程度，它已经是一段时空的记忆。</p>
<p>&#160; &#160; &#160; &#160;因此视频直播，一定是一个 “边生产，边传输，边消费” 的过程。这意味着，我们需要更近一步了解视频从原始的内容元素 ( 图像和音频 ) 到成品 ( 视频文件 ) 之前的中间过程 ( 编码 )。</p>
<h2 id="视频编码压缩"><a href="#视频编码压缩" class="headerlink" title="视频编码压缩"></a>视频编码压缩</h2><p>&#160; &#160; &#160; &#160;不妨让我们来深入浅出理解视频编码压缩技术。</p>
<p>&#160; &#160; &#160; &#160;为了便于视频内容的存储和传输，通常需要减少视频内容的体积，也就是需要将原始的内容元素(图像和音频)经过压缩，压缩算法也简称编码格式。例如视频里边的原始图像数据会采用 H.264 编码格式进行压缩，音频采样数据会采用 AAC 编码格式进行压缩。</p>
<p>&#160; &#160; &#160; &#160;视频内容经过编码压缩后，确实有利于存储和传输; 不过当要观看播放时，相应地也需要解码过程。因此编码和解码之间，显然需要约定一种编码器和解码器都可以理解的约定。就视频图像编码和解码而言，这种约定很简单：</p>
<p><strong>编码器将多张图像进行编码后生产成一段一段的 GOP ( Group of Pictures ) ， 解码器在播放时则是读取一段一段的 GOP 进行解码后读取画面再渲染显示。</strong><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whathappend1.jpg" alt=""><br>&#160; &#160; &#160; &#160;GOP ( Group of Pictures ) 是一组连续的画面，由一张 I 帧和数张 B / P 帧组成，是视频图像编码器和解码器存取的基本单位，它的排列顺序将会一直重复到影像结束。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/whathappend2.jpg" alt=""><br>&#160; &#160; &#160; &#160;I 帧是内部编码帧（也称为关键帧），P 帧是前向预测帧（前向参考帧），B 帧是双向内插帧（双向参考帧）。简单地讲，I 帧是一个完整的画面，而 P 帧和 B 帧记录的是相对于 I 帧的变化。</p>
<p><strong>如果没有 I 帧，P 帧和 B 帧就无法解码。</strong><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/mainvsref.jpg" alt=""><br>&#160; &#160; &#160; &#160;小结一下，一个视频 ( Video ) ，其图像部分的数据是一组 GOP 的集合, 而单个 GOP 则是一组 I / P / B 帧图像的集合。</p>
<p>&#160; &#160; &#160; &#160;在这样的一种几何关系中，Video 好比一个 “物体”，GOP 好比 “分子”，I / P / B 帧的图像则好比 “原子”。</p>
<p>&#160; &#160; &#160; &#160;想象一下，如果我们把传输一个 “物体”，改成传输一个一个的 “原子”，将最小颗粒以光速传送，那么以人的生物肉眼来感知，将是一种怎样的体验？</p>
<h2 id="什么是视频直播？"><a href="#什么是视频直播？" class="headerlink" title="什么是视频直播？"></a>什么是视频直播？</h2><p>&#160; &#160; &#160; &#160;不难脑洞大开一下，直播就是这样的一种体验。视频直播技术，就是将视频内容的最小颗粒 ( I / P / B 帧，…)，基于时间序列，以光速进行传送的一种技术。</p>
<p>&#160; &#160; &#160; &#160;简而言之，直播就是将每一帧数据 ( Video / Audio / Data Frame )，打上时序标签 ( Timestamp ) 后进行流式传输的过程。发送端源源不断的采集音视频数据，经过编码、封包、推流，再经过中继分发网络进行扩散传播，播放端再源源不断地下载数据并按时序进行解码播放。如此就实现了 “边生产、边传输、边消费” 的直播过程。</p>
<p>&#160; &#160; &#160; &#160;理解以上两个关于<code>视频</code>和<code>直播</code>两个基础概念后，接下来我们就可以一窥直播的业务逻辑了。</p>
<h2 id="直播的业务逻辑"><a href="#直播的业务逻辑" class="headerlink" title="直播的业务逻辑"></a>直播的业务逻辑</h2><p>如下是一个最精简的一对多直播业务模型，以及各个层级之间的协议。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/liveprotocol.jpg" alt=""><br>各协议差异对比如下：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/protocoldiff1.jpg" alt=""><br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/protocoldiff2.jpg" alt=""><br>以上就是关于直播技术的一些基础概念。下面我们进一步了解下影响人们视觉体验的直播性能指标。</p>
<h1 id="影响视觉体验的直播性能指标"><a href="#影响视觉体验的直播性能指标" class="headerlink" title="影响视觉体验的直播性能指标"></a>影响视觉体验的直播性能指标</h1><p>&#160; &#160; &#160; &#160;<strong>直播第一个性能指标是延迟</strong>，延迟是数据从信息源发送到目的地所需的时间。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay1.jpg" alt=""><br>根据爱因斯坦的狭义相对论，光速是所有能量、物质和信息运动所能达到的最高速度，这个结论给传播速度设定了上限。因此，即便我们肉眼感觉到的实时，实际上也是有一定的延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay2.jpg" alt=""><br>由于 RTMP/HLS 是基于 TCP 之上的应用层协议，TCP 三次握手，四次挥手，慢启动过程中的每一次往返来回，都会加上一次往返耗时 ( RTT )，这些交互过程都会增加延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay3.jpg" alt=""><br>其次根据 TCP 丢包重传特性，网络抖动可能导致丢包重传，也会间接导致延迟加大。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/jitter.jpg" alt=""><br>&#160; &#160; &#160; &#160;一个完整的直播过程，包括但不限于以下环节：<strong>采集、处理、编码、封包、推流、传输、转码、分发、拉流、解码、播放</strong>。从推流到播放，再经过中间转发环节，延迟越低，则用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;<strong>第二个直播性能指标卡顿</strong>，是指视频播放过程中出现画面滞帧，让人们明显感觉到“卡”。单位时间内的播放卡顿次数统计称之为卡顿率。</p>
<p>&#160; &#160; &#160; &#160;造成卡顿的因素有可能是推流端发送数据中断，也有可能是公网传输拥塞或网络抖动异常，也有可能是终端设备的解码性能太差。卡顿频次越少或没有，则说明用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;<strong>第三个直播性能指标首屏耗时</strong>，指第一次点击播放后，肉眼看到画面所等待的时间。技术上指播放器解码第一帧渲染显示画面所花的耗时。通常说的 “秒开”，指点击播放后，一秒内即可看到播放画面。首屏打开越快，说明用户体验越好。</p>
<p>&#160; &#160; &#160; &#160;如上三个直播性能指标，分别对应一个低延迟、高清流畅、极速秒开 的用户体验诉求。了解这三个性能指标，对优化移动直播 APP 的用户体验至关重要。</p>
<p>&#160; &#160; &#160; &#160;那么移动直播场景下具体而言有哪些常见的坑呢？</p>
<p>&#160; &#160; &#160; &#160;根据实践总结下来的经验，移动平台上视频直播的坑主要可以总结为两方面：设备差异，以及网络环境这些场景下带来的技术考验。</p>
<h1 id="移动直播场景的坑与规避措施"><a href="#移动直播场景的坑与规避措施" class="headerlink" title="移动直播场景的坑与规避措施"></a>移动直播场景的坑与规避措施</h1><h2 id="不同芯片平台上的编码差异"><a href="#不同芯片平台上的编码差异" class="headerlink" title="不同芯片平台上的编码差异"></a>不同芯片平台上的编码差异</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/delay2.jpg" alt=""><br><strong>iOS 平台上无论硬编还是软编，由于是 Apple 一家公司出厂，几乎不存在因为芯片平台不同而导致的编码差异</strong>。</p>
<p>&#160; &#160; &#160; &#160;然而，在 Android 平台上，Android Framework SDK 提供的 MediaCodec 编码器，在不同的芯片平台上，差异表现很大， 不同的厂家使用不同的芯片，而不同的芯片平台上 Android MediaCodec 表现略有差异，通常实现全平台兼容的成本不低。</p>
<p>&#160; &#160; &#160; &#160;另外就是 Android MediaCodec 硬编层面的 H.264 编码画质参数是固定的 baseline，所以画质通常也一般。因此，在 Android 平台下，<strong>推荐是用软编，好处是画质可调控，兼容性也更好</strong>。</p>
<h2 id="低端设备如何上高性能地采集和编码？"><a href="#低端设备如何上高性能地采集和编码？" class="headerlink" title="低端设备如何上高性能地采集和编码？"></a>低端设备如何上高性能地采集和编码？</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/gether.jpg" alt=""><br>&#160; &#160; &#160; &#160;例如 Camera 采集输出的可能是图片，一张图的体积并不会小，如果采集的频次很高，编码的帧率很高，每张图都经过编码器，那么编码器又可能会出现过载。</p>
<p>&#160; &#160; &#160; &#160;这个时候，可以考虑在编码前，不影响画质的前提下（前面我们讲过帧率的微观意义），进行<strong>选择性丢帧</strong>，以此降低编码环节的功耗开销。</p>
<h2 id="弱网下如何保障高清流畅推流"><a href="#弱网下如何保障高清流畅推流" class="headerlink" title="弱网下如何保障高清流畅推流"></a>弱网下如何保障高清流畅推流</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/resource.jpg" alt=""><br>&#160; &#160; &#160; &#160;移动网络下，通常容易遇到网络不稳定，连接被重置，断线重连，一方面频繁重连，建立连接需要开销。另一方面尤其是发生 GPRS / 2G / 3G / 4G 切换时，带宽可能出现瓶颈。当带宽不够，帧率较高/码率较高的内容较难发送出去，这个时候就需要可变码率支持。</p>
<p>&#160; &#160; &#160; &#160;即在推流端，可检测网络状态和简单测速，动态来切换码率，以保障网络切换时的推流流畅。</p>
<p>&#160; &#160; &#160; &#160;其次编码、封包、推流 这一部分的逻辑也可以做微调，可以尝试选择性丢帧，比如优先丢视频参考帧（不丢 I 帧和音频帧 )，这样也可以减少要传输的数据内容，但同时又达到了不影响画质和版视听流畅的目的。</p>
<h2 id="需要区分直播流的状态和业务状态"><a href="#需要区分直播流的状态和业务状态" class="headerlink" title="需要区分直播流的状态和业务状态"></a>需要区分直播流的状态和业务状态</h2><p>&#160; &#160; &#160; &#160;直播是媒体流、APP 的交互是 API 信令流，两者的状态不能混为一谈。尤其是不能基于 APP 的交互的 API 状态来判断直播流的状态。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/seeproduct.jpg" alt=""><br>以上是移动直播场景下常见的几个坑和规避措施。</p>
<h1 id="移动直播场景其他优化措施"><a href="#移动直播场景其他优化措施" class="headerlink" title="移动直播场景其他优化措施"></a>移动直播场景其他优化措施</h1><h2 id="一、怎么优化打开速度，达到传说中的-“秒开”？"><a href="#一、怎么优化打开速度，达到传说中的-“秒开”？" class="headerlink" title="一、怎么优化打开速度，达到传说中的 “秒开”？"></a>一、怎么优化打开速度，达到传说中的 “秒开”？</h2><p>一、怎么优化打开速度，达到传说中的 “秒开”？</p>
<p>&#160; &#160; &#160; &#160;大家可能会看到，市面上某些手机直播 APP 的打开速度非常快，一点就开。而某些手机直播 APP，点击播放后要等好几秒以后才能播放。是什么原因导致如此的天壤之别呢？</p>
<p>&#160; &#160; &#160; &#160;大部分播放器都是拿到一个完成的 GOP 后才能解码播放，基于 FFmpeg 移植的播放器甚至需要等待音画时间戳同步后才能播放（如果一个直播里边没有音频只有视频相当于要等待音频超时后才能播放画面）。</p>
<p>“秒开”可以从以下几个方面考虑：</p>
<h3 id="1-改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。"><a href="#1-改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。" class="headerlink" title="1. 改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。"></a>1. 改写播放器逻辑让播放器拿到第一个关键帧后就给予显示。</h3><p>&#160; &#160; &#160; &#160;GOP 的第一帧通常都是关键帧，由于加载的数据较少，可以达到 “首帧秒开”。</p>
<p>&#160; &#160; &#160; &#160;如果直播服务器支持 GOP 缓存，意味着播放器在和服务器建立连接后可立即拿到数据，从而省却跨地域和跨运营商的回源传输时间。</p>
<p>&#160; &#160; &#160; &#160;GOP 体现了关键帧的周期，也就是两个关键帧之间的距离，即一个帧组的最大帧数。假设一个视频的恒定帧率是 24fps（即1秒24帧图像），关键帧周期为 2s，那么一个 GOP 就是 48 张图像。一般而言，每一秒视频至少需要使用一个关键帧。</p>
<p>&#160; &#160; &#160; &#160;<strong>增加关键帧个数可改善画质（GOP 通常为 FPS 的倍数），但是同时增加了带宽和网络负载</strong>。这意味着，客户端播放器下载一个 GOP，毕竟该 GOP 存在一定的数据体积，如果播放端网络不佳，有可能不是能够快速在秒级以内下载完该 GOP，进而影响观感体验。</p>
<p>&#160; &#160; &#160; &#160;如果不能更改播放器行为逻辑为首帧秒开，直播服务器也可以做一些取巧处理，比如<strong>从缓存 GOP 改成缓存双关键帧</strong>（减少图像数量），这样可以极大程度地减少播放器加载 GOP 要传输的内容体积。</p>
<h3 id="2-在-APP-业务逻辑层面方面优化。"><a href="#2-在-APP-业务逻辑层面方面优化。" class="headerlink" title="2. 在 APP 业务逻辑层面方面优化。"></a>2. 在 APP 业务逻辑层面方面优化。</h3><p>&#160; &#160; &#160; &#160;比如提前做好 DNS 解析（省却几十毫秒），和提前做好测速选线（择取最优线路）。经过这样的预处理后，在点击播放按钮时，将极大提高下载性能。</p>
<p>&#160; &#160; &#160; &#160;一方面，可以围绕传输层面做性能优化；另一方面，可以围绕客户播放行为做业务逻辑优化。两者可以有效的互为补充，作为秒开的优化空间。</p>
<h2 id="二、美颜等滤镜如何处理？"><a href="#二、美颜等滤镜如何处理？" class="headerlink" title="二、美颜等滤镜如何处理？"></a>二、美颜等滤镜如何处理？</h2><p>&#160; &#160; &#160; &#160;在手机直播场景下，这就是一个刚需。没有美颜功能的手机直播 APP，主播基本不爱用。可以在采集画面后，将数据送给编码器之前，将数据源回调给滤镜处理程序，原始数据经过滤镜处理完后，再送回给编码器进行编码即可。</p>
<p>&#160; &#160; &#160; &#160;除了移动端可以做体验优化之外，直播流媒体服务端架构也可以降低延迟。例如收流服务器主动推送 GOP 至边缘节点，边缘节点缓存 GOP，播放端则可以快速加载，减少回源延迟。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/push.jpg" alt=""><br>其次，可以贴近终端就近处理和分发<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/deliver.jpg" alt=""></p>
<h2 id="三、如何保障直播持续播放流畅不卡顿？"><a href="#三、如何保障直播持续播放流畅不卡顿？" class="headerlink" title="三、如何保障直播持续播放流畅不卡顿？"></a>三、如何保障直播持续播放流畅不卡顿？</h2><p>&#160; &#160; &#160; &#160;“秒开”解决的是直播首次加载的播放体验，如何保障直播持续播放过程中的画面和声音视听流畅呢？因为，一个直播毕竟不是一个 HTTP 一样的一次性请求，而是一个 Socket 层面的长连接维持，直到直到主播主动终止推流。</p>
<p>&#160; &#160; &#160; &#160;上述我们讲过卡顿的定义：即播放时画面滞帧，触发了人们的视觉感受。在不考虑终端设备性能差异的情况下，针对网络传输层面的原因，我们看看如何保障一个持续的直播不卡顿。</p>
<p>&#160; &#160; &#160; &#160;这其实是一个直播过程中传输网络不可靠时的容错问题。例如，播放端临时断网了，但又快速恢复了，针对这种场景，播放端如果不做容错处理，很难不出现黑屏或是重新加载播放的现象。</p>
<p>&#160; &#160; &#160; &#160;为了容忍这种网络错误，并达到让终端用户无感知，<strong>客户端播放器可以考虑构建一个FIFO（先进先出）的缓冲队列</strong>，解码器从播放缓存队列读取数据，缓存队列从直播服务器源源不断的下载数据。通常，缓存队列的容量是以时间为单位（比如3s），在播放端网络不可靠时，客户端缓存区可以起到“断网无感”的过渡作用。</p>
<p>&#160; &#160; &#160; &#160;显然，这只是一个“缓兵之计”，如果直播服务器边缘节点出现故障，而此时客户端播放器又是长连接，在无法收到对端的连接断开信号，客户端的缓冲区容量再大也不管用了，这个时候就需要结合客户端业务逻辑来做调度。</p>
<p>&#160; &#160; &#160; &#160;重要的是客户端结合服务端，可以做精准调度。在初始化直播推流之前，例如基于 IP 地理位置和运营商的精确调度，分配线路质量最优的边缘接入节点。在直播推流的过程中，可以实时监测帧率反馈等质量数据，基于直播流的质量动态调整线路。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>1. 关键帧设置频率一般是多少？有没有根据接入动态设置？过长首屏秒会很难做到。</strong></p>
<p>徐立：关键帧间隔越长，也就是 GOP 越长，理论上画面越高清。但是生成 HLS 直播时，最小切割粒度也是一个 GOP，所以针对交互直播，通常不建议 GOP 设置太长。直播一般 2 个关键帧间隔即可。比如帧率是 24fps， 那么 2 个关键帧的间隔就是 48fps ，这个 GOP 就是2s。</p>
<p><strong>2. 七牛这个直播是用的网宿加速？有遇到什么坑没？</strong></p>
<p>徐立：七牛在直播方面主要是自建节点，也支持融合众多第三方 CDN 服务商，多样化的线路组合为客户提供更优质的服务。在和第三方 CDN 合作的过程中遇到的问题等有机会再做更细粒度的交流和分享。</p>
<p><strong>3. RTMP 直播流除了优化线路外，还有什么加速手段吗？</strong></p>
<p>徐立：物理上优化线路，逻辑上优化策略，比如选择性丢帧，不影响编码画质的前提下减轻传输体积。</p>
<p><strong>4. OBS 推流，播放端 HLS 出现视/音频不同步是哪个环节的问题？怎么优化？</strong></p>
<p>徐立：有可能是采集端的问题，如果是采集端编码环节就出现音画不同步，可以在收流服务器上做音画时间戳同步，这样是全局的校对。如果是播放端解码性能问题，那么需要调节播放逻辑，比如保证音画时间戳强一致性的前提下，选择性丢一部帧。</p>
<p><strong>5. PPT 前几页中一个概念好像错了，I 帧不是关键帧，IDR 帧才是。IDR 帧是 I 帧，但是 I 帧不一定是 IDR 帧。只有 IDR 帧才是可重入的。</strong></p>
<p>徐立：中文都把 I 帧翻译成关键帧了，不过既然提到了 IDR 帧，可以展开说明一下。所有的 IDR 帧都是 I 帧，但是并不是所有 I 帧都是 IDR 帧，IDR 帧是 I 帧的子集。I 帧严格定义是帧内编码帧，由于是一个全帧压缩编码帧，通常用 I 帧表示 “关键帧”。IDR 是基于 I 帧的一个 “扩展”，带了控制逻辑，IDR 图像都是 I 帧图像，当解码器解码到 IDR 图像时，会立即将参考帧队列清空，将已解码的数据全部输出或抛弃。重新查找参数集，开始一个新的序列。这样如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR 图像之后的图像永远不会使用 IDR 之前的图像的数据来解码。</p>
<p><strong>6. 有没有调研过 nginx rtmp module，为什么没有用，对它有什么评价？</strong></p>
<p>徐立：有调研过，nginx_rtmp_module 是单进程多线程，非 go 这种轻量级线程/协程用并发自然语义的方式编写流业务。nginx 原本的代码量较大（约 16 万行，但和直播业务相关的功能并不是很多）。且主要靠写 nginx.conf 做配置租户，通常单租户可以，但业务可扩展性方面不是很灵活，可满足基本需求，不满足高级功能。</p>
<p><strong>7. 用到了那些开源软件？编码用的是 x264 吗？直播服务器你们自己开发还是开源的？</strong></p>
<p>徐立：直播服务器用 go 开发的，移动端编码优先硬编，软编用 x264</p>
<p><strong>8. 请教一下用 OBS 推流到 nginx_rtmp_module 的时候是已经做了视频压缩了还是需要基于 OBS 再开发？</strong></p>
<p>徐立：OBS 把编码压缩都做了，不需要再开发。</p>
<p><strong>9. 视频直播想在 HLS 流中无缝插入一段广告的 ts 文件，有问题想请教一下：1、这段 ts 的分辨率是否一定要和之前的视频流一致？2、pts 时间戳是否要和上一个 ts 递增？</strong></p>
<p>徐立：<br>1、可以不一致。这种情况两段视频完全是独立状态，可以没有任何关系，只需要插入 discontinue 标记，播放器在识别到这个标记之后重置解码器参数就可以无缝播放，画面会很平滑的切换。<br>2、不需要递增。举个例子，视频 A 正在直播，播放到 pts 在 5s 的时候，插入一个视频 B，需要先插入一个 discontinue，再插入 B，等 B 播放完之后，再插入一个 discontinue，再插入 A，这个时候 A 的 pts 可以和之前递增，也可以按照中间插入的 B 的时长做偏移，一般做点播和时移的时候 pts 会连续递增，直播的话会算上 B 的时长。</p>
<p>由于移动直播在实践上还有非常多细节，本文未能全部覆盖，感兴趣的朋友欢迎在文章最后留言讨论。</p>
<h1 id="PPT-下载地址"><a href="#PPT-下载地址" class="headerlink" title="PPT 下载地址"></a>PPT 下载地址</h1><p>我备份了一分pdf，下载点<a href="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E7%A7%BB%E5%8A%A8%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/pili_technology_sharing.pdf" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客搭建历程————————Github和Hexo]]></title>
      <url>http://windrunnerlihuan.com/2016/05/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>我的博客搭建历程，使用github pages + hexo，域名解析，配置插件<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#160; &#160; &#160; &#160;其实从去年开始我就想搭建一个自己的个人网站了，主要用于记录自己的技术积累和重点知识。但由于自己太懒，能力也太渣，所以就一直没有行动。直到今年，突然发现随着知识积累的增加，有好多重要的内容脑袋都记不下了，有的网页就直接存个标签，但是标签越存越多，但却很少再次去浏览，最后知识还是会淡忘，所以今天痛下决心，还是自己搭个博客吧，以挽回知识的流失，同时也可以向外部分享自己的一些见解。<br>&#160; &#160; &#160; &#160;博客搭建过程也是一波三折，遇到各种坑爹问题，还好我没那么轻易放弃，最终在无数次失败之后终于成功了。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-github配置"><a href="#1-github配置" class="headerlink" title="1. github配置"></a>1. github配置</h2><p>1）首先需要有一个github账号，没有的话就得申请一个。<br>然后新建一个代码仓库，注意，仓库名一定要是：<strong>你的github账号名字.github.io</strong>，比如我的是windrunnerlihuan.github.io。<br>2）clone到本地，比如我的就是如下命令：<br>git clone <a href="https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git" target="_blank" rel="external">https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</a><br>cd 进文件夹，我们先建个index.html用于测试：<br>cd windrunnerlihuan.github.io<br>vi index.html<br>然后编辑：<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;github pages测试&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后按esc，再输入“:wq”回车保存。然后提交上去：<br>git add .<br>git commit -m “测试github pages”<br>git push<br>此时需要输入你的github账号和密码，输入就是了，成功后我们验证一下。<br>然后打开浏览器，输入地址，比如我的就是：<a href="http://windrunnerlihuan.github.io" target="_blank" rel="external">http://windrunnerlihuan.github.io</a><br>如果能正确显示“<strong>github pages测试</strong>”字样，说明我们成功了。</p>
<hr>
<h2 id="2-hexo安装"><a href="#2-hexo安装" class="headerlink" title="2. hexo安装"></a>2. hexo安装</h2><p>&#160; &#160; &#160; &#160;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。</p>
<p>Hexo的官方网站：<a href="http://hexo.io/" target="_blank" rel="external">http://hexo.io/</a> ，也是基于Github构建的网站。</p>
<p>&#160; &#160; &#160; &#160;不过要使用hexo必须装node.js，这个easy，直接在官网<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a> 上下一个，首页就是下载页面，选一个你自己电脑平台对应的，比如我的是windows x64。如果不想看英文呢，还有个中文网站<a href="http://nodejs.cn/" target="_blank" rel="external">http://nodejs.cn/</a> ，几乎是把英文网站翻译了一遍，套路都一样。下载下来之后文件名叫<strong>node-v4.4.4-x64.msi</strong>，双击，一路next，傻瓜式安装。</p>
<p>接着安装hexo：<br>1）打开控制台（按下win + r，输入cmd，回车）或者直接在git bash界面。<br>输入 npm install -g hexo，然后开始安装hexo。<br>成功后再输入 npm install hexo-deployer-git –save，安装发布工具。</p>
<p>2）接着进入我们从github上克隆下来的windrunnerlihuan.github.io文件，再次git bash here。<br>输入 hexo init，初始化hexo。<br>完成后我们测试一下：<br>输入hexo server<br>bash控制台会打印出 “[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>. Press Ctrl+C to stop.”<br>这时端口4000被打开了，我们能过浏览器打开地址，<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/home.png" alt="hexo首页默认图片"></p>
<p>出现了默认的网页界面，是不是很容易呢！！</p>
<hr>
<h2 id="3-hexo配置"><a href="#3-hexo配置" class="headerlink" title="3. hexo配置"></a>3. hexo配置</h2><p>我们先看一下文件结构</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/file.png" alt="hexo文件结构图图片"></p>
<ul>
<li>scaffolds 脚手架，也就是一个工具模板</li>
<li>scripts 写文件的js，扩展hexo的功能</li>
<li>source 存放博客正文内容</li>
<li>source/_drafts 草稿箱</li>
<li>source/_posts 文件箱</li>
<li>themes 存放皮肤的目录</li>
<li>themes/landscape 默认的皮肤</li>
<li>_config.yml 全局的配置文件</li>
<li>db.json 静态常量</li>
</ul>
<p>在这里，我们每次用到的就是_posts目录里的文件，而_config.yml文件和themes目录是第一次配置好就行了。</p>
<p>_posts目录：Hexo是一个静态博客框架，因此没有数据库。文章内容都是以文本文件方式进行存储的，直接存储在_posts的目录。Hexo天生集成了markdown，我们可以直接使用markdown语法格式写博客，例如:hello-world.md。新增加一篇文章，就在_posts目录，新建一个xxx.md的文件。</p>
<p>themes目录：是存放皮肤的，包括一套Javascript+CSS样式和基于EJS的模板设置。通过在themes目录下，新建一个子目录，就可以创建一套新的皮肤，当然我们也可以直接在landscape上面修改。</p>
<p>我们主要改的就是_config.yml全局配置文件，以及新建文章时要增加或者修改文章在source/-posts/目录下的md文件。</p>
<p>1）修改_config.yml全局配置文件</p>
<p>_config.yml是全局的配置文件：很多的网站配置都在这个文件中定义。</p>
<ul>
<li>站点信息: 定义标题，作者，语言</li>
<li>URL: URL访问路径</li>
<li>文件目录: 正文的存储目录</li>
<li>写博客配置：文章标题，文章类型，外部链接等</li>
<li>目录和标签：默认分类，分类图，标签图</li>
<li>归档设置：归档的类型</li>
<li>服务器设置：IP，访问端口，日志输出</li>
<li>时间和日期格式： 时间显示格式，日期显示格式</li>
<li>分页设置：每页显示数量</li>
<li>评论：外挂的Disqus评论系统</li>
<li>插件和皮肤：换皮肤，安装插件</li>
<li>Markdown语言：markdown的标准</li>
<li>CSS的stylus格式：是否允许压缩</li>
<li>部署配置：github发布</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Hexo Configuration</span></span><br><span class="line"><span class="section">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="section">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="section"># Site 站点信息</span></span><br><span class="line">title: this way, little boy</span><br><span class="line">subtitle: 無限大な夢のあとの 何もない世の中じゃ</span><br><span class="line">description:</span><br><span class="line">author: Huan Li</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"><span class="section"># URL</span></span><br><span class="line"><span class="section">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line">url: http://windrunnerlihuan.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"><span class="section"># Directory 文件目录</span></span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"><span class="section"># Writing 写博客配置</span></span><br><span class="line">new<span class="emphasis">_post_</span>name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post<span class="emphasis">_asset_</span>folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="section"># Category &amp; Tag 目录和标签</span></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"><span class="section"># Date / Time format 时间和日期</span></span><br><span class="line"><span class="section">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="section">## You can customize the date format as defined in</span></span><br><span class="line"><span class="section">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="section"># Pagination 分页设置</span></span><br><span class="line"><span class="section">## Set per_page to 0 to disable pagination</span></span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"><span class="section"># Markdown Markdown语法</span></span><br><span class="line"><span class="section">## https://github.com/chjj/marked</span></span><br><span class="line">markdown:</span><br><span class="line">  gfm: true</span><br><span class="line">  pedantic: false</span><br><span class="line">  sanitize: false</span><br><span class="line">  tables: true</span><br><span class="line">  breaks: true</span><br><span class="line">  smartLists: true</span><br><span class="line">  smartypants: true</span><br><span class="line"></span><br><span class="line"><span class="section"># Deployment 部署配置</span></span><br><span class="line"><span class="section">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;其他没啥改动的，就改个<strong>Site 站点信息</strong>，<strong>URL</strong>，还有<strong>Deployment 部署配置</strong>，前两个没啥难度，这个<strong>Deployment 部署配置</strong>很重要：</p>
<ul>
<li>其中<strong>type</strong>一定要填git，因为以前低版本的hexo是github，不过现在早就废弃了。</li>
<li>其次<strong>repo</strong>填你github项目的clone地址，http/https/ssh类型都行，我的是<br><a href="https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git" target="_blank" rel="external">https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</a> 和git@github.com:windrunnerlihuan/windrunnerlihuan.github.io.git ，我填的是第一个，因为填第二个后期发布时会验证公钥，需要用git bash生成公钥，然后贴到项目的Deploy keys里，比较麻烦，所以为了省事，我填了第一个。</li>
</ul>
<p>2） 新建博客</p>
<p>接下来，我们开始新博客了，创建第一篇博客文章。Hexo建议通过命令行操作，当然你也可以直接在_posts目录下创建文件。</p>
<p>通过命令创建新文章，在bash 里输入 hexo new “新的开始”<br>在source/_posts目录下就会生成文件：”新的开始.md”。</p>
<p>然后我们编辑 <strong>新的开始.md</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 新的开始</span><br><span class="line">date: 2016-05-27 18:44:12</span><br><span class="line">tags:</span><br><span class="line">- 开始</span><br><span class="line">categories: 日志</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是**新的开始**，我用hexo创建了第一篇文章。</span><br><span class="line"></span><br><span class="line">## 引用</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">&gt; Every interaction is both precious and an opportunity to delight.</span><br><span class="line"></span><br><span class="line">## 链接</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% link gank日志 http://gank.io/ true 粉丝日志 %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">[gank日志](http://gank.io/)</span><br><span class="line"></span><br><span class="line">## 图片</span><br><span class="line"># Swig语法</span><br><span class="line">&#123;% img /images/新的开始/meizi.jpg 400 600 这是一张图片 %&#125;</span><br><span class="line"># Markdown语法</span><br><span class="line">![这是一张图片](http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/meizi.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 公式</span><br><span class="line">$$J\_\alpha(x)=\sum _&#123;m=0&#125;^\infty \frac&#123;(-1)^ m&#125;&#123;m! \, \Gamma (m + \alpha + 1)&#125;&#123;\left(&#123;\frac&#123;x&#125;&#123;2&#125;&#125;\right)&#125;^&#123;2 m + \alpha &#125;$$</span><br><span class="line">感觉非常好。</span><br></pre></td></tr></table></figure>
<p>文章使用markedonw语法写的，还有很多普通或者高级的语法，这个可以问度娘或者谷歌，找找别人的帖子学学。</p>
<p>用命令行启动本地server：hexo server<br>通过浏览器打开， <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，就出现了我们新写的文章。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/newstart.png" alt="新的开始文章预览图"></p>
<hr>
<h2 id="4-发布到Github"><a href="#4-发布到Github" class="headerlink" title="4. 发布到Github"></a>4. 发布到Github</h2><p>1)  静态化处理<br>&#160; &#160; &#160; &#160;写完了文章，我们就可以发布了。要说明的一点是hexo的静态博客框架，那什么是静态博客呢？静态博客，是只包含html, javascript, css文件的网站，没有动态的脚本。虽然我们是用Node进行的开发，但博客的发布后就与Node无关了。在发布之前，我们要通过一条命令，把所有的文章都做静态化处理，就是生成对应的html, javascript, css，使得所有的文章都是由静态文件组成的。</p>
<p>输入静态化命令 ：hexo generate<br>在本地目录下，会生成一个public的目录，里面包括了所有静态化的文件。</p>
<p>2) 发布到github<br>接下来，我们把这个博客发布到github。<br>现在检查我们上次填好的_config.yml文件，找到deploy的部分，设置github的项目地址。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/windrunnerlihuan/windrunnerlihuan.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>然后执行部署命令：hexo deploy<br>中间过程会让你再次输入github账号和密码，输入就行了<br>成功后验证，浏览器里输入上次的地址：<a href="http://windrunnerlihuan.github.io" target="_blank" rel="external">http://windrunnerlihuan.github.io</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/newstart.png" alt="新的开始文章预览图"><br>说明我们成功了</p>
<hr>
<h2 id="5-独立购买域名与绑定"><a href="#5-独立购买域名与绑定" class="headerlink" title="5. 独立购买域名与绑定"></a>5. 独立购买域名与绑定</h2><p>&#160; &#160; &#160; &#160;有时候我们想做个人博客，想让自己的博客拥有自己的域名，那就得去买个域名了。这里我们可以通过万网申请购买：<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">https://wanwang.aliyun.com/</a>  。流程很简单，基本上一路next。<br>我也斥资45块买了个.com结尾的域名 <strong>windrunnerlihuan.com</strong> 。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/yulist.png" alt="域名列表图片"></p>
<p>然后就是解析域名了，不过解析之前你得知道你的gihub pages个人主页的ip：<br>首先ping 一下个人主页地址 ，控制台里输入 ping www.windrunnerlihuan.github.io，然后会返回一个ip，然后用这个ip设置我们刚才买的域名解析，也是轻车熟路</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/yudecode.png" alt="域名解析图片"></p>
<p>最后最重要的是：<br>1）在github项目中，新建一个文件CNAME，文件中写出你要绑定的域名windrunnerlihuan.com。通过浏览器，访问<a href="http://windrunnerlihuan.com，就打开了我们建好的博客站点。" target="_blank" rel="external">http://windrunnerlihuan.com，就打开了我们建好的博客站点。</a><br>2）由于每次执行deploy的时候，github代码仓库所有的文件都会被覆盖，所以我们最好在source目录下创建这个CNAME文件，这样每次部署就不用动手创建了。</p>
<hr>
<h2 id="6-个性化功能配置"><a href="#6-个性化功能配置" class="headerlink" title="6. 个性化功能配置"></a>6. 个性化功能配置</h2><p>1） 替换皮肤<br>博客系统流行的原因，是因为他的个人性，而皮肤正式个性化的一种体现。<br>利用hexo替换皮肤，还是比较简单的，3步完成。</p>
<p><strong>No.1</strong>  找到一个皮肤或者自己开发一个皮肤<br>打开hexo的皮肤列表页面，你可以找到很多的皮肤，网页地址： <a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/tommy351/hexo/wiki/Themes</a> 。 </p>
<p><strong>No.2</strong>放到themes目录下<br>比如，我觉得pacman( <a href="https://github.com/A-limon/pacman" target="_blank" rel="external">https://github.com/A-limon/pacman</a> )这个皮肤还不错，我就可以下载皮肤到themes目录下面。<br>通过git命令下载皮肤<br>git clone <a href="https://github.com/A-limon/pacman.git" target="_blank" rel="external">https://github.com/A-limon/pacman.git</a> themes/pacman</p>
<p><strong>No.3</strong>在_config.yml指定皮肤<br>编辑文件_config.yml，找到theme一行，改成 theme: pacman<br>本地启动hexo服务器，打开浏览器 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/pifu.png" alt="替换了皮肤的博客"></p>
<p>新皮肤的效果还不错吧，然后静态化处理，再发布到github，就完成了站点的改版。</p>
<p>这里只介绍换皮肤，当然还有其他很多功能，不过对于我来说暂时没多大卵用，如果其他人有需求可以再google或者baidu搜，也都不难，很easy。</p>
<hr>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;因为这是我第一次搭建个人博客，水平实在比较差，流程写的很粗燥，很多细节都没有涉及，望大家体谅，以后我会努力完善的，将后续文章做的更好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>http://windrunnerlihuan.com/2016/05/27/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>这是<strong>新的开始</strong>，我用hexo创建了第一篇文章。</p>
<p>通过下面的命令，就可以创建新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\javascript\nodejs-hexo&gt;hexo new 新的开始</span><br><span class="line">[info] File created at D:\workspace\javascript\nodejs-hexo\source\_posts\新的开始.md</span><br></pre></td></tr></table></figure></p>
<p>感觉非常好。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h1 id="Swig语法"><a href="#Swig语法" class="headerlink" title="Swig语法"></a>Swig语法</h1><blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote>
<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><blockquote>
<p>Every interaction is both precious and an opportunity to delight.</p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h1 id="Swig语法-1"><a href="#Swig语法-1" class="headerlink" title="Swig语法"></a>Swig语法</h1><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h1 id="Markdown语法-1"><a href="#Markdown语法-1" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h1 id="Swig语法-2"><a href="#Swig语法-2" class="headerlink" title="Swig语法"></a>Swig语法</h1><a href="http://gank.io/" title="粉丝日志" target="_blank">gank日志</a>
<h1 id="Markdown语法-2"><a href="#Markdown语法-2" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><a href="http://gank.io/" target="_blank" rel="external">gank日志</a><br><a href="404html">测试404页面</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h1 id="Swig语法-3"><a href="#Swig语法-3" class="headerlink" title="Swig语法"></a>Swig语法</h1><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8Bmeizi.jpg" width="400" height="600" title="这是一张图片">
<h1 id="Markdown语法-3"><a href="#Markdown语法-3" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8Bmeizi.jpg" alt="这是一张图片"></p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p>
<hr>
]]></content>
    </entry>
    
  
  
</search>
