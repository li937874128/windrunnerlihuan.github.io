<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="3Gndr5oonivG3ajghQU1MgL0IHoMHT4esMsPKjnbeis" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="SurfaceFlinger," />





  <link rel="alternate" href="/atom.xml" title="April is your lie" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们主要分析了计算Layer的脏区域流程，其中涉及了Buffer状态迁移的后两个步骤：ACQUIRED、RELEADED。本届开始就是正式的合成步骤——REFRESH。但是这个步骤比较复杂，所以先分析合成前的准备工作：重建Layer栈与初始化硬件合成器。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android SurfaceFlinger 学习之路(十一)----合成Layer之准备合成">
<meta property="og:url" content="http://windrunnerlihuan.com/2017/12/01/Android-SurfaceFlinger-学习之路-十一-合成Layer之准备合成/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们主要分析了计算Layer的脏区域流程，其中涉及了Buffer状态迁移的后两个步骤：ACQUIRED、RELEADED。本届开始就是正式的合成步骤——REFRESH。但是这个步骤比较复杂，所以先分析合成前的准备工作：重建Layer栈与初始化硬件合成器。">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/composition.png">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/zorder.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/wh.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/whblank.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/cover.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/coveropaque.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/covertransparent.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/offlineandonline.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/hwc.png">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/sourcecrop.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/SF.png">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/meizi.jpg">
<meta property="og:updated_time" content="2019-01-06T07:29:26.105Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android SurfaceFlinger 学习之路(十一)----合成Layer之准备合成">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇我们主要分析了计算Layer的脏区域流程，其中涉及了Buffer状态迁移的后两个步骤：ACQUIRED、RELEADED。本届开始就是正式的合成步骤——REFRESH。但是这个步骤比较复杂，所以先分析合成前的准备工作：重建Layer栈与初始化硬件合成器。">
<meta name="twitter:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/composition.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://windrunnerlihuan.com/2017/12/01/Android-SurfaceFlinger-学习之路-十一-合成Layer之准备合成/"/>





  <title>Android SurfaceFlinger 学习之路(十一)----合成Layer之准备合成 | April is your lie</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-100464707-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bb4df6db80a16ce54c1fb2c6e1767e18";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=62459705";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500465801");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>




  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1262111741&web_id=1262111741" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">April is your lie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">四月是你的谎言</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://windrunnerlihuan.com/2017/12/01/Android-SurfaceFlinger-学习之路-十一-合成Layer之准备合成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="windrunnerlihuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="April is your lie">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Android SurfaceFlinger 学习之路(十一)----合成Layer之准备合成</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-01T14:31:11+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android技术点/" itemprop="url" rel="index">
                    <span itemprop="name">Android技术点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/01/Android-SurfaceFlinger-学习之路-十一-合成Layer之准备合成/" class="leancloud_visitors" data-flag-title="Android SurfaceFlinger 学习之路(十一)----合成Layer之准备合成">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&#160; &#160; &#160; &#160;上一篇我们主要分析了计算Layer的脏区域流程，其中涉及了Buffer状态迁移的后两个步骤：ACQUIRED、RELEADED。本届开始就是正式的合成步骤——REFRESH。但是这个步骤比较复杂，所以先分析合成前的准备工作：重建Layer栈与初始化硬件合成器。<br><a id="more"></a></p>
<h1 id="合成准备"><a href="#合成准备" class="headerlink" title="合成准备"></a>合成准备</h1><p>&#160; &#160; &#160; &#160;当Vsync到来时候，SF会处理MessageQueue的INVALIDATE消息，消息最后一部再次触发REFRESH消息，进入合成阶段。<br>&#160; &#160; &#160; &#160;这个流程在SF的handleMessageRefresh函数，位于frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">/*调Layer的onPreComposition方法，主要是标志一下Layer已经被用于合成*/</span></span><br><span class="line">    preComposition();</span><br><span class="line">    <span class="comment">/*若Layer的位置/先后顺序/可见性发生变化，重新计算Layer的目标合成区域和先后顺序*/</span></span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    <span class="comment">/*配置硬件合成器，调hwc的prepare方法*/</span></span><br><span class="line">    setUpHWComposer();</span><br><span class="line">    <span class="comment">/*当打开开发者选项中的“显示Surface刷新”时，额外为产生变化的图层绘制闪烁动画*/</span></span><br><span class="line">    doDebugFlashRegions();<span class="comment">//ignore</span></span><br><span class="line">    <span class="comment">/*执行合成主体，对3D合成而言，调opengl的drawcall，对硬件合成而言，调hwc的set方法*/</span></span><br><span class="line">    doComposition();</span><br><span class="line">    <span class="comment">/*主要用于调试，调Layer的onPostComposition方法*/</span></span><br><span class="line">    postComposition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数每一步的功能都很清晰，看起来简单粗暴。综合上面几节，流程图如下：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/composition.png" alt="合成流程"></p>
<p>&#160; &#160; &#160; &#160;每一部的功能，我们会在接下来每一步详细分析。</p>
<h1 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><h2 id="preComposition"><a href="#preComposition" class="headerlink" title="preComposition"></a>preComposition</h2><p>&#160; &#160; &#160; &#160;调Layer的onPreComposition方法，主要是标志一下Layer已经被用于合成。我们看看preComposition函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::preComposition()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;</span><br><span class="line">            needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;代码很简单，一共就三步：<br>&#160; &#160; &#160; &#160;1）获取全部经过z-order排序的layer；<br>&#160; &#160; &#160; &#160;2）每个layer调用onPrecomposition判断是否需要触发vsync更新；<br>&#160; &#160; &#160; &#160;3）Layer update。<br>&#160; &#160; &#160; &#160;我们看看第二步的判断逻辑，Layer的onPrecomposition函数，位于frameworks/native/services/surfaceflinger/Layer.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Layer::onPreComposition() &#123;</span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;<span class="comment">//标志一下Layer已经被用于合成</span></span><br><span class="line">    <span class="comment">//当layer里存放被queue的frame以后，就会出发layer update</span></span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span> || mSidebandStreamChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们在<a href="http://windrunnerlihuan.com/2017/07/03/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%AB-Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/">Android SurfaceFlinger 学习之路(八)—-Surface管理图形缓冲区</a>中讲过，当Buffer被queue回BufferQueue，状态迁移到QUEUED，就会回调Layer的onFrameAvailable函数，将mQueuedFrames自动+1。所以当vsync到来时候，就会根据这个判断时候更新layer。</p>
<h2 id="rebuildLayerStacks"><a href="#rebuildLayerStacks" class="headerlink" title="rebuildLayerStacks"></a>rebuildLayerStacks</h2><p>&#160; &#160; &#160; &#160;若Layer的位置/先后顺序/可见性发生变化，重新计算Layer的目标合成区域和先后顺序。我们要看看rebuildLayerStacks函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::rebuildLayerStacks() &#123;</span><br><span class="line">    // rebuild the visible layer list per screen</span><br><span class="line">    //系统显示屏以及各个应用程序窗口的属性变化时</span><br><span class="line">    if (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        ATRACE_CALL();</span><br><span class="line">        mVisibleRegionsDirty = false;</span><br><span class="line">        //将mHwWorkListDirty 标记为true</span><br><span class="line">        invalidateHwcGeometry();</span><br><span class="line">        //获取当前应用程序所有按照z-order排列的layer</span><br><span class="line">        const LayerVector&amp; layers(mDrawingState.layersSortedByZ);</span><br><span class="line">        //遍历每一个显示屏</span><br><span class="line">        for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            Region opaqueRegion;//全局不透明区域</span><br><span class="line">            Region dirtyRegion;//需要重新render的脏区域</span><br><span class="line">            Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;</span><br><span class="line">            const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">            const Transform&amp; tr(hw-&gt;getTransform());</span><br><span class="line">            const Rect bounds(hw-&gt;getBounds());</span><br><span class="line">            if (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">                //计算当前显示屏各个应用程序的可见区域</span><br><span class="line">                SurfaceFlinger::computeVisibleRegions(layers,</span><br><span class="line">                        hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                const size_t count = layers.size();</span><br><span class="line">                for (size_t i=0 ; i&lt;count ; i++) &#123;</span><br><span class="line">                    const sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">                    const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">                    if (s.layerStack == hw-&gt;getLayerStack()) &#123;</span><br><span class="line">                        //可见不透明的区域</span><br><span class="line">                        Region drawRegion(tr.transform(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        drawRegion.andSelf(bounds);</span><br><span class="line">                        if (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                            //添加进入z-order排列的layer</span><br><span class="line">                            layersSortedByZ.add(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //z-order排列的layer</span><br><span class="line">            hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">            //显示屏大小</span><br><span class="line">            hw-&gt;undefinedRegion.set(bounds);</span><br><span class="line">            //减去不透明区域</span><br><span class="line">            hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line">            //累加脏区域</span><br><span class="line">            hw-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SurfaceFlinger::invalidateHwcGeometry()</span><br><span class="line">&#123;</span><br><span class="line">    mHwWorkListDirty = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;流程如下：<br>&#160; &#160; &#160; &#160;1）从上一节的内容可以知道，当SurfaceFlinger服务在处理系统显示屏以及各个应用程序窗口的属性变化时，如果发现需要重新计算各个应用程序窗口的可见区域，那么就会将SurfaceFlinger类的成员变量mVisibleRegionsDirty的值设置为true。<br>&#160; &#160; &#160; &#160;进入判断逻辑之后，将成员变量mVisibleRegionsDirty的值设置为false了，因为这时候系统中各个应用程序窗口的可见区域开始计算了。<br>&#160; &#160; &#160; &#160;2）函数接下来通过SurfaceFlinger类的成员变量mDrawingState所描述的一个State对象的成员变量layersSortedByZ来获得系统当前所有的应用程序窗口，并且保存在一个类型为LayerVector的向量layers中。<br>&#160; &#160; &#160; &#160;3）SurfaceFlinger类的成员函数computeVisibleRegions在计算完成各个应用程序窗口的可见区域之后，会得到一个全局不透明区域，保存在输出参数opaqueRegion中。这个全局不透明区域就是接下来需要渲染的，一般情况下，它的大小就应该等于显示屏的大小，即变量hw-&gt;getBounds()所描述的区域。<strong>在异常情况下，可能会导致显示屏区域bounds大于全局不透明区域opaqueRegion，这时候前者减去后者就可以得到一些称为“虫洞”的区域。由于这些虫洞区域不会被各个应用程序窗口覆盖，因此，SurfaceFlinger服务需要对它们进行特殊处理，即以一种特殊的方式来渲染它们。在后面的部分内容中，我们就会看到SurfaceFlinger服务是通过调用SurfaceFlinger类的成员函数drawWormhole来渲染这些虫洞的。</strong><br>&#160; &#160; &#160; &#160;4）dirtyRegion是需要被刷新的。 opaqueRegion 不透明区域，layer是按Z-order排序的，左右排在前面的opaqueRegion 会挡住后面的layer。Region drawRegion(tr.transform( layer-&gt;visibleNonTransparentRegion));程序需要进一步得出每个layer 绘制的区域。<br>&#160; &#160; &#160; &#160;5）将结果保存到hw中。</p>
<p>&#160; &#160; &#160; &#160;所以上述流程的重点就是computeVisibleRegions就算过程，我们详细分析这个流程。</p>
<p>&#160; &#160; &#160; &#160;再计算可见区域之前，我们要了解一些概念。</p>
<h3 id="相关区域概述"><a href="#相关区域概述" class="headerlink" title="相关区域概述"></a>相关区域概述</h3><p>&#160; &#160; &#160; &#160;在分析源码前，我们自己先来想一下，图层中什么样的区域是可见的呢？</p>
<ul>
<li>Z-order<br>&#160; &#160; &#160; &#160;layer的z-order无疑是第一考虑的要素。因为排在越前面的图层，其获得曝光的机率越大，可见的区域也可能越大，如下图所示：</li>
</ul>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/zorder.jpg" alt="z-order"></p>
<p>&#160; &#160; &#160; &#160;所以在计算可见性时，是按照Z-order由上而下进行的。假如一个layer的某个区域被确定为可见，那么与之相对应的它下面的所有图层区域都会被遮盖而不可见。</p>
<ul>
<li>透明度<br>&#160; &#160; &#160; &#160;虽然越前面的layer优先级越高，但这并不代表后面的图层完全没有机会。只要前一个layer不是完全不透明的，那么从理论上来讲用户就应该能“透过”这部分区域看到后面的内容。</li>
<li>图层大小<br>&#160; &#160; &#160; &#160;与透明度一样，图层大小也直接影响到其可见区域。因为每个layer都是有大有小的，即便前一个layer是完全不透明的，但只要它的尺寸没有达到“满屏”，那么比它z-order小的图层还是有机会暴露出来的。这也是我们需要考虑的因素之一。</li>
</ul>
<p>&#160; &#160; &#160; &#160;因此我们要我们首先解释一些与应用程序窗口相关的概念：<strong>可见区域（Visible Region）、透明区域（Transparent Region）、半透明区域（Translucent Region）、完全不透明区域（Opaque Region）和被覆盖区域（Covered Region）。</strong></p>
<p>&#160; &#160; &#160; &#160;假设一个应用程序窗口的宽度和高度分别为w和h，如图所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/wh.jpg" alt="wh"></p>
<p>&#160; &#160; &#160; &#160;那么我们就可以将由(0,0)、(0, w)、(0, h)和(w,h)四个点组成的区域称为应用程序窗口的<strong>可见区域</strong>。</p>
<p>&#160; &#160; &#160; &#160; 接下来，我们可以在一个应用程序窗口的可见区域挖一个洞出来，如下图所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/whblank.jpg" alt="whblank"></p>
<p>&#160; &#160; &#160; &#160;这时候应用程序窗口真正的可见区域就需要减去中间被挖出来的洞。这个被挖出来的洞就称为应用程序窗口的<strong>透明可见区域</strong>。<br>&#160; &#160; &#160; &#160;如果应用程序窗口的可见区域的Alpha通道大于0并且小255，那么我们就认为应用程序窗口的可见区域是<strong>半透明的</strong>。有两种极端情况，即当应用程序窗口的可见区域的Alpha通道等于0或者255的时候。当等于0的时候，我们就认为应用程序窗口的可见区域是<strong>透明的</strong>，就如图5所示的洞一样，而当等于255的时候，我们就认为应用程序窗口的可见区域是<strong>完全不透明的</strong>。</p>
<p>&#160; &#160; &#160; &#160;上面我们讨论的应用程序窗口的可见区域是基于单个应用程序窗口而言的，当多个应用程序窗口叠加在一起的时候，在讨论一个应用程序窗口的可见区域的时候，就需要考虑位于它上面的其它应用程序窗口的可见区域的影响了。注意，一个应用程序窗口的可见区域只受位于它上面的其它应用程序窗口影响，而不会受到位于它下面的其它的应用程序窗口影响，因此，我们是按照从上到下的顺序（z-order）来计算系统中各个应用程序窗口的可见区域的。</p>
<p>&#160; &#160; &#160; &#160;为了方便描述，我们假设位于一个应用程序窗口上面的所有应用程序窗口组成了一个<strong>整体的可见区域（Above Covered Layers）</strong>，并且这个可见区域与我们所要讨论的应用程序窗口相交，即它们叠加在一起，如图所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/cover.jpg" alt="cover"></p>
<p>&#160; &#160; &#160; &#160;由蓝色矩形组成的区域即为上层所有应用程序窗口所组成的一个<strong>整体可见区域</strong>，这个整体可见区域与下面绿色矩形组成的一个应用程序窗口相交的部分，即由虚线所围成的区域，就是下面的一个应用程序窗口的<strong>被覆盖区域</strong>。</p>
<p>&#160; &#160; &#160; &#160;一个应用程序窗口的<strong>被覆盖区域</strong>有可能是半透明的，也有可能是完全不透明的，但是不可能是透明的，如图所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/coveropaque.jpg" alt="coveropaque"></p>
<p>&#160; &#160; &#160; &#160;在原来由虚线围成的区域中，深蓝色的那部分区域就是<strong>完全不透明的（Above Opaque  Layers）</strong>，这时候由绿色矩形组成的应用程序窗口的可见区域除了要减去中间的洞（<strong>透明区域</strong>）之外，还要减去<strong>被覆盖的完全不透明区域</strong>，如下图所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/covertransparent.jpg" alt="covertransparent"></p>
<p>&#160; &#160; &#160; &#160;从上面的讨论我们就可以清楚地知道，为了计算一个应用程序窗口的最终可见区域，我们需要知道：</p>
<ul>
<li>应用程序窗口的左上角位置，以及宽度和高度，以便可以获得应用程序窗口的<strong>原始可见区域</strong>。</li>
<li>应用程序窗口的<strong>透明区域</strong>。</li>
<li>应用程序窗口的<strong>被覆盖完全不透明区域</strong>。</li>
</ul>
<p>&#160; &#160; &#160; &#160;用第1步到的原始可见区域减去第2步的透明区域和第3步的被覆盖完全不透明区域，就可以得到一个应用程序窗口的最终可见区域。<br>&#160; &#160; &#160; &#160;为了获得第3步的被覆盖完全不透明区域，我们在计算一个应用程序窗口的最终可见区域的过程中，还需要将此前得到的应用程序窗口的完全不透明区域组合起来，形成一个<strong>覆盖完全不透明区域（Above Opaque  Layers）</strong>，因此，我们还需要知道：</p>
<ul>
<li>应用程序窗口的<strong>完全不透明区域</strong>。</li>
</ul>
<p>&#160; &#160; &#160; &#160;此外，由于一个应用程序窗口的被覆盖半透明区域是需要与上层的应用程序窗口可见区域执行混合计算的，因此，我们在计算系统中各个应用程序窗口的可见区域的过程中，<strong>还需要将所有上层的应用程序窗口可见区域组合起来形成一个覆盖区域（Above Covered Layers）</strong>。</p>
<p>&#160; &#160; &#160; &#160;所以计算所有Layer的可见区域逻辑， 按照Z-order逐个计算各layer的可见区域。对于Z-order值最大的layer，显然没有其它图层会遮盖它。所以它的可见区域(visibleRegion)应该是(当然，前提是这个layer没有超过屏幕区域)自身的大小再减去完全透明的部分(transparentRegion)，由此计算出来的结果我们把它称为aboveCoveredLayers。这个变量应该是全局的，因为它需要被传递到后面的layers中，然后不断地累积运算，直到覆盖整个屏幕区域。</p>
<p>&#160; &#160; &#160; &#160;有了这些背景知识之后，接下来我们就可以分析SurfaceFlinger类的成员函数computeVisibleRegions的实现了。</p>
<h3 id="computeVisibleRegions"><a href="#computeVisibleRegions" class="headerlink" title="computeVisibleRegions"></a>computeVisibleRegions</h3><p>&#160; &#160; &#160; &#160;computeVisibleRegions代码有点长，我们分段阅读：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::computeVisibleRegions(</span><br><span class="line">        <span class="keyword">const</span> LayerVector&amp; currentLayers, <span class="keyword">uint32_t</span> layerStack,</span><br><span class="line">        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    Region aboveOpaqueLayers;</span><br><span class="line">    Region aboveCoveredLayers;</span><br><span class="line">    Region dirty;</span><br><span class="line"></span><br><span class="line">    outDirtyRegion.clear();</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码定义了另外两个区域aboveOpaqueLayers，分别用来描述上层<strong>覆盖完全不透明区域（Above Opaque  Layers）</strong>和<strong>上层覆盖区域（Above Covered Layers）</strong>，上面讲过，这两个计算累加的结果。<br>&#160; &#160; &#160; &#160; 我们接着往下阅读代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">size_t i = currentLayers.size();</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        const sp&lt;Layer&gt;&amp; layer = currentLayers[i];</span><br><span class="line"></span><br><span class="line">        // start with the whole surface at its current location</span><br><span class="line">        const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line"></span><br><span class="line">        // only consider the layers on the given layer stack</span><br><span class="line">        if (s.layerStack != layerStack)</span><br><span class="line">            continue;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码是一个while循环的前面几行。系统中所有需要计算可见区域的应用程序窗口都保存在参数currentLayers所描述的一个向量中。这段代码的while循环就是用来逐个地这些应用程序窗口的可见区域的。注意，<strong>这个while是先计算是按照从上到下的顺序来计算系统中各个应用程序窗口的可见区域的</strong>。<br>&#160; &#160; &#160; &#160;然后获得用来描述当前正在处理的应用程序窗口的当前渲染状态的一个State对象s，然后判断是否是当前应用程序的layerStack，否则就continue。<br>&#160; &#160; &#160; &#160;我们继续往下阅读代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * opaqueRegion: area of a surface that is fully opaque.</span><br><span class="line"> */</span></span><br><span class="line">Region opaqueRegion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * visibleRegion: area of a surface that is visible on screen</span><br><span class="line"> * and not fully transparent. This is essentially the layer's</span><br><span class="line"> * footprint minus the opaque regions above it.</span><br><span class="line"> * Areas covered by a translucent surface are considered visible.</span><br><span class="line"> */</span></span><br><span class="line">Region visibleRegion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * coveredRegion: area of a surface that is covered by all</span><br><span class="line"> * visible regions above it (which includes the translucent areas).</span><br><span class="line"> */</span></span><br><span class="line">Region coveredRegion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * transparentRegion: area of a surface that is hinted to be completely</span><br><span class="line"> * transparent. This is only used to tell when the layer has no visible</span><br><span class="line"> * non-transparent regions and can be removed from the layer list. It</span><br><span class="line"> * does not affect the visibleRegion of this layer or any layers</span><br><span class="line"> * beneath it. The hint may not be correct if apps don't respect the</span><br><span class="line"> * SurfaceView restrictions (which, sadly, some don't).</span><br><span class="line"> */</span></span><br><span class="line">Region transparentRegion;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接着再定义了四个Region对象opaqueRegion、visibleRegion、coveredRegion和transparentRegion，分别用来描述当前正在处理的应用程序窗口的<strong>完全不透明区域、可见区域、被覆盖区域和透明区域</strong>。这四个区域的含义和作用如前所述。<br>&#160; &#160; &#160; &#160;go on:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// handle hidden surfaces by setting the visible region to empty</span><br><span class="line">       if (CC_LIKELY(layer-&gt;isVisible())) &#123;</span><br><span class="line">           //是否是半透明</span><br><span class="line">           const bool translucent = !layer-&gt;isOpaque(s);</span><br><span class="line">           //layer的可见区域</span><br><span class="line">           Rect bounds(s.transform.transform(layer-&gt;computeBounds()));</span><br><span class="line">           //以便可以得到当前正在处理的应用程序窗口的初始可见区域visibleRegion</span><br><span class="line">           visibleRegion.set(bounds);</span><br><span class="line">           if (!visibleRegion.isEmpty()) &#123;//计算透明区域</span><br><span class="line">               // Remove the transparent area from the visible region</span><br><span class="line">               if (translucent) &#123;</span><br><span class="line">                   //当前渲染状态的一个State对象s的成员变量transform指向的也是一个变换矩阵</span><br><span class="line">                   //用来描述当前正在处理的应用程序窗口的位置、旋转方向和缩放因子等</span><br><span class="line">                   const Transform tr(s.transform);</span><br><span class="line">                   //函数接着判断当前正在处理的应用程序窗口是否被旋转过或者被缩放过</span><br><span class="line">                   if (tr.transformed()) &#123;</span><br><span class="line">                       //判断当前正在处理的应用程序窗口是否被旋转和缩放得不规则</span><br><span class="line">                       if (tr.preserveRects()) &#123;</span><br><span class="line">                           // transform the transparent region</span><br><span class="line">                           transparentRegion = tr.transform(s.activeTransparentRegion);</span><br><span class="line">                       &#125; else &#123;</span><br><span class="line">                           //即当当前正在处理的应用程序窗口被旋转和缩放得不规则时，</span><br><span class="line">                           //这时候对应用程序窗口的透明区域进行旋转或者缩放就会很复杂，</span><br><span class="line">                           //于是函数就干脆将它的透明区域忽略掉</span><br><span class="line">                           // transformation too complex, can't do the</span><br><span class="line">                           // transparent region optimization.</span><br><span class="line">                           transparentRegion.clear();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; else &#123;//如果没有经过矩阵变换处理</span><br><span class="line">                       transparentRegion = s.activeTransparentRegion;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               // compute the opaque region</span><br><span class="line">               //当当前正在处理的应用程序窗口是完全不透明，并且旋转方向也是规则时，</span><br><span class="line">               //那么它的完全不透明区域opaqueRegion就等于前面计算所得到的可见区域visibleRegion</span><br><span class="line">               const int32_t layerOrientation = s.transform.getOrientation();</span><br><span class="line">               if (s.alpha==255 &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">                       ((layerOrientation &amp; Transform::ROT_INVALID) == false)) &#123;</span><br><span class="line">                   // the opaque region is the layer's footprint</span><br><span class="line">                   opaqueRegion = visibleRegion;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码用来计算当前正在处理的应用程序窗口的可见区域和完全不透明区域。只有在当前正在处理的应用程序窗口处于可见状态，并且它不是完全透明时，才需要计算这两个区域。我们看看Layer的isVisible函数，位于frameworks/native/services/surfaceflinger/Layer.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Layer::isVisible() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Layer::<span class="function">State&amp; <span class="title">s</span><span class="params">(mDrawingState)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> !(s.flags &amp; <span class="keyword">layer_state_t</span>::eLayerHidden) &amp;&amp; s.alpha</span><br><span class="line">            &amp;&amp; (mActiveBuffer != <span class="literal">NULL</span> || mSidebandStream != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;当State对象s的成员变量flags的ISurfaceComposer::eLayerHidden位等于0时，就说明当前正在处理的应用程序窗口是处于可见状态的，而当它的另外一个成员变量alpha的值不等于0的时候，就说明当前正在处理的应用程序窗口不是完全透明的。<br>&#160; &#160; &#160; &#160;回到上面部分，接着计算透明区域。用来描述当前正在处理的应用程序窗口的当前渲染状态的一个State对象s的成员变量transform指向的也是一个变换矩阵，用来描述当前正在处理的应用程序窗口的位置、旋转方向和缩放因子等。<br>&#160; &#160; &#160; &#160;函数接着判断当前正在处理的应用程序窗口是否被旋转过或者被缩放过。如果是的话，那么前面调用变换矩阵tr的成员函数transformed的返回值就会等于true，即变量transformed的等于true。在这种情况下，函数就要相应地对当前正在处理的应用程序窗口的透明区域进行旋转或者缩放。<strong>但是有一种特殊情况，即当当前正在处理的应用程序窗口被旋转和缩放得不规则时，这时候对应用程序窗口的透明区域进行旋转或者缩放就会很复杂，于是函数就干脆将它的透明区域忽略掉。</strong>判断当前正在处理的应用程序窗口是否被旋转和缩放得不规则是通过调用变换矩阵tr的成员函数preserveRects来实现的，当它的返回值等于true的时候，就说明当前正在处理的应用程序窗口是否被旋转和缩放之后还是规则，否则就是不规则的。<br>&#160; &#160; &#160; &#160;当前正在处理的应用程序窗口的透明区域保存在State对象s的成员变量transparentRegion中，按照上述原理，函数按照以下规则来对它进行处理：<br>&#160; &#160; &#160; &#160;1）当变量transformed的等于false时，说明当前正在处理的应用程序窗口的透明区域就不需要进行旋转或者缩放，这时候就可以将这个透明区域保存在变量transparentRegionScreen中。<br>&#160; &#160; &#160; &#160;2）当变量transformed的等于true，并且变换矩阵tr的成员函数preserveRects的返回值也等于true时，那么就说明当前正在处理的应用程序窗口的透明区域需要进行旋转或者缩放，这时候通过调用变换矩阵tr的成员函数transform来实现的。 最终得到的透明区域同样是保存在变量transparentRegionScreen中。<br>&#160; &#160; &#160; &#160;3） 当变量transformed的等于true，并且变换矩阵tr的成员函数preserveRects的返回值等于false时，那么就说明需要忽略掉当前正在处理的应用程序窗口的透明区域，通过成员函数clear来实现的。</p>
<p>&#160; &#160; &#160; &#160;我们接着来看当前正在处理的应用程序窗口的完全不透明区域的计算过程。<br>&#160; &#160; &#160; &#160;当当前正在处理的应用程序窗口是完全不透明，并且旋转方向也是规则时，那么它的完全不透明区域opaqueRegion就等于前面计算所得到的可见区域visibleRegion。当当前正在处理的应用程序窗口的Alpha通道等于255，即当State对象s的成员变量alpha的值等于255，并且变量translucent的值等于false时，就说明它是完全不透明的，而当当前正在处理的应用程序窗口的旋转方向layerOrientation的Transform::ROT_INVALID位等于0的时候，就说明它的旋转方向是规则的。</p>
<p>&#160; &#160; &#160; &#160;go on：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clip the covered region to the visible region</span></span><br><span class="line">        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update aboveCoveredLayers for next (lower) layer</span></span><br><span class="line">        aboveCoveredLayers.orSelf(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// subtract the opaque region covered by the layers above us</span></span><br><span class="line">        visibleRegion.subtractSelf(aboveOpaqueLayers);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码用来计算当前正在处理的应用程序窗口的被覆盖区域，以及再进一步计算它的可见区域，主要考虑是否被上层的不透明区域覆盖了。<br>&#160; &#160; &#160; &#160;变量aboveCoveredLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的可见区域，将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相交，就可以得到当前正在处理的应用程序窗口的被覆盖区域coveredRegion，而将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相或一下，就可以得到下一个应用程序窗口的所有上层应用程序窗口所组成的可见区域aboveCoveredLayers。<br>&#160; &#160; &#160; &#160;变量aboveOpaqueLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的完全不透明区域，这个区域从当前正在处理的应用程序窗口的可见区域visibleRegion减去后，就可以得到当前正在处理的应用程序窗口的最终可见区域visibleRegion。</p>
<p>&#160; &#160; &#160; &#160;go on:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compute this layer's dirty region</span></span><br><span class="line">       <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">           <span class="comment">// we need to invalidate the whole region</span></span><br><span class="line">           dirty = visibleRegion;</span><br><span class="line">           <span class="comment">// as well, as the old visible region</span></span><br><span class="line">           dirty.orSelf(layer-&gt;visibleRegion);</span><br><span class="line">           layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/* compute the exposed region:</span><br><span class="line">            *   the exposed region consists of two components:</span><br><span class="line">            *   1) what's VISIBLE now and was COVERED before</span><br><span class="line">            *   2) what's EXPOSED now less what was EXPOSED before</span><br><span class="line">            *</span><br><span class="line">            * note that (1) is conservative, we start with the whole</span><br><span class="line">            * visible region but only keep what used to be covered by</span><br><span class="line">            * something -- which mean it may have been exposed.</span><br><span class="line">            *</span><br><span class="line">            * (2) handles areas that were not covered by anything but got</span><br><span class="line">            * exposed because of a resize.</span><br><span class="line">            */</span></span><br><span class="line">           <span class="keyword">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">           <span class="keyword">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">           <span class="keyword">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">           <span class="keyword">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line">           dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);</span><br><span class="line">       &#125;</span><br><span class="line">       dirty.subtractSelf(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// accumulate to the screen dirty region</span></span><br><span class="line">       outDirtyRegion.orSelf(dirty);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码用来计算屏幕的脏区域。我们首先解释一下屏幕的脏区域是如何计算的。将所有应用程序窗口的脏区域都组合起来，就可以得到屏幕的脏区域，这个脏区域就是需要重新执行渲染操作的。因此，为了得到屏幕的脏区域，我们要知道当前正在处理的应用程序窗口的脏区域，以及之前已经处理了的应用程序窗口脏区域组合。前者使用变量dirty来描述，而后者使用输出参数outDirtyRegion来描述。</p>
<p>&#160; &#160; &#160; &#160;我们首先来看当前正在处理的应用程序窗口的脏区域dirty是如何计算的。我们分两种情况来考虑。<br>&#160; &#160; &#160; &#160;1）首先考虑当前正在处理的应用程序窗口上一次的状态还未来得及处理的情况，即它当前的内容是脏的。在这种情况下，layer的成员变量contentDirty的值就会等于true。这时候我们就需要将该应用程序窗口的上一次可见区域，以及当前的可见区域合并起来，形成一个大的脏区域，这样就可以将两次渲染操作合并成一次来执行。当前正在处理的应用程序窗口的上一次可见区域保存在layer的成员变量visibleRegion中，而它前的可见区域保存在变量visibleRegion中。将这两者相或一下，就可以得到当前正在处理的应用程序窗口的脏区域dirty。<br>&#160; &#160; &#160; &#160;2）接着考虑当前正在处理的应用程序窗口上一次的状态已经处理了的情况，即它当前的内容不是脏的，这意味着它所要显示的内容没有发生变化。在这种情况下，就不需要重新渲染所有的可见区域。那么那些区域是需要重新渲染的呢？第一部分区域是之前是被覆盖的，现在不被覆盖了，第二部分是由于窗口大小变化而引发的新增不被覆盖区域。接下来，我们就来看看这两部分区域是如何计算的。<br>&#160; &#160; &#160; &#160;将一个应用程序窗口的当前可见区域减去被覆盖区域，就可以它的当前不被覆盖的区域newExposed，按照同样的方法，我们可以也可以得到它的上一次不被覆盖的区域oldExposed。注意，一个应用程序窗口的上一次可见区域和被覆盖区域分别保存与它相对应的一个Layer对象的成员变量visibleRegion和coveredRegion中。这样，将一个应用程序窗口的当前不被覆盖的区域newExposed减去它的上一次不被覆盖的区域oldExposed，就可以得到新增的不被覆盖区域，即可以得到第二部分需要重新渲染的区域。另一方面，将一个应用程序窗口的当前可见区域visibleRegion与它的上一次被覆盖区域oldCoveredRegion相交，就可以得到之前是被覆盖的而现在不被覆盖了的区域，即可以得到第一部分需要重新渲染的区域。将第一部分和第二部分需要重新渲染的区域组合起来，就可以得到当前正在处理的应用程序窗口的脏区域dirty。<br>&#160; &#160; &#160; &#160;得到了当前正在处理的应用程序窗口的脏区域dirty，接下来的事情就好办了。首先从该脏区域dirty减去上层的完全不透明区域，因为后者的渲染不需要当前应用程序窗口来参与，接着最将得到的新的脏区域dirty累加到输出参数outDirtyRegion中去，这样就可以得到目前为止，SurfaceFlinger服务需要渲染的脏区域。</p>
<p>&#160; &#160; &#160; &#160;go on:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Update aboveOpaqueLayers for next (lower) layer</span></span><br><span class="line">        aboveOpaqueLayers.orSelf(opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store the visible region in screen space</span></span><br><span class="line">        layer-&gt;setVisibleRegion(visibleRegion);</span><br><span class="line">        layer-&gt;setCoveredRegion(coveredRegion);</span><br><span class="line">        layer-&gt;setVisibleNonTransparentRegion(</span><br><span class="line">                visibleRegion.subtract(transparentRegion));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码是前面的while循环的几行结束代码，主要用来做三件事情。<br>&#160; &#160; &#160; &#160;第一件事情是计算到目前为止所得到的上层应用程序窗口的完全不透明区域，这是通过组合当前正在处理的应用程序窗口的完全不透明区域与位于它上面的的所有应用程序窗口的完全不透明区域aboveOpaqueLayers来得到的，并且最终结果保存在变量aboveOpaqueLayers中。<br>&#160; &#160; &#160; &#160;第二件事情是调用layer的成员函数setVisibleRegion、setCoveredRegion和setVisibleNonTransparentRegion来保存当前正在处理的应用程序窗口的可见区域、被覆盖区域和没有透明区域的可见区域。<br>&#160; &#160; &#160; &#160;第三件事情是，函数还将前面所有的应用程序窗口组成的完全不透明区域aboveOpaqueLayers保存在输出参数opaqueRegion，以便可以返回给调用者使用。</p>
<p>&#160; &#160; &#160; &#160;这就是计算Layer可视区域的所有流程，只要理解了里面每个变量代表对应含义区域的意义，就不难分析。这里我们rebuildLayerStacks流程就分析完了。我们继续往下走，分析下一步。</p>
<h2 id="setUpHWComposer"><a href="#setUpHWComposer" class="headerlink" title="setUpHWComposer"></a>setUpHWComposer</h2><p>&#160; &#160; &#160; &#160;合成步骤的下一步就是setUpHWComposer函数调用，配置硬件合成器。</p>
<h3 id="回顾HWC"><a href="#回顾HWC" class="headerlink" title="回顾HWC"></a>回顾HWC</h3><p>&#160; &#160; &#160; &#160;我们之前在<a href="http://windrunnerlihuan.com/2017/04/27/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C-SurfaceFlinger%E6%A6%82%E8%BF%B0/">Android SurfaceFlinger 学习之路(二)—-SurfaceFlinger概述</a>讲过，用于合成surface的功能模块可以有2个，OpenGL ES &amp; HWC，它的管理实在HWC里面实现的。<br>&#160; &#160; &#160; &#160;官网也给出了一些解释，<a href="https://source.android.google.cn/devices/graphics/arch-sf-hwc" target="_blank" rel="external">https://source.android.google.cn/devices/graphics/arch-sf-hwc</a> ，不过中文翻译的不是很好，最好看看英文：<br>&#160; &#160; &#160; &#160;Hardware Composer HAL (HWC) 是在 Android 3.0 中推出的，并且多年来一直都在不断演进。它主要是用来确定通过可用硬件来合成缓冲区的最有效方法。作为 HAL，其实现是特定于设备的，而且通常由显示设备硬件原始设备制造商 (OEM) 完成。<br>&#160; &#160; &#160; &#160;当考虑叠加平面时，很容易发现这种方法的好处。它的目的是在显示硬件（而不是 GPU）中将多个缓冲区合成在一起。例如，假设有一部处于纵向模式的普通 Android 手机，其状态栏在顶部，导航栏在底部，其他地方为应用内容。每个层的内容都在单独的缓冲区中。您可以使用以下任一方法处理合成：</p>
<ul>
<li>将应用内容渲染到暂存缓冲区中，然后在其上渲染状态栏，再在其上渲染导航栏，最后将暂存缓冲区传送到显示硬件。</li>
<li>将三个缓冲区全部传送到显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。</li>
</ul>
<p>&#160; &#160; &#160; &#160;后一种方法可以显著提高效率。<br>&#160; &#160; &#160; &#160;上面两种合成分别叫<strong>离线合成</strong>和<strong>在线合成</strong>。</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/offlineandonline.jpg" alt="offlineandonline"></p>
<p>&#160; &#160; &#160; &#160;离线合成：先将所有图层画到一个最终层（FrameBuffer）上，再将FrameBuffer送到LCD显示。由于合成FrameBuffer与送LCD显示一般是异步的（线下生成FrameBuffer，需要时线上的LCD去取），因此叫离线合成。<br>&#160; &#160; &#160; &#160;在线合成：不使用FrameBuffer，在LCD需要显示某一行的像素时，用显示控制器将所有图层与该行相关的数据取出，合成一行像素送过去。只有一个图层时，又叫Overlay技术。<br>&#160; &#160; &#160; &#160;由于省去合成FrameBuffer时读图层，写FrameBuffer的步骤，大幅降低了内存传输量，减少了功耗，但这个需要硬件支持。</p>
<p>&#160; &#160; &#160; &#160;效率对比：大部分情况下，在线合成比起离线合成有很明显的优势，大幅降低了内存带宽的消耗。不过对于多屏显示，静态场景（仅限LCD不带缓存的情况），离线合成会有优势，做下简单的计算不难推得。</p>
<p>&#160; &#160; &#160; &#160;显示处理器功能差异很大。overlay的数量（无论层是否可以旋转或混合）以及对定位和叠加的限制很难通过 API 表达。HWC 会尝试通过一系列决策来适应这种多样性：</p>
<ol>
<li>SurfaceFlinger给HWC提供layer list，询问如何处理这些layer；</li>
<li>HWC将每个layer标记为overlay或者GLES composition，然后回馈给SurfaceFlinger；</li>
<li>SurfaceFlinger需要去处理那些GLES的合成，而不用去管overlay的合成，最后将overlay的layer和GLES合成后的buffer发送给HWC处理。</li>
</ol>
<p>&#160; &#160; &#160; &#160;用之前一幅图表示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/hwc.png" alt="hwc"></p>
<p>&#160; &#160; &#160; &#160;屏幕上的内容没有变化时，overlay的效率可能会低于 GL 合成。当overlay内容具有透明像素且overlay混合在一起时，尤其如此。在此类情况下，HWC 可以选择为部分或全部层请求 GLES 合成，并保留合成的缓冲区。如果 SurfaceFlinger 返回要求合成同一组缓冲区，HWC 可以继续显示先前合成的暂存缓冲区。这可以延长闲置设备的电池续航时间。<br>&#160; &#160; &#160; &#160;运行 Android 4.4 或更高版本的设备通常支持 4 个overlay。尝试合成多于overlay的层会导致系统对其中一些层使用 GLES 合成，这意味着应用使用的层数会对功耗和性能产生重大影响。</p>
<p>&#160; &#160; &#160; &#160;关于HWC HAL有更详细的解释，官网在置如此：<a href="https://source.android.google.cn/devices/graphics/implement-hwc" target="_blank" rel="external">https://source.android.google.cn/devices/graphics/implement-hwc</a> ，中文翻译的依旧有些别扭：</p>
<p>&#160; &#160; &#160; &#160;Hardware Composer HAL (HWC) 由 SurfaceFlinger 用来将 Surface 合成到屏幕。HWC 可以抽象出叠加层和 2D 位块传送器等对象，有助于分载通常使用 OpenGL 完成的一些工作。<br>Android 7.0 包含新版本的 HWC (HWC2)，由 SurfaceFlinger 用来与专门的窗口合成硬件进行通信。SurfaceFlinger 包含使用 3D 图形处理器 (GPU) 执行窗口合成任务的备用路径，但由于以下几个原因，此路径并不理想：</p>
<ul>
<li>通常，GPU 未针对此用例进行过优化，因此能耗可能要大于执行合成所需的能耗。</li>
<li>每次 SurfaceFlinger 使用 GPU 进行合成时，应用都无法使用处理器进行自我渲染，因此应尽可能使用专门的硬件而不是 GPU 进行合成。</li>
</ul>
<p>&#160; &#160; &#160; &#160;由于 Hardware Composer 抽象层后的物理显示设备硬件可因设备而异，因此很难就具体功能提供建议。一般来说，请遵循以下准则：</p>
<ul>
<li>HWC 应至少支持 4 个叠加层（状态栏、系统栏、应用和壁纸/背景）。</li>
<li>层可以大于屏幕，因此 HWC 应能处理大于显示屏的层（例如壁纸）。</li>
<li>应同时支持预乘每像素 Alpha 混合和每平面 Alpha 混合。</li>
<li>HWC 应能消耗 GPU、相机和视频解码器生成的相同缓冲区，因此支持以下某些属性很有帮助：<ul>
<li>RGBA 打包顺序</li>
<li>YUV 格式</li>
<li>平铺、重排和步幅属性</li>
</ul>
</li>
<li>为了支持受保护的内容，必须提供受保护视频播放的硬件路径。</li>
</ul>
<p>&#160; &#160; &#160; &#160;常规建议是首先实现非运行的 HWC；在结构完成后，实现一个简单的算法，以将合成委托给 HWC（例如，仅将前 3 个或前 4 个 Surface 委托给 HWC 的叠加硬件）。</p>
<p>&#160; &#160; &#160; &#160;专注于优化，例如智能地选择要发送到叠加硬件的 Surface，以最大限度提高从 GPU 移除的负载。另一种优化是检测屏幕是否正在更新；如果不是，则将合成委托给 OpenGL 而不是 HWC，以节省电量。当屏幕再次更新时，继续将合成分载到 HWC。<br>&#160; &#160; &#160; &#160;为常见用例做准备，如：</p>
<ul>
<li>纵向和横向模式下的全屏游戏</li>
<li>带有字幕和播放控件的全屏视频</li>
<li>主屏幕（合成状态栏、系统栏、应用窗口和动态壁纸）</li>
<li>受保护的视频播放</li>
<li>多显示设备支持</li>
</ul>
<p>&#160; &#160; &#160; &#160;这些用例应针对常规可预测的用途，而不是很少遇到的边缘用例（否则，优化将收效甚微）。实现必须平衡动画流畅性和交互延迟时间这两个相互矛盾的目标。</p>
<p>&#160; &#160; &#160; &#160;根据这些Google定义的这些准则，我们能够更好地分析配置硬件合成器的步骤。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>&#160; &#160; &#160; &#160;在分析setUpHWComposer函数之前，我们要回顾一下<a href="http://windrunnerlihuan.com/2017/05/25/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%94-VSync-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">Android SurfaceFlinger 学习之路(五)—-VSync 工作原理</a>中的<code>硬件加载</code>的部分，初始化<strong>显示设备</strong>和<strong>HWComposer设备</strong>的内容。</p>
<p>&#160; &#160; &#160; &#160;从上一部分得知，比如使用3D合成，需要大面积的像素混合计算和大量的内存传输（GPU读写GraphicBuffer所需），对GPU和DDR来说是一个巨大的负担。在GPU/DDR重度使用的场景（比如玩游戏），会造成发热、卡顿等。<br>&#160; &#160; &#160; &#160;为了提升性能，减少功耗，可以将合成这个过程交由另一个芯片完成，减轻GPU负担。进一步，直接让这个芯片连LCD，在LCD需要显示某一行时在线合成。<br>&#160; &#160; &#160; &#160;HwComposer便是这一个/多个专用合成芯片的驱动HAL层。<br>&#160; &#160; &#160; &#160;驱动由集成芯片系统的厂商自行设计，但需要遵循一定的标准，这个标准就是Android规定的HwComposer接口。</p>
<p>&#160; &#160; &#160; &#160;hwcomposer的接口定义位于此文件：<br>&#160; &#160; &#160; &#160;hardware/libhardware/include/hardware/hwcomposer.h<br>&#160; &#160; &#160; &#160;其中部分宏定义在：<br>&#160; &#160; &#160; &#160;hardware/libhardware/include/hardware/hwcomposer_defs.h</p>
<p>&#160; &#160; &#160; &#160;相关结构解释如下：</p>
<h4 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h4><p>&#160; &#160; &#160; &#160;在SurfaceFlinger中，Layer对应于window表示一个Buffer循环体系，对HwComposer而言，Layer仅指代当前Buffer，也即SurfaceFlinger中的Layer的当前帧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> hwc_layer_1 &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> compositionType;<span class="comment">//合成类型，SurfaceFlinger将合成目标Framebuffer的合成类型设为HWC_FRAMEBUFFER_TARGET，其他hwcomposer在prepare时根据实际情况修改</span></span><br><span class="line">    <span class="comment">//在(*prepare)()调用前，需要复位HWC_BACKGROUND or HWC_FRAMEBUFFER，需要设置HWC_GEOMETRY_CHANGED的标志符，并在(*prepare)()过程中保持，</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * HWC_BACKGROUND：(*prepare)()调用前设置，表明这是个特殊的"background"的层，backgroundColor是无效的，HWC向HWC_FRAMEBUFFER切换此值，并表示无法使用backgroundColor。</span><br><span class="line">     * HWC_FRAMEBUFFER_TARGET：在prepare前设置此值，此值表明此层是framebuffersurface层，作为OpenGLEScomposition的对象，如果HWC设置其他层为HWC_OVERLAY或则为HWC_BACKGROUND，则在set（）过程中opengles则什么都不干。</span><br><span class="line">     * 此标志仅仅用在版本至少为HWC_DEVICE_API_VERSION_1_1，在老版本的过程中，OpenGLES target 与（dpy, sur)通信，在HWC实现的过程中此值不能设置。</span><br><span class="line">     * 该Layer是3D合成的目标Layer</span><br><span class="line">     * HWC_FRAMEBUFFER：在(*prepare)()调用前设置，仅仅在HWC_GEOMETRY_CHANGED flag 也在设置的时候设置，并表明此层将使用opengles画进framebuffer中。HWC可以切换此值到HWC_OVERLAY表明其将要管理此层。</span><br><span class="line">     * hwcomposer无法处理此Layer，该Layer需要走3D合成流程，用OpenGL绘制</span><br><span class="line">     * HWC_OVERLAY：在(*prepare)()过程中，通过HWC设置，表明此层由HWC设置，不能通过OpenGLES 合成。</span><br><span class="line">     * 该Layer为硬件合成器所处理，不需要OpenGLES去渲染</span><br><span class="line">     * HWC_SIDEBAND：在(*prepare)()前设置，此值表明此层的内容来自于边带视频流，此流在适当的时间（去同步多媒体流），与其他层当前内容进行合成，显示结果图片。此现象依赖于正常的prepare/set周期。prepare/set调用仅仅发生在其他层的改变，或则是边带视频流的位置或则大小的改变。</span><br><span class="line">假如h/w composer 无法管理层由于边带视频流的原因（unsupportedscaling/blending/rotation, or too many sideband layers)，其可以在(*prepare)()设置合成类型为HWC_FRAMEBUFFER。但是，这样做显示维实体颜色，因为平台无法使用GPU进行合成边带视频层。这个问题在未来的平台版本中将得到改善。</span><br><span class="line">     * 该Layer为视频的边频带，需要硬件合成器作特殊处理，若不支持，OpenGL方式只能以一个色块替代，这个标志是外界（应用/驱动）调用窗口系统的perform方法配置的</span><br><span class="line">     * HWC_CURSOR_OVERLAY：在(*prepare)()期间，设置HWC实现，这个值意味着此层的合成将要被HWC的管理，另外，客户端在屏幕上可以异步刷新，这个层的位置可以使用setCursorPositionAsync() api。</span><br><span class="line">     * 该Layer可通过setCursorPositionAsync 方法改变坐标</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> hints;<span class="comment">//hwcomposer设置，通知SurfaceFlinger需要修改的配置</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    HWC_HINT_TRIPLE_BUFFER  = 0x00000001：表示需要SurfaceFlinger将此Layer改成3Buffer循环</span><br><span class="line">    HWC_HINT_CLEAR_FB       = 0x00000002：要求SurfaceFlinger清空该Layer位置的FrameBuffer数据（即置0）</span><br><span class="line">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;<span class="comment">//SurfaceFlinger设置，hwcomposer作处理</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    HWC_SKIP_LAYER = 0x00000001：此Layer不参与合成，应当忽略</span><br><span class="line">    HWC_IS_CURSOR_LAYER = 0x00000002：此Layer建议设定为一个CURSOR_LAYER，hwcomposer能处理的话将其合成类型改为HWC_CURSOR_OVERLAY</span><br><span class="line">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*该Layer的颜色/Buffer信息*/</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">hwc_color_t</span> backgroundColor;<span class="comment">//背景颜色，适用于纯色Layer，hwc_color_t 为一个 argb 结构体</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">buffer_handle_t</span> handle;<span class="comment">//此即之间提到的GraphicBuffer</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">native_handle_t</span>* sidebandStream;<span class="comment">//HWC_SIDEBAND类型Layer的buffer</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> transform;<span class="comment">//该Layer所需要作的变换，具体为：</span></span><br><span class="line">            <span class="comment">/*</span><br><span class="line">        HWC_TRANSFORM_FLIP_H = HAL_TRANSFORM_FLIP_H//水平翻转</span><br><span class="line">        HWC_TRANSFORM_FLIP_V = HAL_TRANSFORM_FLIP_V//垂直翻转</span><br><span class="line">        HWC_TRANSFORM_ROT_90 = HAL_TRANSFORM_ROT_90,//需要旋转90度</span><br><span class="line">        HWC_TRANSFORM_ROT_180 = HAL_TRANSFORM_ROT_180,//需要旋转180度</span><br><span class="line">        HWC_TRANSFORM_ROT_270 = HAL_TRANSFORM_ROT_270,//需要旋转270度</span><br><span class="line">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int32_t</span> blending;<span class="comment">//当前Layer绘制时，和底色/目标色的混合方式</span></span><br><span class="line">            <span class="comment">//HWC_BLENDING_NONE = 0x100：不混合，直接覆盖</span></span><br><span class="line">            <span class="comment">//HWC_BLENDING_PREMULT = 0x105：该Layer的颜色已经做过alpha预乘，因此混合方式为 src + (1-src.a)*dst</span></span><br><span class="line">            <span class="comment">//HWC_BLENDING_COVERAGE = 0x405：该Layer的颜色未做过预乘，按 src.a * src + (1-src.a) * dst 的方式混合</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="comment">// crop rectangle in integer (pre HWC_DEVICE_API_VERSION_1_3)</span></span><br><span class="line">                <span class="keyword">hwc_rect_t</span> sourceCropi;</span><br><span class="line">                <span class="keyword">hwc_rect_t</span> sourceCrop; <span class="comment">// just for source compatibility</span></span><br><span class="line">                <span class="comment">// crop rectangle in floats (as of HWC_DEVICE_API_VERSION_1_3)</span></span><br><span class="line">                <span class="keyword">hwc_frect_t</span> sourceCropf;</span><br><span class="line">            &#125;;<span class="comment">//该Layer取哪一个区域进行合成</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">hwc_rect_t</span> displayFrame;<span class="comment">//该Layer合成的目标区域</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">hwc_region_t</span> visibleRegionScreen;<span class="comment">//该Layer的可见区域，该区域必然是displayFrame的子集。这个区域由SurfaceFlinger计算而得，用于提示hwcomposer不去合成该Layer的不可见区域，hwcomposer中应当以这个为基准，对应计算该Layer相应的sourcecrop。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> acquireFenceFd;<span class="comment">//由Buffer生产者创建，SurfaceFlinger传递进来，hwcomposer在使用该Layer的Buffer之前，需要等这个fence</span></span><br><span class="line">            <span class="keyword">int</span> releaseFenceFd;<span class="comment">//由hwcomposer创建，生产者在使用该Buffer之前需要等此fence</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint8_t</span> planeAlpha;<span class="comment">//整个Layer的alpha值，在取Layer的像素作运算之前，需要先乘 planeAlpha/255。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Pad to 32 bits */</span></span><br><span class="line">            <span class="keyword">uint8_t</span> _pad[<span class="number">3</span>];<span class="comment">//用于结构体对齐，占位用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">hwc_region_t</span> surfaceDamage;<span class="comment">//记录相对上一次合成而言，发生了改变的source区域</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保留位，用于驱动层自行设计</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint8_t</span> reserved[<span class="number">120</span> - <span class="number">112</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint8_t</span> reserved[<span class="number">96</span> - <span class="number">84</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hwc_layer_1_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里面最难理解和最易出错的是 SourceCrop、DisplayFrame和VisibleRegion，在处理SOC上的显示问题时，这往往是首先考虑的因素： </p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/sourcecrop.jpg" alt="sourcecrop"></p>
<p>&#160; &#160; &#160; &#160;如图所示，该Layer的显示区域部分被L2完全挡住，source crop 为该Layer参与合成的范围，display frame 为该Layer合成的目标区域，visibleRegion为该Layer被挡住后，剩余的可见区域集。</p>
<p>&#160; &#160; &#160; &#160;这里我用了我的渣渣小米5，在Home页面，然后进入调试模式，输入adb shell dumpsys SurfaceFlinger ： </p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/SF.png" alt="SF"></p>
<p>&#160; &#160; &#160; &#160;截取出这段信息，这段信息是SurfaceFlinger告知硬件合成器如何进行合成的。<strong>最后一个FramebufferTarget是目标层，不算进去</strong>，参与合成的图层是三个，分别是 :</p>
<ul>
<li>com.android.systemui.ImageWallpaper</li>
<li>com.miui.home/com.miui.home.launcher.Launcher</li>
<li>StatusBar</li>
</ul>
<p>&#160; &#160; &#160; &#160;其他参数对比我们上面的hwc_layer_1_t结构体，就能理解这些参数的意义。</p>
<h4 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> hwc_display_contents_1 &#123;</span><br><span class="line">    <span class="comment">/* hwcomposer设置，surfaceflinger去等的fence。对于物理屏(实际上是使用在线合成方式的物理屏），对于虚拟屏/离线合成，此fence在离线合成的目标buffer完成全部写入后解除。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">int</span> retireFenceFd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">/* HWC_DEVICE_VERSION_1_0 使用，dpy和sur对应于EGLDisplay 和 EGLSurface</span><br><span class="line">             */</span></span><br><span class="line">            <span class="keyword">hwc_display_t</span> dpy;</span><br><span class="line">            <span class="keyword">hwc_surface_t</span> sur;</span><br><span class="line">        &#125;;<span class="comment">//HWC_DEVICE_VERSION_1_0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">/*HWC_DEVICE_VERSION_1_3 之后支持 hwcomposer合成多屏，这里是指虚拟屏的输出buffer和对应的fence*/</span></span><br><span class="line">            <span class="keyword">buffer_handle_t</span> outbuf;</span><br><span class="line">            <span class="keyword">int</span> outbufAcquireFenceFd;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*合成该显示屏的所有Layer*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">size_t</span> numHwLayers;</span><br><span class="line">    <span class="keyword">hwc_layer_1_t</span> hwLayers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hwc_display_contents_1_t</span>;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;物理显示屏表示连接实际的显示仪器如LCD，目的是产生显示效果，可以使用在线合成。<br>&#160; &#160; &#160; &#160;虚拟显示屏表示目的是合成一个Buffer，不需要理会这个Buffer后续如何产生显示效果，这时需要把所有图层合成到指定的Buffer上。这种情况下必须离线合成。典型场景是手机连WFD/hdmi，手机合成好的Buffer通过wifi/hdmi传输到电视上显示。</p>
<h4 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h4><p>&#160; &#160; &#160; &#160;最后是device的函数指针定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> hwc_composer_device_1 &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="comment">//这种方式相当于C语言的继承实现，理解为 hwc_composer_device_1 继承于 hw_device_t 就可以了。</span></span><br><span class="line">    <span class="comment">//hw_device_t 包含一个基本信息 version（版本号），下面会提到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*对所有显示屏中所有Layer作合成准备（此时也可以开始发送合成的命令码下去，启动硬件合成，但不需要等待完成），hwcomposer需要正确汇报每个Layer的composetype，以告知SurfaceFlinger是否需要额外处理。</span><br><span class="line">    version 为 1.0 的驱动，只支持一个显示屏</span><br><span class="line">    version 为 1.1 的驱动，只支持物理显示屏</span><br><span class="line">    version 为 1.3 及以上的驱动，支持物理和虚拟显示屏*/</span></span><br><span class="line">    <span class="keyword">int</span> (*prepare)(<span class="keyword">struct</span> hwc_composer_device_1 *dev,</span><br><span class="line">                    <span class="keyword">size_t</span> numDisplays, <span class="keyword">hwc_display_contents_1_t</span>** displays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*此方法将完成各个图层的合成与显示，等效于EGL标准里面的eglSwapBuffers，不过eglSwapBuffers是对OpenGL标准/GPU有效，此方法是对硬件合成器有效*/</span></span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">set</span>)(<span class="keyword">struct</span> hwc_composer_device_1 *dev,</span><br><span class="line">                <span class="keyword">size_t</span> numDisplays, <span class="keyword">hwc_display_contents_1_t</span>** displays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*这个接口一般只用于开启hwcomposer的vsync，在线合成触发vsync的机制较离线合成的设计会麻烦一些*/</span></span><br><span class="line">    <span class="keyword">int</span> (*eventControl)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">int</span> disp,</span><br><span class="line">            <span class="keyword">int</span> event, <span class="keyword">int</span> enabled);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制屏幕状态的方法</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">/* HWC 1.3及之前版本，采用 blank 方式，开关某个显示屏 */</span></span><br><span class="line">        <span class="keyword">int</span> (*blank)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">int</span> disp, <span class="keyword">int</span> blank);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* HWC 1.4及之后，提供更精细的 setPowerMode ，支持显示屏以较低功耗（但不关）的状态显示*/</span></span><br><span class="line">        <span class="keyword">int</span> (*setPowerMode)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">int</span> disp,</span><br><span class="line">                <span class="keyword">int</span> mode);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*查询Hwcomposer的信息*/</span></span><br><span class="line">    <span class="keyword">int</span> (*query)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">int</span> what, <span class="keyword">int</span>* value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注册</span><br><span class="line">    *invalidate：屏幕刷新时触发</span><br><span class="line">    *vsync：hwcomopser中的vsync事件产生时触发</span><br><span class="line">    *hotplug：显示屏连接/断开时触发</span><br><span class="line">    * 三个回调函数*/</span></span><br><span class="line">    <span class="keyword">void</span> (*registerProcs)(<span class="keyword">struct</span> hwc_composer_device_1* dev,</span><br><span class="line">            <span class="keyword">hwc_procs_t</span> <span class="keyword">const</span>* procs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*打印信息，调试用*/</span></span><br><span class="line">    <span class="keyword">void</span> (*dump)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">char</span> *buff, <span class="keyword">int</span> buff_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取显示屏配置、属性*/</span></span><br><span class="line">    <span class="keyword">int</span> (*getDisplayConfigs)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">int</span> disp,</span><br><span class="line">            <span class="keyword">uint32_t</span>* configs, <span class="keyword">size_t</span>* numConfigs);</span><br><span class="line">    <span class="keyword">int</span> (*getDisplayAttributes)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">int</span> disp,</span><br><span class="line">            <span class="keyword">uint32_t</span> config, <span class="keyword">const</span> <span class="keyword">uint32_t</span>* attributes, <span class="keyword">int32_t</span>* values);</span><br><span class="line">    <span class="keyword">int</span> (*getActiveConfig)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">int</span> disp);</span><br><span class="line">    <span class="comment">/*配置属性，index表示有效属性的编号*/</span></span><br><span class="line">    <span class="keyword">int</span> (*setActiveConfig)(<span class="keyword">struct</span> hwc_composer_device_1* dev, <span class="keyword">int</span> disp,</span><br><span class="line">            <span class="keyword">int</span> index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*更改游标层的坐标*/</span></span><br><span class="line">    <span class="keyword">int</span> (*setCursorPositionAsync)(<span class="keyword">struct</span> hwc_composer_device_1 *dev, <span class="keyword">int</span> disp, <span class="keyword">int</span> x_pos, <span class="keyword">int</span> y_pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*自行添加的保留函数*/</span></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hwc_composer_device_1_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&#160; &#160; &#160; &#160;然后我们看看setUpHWComposer的实现。这个函数有点长，但是每个步骤都比较清晰，我们分步骤查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::setUpHWComposer() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">        <span class="keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If nothing has changed (!dirty), don't recompose.</span></span><br><span class="line">        <span class="comment">// If something changed, but we don't currently have any visible layers,</span></span><br><span class="line">        <span class="comment">//   and didn't when we last did a composition, then skip it this time.</span></span><br><span class="line">        <span class="comment">// The second rule does two things:</span></span><br><span class="line">        <span class="comment">// - When all layers are removed from a display, we'll emit one black</span></span><br><span class="line">        <span class="comment">//   frame, then nothing more until we get new layers.</span></span><br><span class="line">        <span class="comment">// - When a display is created with a private layer stack, we won't</span></span><br><span class="line">        <span class="comment">//   emit any black frames until a layer is added to the layer stack.</span></span><br><span class="line">        <span class="comment">//如果没有改变（！dirty），不重新合成</span></span><br><span class="line">        <span class="comment">//如果有变化，但是当前没有可见的layers，并且上次合成过，那么这次跳过</span></span><br><span class="line">        <span class="comment">//有两个规则如下：</span></span><br><span class="line">        <span class="comment">//1.当所有的layers从显示屏移除，我们发射一个黑的frame，在来到新的layer之前都是黑的</span></span><br><span class="line">        <span class="comment">//2.当一个显示屏被创建时候带着一个私有的layer栈，我们直到新的layer被添加到这个layer stack时，</span></span><br><span class="line">        <span class="comment">//才发射黑的frame</span></span><br><span class="line">        <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">        ALOGV_IF(mDisplays[dpy]-&gt;getDisplayType() == DisplayDevice::DISPLAY_VIRTUAL,</span><br><span class="line">                <span class="string">"dpy[%zu]: %s composition (%sdirty %sempty %swasEmpty)"</span>, dpy,</span><br><span class="line">                mustRecompose ? <span class="string">"doing"</span> : <span class="string">"skipping"</span>,</span><br><span class="line">                dirty ? <span class="string">"+"</span> : <span class="string">"-"</span>,</span><br><span class="line">                empty ? <span class="string">"+"</span> : <span class="string">"-"</span>,</span><br><span class="line">                wasEmpty ? <span class="string">"+"</span> : <span class="string">"-"</span>);</span><br><span class="line">        <span class="comment">//DisplayDevice的beginFrame函数，调用FrameBufferSurface的beginFrame函数，返回NO_ERROR</span></span><br><span class="line">        mDisplays[dpy]-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">            mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一步检查每个显示的dirty区域是否改变了，如果是就要Recompose。DisplayDevice的beginFrame函数，调用FrameBufferSurface的beginFrame函数，返回NO_ERROR。如果需要重新合成，将DisplayDevice的lastCompositionHadVisibleLayers标志只为true（！empty）。<br>&#160; &#160; &#160; &#160;这一步作用不大，可以忽略。</p>
<p>&#160; &#160; &#160; &#160;go on：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HWComposer&amp; hwc(getHwComposer());  </span><br><span class="line">    if (hwc.initCheck() == NO_ERROR) &#123;  </span><br><span class="line">        // build the h/w work list  </span><br><span class="line">        if (CC_UNLIKELY(mHwWorkListDirty)) &#123;  </span><br><span class="line">            mHwWorkListDirty = false;  </span><br><span class="line">            for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;//遍历mDisplays  </span><br><span class="line">                sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); </span><br><span class="line">                //以前我们讲过，这个id就是不同display的type，比如0，1，2 </span><br><span class="line">                const int32_t id = hw-&gt;getHwcDisplayId();  </span><br><span class="line">                if (id &gt;= 0) &#123;  </span><br><span class="line">                    const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(//遍历DisplayDevice所有可见layer  </span><br><span class="line">                        hw-&gt;getVisibleLayersSortedByZ());  </span><br><span class="line">                    const size_t count = currentLayers.size();  </span><br><span class="line">                    if (hwc.createWorkList(id, count) == NO_ERROR) &#123;//根据layer数量调用createWorkList创建hwc_layer_list_t列表  </span><br><span class="line">                        HWComposer::LayerListIterator cur = hwc.begin(id);  </span><br><span class="line">                        const HWComposer::LayerListIterator end = hwc.end(id);  </span><br><span class="line">                        for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;  </span><br><span class="line">                            const sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                            //设置HWC每一个帧hwc_layer_1_t的Geometry信息</span><br><span class="line">                            //如transform/orientation/alpha等</span><br><span class="line">                            layer-&gt;setGeometry(hw, *cur);  </span><br><span class="line">                            if (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;  </span><br><span class="line">                                cur-&gt;setSkip(true);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一步主要工作有：<br>&#160; &#160; &#160; &#160;1）遍历mDisplays，在所有显示屏信息中，遍历DisplayDevice所有可见layer；<br>&#160; &#160; &#160; &#160;2）根据layer数量调用createWorkList创建hwc_layer_list_t列表；<br>&#160; &#160; &#160; &#160;3）设置HWC每一个帧hwc_layer_1_t的Geometry信息，如transform/orientation/alpha等。</p>
<p>&#160; &#160; &#160; &#160;我们先来看下HWComposer的createWorkList函数实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> HWComposer::createWorkList(<span class="keyword">int32_t</span> id, <span class="keyword">size_t</span> numLayers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(id)&gt;<span class="number">31</span> || !mAllocatedDisplayIDs.hasBit(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_INDEX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[id])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">            <span class="comment">// we need space for the HWC_FRAMEBUFFER_TARGET</span></span><br><span class="line">            <span class="comment">//当支持Open GL合成时候，会把numLayer数目+1，</span></span><br><span class="line">            <span class="comment">//这个多余的1就是合成目标HWC_FRAMEBUFFER_TARGET</span></span><br><span class="line">            <span class="comment">//之前从dumpsys SurfaceFlinger中能看到最后一个是HWC_FRAMEBUFFER_TARGET</span></span><br><span class="line">            numLayers++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////当DisplayData中的list为空，我们就要malloc  </span></span><br><span class="line">        <span class="keyword">if</span> (disp.capacity &lt; numLayers || disp.<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//整个申请内存长度，hwc_display_contents_1_t结构体本身的长度加上后面hwc_layer_1_t个数的长度  </span></span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">hwc_display_contents_1_t</span>)</span><br><span class="line">                    + numLayers * <span class="keyword">sizeof</span>(<span class="keyword">hwc_layer_1_t</span>);</span><br><span class="line">            <span class="built_in">free</span>(disp.<span class="built_in">list</span>);</span><br><span class="line">            disp.<span class="built_in">list</span> = (<span class="keyword">hwc_display_contents_1_t</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">            disp.capacity = numLayers;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">            disp.framebufferTarget = &amp;disp.<span class="built_in">list</span>-&gt;hwLayers[numLayers - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//DisplayData的framebufferTarget清0 </span></span><br><span class="line">            <span class="built_in">memset</span>(disp.framebufferTarget, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">hwc_layer_1_t</span>));</span><br><span class="line">            <span class="keyword">const</span> DisplayConfig&amp; currentConfig =</span><br><span class="line">                    disp.configs[disp.currentConfig];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">hwc_rect_t</span> r = &#123; <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) currentConfig.width, (<span class="keyword">int</span>) currentConfig.height &#125;;</span><br><span class="line">            disp.framebufferTarget-&gt;compositionType = HWC_FRAMEBUFFER_TARGET;</span><br><span class="line">            disp.framebufferTarget-&gt;hints = <span class="number">0</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;flags = <span class="number">0</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;handle = disp.fbTargetHandle;</span><br><span class="line">            disp.framebufferTarget-&gt;transform = <span class="number">0</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;blending = HWC_BLENDING_PREMULT;</span><br><span class="line">            <span class="comment">//framebufferTarget的sourceCrop初始化</span></span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCropf.left = <span class="number">0</span>;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCropf.top = <span class="number">0</span>;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCropf.right =</span><br><span class="line">                        currentConfig.width;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCropf.bottom =</span><br><span class="line">                        currentConfig.height;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disp.framebufferTarget-&gt;sourceCrop = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//framebufferTarget的displayFrame初始化</span></span><br><span class="line">            disp.framebufferTarget-&gt;displayFrame = r;</span><br><span class="line">            disp.framebufferTarget-&gt;visibleRegionScreen.numRects = <span class="number">1</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;visibleRegionScreen.rects =</span><br><span class="line">                &amp;disp.framebufferTarget-&gt;displayFrame;</span><br><span class="line">            disp.framebufferTarget-&gt;acquireFenceFd = <span class="number">-1</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;releaseFenceFd = <span class="number">-1</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;planeAlpha = <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        disp.<span class="built_in">list</span>-&gt;retireFenceFd = <span class="number">-1</span>;</span><br><span class="line">        disp.<span class="built_in">list</span>-&gt;flags = HWC_GEOMETRY_CHANGED;</span><br><span class="line">        disp.<span class="built_in">list</span>-&gt;numHwLayers = numLayers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;当支持Open GL合成时候，会把numLayer数目+1，这个多余的1就是合成目标HWC_FRAMEBUFFER_TARGET，之前从dumpsys SurfaceFlinger中能看到最后一个是HWC_FRAMEBUFFER_TARGET。<br>&#160; &#160; &#160; &#160;然后就是为DisplayData的list申请内存，这个内存要先hwc_display_contents_1_t结构体本身的长度加上后面hwc_layer_1_t个数的长度。<br>&#160; &#160; &#160; &#160;后面用DisplayData中list中hwLayers最后一个作为DisplayData中的framebufferTarget。<br>&#160; &#160; &#160; &#160;最后就是framebufferTarget的一些初始化操作。</p>
<p>&#160; &#160; &#160; &#160;关于DisplayData结构体，可以回顾<a href="http://windrunnerlihuan.com/2017/05/25/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%94-VSync-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">Android SurfaceFlinger 学习之路(五)—-VSync 工作原理</a>中的<code>硬件加载</code>的部分，初始化<strong>显示设备</strong>和<strong>HWComposer设备</strong>的内容，这里先贴出来结构体内容：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> DisplayData &#123;  </span><br><span class="line">    DisplayData();  </span><br><span class="line">    ~DisplayData();  </span><br><span class="line">    Vector&lt;DisplayConfig&gt; configs;  </span><br><span class="line">    <span class="keyword">size_t</span> currentConfig;  </span><br><span class="line">    <span class="keyword">uint32_t</span> format;    <span class="comment">// pixel format from FB hal, for pre-hwc-1.1  </span></span><br><span class="line">    <span class="keyword">bool</span> connected;  </span><br><span class="line">    <span class="keyword">bool</span> hasFbComp;  </span><br><span class="line">    <span class="keyword">bool</span> hasOvComp;  </span><br><span class="line">    <span class="keyword">size_t</span> capacity;  </span><br><span class="line">    <span class="comment">//上面构造Worklist，并且给DisplayData:list 申请空间</span></span><br><span class="line">    hwc_display_contents_1* <span class="built_in">list</span>;  </span><br><span class="line">    <span class="comment">//DisplayData中list中hwLayers最后一个作为DisplayData中的framebufferTarget</span></span><br><span class="line">    hwc_layer_1* framebufferTarget;  </span><br><span class="line">    <span class="keyword">buffer_handle_t</span> fbTargetHandle;  </span><br><span class="line">    sp&lt;Fence&gt; lastRetireFence;  <span class="comment">// signals when the last set op retires  </span></span><br><span class="line">    sp&lt;Fence&gt; lastDisplayFence; <span class="comment">// signals when the last set op takes  </span></span><br><span class="line">                                <span class="comment">// effect on screen  </span></span><br><span class="line">    <span class="keyword">buffer_handle_t</span> outbufHandle;  </span><br><span class="line">    sp&lt;Fence&gt; outbufAcquireFence;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// protected by mEventControlLock  </span></span><br><span class="line">    <span class="keyword">int32_t</span> events;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DisplayData 结构体的成员list是一个hwc_display_contents_1指针，这个hwc_display_contents_1结构体我们上面讲过。里面有个联合体union，联合体里面又有两个结构体。</p>
<ul>
<li>第一个结构体是HWC_DEVICE_VERSION_1_0 使用，dpy和sur对应于EGLDisplay 和 EGLSurface，这是EGL使用的</li>
<li>第二个结构体是HWC_DEVICE_VERSION_1_3 之后支持 hwcomposer合成多屏，这里是指虚拟屏的输出buffer和对应的fence</li>
</ul>
<p>&#160; &#160; &#160; &#160;hwc_display_contents_1后面成员保存了后面还保存了layer的个数和hwc_layer_1_t 数组的起始地址hwLayers[0]。</p>
<p>&#160; &#160; &#160; &#160;DisplayData 结构体的成员framebufferTarget是一个hwc_layer_1指针，这个hwc_layer_1我们上面也贴出来了。相关成员可以参考上面的内容，包括上面提到的 SourceCrop、DisplayFrame和VisibleRegion。其主要数据在buffer_handle_t handle中，buffer_handle_t 其实就是native_handle_t之前分析过，里面有共享内存的fd和地址。关于buffer_handle_t可以回顾之前申请GraphicBuffer的内容。</p>
<p>&#160; &#160; &#160; &#160;然后就是设置HWC每一个帧hwc_layer_1_t的Geometry信息，如transform/orientation/alpha等。不过这之前我们要先看看HWComposer的begin和end函数，还有相关类或者结构体。</p>
<p>&#160; &#160; &#160; &#160;先看下HWComposer中的begin函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::LayerListIterator HWComposer::begin(<span class="keyword">int32_t</span> id) &#123;</span><br><span class="line">    <span class="keyword">return</span> getLayerIterator(id, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWComposer::LayerListIterator HWComposer::getLayerIterator(<span class="keyword">int32_t</span> id, <span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(id)&gt;<span class="number">31</span> || !mAllocatedDisplayIDs.hasBit(id)) &#123;<span class="comment">//pass</span></span><br><span class="line">        <span class="keyword">return</span> LayerListIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[id])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mHwc || !disp.<span class="built_in">list</span> || index &gt; disp.<span class="built_in">list</span>-&gt;numHwLayers) &#123;<span class="comment">//pass</span></span><br><span class="line">        <span class="keyword">return</span> LayerListIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//go to</span></span><br><span class="line">    <span class="keyword">return</span> LayerListIterator(<span class="keyword">new</span> HWCLayerVersion1(mHwc, disp.<span class="built_in">list</span>-&gt;hwLayers), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里不走前两个if，最后新建一个LayerListIterator对象，构造函数中传入HWCLayerVersion1对象，和index，为0。我们贴出来LayerListIterator类结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Iterator through a HWCLayer list.</span><br><span class="line"> * This behaves more or less like a forward iterator.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> LayerListIterator &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">struct</span> HWComposer;</span><br><span class="line">    HWCLayer* <span class="keyword">const</span> mLayerList;</span><br><span class="line">    <span class="keyword">size_t</span> mIndex;</span><br><span class="line"></span><br><span class="line">    LayerListIterator() : mLayerList(<span class="literal">NULL</span>), mIndex(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    LayerListIterator(HWCLayer* layer, <span class="keyword">size_t</span> index)</span><br><span class="line">        : mLayerList(layer), mIndex(index) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we don't allow assignment, because we don't need it for now</span></span><br><span class="line">    LayerListIterator&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> LayerListIterator&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// copy operators</span></span><br><span class="line">    LayerListIterator(<span class="keyword">const</span> LayerListIterator&amp; rhs)</span><br><span class="line">        : mLayerList(HWCLayer::copy(rhs.mLayerList)), mIndex(rhs.mIndex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~LayerListIterator() &#123; <span class="keyword">delete</span> mLayerList; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pre-increment</span></span><br><span class="line">    LayerListIterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        mLayerList-&gt;setLayer(++mIndex);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dereference</span></span><br><span class="line">    HWCLayerInterface&amp; <span class="keyword">operator</span> * () &#123; <span class="keyword">return</span> *mLayerList; &#125;</span><br><span class="line">    HWCLayerInterface* <span class="keyword">operator</span> -&gt; () &#123; <span class="keyword">return</span> mLayerList; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// comparison</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> LayerListIterator&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mIndex == rhs.mIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> LayerListIterator&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">operator</span>==(rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>这里要留意一下后面几个运算符重载，后面会用到。</strong><br>&#160; &#160; &#160; &#160;这里面HWCLayerVersion1就是mLayerList， index就是mIndex。HWCLayerVersion1的结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Concrete implementation of HWCLayer for HWC_DEVICE_API_VERSION_1_0.</span><br><span class="line"> * This implements the HWCLayer side of HWCIterableLayer.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> HWCLayerVersion1 : <span class="keyword">public</span> Iterable&lt;HWCLayerVersion1, <span class="keyword">hwc_layer_1_t</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">struct</span> hwc_composer_device_1* mHwc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HWCLayerVersion1(<span class="keyword">struct</span> hwc_composer_device_1* hwc, <span class="keyword">hwc_layer_1_t</span>* layer)</span><br><span class="line">        : Iterable&lt;HWCLayerVersion1, <span class="keyword">hwc_layer_1_t</span>&gt;(layer), mHwc(hwc) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ignore</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造函数中传入了mHwc和disp.list-&gt;hwLayers，就是HWC Device HAL层指针和上面我们分析的合成该显示屏的所有Layer。</p>
<p>&#160; &#160; &#160; &#160;而我们再来看看下HWComposer中的end函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::LayerListIterator HWComposer::end(<span class="keyword">int32_t</span> id) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> numLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(id) &lt;= <span class="number">31</span> &amp;&amp; mAllocatedDisplayIDs.hasBit(id)) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[id])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mHwc &amp;&amp; disp.<span class="built_in">list</span>) &#123;</span><br><span class="line">            numLayers = disp.<span class="built_in">list</span>-&gt;numHwLayers;<span class="comment">//获取到list中laye的个数  </span></span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">                <span class="comment">// with HWC 1.1, the last layer is always the HWC_FRAMEBUFFER_TARGET,</span></span><br><span class="line">                <span class="comment">// which we ignore when iterating through the layer list.</span></span><br><span class="line">                ALOGE_IF(!numLayers, <span class="string">"mDisplayData[%d].list-&gt;numHwLayers is 0"</span>, id);</span><br><span class="line">                <span class="keyword">if</span> (numLayers) &#123;</span><br><span class="line">                    numLayers--;<span class="comment">//变成最后一个用于合成的layer，因为本来最后一个是HWC_FRAMEBUFFER_TARGET</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getLayerIterator(id, numLayers);<span class="comment">//和上面一样，只是传入的index不一样。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;end函数和begin很像只是在调用getLayerIterator的时候，begin传入0，end传入layer的最后一位，变成最后一个用于合成的layer，因为本来最后一个是HWC_FRAMEBUFFER_TARGET。最后就是mIndex成员变量不一样。</p>
<p>&#160; &#160; &#160; &#160;接着我们回到上面setUpHWComposer函数，第二部第三个步骤，layer-&gt;setGeometry(hw, （星号，解引用，MD语法转义了这个符号）cur);这里layer是Layer对象，hw是DisplayDevice对象，cur是HWComposer::LayerListIterator对象。<strong>我们上面强调了一定要注意LayerListIterator类内部的运算符重载，这里用到了（星号，解引用，MD语法转义了这个符号）运算符</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HWCLayerInterface&amp; <span class="keyword">operator</span> * () &#123; <span class="keyword">return</span> *mLayerList; &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;而上面的mLayerList就是HWCLayerVersion1对象。所以我们继续查看Layer的setGeometry函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">void Layer::setGeometry(</span><br><span class="line">    const sp&lt;const DisplayDevice&gt;&amp; hw,</span><br><span class="line">        HWComposer::HWCLayerInterface&amp; layer)</span><br><span class="line">&#123;</span><br><span class="line">    layer.setDefaultState();</span><br><span class="line"></span><br><span class="line">    // enable this layer</span><br><span class="line">    layer.setSkip(false);</span><br><span class="line">    //受安全保护的layer，不可以在进程间传入，所以合成时候跳过</span><br><span class="line">    if (isSecure() &amp;&amp; !hw-&gt;isSecure()) &#123;</span><br><span class="line">        layer.setSkip(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this gives us only the "orientation" component of the transform</span><br><span class="line">    const State&amp; s(getDrawingState());</span><br><span class="line">    //半透明颜色处理</span><br><span class="line">    if (!isOpaque(s) || s.alpha != 0xFF) &#123;</span><br><span class="line">        layer.setBlending(mPremultipliedAlpha ?</span><br><span class="line">                HWC_BLENDING_PREMULT :</span><br><span class="line">                HWC_BLENDING_COVERAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // apply the layer's transform, followed by the display's global transform</span><br><span class="line">    // here we're guaranteed that the layer's transform preserves rects</span><br><span class="line">    //处理displayFrame，sourceCrop，还有透明度</span><br><span class="line">    Rect frame(s.transform.transform(computeBounds()));</span><br><span class="line">    frame.intersect(hw-&gt;getViewport(), &amp;frame);</span><br><span class="line">    const Transform&amp; tr(hw-&gt;getTransform());</span><br><span class="line">    layer.setFrame(tr.transform(frame));</span><br><span class="line">    layer.setCrop(computeCrop(hw));</span><br><span class="line">    layer.setPlaneAlpha(s.alpha);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Transformations are applied in this order:</span><br><span class="line">     * 1) buffer orientation/flip/mirror</span><br><span class="line">     * 2) state transformation (window manager)</span><br><span class="line">     * 3) layer orientation (screen orientation)</span><br><span class="line">     * (NOTE: the matrices are multiplied in reverse order)</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    const Transform bufferOrientation(mCurrentTransform);</span><br><span class="line">    Transform transform(tr * s.transform * bufferOrientation);</span><br><span class="line">    //如果这个图形缓冲区之前曾经被旋转过，例如，被水平翻转或者垂直翻转过，那么在对它进行合并之前，还需要将它的旋转方向恢复回来。</span><br><span class="line">    if (mSurfaceFlingerConsumer-&gt;getTransformToDisplayInverse()) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * the code below applies the display's inverse transform to the buffer</span><br><span class="line">         */</span><br><span class="line">        uint32_t invTransform = hw-&gt;getOrientationTransform();</span><br><span class="line">        uint32_t t_orientation = transform.getOrientation();</span><br><span class="line">        // calculate the inverse transform</span><br><span class="line">        if (invTransform &amp; NATIVE_WINDOW_TRANSFORM_ROT_90) &#123;</span><br><span class="line">            invTransform ^= NATIVE_WINDOW_TRANSFORM_FLIP_V |</span><br><span class="line">                    NATIVE_WINDOW_TRANSFORM_FLIP_H;</span><br><span class="line">            // If the transform has been rotated the axis of flip has been swapped</span><br><span class="line">            // so we need to swap which flip operations we are performing</span><br><span class="line">            bool is_h_flipped = (t_orientation &amp; NATIVE_WINDOW_TRANSFORM_FLIP_H) != 0;</span><br><span class="line">            bool is_v_flipped = (t_orientation &amp; NATIVE_WINDOW_TRANSFORM_FLIP_V) != 0;</span><br><span class="line">            if (is_h_flipped != is_v_flipped) &#123;</span><br><span class="line">                t_orientation ^= NATIVE_WINDOW_TRANSFORM_FLIP_V |</span><br><span class="line">                        NATIVE_WINDOW_TRANSFORM_FLIP_H;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // and apply to the current transform</span><br><span class="line">        transform = Transform(t_orientation) * Transform(invTransform);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // this gives us only the "orientation" component of the transform</span><br><span class="line">    const uint32_t orientation = transform.getOrientation();</span><br><span class="line">    if (orientation &amp; Transform::ROT_INVALID) &#123;</span><br><span class="line">        // we can only handle simple transformation</span><br><span class="line">        layer.setSkip(true);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        layer.setTransform(orientation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面就是设置Layer的Geometry信息：<br>&#160; &#160; &#160; &#160;1）受安全保护的layer，不可以在进程间传入，所以合成时候跳过。界面受到安全保护的应用程序窗口的内容是不可以在进程间传输的，这个属性主要是应用在屏幕截图中。例如，如果系统中存在一个界面受到安全保护的应用程序窗口，那么我们就不可以请求SurfaceFlinger服务执行截屏功能，因为SurfaceFlinger服务截取下来的屏幕会被传输给请求的进程使用。<br>&#160; &#160; &#160; &#160;2）处理displayFrame，sourceCrop，还有透明度。<br>&#160; &#160; &#160; &#160;3）如果这个图形缓冲区之前曾经被旋转过，例如，被水平翻转或者垂直翻转过，那么在对它进行合并之前，还需要将它的旋转方向恢复回来。</p>
<p>&#160; &#160; &#160; &#160;这样我们setUpHWComposer第二部就完了，go on：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// set the per-frame data</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">    <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">            hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">        HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">        <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * update the per-frame h/w composer data for each layer</span><br><span class="line">             * and build the transparent region of the FB</span><br><span class="line">             */</span></span><br><span class="line">             <span class="comment">//将layer的mActiveBuffer设置到HWComposer中去  </span></span><br><span class="line">            <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">            layer-&gt;setPerFrameData(hw, *cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;有了上面的基础，我们先留意上面强调过，<strong>注意LayerListIterator类内部的运算符重载</strong>，这里需要用到的是++的重载：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LayerListIterator&amp; <span class="keyword">operator</span>++() &#123;  </span><br><span class="line">    mLayerList-&gt;setLayer(++mIndex);  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">setLayer</span><span class="params">(<span class="keyword">size_t</span> index)</span> </span>&#123;  </span><br><span class="line">    mCurrentLayer = &amp;mLayerList[index];  </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;会调用mLayerList-&gt;setLayer函数,setLayer会从mLayerList中设置当前的mCurrentLayer，通过mLayerList, 这个变量就是disp.list-&gt;hwLayers。<br>&#160; &#160; &#160; &#160;这样准备工作就好了，我们再来分析Layer的setPerFrameData函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> Layer::setPerFrameData(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">        HWComposer::HWCLayerInterface&amp; layer) &#123;</span><br><span class="line">    <span class="comment">// we have to set the visible region on every frame because</span></span><br><span class="line">    <span class="comment">// we currently free it during onLayerDisplayed(), which is called</span></span><br><span class="line">    <span class="comment">// after HWComposer::commit() -- every frame.</span></span><br><span class="line">    <span class="comment">// Apply this display's projection's viewport to the visible region</span></span><br><span class="line">    <span class="comment">// before giving it to the HWC HAL.</span></span><br><span class="line">    <span class="keyword">const</span> Transform&amp; tr = hw-&gt;getTransform();</span><br><span class="line">    Region visible = tr.transform(visibleRegion.intersect(hw-&gt;getViewport()));</span><br><span class="line">    layer.setVisibleRegionScreen(visible);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSidebandStream.get()) &#123;</span><br><span class="line">        layer.setSidebandStream(mSidebandStream);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> buffer can be NULL if the client never drew into this</span></span><br><span class="line">        <span class="comment">// layer yet, or if we ran out of memory</span></span><br><span class="line">        layer.setBuffer(mActiveBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;主要就是调用了HWCLayerVersion1的setBuffer函数:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setBuffer</span><span class="params">(<span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (buffer == <span class="number">0</span> || buffer-&gt;handle == <span class="number">0</span>) &#123;</span><br><span class="line">           getLayer()-&gt;compositionType = HWC_FRAMEBUFFER;</span><br><span class="line">           getLayer()-&gt;flags |= HWC_SKIP_LAYER;</span><br><span class="line">           getLayer()-&gt;handle = <span class="number">0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (getLayer()-&gt;compositionType == HWC_SIDEBAND) &#123;</span><br><span class="line">               <span class="comment">// If this was a sideband layer but the stream was removed, reset</span></span><br><span class="line">               <span class="comment">// it to FRAMEBUFFER. The HWC can change it to OVERLAY in prepare.</span></span><br><span class="line">               getLayer()-&gt;compositionType = HWC_FRAMEBUFFER;</span><br><span class="line">           &#125;</span><br><span class="line">           getLayer()-&gt;handle = buffer-&gt;handle;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> HWCTYPE* <span class="title">getLayer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mCurrentLayer; &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>用getLayer函数设置其handle，而getLayer就是mCurrentLayer。之前mCurrentLayer会一个个遍历各个Layer,这样就把所有的layer都设置其handle，就是hwc_layer_1_t中的handle。这样就把GraphicBuffer和hwc_layer_1_t关联起来了。</strong></p>
<p>&#160; &#160; &#160; &#160;go on：ignore // If possible, attempt to use the cursor overlay on each display.<br>&#160; &#160; &#160; &#160;go on：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将使用哪种合成报告给HWC</span></span><br><span class="line"> <span class="keyword">status_t</span> err = hwc.prepare();</span><br><span class="line">        ALOGE_IF(err, <span class="string">"HWComposer::prepare failed (%s)"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">            <span class="comment">//return NO_ERROR</span></span><br><span class="line">            hw-&gt;prepareFrame(hwc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;最后会调用HWComposer的prepare函数，将使用哪种合成报告给HWC，我们再来看下这个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> HWComposer::prepare() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (disp.framebufferTarget) &#123;<span class="comment">//这里其实就是disp.list中最后一个layer </span></span><br><span class="line">            <span class="comment">// make sure to reset the type to HWC_FRAMEBUFFER_TARGET</span></span><br><span class="line">            <span class="comment">// DO NOT reset the handle field to NULL, because it's possible</span></span><br><span class="line">            <span class="comment">// that we have nothing to redraw (eg: eglSwapBuffers() not called)</span></span><br><span class="line">            <span class="comment">// in which case, we should continue to use the same buffer.</span></span><br><span class="line">            LOG_FATAL_IF(disp.<span class="built_in">list</span> == <span class="literal">NULL</span>);</span><br><span class="line">            disp.framebufferTarget-&gt;compositionType = HWC_FRAMEBUFFER_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!disp.connected &amp;&amp; disp.<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"WARNING: disp %zu: connected, non-null list, layers=%zu"</span>,</span><br><span class="line">                  i, disp.<span class="built_in">list</span>-&gt;numHwLayers);</span><br><span class="line">        &#125;</span><br><span class="line">        mLists[i] = disp.<span class="built_in">list</span>;<span class="comment">//DisplayData的list就是mList的一个组员,hwc_display_contents_1* </span></span><br><span class="line">        <span class="keyword">if</span> (mLists[i]) &#123;</span><br><span class="line">            <span class="comment">//HWC_DEVICE_VERSION_1_3 之后支持 hwcomposer合成多屏，这里是指虚拟屏的输出buffer和对应的fence</span></span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) &#123;</span><br><span class="line">                mLists[i]-&gt;outbuf = disp.outbufHandle;</span><br><span class="line">                mLists[i]-&gt;outbufAcquireFenceFd = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;<span class="comment">// HWC_DEVICE_VERSION_1_0 使用，dpy和sur对应于EGLDisplay 和 EGLSurface</span></span><br><span class="line">                <span class="comment">// garbage data to catch improper use</span></span><br><span class="line">                mLists[i]-&gt;dpy = (<span class="keyword">hwc_display_t</span>)<span class="number">0xDEADBEEF</span>;</span><br><span class="line">                mLists[i]-&gt;sur = (<span class="keyword">hwc_surface_t</span>)<span class="number">0xDEADBEEF</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mLists[i]-&gt;dpy = EGL_NO_DISPLAY;</span><br><span class="line">                mLists[i]-&gt;sur = EGL_NO_SURFACE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/*对所有显示屏中所有Layer作合成准备（此时也可以开始发送合成的命令码下去，启动硬件合成，但不需要等待完成），hwcomposer需要正确汇报每个Layer的composetype，以告知SurfaceFlinger是否需要额外处理。</span><br><span class="line">    version 为 1.0 的驱动，只支持一个显示屏</span><br><span class="line">    version 为 1.1 的驱动，只支持物理显示屏</span><br><span class="line">    version 为 1.3 及以上的驱动，支持物理和虚拟显示屏*/</span></span><br><span class="line">    <span class="keyword">int</span> err = mHwc-&gt;prepare(mHwc, mNumDisplays, mLists);</span><br><span class="line">    ALOGE_IF(err, <span class="string">"HWComposer: prepare failed (%s)"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// here we're just making sure that "skip" layers are set</span></span><br><span class="line">        <span class="comment">// to HWC_FRAMEBUFFER and we're also counting how many layers</span></span><br><span class="line">        <span class="comment">// we have of each type.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If there are no window layers, we treat the display has having FB</span></span><br><span class="line">        <span class="comment">// composition, because SurfaceFlinger will use GLES to draw the</span></span><br><span class="line">        <span class="comment">// wormhole region.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">            <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">            disp.hasFbComp = <span class="literal">false</span>;</span><br><span class="line">            disp.hasOvComp = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (disp.<span class="built_in">list</span>) &#123;</span><br><span class="line">                <span class="comment">//下面就是根据hwc汇报的composetype来设置相关属性</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;disp.<span class="built_in">list</span>-&gt;numHwLayers ; i++) &#123;</span><br><span class="line">                    <span class="keyword">hwc_layer_1_t</span>&amp; l = disp.<span class="built_in">list</span>-&gt;hwLayers[i];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//ALOGD("prepare: %d, type=%d, handle=%p",</span></span><br><span class="line">                    <span class="comment">//        i, l.compositionType, l.handle);</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (l.flags &amp; HWC_SKIP_LAYER) &#123;</span><br><span class="line">                        l.compositionType = HWC_FRAMEBUFFER;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (l.compositionType == HWC_FRAMEBUFFER) &#123;</span><br><span class="line">                        disp.hasFbComp = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (l.compositionType == HWC_OVERLAY) &#123;</span><br><span class="line">                        disp.hasOvComp = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (l.compositionType == HWC_CURSOR_OVERLAY) &#123;</span><br><span class="line">                        disp.hasOvComp = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (disp.<span class="built_in">list</span>-&gt;numHwLayers == (disp.framebufferTarget ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">                    disp.hasFbComp = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disp.hasFbComp = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">status_t</span>)err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1）遍历每一个显示屏，先取出framebufferTarget进行设置；<br>&#160; &#160; &#160; &#160;2）填充mList，DisplayData的list就是mList的一个组员,hwc_display_contents_1*，上面createWorkList讲过；<br>&#160; &#160; &#160; &#160;3）根据hwc版本初始化dpy和surface，或者outbuf；<br>&#160; &#160; &#160; &#160;4）调用hwc_composer_device_1 的set函数，对所有显示屏中所有Layer作合成准备（此时也可以开始发送合成的命令码下去，启动硬件合成，但不需要等待完成），hwcomposer需要正确汇报每个Layer的composetype，以告知SurfaceFlinger是否需要额外处理。<br>&#160; &#160; &#160; &#160;5）下面就是根据hwc汇报的composetype来设置相关属性，关于不同type再次贴一遍：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">    * HWC_FRAMEBUFFER_TARGET：该Layer是3D合成的目标Layer</span><br><span class="line">    * HWC_FRAMEBUFFER：hwcomposer无法处理此Layer，该Layer需要走3D合成流程，用OpenGL绘制</span><br><span class="line">    * HWC_OVERLAY：该Layer为硬件合成器所处理，不需要OpenGLES去渲染</span><br><span class="line">    * HWC_SIDEBAND：该Layer为视频的边频带，需要硬件合成器作特殊处理，若不支持，OpenGL方式只能以一个色块替代，这个标志是外界（应用/驱动）调用窗口系统的perform方法配置的</span><br><span class="line">    * HWC_CURSOR_OVERLAY：该Layer可通过setCursorPositionAsync 方法改变坐标</span><br><span class="line">    */</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这就是最后一步，提交hwc，然后获得合成类型的步骤。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;这就是本节内容，太晚了，不想写总结了，先睡了~</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%B8%80%29----%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/meizi.jpg" alt="meizi"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat.jpg" alt="windrunnerlihuan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="windrunnerlihuan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SurfaceFlinger/" rel="tag"># SurfaceFlinger</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/09/Android-SurfaceFlinger-学习之路-十-SurfaceFlinger处理Layer更新/" rel="next" title="Android SurfaceFlinger 学习之路(十)----SurfaceFlinger处理Layer更新">
                <i class="fa fa-chevron-left"></i> Android SurfaceFlinger 学习之路(十)----SurfaceFlinger处理Layer更新
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/19/Android-SurfaceFlinger-学习之路-十一-PostView-附：硬件HWC选取合成类型（Intel）/" rel="prev" title="Android SurfaceFlinger 学习之路(十一)(PostView)--附：硬件HWC选取合成类型（Intel）">
                Android SurfaceFlinger 学习之路(十一)(PostView)--附：硬件HWC选取合成类型（Intel） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTQwMC83OTYz"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="windrunnerlihuan" />
          <p class="site-author-name" itemprop="name">windrunnerlihuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="mailto:937874128@qq.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope-o"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/windrunnerlihuan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://gank.io/" title="干货集中营" target="_blank">干货集中营</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jcodecraeer.com/" title="泡在网上的日子" target="_blank">泡在网上的日子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#合成准备"><span class="nav-number">1.</span> <span class="nav-text">合成准备</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流程分析"><span class="nav-number">2.</span> <span class="nav-text">流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#preComposition"><span class="nav-number">2.1.</span> <span class="nav-text">preComposition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rebuildLayerStacks"><span class="nav-number">2.2.</span> <span class="nav-text">rebuildLayerStacks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相关区域概述"><span class="nav-number">2.2.1.</span> <span class="nav-text">相关区域概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#computeVisibleRegions"><span class="nav-number">2.2.2.</span> <span class="nav-text">computeVisibleRegions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setUpHWComposer"><span class="nav-number">2.3.</span> <span class="nav-text">setUpHWComposer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾HWC"><span class="nav-number">2.3.1.</span> <span class="nav-text">回顾HWC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备工作"><span class="nav-number">2.3.2.</span> <span class="nav-text">准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Layer"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">Layer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Display"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">Display</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Device"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">Device</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">2.3.3.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">3.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">windrunnerlihuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("bJlEg1N9ed75pssz1m514avl-gzGzoHsz", "Swtq2cOp8A7KYeJ9lpD5nKAy");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
