<!DOCTYPE html>
<html >
<head>
  
    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="zzKGwrFJYw" />
  
  <title>Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现 | April is your lie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;好久没更新了，主要是因为年前和年后太忙了，尤其是年后这一段时间，忙得把身体都忙坏了。。。。。。终于在我GG之前，提交了离职，总算赢得了一些空闲时间，赶紧养养身体。。。现在处于即将待业状态，正好有时间研究一下年前就想了解的surfaceflinger模块。。。不过最近我也看了下，surfaceflinger内容太多太复杂了，也许这个系列我坚持不了">
<meta property="og:type" content="article">
<meta property="og:title" content="Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现">
<meta property="og:url" content="http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;好久没更新了，主要是因为年前和年后太忙了，尤其是年后这一段时间，忙得把身体都忙坏了。。。。。。终于在我GG之前，提交了离职，总算赢得了一些空闲时间，赶紧养养身体。。。现在处于即将待业状态，正好有时间研究一下年前就想了解的surfaceflinger模块。。。不过最近我也看了下，surfaceflinger内容太多太复杂了，也许这个系列我坚持不了">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/jicheng.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/leitu.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/framebuffer.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/meizi.jpg">
<meta property="og:updated_time" content="2017-03-13T15:51:37.230Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;好久没更新了，主要是因为年前和年后太忙了，尤其是年后这一段时间，忙得把身体都忙坏了。。。。。。终于在我GG之前，提交了离职，总算赢得了一些空闲时间，赶紧养养身体。。。现在处于即将待业状态，正好有时间研究一下年前就想了解的surfaceflinger模块。。。不过最近我也看了下，surfaceflinger内容太多太复杂了，也许这个系列我坚持不了">
<meta name="twitter:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/jicheng.jpg">
  
    <link rel="alternative" href="/atom.xml" title="April is your lie" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
          search: true
      }
  </script>

  
      <script>
          yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
      </script>
  

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
  <!-- 自动推送工具代码 start -->
  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- 自动推送工具代码 end -->
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">windrunnerlihuan</a></h1>
        </hgroup>

        
        <p class="header-subtitle">四月是你的谎言</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" results="0" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="undefined" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">时间轴</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:937874128@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/windrunnerlihuan" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPC/">IPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SO库/">SO库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SurfaceFlinger/">SurfaceFlinger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客搭建/">博客搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/壁纸/">壁纸</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多媒体/">多媒体</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/属性动画/">属性动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开始/">开始</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/弹幕/">弹幕</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件开发/">插件开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能指针/">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息/">消息</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动直播/">移动直播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程池/">线程池</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://gank.io/">干货集中营</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jcodecraeer.com/">泡在网上的日子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://trinea.cn/">Trinea</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">windrunnerlihuan，开发小菜一枚，坐标位于上海。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">windrunnerlihuan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">windrunnerlihuan</a></h1>
            </hgroup>
            
            <p class="header-subtitle">四月是你的谎言</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">时间轴</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:937874128@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/windrunnerlihuan" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap"><article id="post-Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/12/Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现/" class="article-date">
      <time datetime="2017-03-12T12:10:11.000Z" itemprop="datePublished">2017-03-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android技术点/">Android技术点</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SurfaceFlinger/">SurfaceFlinger</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>&#160; &#160; &#160; &#160;好久没更新了，主要是因为年前和年后太忙了，尤其是年后这一段时间，忙得把身体都忙坏了。。。。。。终于在我GG之前，提交了离职，总算赢得了一些空闲时间，赶紧养养身体。。。现在处于即将待业状态，正好有时间研究一下年前就想了解的surfaceflinger模块。。。不过最近我也看了下，surfaceflinger内容太多太复杂了，<code>也许这个系列我坚持不了多久</code>，不能像上一个MediaPlayer系列那样。。。。。。<code>同时，因为目前我处于即将待业状况，所以求好心HR或者大牛带我入新坑，感激不尽(~ToT~)</code><br><a id="more"></a></p>
<h1 id="下载内核代码-准备工作"><a href="#下载内核代码-准备工作" class="headerlink" title="下载内核代码(准备工作)"></a>下载内核代码(准备工作)</h1><p>&#160; &#160; &#160; &#160;因为接下来分析需要用到部分kernel代码，所有我们需要先把kernel代码下载下来。</p>
<h2 id="更换hosts文件"><a href="#更换hosts文件" class="headerlink" title="更换hosts文件"></a>更换hosts文件</h2><p>&#160; &#160; &#160; &#160;因为天朝<code>GFW</code>的原因，所以不能直接访问google放置android source code的网站 <a href="https://source.android.com/" target="_blank" rel="external">https://source.android.com/</a> 。这个上面有很详细的教程，教大家下载、编译源码，和其他变动相关的知识。所以我们需要<strong>Fan Qiang</strong>。</p>
<p>&#160; &#160; &#160; &#160;如果买了VPN的土豪；找到免费vpn（GreenVPN、FreeVPN、hideVPN、rssVPN等等，好多都失效了）；还有可以去<strong>亚马逊</strong>申请一个免费服务器（一年），可以搭建自己的FQ服务器（这个需要绑定一张VISA信用卡，银联的不行），<a href="http://o7xxrho8u.bkt.clouddn.com/file/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/AWS%E8%AF%A6%E7%BB%86FQ%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.doc" target="_blank" rel="external">这里</a> 有个教程，我上传到了自己博客服务器，大家可以下载下来；或者有稳定且流量大的FQ软件（比如赛风、自由门、蓝灯、畅游无限浏览器、影梭等）；或者有靠谱的hosts文件的，可以跳过这一步。</p>
<p>&#160; &#160; &#160; &#160;因为要拉kernel代码，文件比较大，所以我推荐更换hosts文件。这里推荐<code>老D</code> hosts，地址是 <a href="https://laod.cn/hosts/2017-google-hosts.html" target="_blank" rel="external">https://laod.cn/hosts/2017-google-hosts.html</a> 。都是傻瓜式教程，应该都会。</p>
<h2 id="下载kernel代码"><a href="#下载kernel代码" class="headerlink" title="下载kernel代码"></a>下载kernel代码</h2><p>&#160; &#160; &#160; &#160;更换完hosts文件后，进入android源码官网，然后找到里面的<strong>Explore the Source</strong>标题下面描述里面的<strong>AOSP repository</strong>，点击进入源码仓库 <a href="https://android.googlesource.com/" target="_blank" rel="external">https://android.googlesource.com/</a> 。<br>&#160; &#160; &#160; &#160;1) 因为我们要下kernel源码，所以选择<strong>kenrnel/common</strong>,下载这一个通用代码；<br>&#160; &#160; &#160; &#160;2) 用git下载代码：git clone <a href="https://android.googlesource.com/kernel/common" target="_blank" rel="external">https://android.googlesource.com/kernel/common</a> ；<br>&#160; &#160; &#160; &#160;3) 切换分支，我选了一个release版本：android-4.4-n-release，所以要git checkout -b android-4.4-n-release remotes/origin/android-4.4-n-release，然后pull一下，common文件夹下就有代码了。<br>&#160; &#160; &#160; &#160;4) 最后将下载好的代码导入source insight，这一步就不用细说了。</p>
<h1 id="初识Gralloc模块"><a href="#初识Gralloc模块" class="headerlink" title="初识Gralloc模块"></a>初识Gralloc模块</h1><h2 id="Gralloc模块简介"><a href="#Gralloc模块简介" class="headerlink" title="Gralloc模块简介"></a>Gralloc模块简介</h2><p>&#160; &#160; &#160; &#160;Android设备的显示屏被抽象为一个帧缓冲区，而Android系统中的SurfaceFlinger服务就是通过向这个帧缓冲区写入内容来绘制应用程序的用户界面的。Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对帧缓冲区的所有访问操作。<br>&#160; &#160; &#160; &#160;Linux内核在启动的过程中会创建一个类别和名称分别为“graphics”和“fb0”的设备，用来描述系统中的第一个帧缓冲区，即第一个显示屏，其中，数字0表示从设备号。注意，系统中至少要存在一个显示屏，因此，名称为“fb0”的设备是肯定会存在的，否则的话，就是出错了。<br>&#160; &#160; &#160; &#160;init进程在启动的过程中，会启动另外一个进程ueventd来管理系统的设备文件。当ueventd进程启动起来之后，会通过netlink接口来Linux内核通信，以便可以获得内核中的硬件设备变化通知。而当ueventd进程发现内核中创建了一个类型和名称分别为“graphics”和“fb0”的设备的时候，就会这个设备创建一个/dev/graphics/fb0设备文件。这样，用户空间的应用程序就可以通过设备文件/dev/graphics/fb0来访问内核中的帧缓冲区，即在设备的显示屏中绘制指定的画面。注意，用户空间的应用程序一般是通过内存映射的方式来访问设备文件/dev/graphics/fb0的。<br>&#160; &#160; &#160; &#160;Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对帧缓冲区的所有访问操作。用户空间的应用程序在使用帧缓冲区之间，首先要加载Gralloc模块，并且获得一个gralloc设备和一个fb设备。有了gralloc设备之后，用户空间中的应用程序就可以申请分配一块图形缓冲区，并且将这块图形缓冲区映射到应用程序的地址空间来，以便可以向里面写入要绘制的画面的内容。最后，用户空间中的应用程序就通过fb设备来将已经准备好了的图形缓冲区渲染到帧缓冲区中去，即将图形缓冲区的内容绘制到显示屏中去。相应地，当用户空间中的应用程序不再需要使用一块图形缓冲区的时候，就可以通过gralloc设备来释放它，并且将它从地址空间中解除映射。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>&#160; &#160; &#160; &#160;Gralloc模块实现源码位于：hardware/libhardware/modules/gralloc ：</p>
<p>&#160; &#160; &#160; &#160;|——– Android.mk<br>&#160; &#160; &#160; &#160;|——– framebuffer.cpp<br>&#160; &#160; &#160; &#160;|——– gralloc.cpp<br>&#160; &#160; &#160; &#160;|——– gralloc_priv.h<br>&#160; &#160; &#160; &#160;|——– gr.h<br>&#160; &#160; &#160; &#160;|——– mapper.cpp</p>
<h1 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h1><p>&#160; &#160; &#160; &#160;接下来，我们就按照上述使用情景来分析Gralloc模块的实现。</p>
<h2 id="Gralloc模块的加载过程"><a href="#Gralloc模块的加载过程" class="headerlink" title="Gralloc模块的加载过程"></a>Gralloc模块的加载过程</h2><p>&#160; &#160; &#160; &#160;每一个HAL模块都有一个ID值，以这些ID值为参数来调用硬件抽象层提供的函数<strong>hw_get_module</strong>就可以将指定的模块加载到内存来，并且获得一个<strong>hw_module_t</strong>接口来打开相应的设备。<br>&#160; &#160; &#160; &#160;Gralloc模块的ID值定义在hardware/libhardware/include/hardware/gralloc.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * The id of this module</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_MODULE_ID <span class="string">"gralloc"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;函数<strong>hw_get_module</strong>实现在hardware/libhardware/hardware.c文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span> **module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hw_get_module_by_class(id, <span class="literal">NULL</span>, module);<span class="comment">//调用hw_get_module_by_class函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hw_get_module_by_class函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span> **module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> prop[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> name[PATH_MAX]; <span class="comment">//PATH_MAX为256</span></span><br><span class="line">    <span class="keyword">char</span> prop_name[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inst)<span class="comment">//NULL</span></span><br><span class="line">        <span class="built_in">snprintf</span>(name, PATH_MAX, <span class="string">"%s.%s"</span>, class_id, inst);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        strlcpy(name, class_id, PATH_MAX);<span class="comment">//字符串拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Here we rely on the fact that calling dlopen multiple times on</span><br><span class="line">     * the same .so will simply increment a refcount (and not load</span><br><span class="line">     * a new copy of the library).</span><br><span class="line">     * We also assume that dlopen() is thread-safe.</span><br><span class="line">     */</span></span><br><span class="line">     <span class="comment">//我们依赖的事实是，调用dlopen方法多次打开相同的so库会简单的增加引用计数(而不会重复加载多次库的拷贝)</span></span><br><span class="line">     <span class="comment">//我们认为dlopen方法是线程安全的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First try a property specific to the class and possibly instance */</span></span><br><span class="line">    <span class="comment">//先查找确定系统属性的值是否为空</span></span><br><span class="line">    <span class="built_in">snprintf</span>(prop_name, <span class="keyword">sizeof</span>(prop_name), <span class="string">"ro.hardware.%s"</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (property_get(prop_name, prop, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果不为空，则找到属性对应的so库是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, prop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop through the configuration variants looking for a module */</span></span><br><span class="line">    <span class="comment">//如果上面没找到指定的so库，则循环遍历指定数组里的属性，然后找到第一个存在的so并跳出</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;HAL_VARIANT_KEYS_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (property_get(variant_keys[i], prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, prop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing found, try the default */</span></span><br><span class="line">    <span class="comment">//如果第二步查找也没找到，就用默认的default属性</span></span><br><span class="line">    <span class="keyword">if</span> (hw_module_exists(path, <span class="keyword">sizeof</span>(path), name, <span class="string">"default"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    <span class="comment">/* load the module, if this fails, we're doomed, and we should not try</span><br><span class="line">     * to load a different variant. */</span></span><br><span class="line">    <span class="comment">//如果我们找到了相关so，则加载它</span></span><br><span class="line">    <span class="keyword">return</span> load(class_id, path, module);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * There are a set of variant filename for modules. The form of the filename</span><br><span class="line"> * is "&lt;MODULE_ID&gt;.variant.so" so for the led module the Dream variants </span><br><span class="line"> * of base "ro.product.board", "ro.board.platform" and "ro.arch" would be:</span><br><span class="line"> *</span><br><span class="line"> * led.trout.so</span><br><span class="line"> * led.msm7k.so</span><br><span class="line"> * led.ARMV6.so</span><br><span class="line"> * led.default.so</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *variant_keys[] = &#123;</span><br><span class="line">    <span class="string">"ro.hardware"</span>,  <span class="comment">/* This goes first so that it can pick up a different</span><br><span class="line">                       file on the emulator. */</span></span><br><span class="line">    <span class="string">"ro.product.board"</span>,</span><br><span class="line">    <span class="string">"ro.board.platform"</span>,</span><br><span class="line">    <span class="string">"ro.arch"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面流程我们分步来看：</p>
<h3 id="查询对应动态库"><a href="#查询对应动态库" class="headerlink" title="查询对应动态库"></a>查询对应动态库</h3><p>&#160; &#160; &#160; &#160;1）先查找确定系统属性的值是否为空，property_get函数到系统属性，可以在shell环境下用getprop ro.hardware.%s找到ro.hardware.%s属性，最后一个字符串自己指定；然后调用hw_module_exists函数顺着<strong>/system/lib/hw和/vendor/lib/hw或者/system/lib64/hw和/vendor/lib64/hw</strong>查找相应so库是否存在，我们看看hw_module_exists函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Check if a HAL with given name and subname exists, if so return 0, otherwise</span><br><span class="line"> * otherwise return negative.  On success path will contain the path to the HAL.</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">//检查HAL层给的文件名是否存在，如果存在返回0，否则返回负无穷</span></span><br><span class="line"> <span class="comment">//如果成功了，会把这个路径包含进HAL</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hw_module_exists</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">size_t</span> path_len, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">char</span> *subname)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(path, path_len, <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">             HAL_LIBRARY_PATH2, name, subname);</span><br><span class="line">    <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(path, path_len, <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">             HAL_LIBRARY_PATH1, name, subname);</span><br><span class="line">    <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Base path of the hal modules */</span></span><br><span class="line"><span class="comment">//主要在下面目录下找相关so库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="string">"/system/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="string">"/vendor/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="string">"/system/lib/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="string">"/vendor/lib/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;2）如果第一步GG了，就进入第二步，则循环遍历指定数组里的属性，然后找到第一个存在的so并跳出。<br>&#160; &#160; &#160; &#160;函数hw_get_module依次在目录/system/lib/hw和/vendor/lib/hw中(或64位对应目录)查找一个名称为”<module_id>.variant.so”的文件，其中，&lt; MODULE_ID &gt;是一个模块ID，而variant表示”ro.hardware”、”ro.product.board”、”ro.board.platform”和”ro.arch”四个系统属性值之一。例如，对于Gralloc模块来说，函数hw_get_module依次在目录/system/lib/hw和/vendor/lib/hw中检查是否存在以下四个文件：</module_id></p>
<ul>
<li><strong>gralloc.&lt; ro.hardware &gt;.so</strong></li>
<li><strong>gralloc.&lt; ro.product.board &gt;.so</strong></li>
<li><strong>gralloc.&lt; ro.board.platform &gt;.so</strong></li>
<li><strong>gralloc.&lt; ro.arch &gt;.so</strong></li>
</ul>
<p>&#160; &#160; &#160; &#160;只要其中的一个文件存在，  函数hw_get_module就会停止查找过程，并且调用另外一个函数load来将这个文件加载到内存中来。</p>
<p>&#160; &#160; &#160; &#160;3）如果第二步也GG了，就进入第三步，如果第二步查找也没找到，就用默认的default属性。如果在/system/lib/hw和/vendor/lib/hw中均不存这些文件，那么函数hw_get_module就会在目录/system/lib/hw中查找是否存在一个名称为<strong>gralloc.default.so</strong>的文件。如果存在的话，那么也会调用函数load将它加载到内存中来。</p>
<p>&#160; &#160; &#160; &#160;4）找到对应的so库后，就要调用<strong>load</strong>函数将他加载到内存中。</p>
<h3 id="加载对应动态库"><a href="#加载对应动态库" class="headerlink" title="加载对应动态库"></a>加载对应动态库</h3><p>&#160; &#160; &#160; &#160;函数load也是实现在文件hardware/libhardware/hardware.c文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Load the file defined by the variant and if successful</span><br><span class="line"> * return the dlopen handle and the hmi.</span><br><span class="line"> * @return 0 = success, !0 = failure.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *path,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span> **pHmi)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">void</span> *handle;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">hw_module_t</span> *hmi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * load the symbols resolving undefined symbols before</span><br><span class="line">     * dlopen returns. Since RTLD_GLOBAL is not or'd in with</span><br><span class="line">     * RTLD_NOW the external symbols will not be global</span><br><span class="line">     */</span></span><br><span class="line">    handle = dlopen(path, RTLD_NOW);<span class="comment">//用dlopen函数将对应so库加载到内存中</span></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> <span class="keyword">const</span> *err_str = dlerror();</span><br><span class="line">        ALOGE(<span class="string">"load: module=%s\n%s"</span>, path, err_str?err_str:<span class="string">"unknown"</span>);</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the address of the struct hal_module_info. */</span></span><br><span class="line">    <span class="comment">//调用函数dlsym来获得它所导出的符号HMI</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sym = HAL_MODULE_INFO_SYM_AS_STR;</span><br><span class="line">    hmi = (<span class="keyword">struct</span> <span class="keyword">hw_module_t</span> *)dlsym(handle, sym);</span><br><span class="line">    <span class="keyword">if</span> (hmi == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"load: couldn't find symbol %s"</span>, sym);</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that the id matches */</span></span><br><span class="line">    <span class="comment">//检查id是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(id, hmi-&gt;id) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"load: id=%s != hmi-&gt;id=%s"</span>, id, hmi-&gt;id);</span><br><span class="line">        status = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hmi-&gt;dso = handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* success */</span></span><br><span class="line">    status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    done:</span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">        hmi = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (handle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dlclose(handle);</span><br><span class="line">            handle = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGV(<span class="string">"loaded HAL id=%s path=%s hmi=%p handle=%p"</span>,</span><br><span class="line">                id, path, *pHmi, handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pHmi = hmi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在Linux系统中，后缀名为”so”的文件为动态链接库文件，可能通过函数dlopen来加载到内存中。硬件抽象层模块编写规范规定每一个硬件抽象层模块都必须导出一个符号名称为<strong>HAL_MODULE_INFO_SYM_AS_STR</strong>的符号，而且这个符号必须是用来描述一个类型为<strong>hw_module_t</strong>的结构体的。<br>&#160; &#160; &#160; &#160;<strong>HAL_MODULE_INFO_SYM_AS_STR</strong>是一个宏，定义在文件hardware/libhardware/include/hardware/hardware.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Name of the hal_module_info as a string</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_MODULE_INFO_SYM_AS_STR  <span class="string">"HMI"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;将Gralloc模块加载到内存中来之后，就可以调用函数dlsym来获得它所导出的符号<strong>HMI</strong>。由于这个符号指向的是一个<strong>hw_module_t</strong>结构体，因此，最后函数load就可以强制地将这个符号转换为一个hw_module_t结构体指针，并且保存在输出参数pHmi中返回给调用者。调用者获得了这个hw_module_t结构体指针之后，就可以创建一个gralloc设备或者一个fb设备。</p>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>&#160; &#160; &#160; &#160;模块Gralloc实现在目录hardware/libhardware/modules/gralloc中，它导出的符号<strong>HMI</strong>定义在文件hardware/libhardware/modules/gralloc/gralloc.cpp文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">hw_module_methods_t</span> gralloc_module_methods = &#123;</span><br><span class="line">        .open = gralloc_device_open</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">private_module_t</span> HAL_MODULE_INFO_SYM = &#123;</span><br><span class="line">    .base = &#123;</span><br><span class="line">        .common = &#123;</span><br><span class="line">            .tag = HARDWARE_MODULE_TAG,</span><br><span class="line">            .version_major = <span class="number">1</span>,</span><br><span class="line">            .version_minor = <span class="number">0</span>,</span><br><span class="line">            .id = GRALLOC_HARDWARE_MODULE_ID,</span><br><span class="line">            .name = <span class="string">"Graphics Memory Allocator Module"</span>,</span><br><span class="line">            .author = <span class="string">"The Android Open Source Project"</span>,</span><br><span class="line">            .methods = &amp;gralloc_module_methods</span><br><span class="line">        &#125;,</span><br><span class="line">        .registerBuffer = gralloc_register_buffer,</span><br><span class="line">        .unregisterBuffer = gralloc_unregister_buffer,</span><br><span class="line">        .lock = gralloc_lock,</span><br><span class="line">        .unlock = gralloc_unlock,</span><br><span class="line">    &#125;,</span><br><span class="line">    .framebuffer = <span class="number">0</span>,</span><br><span class="line">    .flags = <span class="number">0</span>,</span><br><span class="line">    .numBuffers = <span class="number">0</span>,</span><br><span class="line">    .bufferMask = <span class="number">0</span>,</span><br><span class="line">    .lock = PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    .currentBuffer = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>HAL_MODULE_INFO_SYM</strong>也是一个宏，它的值是与宏HAL_MODULE_INFO_SYM_AS_STR对应的，它也是定义在文件hardware/libhardware/include/hardware/hardware.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Name of the hal_module_info</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_MODULE_INFO_SYM         HMI</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;符号<strong>HAL_MODULE_INFO_SYM</strong>的类型为<strong>private_module_t</strong>。前面提到，符号HAL_MODULE_INFO_SYM必须指向一个<strong>hw_module_t</strong>结构体，但是这里它指向的却是一个private_module_t结构体，是不是有问题呢？为了弄清楚这个问题，我们首先了解一下结构体private_module_t的定义，如下图：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/jicheng.jpg" alt="继承关系"></p>
<p>&#160; &#160; &#160; &#160;结构体<strong>private_module_t</strong>的第一个成员变量<strong>base</strong>指向一个<strong>gralloc_module_t</strong>结构体，而gralloc_module_t结构体的第一个成员变量<strong>common</strong>又指向了一个<strong>hw_module_t</strong>结构体，这意味着，指向一个private_module_t结构体的指针同时可以用作一个gralloc_module_t或者hw_module_t结构体提针来使用。<code>事实上，这是使用C语言来实现的一种继承关系</code>，等价于结构体private_module_t继承结构体gralloc_module_t，而结构体gralloc_module_t继承hw_module_t结构体。这样，<strong>我们就可以把在Gralloc模块中定义的符号HAL_MODULE_INFO_SYM看作是一个hw_module_t结构体</strong>。</p>
<p>&#160; &#160; &#160; &#160;<strong>hw_module_t</strong>结构体有一个重要的成员变量<strong>methods</strong>，它的类型为<strong>hw_module_methods_t</strong>，它用来描述一个HAL模块的操作方法列表。结构体hw_module_methods_t只定义有一个操作方法open，用来打开一个指定的设备。在Gralloc模块中，用来打开指定设备的函数被指定为gralloc_device_open，通过这个函数就可以打开Gralloc模块中的gralloc或者fb设备，后面我们再详细分析。</p>
<p>&#160; &#160; &#160; &#160;1）结构体<strong>gralloc_module_t</strong>定义在文件hardware/libhardware/include/hardware/gralloc.h中，它主要是定义了四个用来操作图形缓冲区的成员函数，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> &#123;  </span><br><span class="line">　　<span class="keyword">struct</span> <span class="keyword">hw_module_t</span> common;  </span><br><span class="line">　　<span class="comment">//映射一块图形缓冲区到一个进程的地址空间去  </span></span><br><span class="line">　　<span class="keyword">int</span> (*registerBuffer)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">buffer_handle_t</span> handle);  </span><br><span class="line">　　<span class="comment">//取消映射一块图形缓冲区到一个进程的地址空间去  </span></span><br><span class="line">　　<span class="keyword">int</span> (*unregisterBuffer)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">buffer_handle_t</span> handle);  </span><br><span class="line">　　<span class="comment">//锁定一个指定的图形缓冲区  </span></span><br><span class="line">    <span class="keyword">int</span> (*lock)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">buffer_handle_t</span> handle, <span class="keyword">int</span> usage,  </span><br><span class="line">            <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> h,<span class="keyword">void</span>** vaddr);  </span><br><span class="line">    <span class="comment">//解锁一个指定的图形缓冲区  </span></span><br><span class="line">　　<span class="keyword">int</span> (*unlock)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">buffer_handle_t</span> handle);  </span><br><span class="line">    <span class="keyword">int</span> (*perform)(<span class="keyword">struct</span> <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,<span class="keyword">int</span> operation, ... );  </span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">3</span>];  </span><br><span class="line">&#125; <span class="keyword">gralloc_module_t</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>成员函数registerBuffer和unregisterBuffer分别用来注册和注销一个指定的图形缓冲区，这个指定的图形缓冲区使用一个buffer_handle_t句柄来描述。所谓注册图形缓冲区，实际上就是将一块图形缓冲区映射到一个进程的地址空间去，而注销图形缓冲区就是执行相反的操作。</li>
<li>成员函数lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，这个指定的图形缓冲区同样是使用一个buffer_handle_t句柄来描述。在访问一块图形缓冲区的时候，例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突。在锁定一块图形缓冲区的时候，可以指定要锁定的图形绘冲区的位置以及大小，这是通过参数l、t、w和h来指定的，其中，参数l和t指定的是要访问的图形缓冲区的左上角位置，而参数w和h指定的是要访问的图形缓冲区的宽度和长度。锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中。另一方面，在访问完成一块图形缓冲区之后，需要解除这块图形缓冲区的锁定。</li>
<li>在Gralloc模块中，符号HAL_MODULE_INFO_SYM指向的gralloc结构体的成员函数registerBuffer、unregisterBuffer、lock和unlock分别被指定为函数gralloc_register_buffer、gralloc_unregister_buffer、gralloc_lock和gralloc_unlock，后面我们再详细分析它们的实现。</li>
</ul>
<p>&#160; &#160; &#160; &#160;2）结构体<strong>private_module_t</strong>定义在文件hardware/libhardware/modules/gralloc/gralloc_priv.h中，它主要是用来描述帧缓冲区的属性，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">private_module_t</span> &#123;  </span><br><span class="line">    <span class="keyword">gralloc_module_t</span> base;  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* framebuffer; <span class="comment">//指向系统帧缓冲区的句柄  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags; <span class="comment">//用来标志系统帧缓冲区是否支持双缓冲  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> numBuffers;<span class="comment">//表示系统帧缓冲区包含有多少个图形缓冲区  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> bufferMask; <span class="comment">//记录系统帧缓冲区中的图形缓冲区的使用情况  </span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock; <span class="comment">//一个互斥锁，用来保护结构体private_module_t的并行访问  </span></span><br><span class="line">    <span class="keyword">buffer_handle_t</span> currentBuffer; <span class="comment">//用来描述当前正在被渲染的图形缓冲区  </span></span><br><span class="line">    <span class="keyword">int</span> pmem_master;  </span><br><span class="line">    <span class="keyword">void</span>* pmem_master_base;  </span><br><span class="line">    <span class="keyword">struct</span> fb_var_screeninfo info; <span class="comment">//保存设备显示屏的动态属性信息  </span></span><br><span class="line">    <span class="keyword">struct</span> fb_fix_screeninfo finfo; <span class="comment">////保存设备显示屏的固定属性信息  </span></span><br><span class="line">    <span class="keyword">float</span> xdpi; <span class="comment">//描述设备显示屏在宽度  </span></span><br><span class="line">    <span class="keyword">float</span> ydpi; <span class="comment">//描述设备显示屏在高度  </span></span><br><span class="line">    <span class="keyword">float</span> fps; <span class="comment">//用来描述显示屏的刷新频率  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>成员变量framebuffer的类型为private_handle_t，它是一个指向系统帧缓冲区的句柄，后面我们再分析结构体private_handle_t的定义。</li>
<li>成员变量flags用来标志系统帧缓冲区是否支持双缓冲。如果支持的话，那么它的PAGE_FLIP位就等于1，否则的话，就等于0。</li>
<li>成员变量numBuffers表示系统帧缓冲区包含有多少个图形缓冲区。一个帧缓冲区包含有多少个图形缓冲区是与它的可视分辨率以及虚拟分辨率的大小有关的。例如，如果一个帧缓冲区的可视分辨率为800 x 600，而虚拟分辨率为1600 x 600，那么这个帧缓冲区就可以包含有两个图形缓冲区。</li>
<li>成员变量bufferMask用来记录系统帧缓冲区中的图形缓冲区的使用情况。例如，假设系统帧缓冲区有两个图形缓冲区，这时候成员变量bufferMask就有四种取值，分别是二进制的00、01、10和11，其中，00分别表示两个图缓冲区都是空闲的，01表示第1个图形缓冲区已经分配出去，而第2个图形缓冲区是空闲的，10表示第1个图形缓冲区是空闲的，而第2个图形缓冲区已经分配出去，11表示两个图缓冲区都已经分配出去。</li>
<li>成员变量lock是一个互斥锁，用来保护结构体private_module_t的并行访问。</li>
<li>成员变量<strong>currentBuffer</strong>的类型为<strong>buffer_handle_t</strong>，用来描述当前正在被渲染的图形缓冲区，后面我们再分析它的定义。</li>
<li>成员变量pmem_master和pmem_master_base目前没有使用。</li>
<li>成员变量info和finfo的类型分别为fb_var_screeninfo和fb_fix_screeninfo，它们用来保存设备显示屏的属性信息，其中，成员变量info保存的属性信息是可以动态设置的，而成员变量finfo保存的属性信息是只读的。这两个成员变量的值可以通过IO控制命令FBIOGET_VSCREENINFO和FBIOGET_FSCREENINFO来从帧缓冲区驱动模块中获得。</li>
<li>成员变量xdpi和ydpi分别用来描述设备显示屏在宽度和高度上的密度，即每英寸有多少个像素点。</li>
<li><p>成员变量fps用来描述显示屏的刷新频率，它的单位的fps，即每秒帧数。</p>
<p>&#160; &#160; &#160; &#160;3）接下来， 我们再分析结构体<strong>buffer_handle_t</strong>的定义。结构体buffer_handle_t定义在文件hardware/libhardware/include/hardware/gralloc.h文件中，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> native_handle* <span class="keyword">buffer_handle_t</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&#160; &#160; &#160; &#160;它是一个类型为<strong>native_handle_t</strong>的指针，而结构体native_handle_t用来描述一个本地句柄值，它定义在系统运行时层的文件system/core/include/cutils/native_handle.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> native_handle  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> version; <span class="comment">//设置为结构体native_handle_t的大小，用来标识结构体native_handle_t的版本  </span></span><br><span class="line">    <span class="keyword">int</span> numFds;  <span class="comment">//表示结构体native_handle_t所包含的文件描述符的个数，这些文件描述符保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> numInts; <span class="comment">//表示结构体native_handle_t所包含的整数值的个数，这些整数保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>]; <span class="comment">//指向的一块缓冲区中  </span></span><br><span class="line">&#125; <span class="keyword">native_handle_t</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>成员变量version的大小被设置为结构体native_handle_t的大小，用来标识结构体native_handle_t的版本。</li>
<li>成员变量numFds和numInts表示结构体native_handle_t所包含的文件描述符以及整数值的个数，这些文件描述符和整数保存在成员变量data所指向的一块缓冲区中。</li>
</ul>
<p>&#160; &#160; &#160; &#160;4）我们一般不直接使用native_handle_t结构体来描述一个本地句柄值，而是通过它的子类来描述一个具体的本地句柄值。接下来我们就通过结构体private_handle_t的定义来说明native_handle_t结构体的用法。<br>&#160; &#160; &#160; &#160;结构体<strong>private_handle_t</strong>用来描述一块图形缓冲区，这块图形缓冲区可能是在帧缓冲区中分配的，也可能是在内存中分配的，视具体情况而定，它定义在文件hardware/libhardware/modules/gralloc/gralloc_priv.h文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">private_handle_t</span> : <span class="keyword">public</span> native_handle &#123;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">private_handle_t</span> &#123;  </span><br><span class="line">    <span class="keyword">struct</span> native_handle nativeHandle;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">enum</span> &#123;  </span><br><span class="line">        PRIV_FLAGS_FRAMEBUFFER = <span class="number">0x00000001</span>  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// file-descriptors  </span></span><br><span class="line">    <span class="keyword">int</span>     fd;  <span class="comment">////指向一个文件描述符，这个文件描述符要么指向帧缓冲区设备，要么指向一块匿名共享内存 </span></span><br><span class="line">    <span class="comment">// ints  </span></span><br><span class="line">    <span class="keyword">int</span>     magic;  <span class="comment">//指向一个魔数，它的值由静态成员变量sMagic来指定，用来标识一个private_handle_t结构</span></span><br><span class="line">    <span class="keyword">int</span>     flags;  <span class="comment">//用来描述一个缓冲区的标志，它的值要么等于0，要么等于PRIV_FLAGS_FRAMEBUFFER  </span></span><br><span class="line">    <span class="keyword">int</span>     size;   <span class="comment">//用来描述一个缓冲区的大小。 </span></span><br><span class="line">    <span class="keyword">int</span>     offset; <span class="comment">//用来描述一个缓冲区的偏移地址。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> the attributes below should be out-of-line  </span></span><br><span class="line">    <span class="keyword">int</span>     base;  <span class="comment">//用来描述一个缓冲区的实际地址，它是通过成员变量offset来计算得到的。 </span></span><br><span class="line">    <span class="keyword">int</span>     pid;   <span class="comment">//用来描述一个缓冲区的创建者的PID。  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> sNumInts = <span class="number">6</span>;  <span class="comment">//包含有6个整数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> sNumFds = <span class="number">1</span>;   <span class="comment">//包含有1个文件描述符 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> sMagic = <span class="number">0x3141592</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private_handle_t</span>(<span class="keyword">int</span> fd, <span class="keyword">int</span> size, <span class="keyword">int</span> flags) :  </span><br><span class="line">        fd(fd), magic(sMagic), flags(flags), size(size), offset(<span class="number">0</span>),  </span><br><span class="line">        base(<span class="number">0</span>), pid(getpid())  </span><br><span class="line">    &#123;  </span><br><span class="line">        version = <span class="keyword">sizeof</span>(native_handle);  </span><br><span class="line">        numInts = sNumInts;  </span><br><span class="line">        numFds = sNumFds;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~<span class="keyword">private_handle_t</span>() &#123;  </span><br><span class="line">        magic = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">validate</span><span class="params">(<span class="keyword">const</span> native_handle* h)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">const</span> <span class="keyword">private_handle_t</span>*)h;  </span><br><span class="line">        <span class="keyword">if</span> (!h || h-&gt;version != <span class="keyword">sizeof</span>(native_handle) ||  </span><br><span class="line">                h-&gt;numInts != sNumInts || h-&gt;numFds != sNumFds ||  </span><br><span class="line">                hnd-&gt;magic != sMagic)  </span><br><span class="line">        &#123;  </span><br><span class="line">            LOGE(<span class="string">"invalid gralloc handle (at %p)"</span>, h);  </span><br><span class="line">            <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;为了方便描述，我们假设我们是在C++环境中编译文件gralloc_priv.h，即编译环境定义有宏__cplusplus。这样，结构体private_handle_t就是从结构体native_handle_t继承下来的，它包含有1个文件描述符以及6个整数，以及三个静态成员变量。</p>
<ul>
<li>成员变量fd指向一个文件描述符，这个文件描述符要么指向帧缓冲区设备，要么指向一块匿名共享内存，取决于它的宿主结构体private_handle_t描述的一个图形缓冲区是在帧缓冲区分配的，还是在内存中分配的。</li>
<li>成员变量magic指向一个魔数，它的值由静态成员变量sMagic来指定，用来标识一个private_handle_t结构体。</li>
<li>成员变量flags用来描述一个图形缓冲区的标志，它的值要么等于0，要么等于PRIV_FLAGS_FRAMEBUFFER。当一个图形缓冲区的标志值等于PRIV_FLAGS_FRAMEBUFFER的时候，就表示它是在帧缓冲区中分配的。</li>
<li>成员变量size用来描述一个图形缓冲区的大小。</li>
<li>成员变量offset用来描述一个图形缓冲区的偏移地址。例如，当一个图形缓冲区是在一块内存中分块的时候，假设这块内存的地址为start，那么这个图形缓冲区的起始地址就为start + offset。</li>
<li>成员变量base用来描述一个图形缓冲区的实际地址，它是通过成员变量offset来计算得到的。例如，上面计算得到的start + offset的值就保存在成员变量base中。</li>
<li>成员变量pid用来描述一个图形缓冲区的创建者的PID。例如，如果一个图形缓冲区是在ID值为1000的进程中创建的，那么用来描述这个图形缓冲区的private_handle_t结构体的成员变量pid的值就等于1000。</li>
</ul>
<p>&#160; &#160; &#160; &#160;结构体private_handle_t的静态成员变量sMagic前面已经描述过了，另外两个静态成员变量sNumInts和sNumFds的值分别等于1和6，表示结构体private_handle_t包含有1个文件描述符和6个整数，它们是用来初始化结构体private_handle_t的父类native_handle_t的成员变量numInts和numFds的，如结构体private_handle_t的构造函数所示。从这里就可以看出，结构体private_handle_t的父类native_handle_t的成员变量data所指向的缓冲区就是由结构体private_handle_t的成员变量fds、magic、flags、size、offset、base和pid所占用的连续内存块来组成的，一共包含有7个整数。<br>&#160; &#160; &#160; &#160;结构体private_handle_t还定义了一个静态成员函数validate，用来验证一个native_handle_t指针是否指向了一个private_handle_t结构体。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/leitu.png" alt="数据结构图"></p>
<p>&#160; &#160; &#160; &#160;至此，Gralloc模块的加载过程以及相关的数据结构体就介绍到这里，接下来我们分别分析定义在Gralloc模块中的gralloc和fb设备的打开过程。</p>
<h2 id="Gralloc设备的打开过程"><a href="#Gralloc设备的打开过程" class="headerlink" title="Gralloc设备的打开过程"></a>Gralloc设备的打开过程</h2><p>&#160; &#160; &#160; &#160;在Gralloc模块中，gralloc设备的ID值定义为<strong>GRALLOC_HARDWARE_GPU0</strong>。GRALLOC_HARDWARE_GPU0是一个宏，定义在文件hardware/libhardware/include/hardware/gralloc.h中， 如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Name of the graphics device to open</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_GPU0 <span class="string">"gpu0"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;gralloc设备使用结构体<strong>alloc_device_t</strong> 来描述。结构体alloc_device_t有两个成员函数<strong>alloc</strong>和<strong>free</strong>，分别用来分配和释放图形缓冲区。<br>&#160; &#160; &#160; &#160;结构体alloc_device_t 也是定义在文件hardware/libhardware/include/hardware/gralloc.h中， 如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">alloc_device_t</span> &#123;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">hw_device_t</span> common;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*alloc)(<span class="keyword">struct</span> <span class="keyword">alloc_device_t</span>* dev,  </span><br><span class="line">            <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,  </span><br><span class="line">            <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">int</span>* stride);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> <span class="keyword">alloc_device_t</span>* dev,  </span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);  </span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">alloc_device_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Gralloc模块在在文件hardware/libhardware/include/hardware/gralloc.h中定义了一个帮助函数gralloc_open，用来打开gralloc设备，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** convenience API for opening and closing a supported device */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gralloc_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span>* module, </span><br><span class="line">        <span class="keyword">struct</span> <span class="keyword">alloc_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> module-&gt;methods-&gt;open(module, </span><br><span class="line">            GRALLOC_HARDWARE_GPU0, (<span class="keyword">struct</span> <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;参数<strong>module</strong>指向的是一个用来描述Gralloc模块的<strong>hw_module_t</strong>结构体，它的成员变量<strong>methods</strong>所指向的一个<strong>hw_module_methods_t</strong>结构体的成员函数<strong>open</strong>指向了Gralloc模块中的函数<strong>gralloc_device_open</strong>。</p>
<p>&#160; &#160; &#160; &#160;函数<strong>gralloc_device_open</strong>定义在文件hardware/libhardware/modules/gralloc/gralloc.cpp文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">gralloc_context_t</span> &#123;  </span><br><span class="line">    <span class="keyword">alloc_device_t</span>  device;  </span><br><span class="line">    <span class="comment">/* our private data here */</span>  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* module, <span class="keyword">const</span> <span class="keyword">char</span>* name,  </span><br><span class="line">        <span class="keyword">hw_device_t</span>** device)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;  </span><br><span class="line">        <span class="keyword">gralloc_context_t</span> *dev;  </span><br><span class="line">        dev = (<span class="keyword">gralloc_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* initialize our state here */</span>  </span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* initialize the procs */</span>  </span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;  </span><br><span class="line">        dev-&gt;device.common.version = <span class="number">0</span>;  </span><br><span class="line">        dev-&gt;device.common.module = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(module);  </span><br><span class="line">        dev-&gt;device.common.close = gralloc_close;  </span><br><span class="line">  </span><br><span class="line">        dev-&gt;device.alloc   = gralloc_alloc;  </span><br><span class="line">        dev-&gt;device.<span class="built_in">free</span>    = gralloc_free;  </span><br><span class="line">  </span><br><span class="line">        *device = &amp;dev-&gt;device.common;  </span><br><span class="line">        status = <span class="number">0</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> status;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数主要是用来创建一个<strong>gralloc_context_t</strong>结构体，并且对它的成员变量<strong>device</strong>进行初始化。结构体gralloc_context_t的成员变量device的类型为<strong>gralloc_device_t</strong>，它用来描述一个gralloc设备。前面提到，gralloc设备是用来分配和释放图形缓冲区的，这是通过调用它的成员函数alloc和free来实现的。从这里可以看出，函数gralloc_device_open所打开的gralloc设备的成员函数alloc和free分别被设置为Gralloc模块中的函数<strong>gralloc_alloc</strong>和<strong>gralloc_free</strong>，后面我们再详细分析它们的实现。</p>
<p>&#160; &#160; &#160; &#160;至此，gralloc设备的打开过程就分析完成了，接下来我们继续分析fb设备的打开过程。</p>
<h2 id="fb设备的打开过程"><a href="#fb设备的打开过程" class="headerlink" title="fb设备的打开过程"></a>fb设备的打开过程</h2><p>&#160; &#160; &#160; &#160;在Gralloc模块中，fb设备的ID值定义为<strong>GRALLOC_HARDWARE_FB0</strong>。GRALLOC_HARDWARE_FB0是一个宏，定义在文件hardware/libhardware/include/hardware/fb.h中， 如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_FB0 <span class="string">"fb0"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;fb设备使用结构体framebuffer_device_t 来描述。结构体framebuffer_device_t是用来描述系统帧缓冲区的信息，它定义在文件hardware/libhardware/include/hardware/fb.h中， 如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span> &#123;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">hw_device_t</span> common;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* flags describing some attributes of the framebuffer */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  flags;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* dimensions of the framebuffer in pixels */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  width;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  height;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* frambuffer stride in pixels */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       stride;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* framebuffer pixel format */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       format;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* resolution of the framebuffer's display panel in pixel per inch*/</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     xdpi;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     ydpi;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* framebuffer's display panel refresh rate in frames per second */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     fps;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* min swap interval supported by this framebuffer */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       minSwapInterval;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* max swap interval supported by this framebuffer */</span>  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       maxSwapInterval;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> reserved[<span class="number">8</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*setSwapInterval)(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* window,  </span><br><span class="line">            <span class="keyword">int</span> interval);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*setUpdateRect)(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* window,  </span><br><span class="line">            <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*post)(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> (*compositionComplete)(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* dev);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">8</span>];  </span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">framebuffer_device_t</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>成员变量flags用来记录系统帧缓冲区的标志，目前没有使用这成员变量，它的值被设置为0。</li>
<li>成员变量width和height分别用来描述设备显示屏的宽度和高度，它们是以像素为单位的。</li>
<li>成员变量stride用来描述设备显示屏的一行有多少个像素点。</li>
<li>成员变量format用来描述系统帧缓冲区的像素格式，支持的像素格式主要有HAL_PIXEL_FORMAT_RGBX_8888和HAL_PIXEL_FORMAT_RGB_565两种。HAL_PIXEL_FORMAT_RGBX_8888表示一个像素使用32位来描述，R、G和B分别占8位，另外8位未使用。HAL_PIXEL_FORMAT_RGB_565表示一个像素使用16位来描述，R、G和B分别占5、6和5位。</li>
<li>成员变量xdpi和ydpi分别用来描述设备显示屏在宽度和高度上的密度，即每英寸有多少个像素点。</li>
<li>成员变量fps用来描述设备显示屏的刷新频率，它的单位是帧每秒。</li>
<li>成员变量minSwapInterval和maxSwapInterval用来描述帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔。</li>
<li>成员变量reserved是保留给将来使用的。</li>
<li>成员函数setSwapInterval用来设置帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔。</li>
<li>成员函数setUpdateRect用来设置帧缓冲区的更新区域。</li>
<li>成员函数post用来将图形缓冲区buffer的内容渲染到帧缓冲区中去，即显示在设备的显示屏中去。</li>
<li>成员函数compositionComplete用来通知fb设备device，图形缓冲区的组合工作已经完成，目前没有使用这个成员函数。</li>
<li>成员变量reserved是一个函数指针数组，它们是保留给将来使用的。</li>
</ul>
<p>&#160; &#160; &#160; &#160;在结构体framebuffer_device_t的一系列成员函数中，<strong>post</strong>是最重要的一个成员函数，用户空间的应用程序通过调用这个成员函数就可以在设备的显示屏中渲染指定的画面，后面我们将详细讲这个函数的实现。</p>
<p>Gralloc模块在在文件hardware/libhardware/include/hardware/fb.h中定义了一个帮助函数<strong>framebuffer_open</strong>，用来打开fb设备，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** convenience API for opening and closing a supported device */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">framebuffer_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">hw_module_t</span>* module,</span><br><span class="line">        <span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> module-&gt;methods-&gt;open(module,</span><br><span class="line">            GRALLOC_HARDWARE_FB0, (<span class="keyword">struct</span> <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;参数module指向的是一个用来描述Gralloc模块的<strong>hw_module_t</strong>结构体，前面提到，它的成员变量methods所指向的一个hw_module_methods_t结构体的成员函数open指向了Gralloc模块中的函数<strong>gralloc_device_open</strong>，这个函数打开fb设备的代码段如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* module, <span class="keyword">const</span> <span class="keyword">char</span>* name,  </span><br><span class="line">        <span class="keyword">hw_device_t</span>** device)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;  </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;  </span><br><span class="line">        ......  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        status = fb_device_open(module, name, device);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> status;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;参数name的值等于<strong>GRALLOC_HARDWARE_FB0</strong>，因此，函数gralloc_device_open接下来会调用另外一个函数<strong>fb_device_open</strong>来执行打开fb设备的操作。</p>
<p>&#160; &#160; &#160; &#160;函数<strong>fb_device_open</strong>定义在文件hardware/libhardware/modules/gralloc/framebuffer.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">fb_context_t</span> &#123;  </span><br><span class="line">    <span class="keyword">framebuffer_device_t</span>  device;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fb_device_open</span><span class="params">(<span class="keyword">hw_module_t</span> <span class="keyword">const</span>* module, <span class="keyword">const</span> <span class="keyword">char</span>* name,  </span><br><span class="line">        <span class="keyword">hw_device_t</span>** device)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL; </span><br><span class="line">    <span class="comment">//判断打开的是fb设备  </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_FB0)) &#123;  </span><br><span class="line">        <span class="keyword">alloc_device_t</span>* gralloc_device;  </span><br><span class="line">        <span class="comment">//打开gpu设备 </span></span><br><span class="line">        status = gralloc_open(module, &amp;gralloc_device);  </span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> status;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* initialize our state here */</span>  </span><br><span class="line">        <span class="comment">//创建一个fb_context_t对象，用来描述fb设备上下文  </span></span><br><span class="line">        <span class="keyword">fb_context_t</span> *dev = (<span class="keyword">fb_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));  </span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* initialize the procs */</span>  </span><br><span class="line">        <span class="comment">//初始化fb_context_t对象  </span></span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;  </span><br><span class="line">        dev-&gt;device.common.version = <span class="number">0</span>;  </span><br><span class="line">        dev-&gt;device.common.module = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(module);  </span><br><span class="line">        <span class="comment">//注册fb设备的操作函数 </span></span><br><span class="line">        dev-&gt;device.common.close = fb_close;  </span><br><span class="line">        dev-&gt;device.setSwapInterval = fb_setSwapInterval;  </span><br><span class="line">        dev-&gt;device.post            = fb_post;  </span><br><span class="line">        dev-&gt;device.setUpdateRect = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private_module_t</span>* m = (<span class="keyword">private_module_t</span>*)module;  </span><br><span class="line">        <span class="comment">//将fb映射到当前进程地址空间 </span></span><br><span class="line">        status = mapFrameBuffer(m);  </span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">int</span> stride = m-&gt;finfo.line_length / (m-&gt;info.bits_per_pixel &gt;&gt; <span class="number">3</span>);  </span><br><span class="line">            <span class="keyword">int</span> format = (m-&gt;info.bits_per_pixel == <span class="number">32</span>)  </span><br><span class="line">                         ? HAL_PIXEL_FORMAT_RGBX_8888  </span><br><span class="line">                         : HAL_PIXEL_FORMAT_RGB_565;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NO_32BPP  </span></span><br><span class="line">            format = HAL_PIXEL_FORMAT_RGB_565;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.flags) = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.stride) = stride;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.format) = format;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.minSwapInterval) = <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.maxSwapInterval) = <span class="number">1</span>;  </span><br><span class="line">            *device = &amp;dev-&gt;device.common;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> status;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1）这个函数主要是用来创建一个<strong>fb_context_t</strong>结构体，并且对它的成员变量<strong>device</strong>进行初始化。结构体fb_context_t的成员变量device的类型为<strong>framebuffer_device_t</strong>，前面提到，它是用来描述fb设备的。fb设备主要是用来渲染图形缓冲区的，这是通过调用它的成员函数post来实现的。从这里可以看出，函数fb_device_open所打开的fb设备的成员函数<strong>post</strong>被设置为Gralloc模块中的函数<strong>fb_post</strong>，后面我们再详细分析它的实现。</p>
<p>&#160; &#160; &#160; &#160;2）函数fb_device_open在打开fb设备的过程中，会调用另外一个函数<strong>mapFrameBuffer</strong>来获得系统帧缓冲区的信息，并且将这些信息保存在参数<strong>module</strong>所描述的一个<strong>private_module_t</strong>结构体的各个成员变量中。有了系统帧缓冲区的信息之后，函数fb_device_open接下来就可以对前面所打开的一个fb设备的各个成员变量进行初始化。这些成员变量的含义可以参考前面对结构体<strong>framebuffer_device_t</strong>的介绍。接下来我们只简单介绍一下结构体framebuffer_device_t的成员变量<strong>stride</strong>和<strong>format</strong>的初始化过程。</p>
<p>&#160; &#160; &#160; &#160;3）变量<strong>m</strong>的成员变量<strong>finfo</strong>的类型为<strong>fb_fix_screeninfo</strong>，它是在函数mapFrameBuffer中被始化的。fb_fix_screeninfo是在内核中定义的一个结构体，<strong>用来描述设备显示屏的固定属性信息</strong>，其中，它的成员变量<strong>line_length</strong>用来描述显示屏一行像素总共所占用的字节数。<br>&#160; &#160; &#160; &#160;变量m的另外一个成员变量<strong>info</strong>的类型为<strong>fb_var_screeninfo</strong>，它也是在函数mapFrameBuffer中被始化的。fb_var_screeninfo也是内核中定义的一个结构体，<strong>用来描述可以动态设置的显示屏属性信息</strong>，其中，它的成员变量<strong>bits_per_pixel</strong>用来描述显示屏每一个像素所占用的位数。<br>&#160; &#160; &#160; &#160;这样，我们将<strong>m-&gt;info.bits_per_pixel</strong>的值向右移3位，就可以得到显示屏每一个像素所占用的字节数。用显示屏每一个像素所占用的字节数去除显示屏一行像素总共所占用的字节数<strong>m-&gt;finfo.line_length</strong>，就可以得到显示屏一行有多少个像素点。这个值最终就可以保存在前面所打开的fb设备的成员变量<strong>stride</strong>中。<br>&#160; &#160; &#160; &#160;当显示屏每一个像素所占用的位数等于<strong>32</strong>的时候，那么前面所打开的fb设备的像素格式<strong>format</strong>就会被设置为HAL_PIXEL_FORMAT_RGBX_8888，否则的话，就会被设置为HAL_PIXEL_FORMAT_RGB_565。另一方面，如果在编译的时候定义了<strong>NO_32BPP</strong>宏，即不要使用32位来描述一个像素，那么函数fb_device_open就会强制将前面所打开的fb设备的像素格式format设置为HAL_PIXEL_FORMAT_RGB_565。</p>
<p>&#160; &#160; &#160; &#160;3）函数<strong>mapFrameBuffer</strong>除了用来获得系统帧缓冲区的信息之外，还会将系统帧缓冲区映射到当前进程的地址空间来。<strong>在Android系统中，Gralloc模块中的fb设备是由SurfaceFlinger服务来负责打开和管理的，而SurfaceFlinger服是运行System进程中的，因此，系统帧缓冲区实际上是映射到System进程的地址空间中的</strong>。</p>
<p>&#160; &#160; &#160; &#160;函数mapFrameBuffer实现在文件hardware/libhardware/modules/gralloc/framebuffer.cpp，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapFrameBuffer</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;module-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> err = mapFrameBufferLocked(module);</span><br><span class="line">    pthread_mutex_unlock(&amp;module-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数调用了同一个文件中的另外一个函数mapFrameBufferLocked来初始化参数module以及将系统帧缓冲区映射到当前进程的地址空间来。</p>
<h3 id="映射内存过程"><a href="#映射内存过程" class="headerlink" title="映射内存过程"></a>映射内存过程</h3><p>&#160; &#160; &#160; &#160;函数mapFrameBufferLocked的实现比较长，我们分段来阅读：<br>&#160; &#160; &#160; &#160;Part.1：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="comment">// already initialized...  </span></span><br><span class="line">    <span class="keyword">if</span> (module-&gt;framebuffer) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> device_template[] = &#123;  </span><br><span class="line">            <span class="string">"/dev/graphics/fb%u"</span>,  </span><br><span class="line">            <span class="string">"/dev/fb%u"</span>,  </span><br><span class="line">            <span class="number">0</span> &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> ((fd==<span class="number">-1</span>) &amp;&amp; device_template[i]) &#123;  </span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="number">64</span>, device_template[i], <span class="number">0</span>);  </span><br><span class="line">        fd = open(name, O_RDWR, <span class="number">0</span>);  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码在首先在系统中检查是否存在设备文件/dev/graphics/fb0或者/dev/fb0。如果存在的话，那么就调用函数open来打开它，并且将得到的文件描述符保存在变量fd中。这样，接下来函数mapFrameBufferLocked就可以通过文件描述符fd来与内核中的帧缓冲区驱动程序交互。</p>
<p>&#160; &#160; &#160; &#160;Part.2：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> fb_fix_screeninfo finfo;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> fb_var_screeninfo info;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这几行代码分别通过IO控制命令FBIOGET_FSCREENINFO和FBIOGET_VSCREENINFO来获得系统帧缓冲区的信息，分别保存在fb_fix_screeninfo结构体finfo和fb_var_screeninfo结构体info中。</p>
<p>&#160; &#160; &#160; &#160;Part.3：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    </span><br><span class="line">    info.reserved[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    info.reserved[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    info.reserved[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    info.xoffset = <span class="number">0</span>;</span><br><span class="line">    info.yoffset = <span class="number">0</span>;</span><br><span class="line">    info.activate = FB_ACTIVATE_NOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Request NUM_BUFFERS screens (at lest 2 for page flipping)</span><br><span class="line">     */</span></span><br><span class="line">    info.yres_virtual = info.yres * NUM_BUFFERS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = PAGE_FLIP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_PAN_DISPLAY  <span class="comment">// 0</span></span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOPAN_DISPLAY, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"FBIOPAN_DISPLAY failed, page flipping not supported"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOPUT_VSCREENINFO, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"FBIOPUT_VSCREENINFO failed, page flipping not supported"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        info.yres_virtual = info.yres;</span><br><span class="line">        flags &amp;= ~PAGE_FLIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.yres_virtual &lt; info.yres * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// we need at least 2 for page-flipping</span></span><br><span class="line">        info.yres_virtual = info.yres;</span><br><span class="line">        flags &amp;= ~PAGE_FLIP;</span><br><span class="line">        ALOGW(<span class="string">"page flipping not supported (yres_virtual=%d, requested=%d)"</span>,</span><br><span class="line">                info.yres_virtual, info.yres*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码主要是用来设置设备显示屏的虚拟分辨率。结构体<strong>fb_var_screeninfo</strong>的成员变量<strong>xres</strong>和<strong>yres</strong>用来描述显示屏的可视分辨率，而成员变量<strong>xres_virtual</strong>和<strong>yres_virtual</strong>用来描述显示屏的虚拟分辨率。这里保持可视分辨率以及虚拟分辨率的宽度值不变，而将虚拟分辨率的高度值设置为可视分辨率的高度值的<strong>NUM_BUFFERS</strong>倍。NUM_BUFFERS是一个宏，它的值被定义为<code>2</code>。这样，我们就可以将系统帧缓冲区划分为两个图形缓冲区来使用，即可以通过硬件来实现双缓冲技术。<br>&#160; &#160; &#160; &#160;在结构体fb_var_screeninfo中，与显示屏的可视分辨率和虚拟分辨率相关的另外两个成员变量是<strong>xoffset</strong>和<strong>yoffset</strong>，它们用来告诉帧缓冲区当前要渲染的图形缓冲区是哪一个。</p>
<p>&#160; &#160; &#160; &#160;这段代码最终是通过IO控制命令<strong>FBIOPUT_VSCREENINFO</strong>来设置设备显示屏的虚拟分辨率以及像素格式的。如果设置失败，即调用函数<strong>ioctl</strong>的返回值等于-1，那么很可能是因为系统帧缓冲区在硬件上不支持双缓冲，因此，接下来的代码就会重新将显示屏的虚拟分辨率的高度值设置为可视分辨率的高度值，并且将变量<strong>flags</strong>的<strong>PAGE_FLIP</strong>位置为0。<br>&#160; &#160; &#160; &#160;另一方面，如果调用函数ioctl成功，但是最终获得的显示屏的虚拟分辨率的高度值小于可视分辨率的高度值的2倍，那么也说明系统帧缓冲区在硬件上不支持双缓冲。在这种情况下，接下来的代码也会重新将显示屏的虚拟分辨率的高度值设置为可视分辨率的高度值，并且将变量flags的PAGE_FLIP位置为0。</p>
<p>&#160; &#160; &#160; &#160;Part.4：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == <span class="number">-1</span>)  </span><br><span class="line">    <span class="keyword">return</span> -errno;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">uint64_t</span>  refreshQuotient =  </span><br><span class="line">(  </span><br><span class="line">        <span class="keyword">uint64_t</span>( info.upper_margin + info.lower_margin + info.yres )  </span><br><span class="line">        * ( info.left_margin  + info.right_margin + info.xres )  </span><br><span class="line">        * info.pixclock  </span><br><span class="line">);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Beware, info.pixclock might be 0 under emulation, so avoid a </span><br><span class="line"> * division-by-0 here (SIGFPE on ARM) */</span>  </span><br><span class="line"><span class="keyword">int</span> refreshRate = refreshQuotient &gt; <span class="number">0</span> ? (<span class="keyword">int</span>)(<span class="number">1000000000000000L</span>LU / refreshQuotient) : <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (refreshRate == <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="comment">// bleagh, bad info from the driver  </span></span><br><span class="line">    refreshRate = <span class="number">60</span>*<span class="number">1000</span>;  <span class="comment">// 60 Hz  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码再次通过IO控制命令<strong>FBIOGET_VSCREENINFO</strong>来获得系统帧缓冲区的可变属性信息，并且保存在<strong>fb_var_screeninfo</strong>结构体<strong>info</strong>中，接下来再计算设备显示屏的刷新频率。</p>
<p>&#160; &#160; &#160; &#160;显示屏的刷新频率与显示屏的扫描时序相关。显示屏的扫描时序可以参考Kernel代码目录下的Documentation/fb/framebuffer.txt文件。我们结合这个txt文件中的一幅图来简单说明上述代码是如何计算显示屏的刷新频率的：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/framebuffer.jpg" alt="显示屏扫描时序示意图"></p>
<p>&#160; &#160; &#160; &#160;中间由xres和yres组成的区域即为显示屏的图形绘制区，在绘制区的上、下、左和右分别有四个边距upper_margin、lower_margin、left_margin和right_margin。此外，在显示屏的最右边以及最下边还有一个水平同步区域hsync_len和一个垂直同步区域vsync_len。电子枪按照从左到右、从上到下的顺序来显示屏中打点，从而可以将要渲染的图形显示在屏幕中。前面所提到的区域信息分别保存在fb_var_screnninfo结构体info的成员变量xres、yres、upper_margin、lower_margin、left_margin、right_margin、hsync_len和vsync_len。</p>
<p>&#160; &#160; &#160; &#160;电子枪每在xres和yres所组成的区域中打一个点所花费的时间记录在fb_var_screnninfo结构体info的成员变量pixclock，单位为pico seconds，即10E-12秒。</p>
<p>&#160; &#160; &#160; &#160;电子枪从左到右扫描完成一行之后，都会处理关闭状态，并且会重新折回到左边去。由于电子枪在从右到左折回的过程中不需要打点，因此，这个过程会比从左到右扫描屏幕的过程要快，这个折回的时间大概就等于在xres和yres所组成的区域扫描（left_margin+right_margin）个点的时间。这样，我们就可以认为每渲染一行需要的时间为（xres + left_margin + right_margin）* pixclock。</p>
<p>&#160; &#160; &#160; &#160;同样，电子枪从上到下扫描完成显示屏之后，需要从右下角折回到左上角去，折回的时间大概等于在xres和yres所组成的区域中扫描（upper_margin + lower_margin）行所需要的时间。这样，我们就可以认为每渲染一屏图形所需要的时间等于在xres和yres所组成的区域中扫描（yres + upper_margin + lower_margin）行所需要的时间。由于在xres和yres所组成的区域中扫描一行所需要的时间为（xres + left_margin + right_margin）<em> pixclock，因此，每渲染一屏图形所需要的总时间就等于（yres + upper_margin + lower_margin）</em> （xres + left_margin + right_margin）* pixclock。</p>
<p>&#160; &#160; &#160; &#160;每渲染一屏图形需要的总时间经过计算之后，就保存在变量refreshQuotient中。注意，变量refreshQuotient所描述的时间的单位为1E-12秒。这样，将变量refreshQuotient的值倒过来，就可以得到设备显示屏的刷新频率。将这个频率值乘以10E15次方之后，就得到一个单位为10E-3 HZ的刷新频率，保存在变量refreshRate中。</p>
<p>&#160; &#160; &#160; &#160;当Android系统在模拟器运行的时候，保存在fb_var_screnninfo结构体info的成员变量pixclock中的值可能等于0。在这种情况下，前面计算得到的变量refreshRate的值就会等于0。在这种情况下，接下来的代码会将变量refreshRate的值设置为60 <em> 1000 </em> 10E-3 HZ，即将显示屏的刷新频率设置为60HZ。</p>
<p>&#160; &#160; &#160; &#160;Part.5：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">int</span>(info.width) &lt;= <span class="number">0</span> || <span class="keyword">int</span>(info.height) &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="comment">// the driver doesn't return that information  </span></span><br><span class="line">    <span class="comment">// default to 160 dpi  </span></span><br><span class="line">    info.width  = ((info.xres * <span class="number">25.4f</span>)/<span class="number">160.0f</span> + <span class="number">0.5f</span>);  </span><br><span class="line">    info.height = ((info.yres * <span class="number">25.4f</span>)/<span class="number">160.0f</span> + <span class="number">0.5f</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">float</span> xdpi = (info.xres * <span class="number">25.4f</span>) / info.width;  </span><br><span class="line"><span class="keyword">float</span> ydpi = (info.yres * <span class="number">25.4f</span>) / info.height;  </span><br><span class="line"><span class="keyword">float</span> fps  = refreshRate / <span class="number">1000.0f</span>; </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码首先计算显示屏的密度，即每英寸有多少个像素点，分别宽度和高度两个维度，分别保存在变量xdpi和ydpi中。注意，fb_var_screeninfo结构体info的成员变量width和height用来描述显示屏的宽度和高度，它们是以<strong>毫米</strong>（mm）为单位的。<br>&#160; &#160; &#160; &#160;这段代码接着再将前面计算得到的显示屏刷新频率的单位由10E-3 HZ转换为HZ，即帧每秒，并且保存在变量fps中。</p>
<p>&#160; &#160; &#160; &#160;Part.6：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line">    ...Part<span class="number">.5</span>...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == <span class="number">-1</span>)  </span><br><span class="line">    <span class="keyword">return</span> -errno;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (finfo.smem_len &lt;= <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> -errno;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">module-&gt;flags = flags;  </span><br><span class="line">module-&gt;info = info;  </span><br><span class="line">module-&gt;finfo = finfo;  </span><br><span class="line">module-&gt;xdpi = xdpi;  </span><br><span class="line">module-&gt;ydpi = ydpi;  </span><br><span class="line">module-&gt;fps = fps;  </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码再次通过IO控制命令<strong>FBIOGET_FSCREENINFO</strong>来获得系统帧缓冲区的固定信息，并且保存在<strong>fb_fix_screeninfo</strong>结构体<strong>finfo</strong>中，接下来再使用fb_fix_screeninfo结构体finfo以及前面得到的系统帧缓冲区的其它信息来初始化参数<strong>module</strong>所描述的一个<strong>private_module_t</strong>结构体。</p>
<p>&#160; &#160; &#160; &#160;Part.7：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">private_module_t</span>* module)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...Part<span class="number">.1</span>...</span><br><span class="line">    ...Part<span class="number">.2</span>...</span><br><span class="line">    ...Part<span class="number">.3</span>...</span><br><span class="line">    ...Part<span class="number">.4</span>...</span><br><span class="line">    ...Part<span class="number">.5</span>...</span><br><span class="line">    ...Part<span class="number">.6</span>...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">     * map the framebuffer </span><br><span class="line">     */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> err;  </span><br><span class="line">    <span class="keyword">size_t</span> fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);  </span><br><span class="line">    module-&gt;framebuffer = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(dup(fd), fbSize, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    module-&gt;numBuffers = info.yres_virtual / info.yres;  </span><br><span class="line">    module-&gt;bufferMask = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span>* vaddr = mmap(<span class="number">0</span>, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (vaddr == MAP_FAILED) &#123;  </span><br><span class="line">        LOGE(<span class="string">"Error mapping the framebuffer (%s)"</span>, strerror(errno));  </span><br><span class="line">        <span class="keyword">return</span> -errno;  </span><br><span class="line">    &#125;  </span><br><span class="line">    module-&gt;framebuffer-&gt;base = <span class="keyword">intptr_t</span>(vaddr);  </span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, fbSize);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;表达式<strong>finfo.line_length * info.yres_virtual</strong>计算的是整个系统帧缓冲区的大小，它的值等于显示屏行数（虚拟分辨率的高度值，<strong>info.yres_virtual</strong>）乘以每一行所占用的字节数（<strong>finfo.line_length</strong>）。函数<strong>roundUpToPageSize</strong>用来将整个系统帧缓冲区的大小对齐到页面边界。对齐后的大小保存在变量<strong>fbSize</strong>中。</p>
<p>&#160; &#160; &#160; &#160;表达式<strong>finfo.yres_virtual / info.yres</strong>计算的是整个系统帧缓冲区可以划分为多少个图形缓冲区来使用，这个数值保存在参数module所描述的一个private_module_t结构体的成员变量<strong>nmBuffers</strong>中。参数module所描述的一个private_module_t结构体的另外一个成员变量<strong>bufferMask</strong>的值接着被设置为0，表示系统帧缓冲区中的所有图形缓冲区都是处于空闲状态，即它们可以分配出去给应用程序使用。</p>
<p>&#160; &#160; &#160; &#160;系统帧缓冲区是通过调用函数<strong>mmap</strong>来映射到当前进程的地址空间来的。映射后得到的地址空间使用一个<strong>private_handle_t</strong>结构体来描述，这个结构体的成员变量<strong>base</strong>保存的即为系统帧缓冲区在当前进程的地址空间中的起始地址。这样，Gralloc模块以后就可以从这块地址空间中分配图形缓冲区给当前进程使用。</p>
<p>&#160; &#160; &#160; &#160;至此，fb设备的打开过程就分析完成了。在打开fb设备的过程中，Gralloc模块还完成了对系统帧缓冲区的初始化工作。接下来我们继续分析Gralloc模块是如何分配图形缓冲区给用户空间的应用程序使用的。</p>
<h2 id="分配图形缓冲区"><a href="#分配图形缓冲区" class="headerlink" title="分配图形缓冲区"></a>分配图形缓冲区</h2><p>&#160; &#160; &#160; &#160;前面提到，用户空间的应用程序用到的图形缓冲区是由Gralloc模块中的函数gralloc_alloc来分配的，这个函数实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">        <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,</span><br><span class="line">        <span class="keyword">buffer_handle_t</span>* pHandle, <span class="keyword">int</span>* pStride)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHandle || !pStride)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size, stride;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> align = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> bpp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (format) &#123;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBA_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBX_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_BGRA_8888:</span><br><span class="line">            bpp = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_888:</span><br><span class="line">            bpp = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_565:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW_SENSOR:</span><br><span class="line">            bpp = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> bpr = (w*bpp + (align<span class="number">-1</span>)) &amp; ~(align<span class="number">-1</span>);</span><br><span class="line">    size = bpr * h;</span><br><span class="line">    stride = bpr / bpp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> (usage &amp; GRALLOC_USAGE_HW_FB) &#123;</span><br><span class="line">        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = gralloc_alloc_buffer(dev, size, usage, pHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pStride = stride;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>参数format用来描述要分配的图形缓冲区的颜色格式。当format值等于HAL_PIXEL_FORMAT_RGBA_8888、HAL_PIXEL_FORMAT_RGBX_8888或者HAL_PIXEL_FORMAT_BGRA_8888的时候，一个像素需要使用32位来表示，即4个字节。当format值等于HAL_PIXEL_FORMAT_RGB_888的时候，一个像素需要使用24位来描述，即3个字节。当format值等于HAL_PIXEL_FORMAT_RGB_565、HAL_PIXEL_FORMAT_RGBA_5551或者HAL_PIXEL_FORMAT_RGBA_4444的时候，一个像需要使用16位来描述，即2个字节。最终一个像素需要使用的字节数保存在变量bpp中。</li>
<li>参数w表示要分配的图形缓冲区所保存的图像的宽度，将它乘以bpp，就可以得到保存一行像素所需要使用的字节数。我们需要将这个字节数对齐到4个字节边界，最后得到一行像素所需要的字节数就保存在变量bpr中。</li>
<li>参数h表示要分配的图形缓冲区所保存的图像的高度，将它乘以bpr，就可以得到保存整个图像所需要使用的字节数。</li>
<li>将变量bpr的值除以变量bpp的值，就得到要分配的图形缓冲区一行包含有多少个像素点，这个结果需要保存在输出参数pStride中，以便可以返回给调用者。</li>
<li>参数usage用来描述要分配的图形缓冲区的用途。如果是用来在系统帧缓冲区中渲染的，即参数usage的GRALLOC_USAGE_HW_FB位等于1，那么就必须要系统帧缓冲区中分配，否则的话，就在内存中分配。注意，在内存中分配的图形缓冲区，最终是需要拷贝到系统帧缓冲区去的，以便可以将它所描述的图形渲染出来。</li>
<li>函数gralloc_alloc_framebuffer用来在系统帧缓冲区中分配图形缓冲区，而函数gralloc_alloc_buffer用来在内存在分配图形缓冲区，接下来我们就分别分析这两个函数的实现。</li>
</ul>
<h3 id="系统帧缓冲区中分配图形缓冲区"><a href="#系统帧缓冲区中分配图形缓冲区" class="headerlink" title="系统帧缓冲区中分配图形缓冲区"></a>系统帧缓冲区中分配图形缓冲区</h3><p>&#160; &#160; &#160; &#160;函数gralloc_alloc_framebuffer实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc_framebuffer</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">        <span class="keyword">size_t</span> size, <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            dev-&gt;common.module);</span><br><span class="line">    pthread_mutex_lock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle);</span><br><span class="line">    pthread_mutex_unlock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数调用了另外一个函数gralloc_alloc_framebuffer_locked来分配图形缓冲区。函数gralloc_alloc_framebuffer_locked也是实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc_framebuffer_locked</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">        <span class="keyword">size_t</span> size, <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            dev-&gt;common.module);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate the framebuffer</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;framebuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// initialize the framebuffer, the framebuffer is mapped once</span></span><br><span class="line">        <span class="comment">// and forever.</span></span><br><span class="line">        <span class="keyword">int</span> err = mapFrameBufferLocked(m);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> bufferMask = m-&gt;bufferMask;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> numBuffers = m-&gt;numBuffers;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line">    <span class="keyword">if</span> (numBuffers == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// If we have only one buffer, we never use page-flipping. Instead,</span></span><br><span class="line">        <span class="comment">// we return a regular buffer which will be memcpy'ed to the main</span></span><br><span class="line">        <span class="comment">// screen when post is called.</span></span><br><span class="line">        <span class="keyword">int</span> newUsage = (usage &amp; ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;</span><br><span class="line">        <span class="keyword">return</span> gralloc_alloc_buffer(dev, bufferSize, newUsage, pHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferMask &gt;= ((<span class="number">1L</span>U&lt;&lt;numBuffers)<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="comment">// We ran out of buffers.</span></span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a "fake" handles for it</span></span><br><span class="line">    <span class="keyword">intptr_t</span> vaddr = <span class="keyword">intptr_t</span>(m-&gt;framebuffer-&gt;base);</span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(dup(m-&gt;framebuffer-&gt;fd), size,</span><br><span class="line">            <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find a free slot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i=<span class="number">0</span> ; i&lt;numBuffers ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((bufferMask &amp; (<span class="number">1L</span>U&lt;&lt;i)) == <span class="number">0</span>) &#123;</span><br><span class="line">            m-&gt;bufferMask |= (<span class="number">1L</span>U&lt;&lt;i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vaddr += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hnd-&gt;base = vaddr;</span><br><span class="line">    hnd-&gt;offset = vaddr - <span class="keyword">intptr_t</span>(m-&gt;framebuffer-&gt;base);</span><br><span class="line">    *pHandle = hnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在系统帧缓冲区分配图形缓冲区之前，首先要对系统帧缓冲区进行过初始化，即这里的变量<strong>m</strong>所指向的一个<strong>private_module_t</strong>结构体的成员变量<strong>framebuffer</strong>的值不能等于NULL。如果等于NULL的话，那么就必须要调用另外一个函数<strong>mapFrameBufferLocked</strong>来初始化系统帧缓冲区。初始化系统帧缓冲区的过程可以参考前面的内容。</p>
<p>&#160; &#160; &#160; &#160;变量<strong>bufferMask</strong>用来描述系统帧缓冲区的使用情况，而变量<strong>numBuffers</strong>用来描述系统帧缓冲区可以划分为多少个图形缓冲区来使用，另外一个变量<strong>bufferSize</strong>用来描述设备显示屏一屏内容所占用的内存的大小。</p>
<p>&#160; &#160; &#160; &#160;如果系统帧缓冲区只有一个图形缓冲区大小，即变量numBuffers的值等于1，那么这个图形缓冲区就始终用作系统主图形缓冲区来使用。在这种情况下，我们就不能够在系统帧缓冲区中分配图形缓冲区来给用户空间的应用程序使用，因此，<strong>这时候就会转向内存中来分配图形缓冲区</strong>，即调用函数<strong>gralloc_alloc_buffer</strong>来分配图形缓冲区。注意，<strong>这时候分配的图形缓冲区的大小为一屏内容的大小，即bufferSize</strong>。</p>
<p>&#160; &#160; &#160; &#160;如果bufferMask的值大于等于((1LU&lt;&lt;numBuffers)-1)的值，那么就说明系统帧缓冲区中的图形缓冲区全部都分配出去了，这时候分配图形缓冲区就失败了。例如，假设图形缓冲区的个数为2，那么((1LU&lt;&lt;numBuffers)-1)的值就等于3，即二制制0x11。如果这时候bufferMask的值也等于0x11，那么就表示第一个和第二个图形缓冲区都已经分配出去了。因此，这时候就不能再在系统帧缓冲区中分配图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;假设此时系统帧缓冲区中尚有空闲的图形缓冲区的，接下来函数就会创建一个private_handle_t结构体<strong>hnd</strong>来描述这个即将要分配出去的图形缓冲区。注意，这个图形缓冲区的标志值等于<strong>PRIV_FLAGS_FRAMEBUFFER</strong>，即表示这是一块在系统帧缓冲区中分配的图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;接下来的for循环从低位到高位检查变量bufferMask的值，并且找到第一个值等于0的位，这样就可以知道在系统帧缓冲区中，第几个图形缓冲区的是空闲的。注意，变量<strong>vadrr</strong>的值开始的时候指向系统帧缓冲区的基地址，在下面的for循环中，每循环一次它的值都会增加bufferSize。从这里就可以看出，每次从系统帧缓冲区中分配出去的图形缓冲区的大小都是刚好等于显示屏一屏内容大小的。</p>
<p>&#160; &#160; &#160; &#160;最后分配出去的图形缓冲区的开始地址就保存在前面所创建的private_handle_t结构体<strong>hnd</strong>的成员变量<strong>base</strong>中，这样，用户空间的应用程序就可以直接将要渲染的图形内容拷贝到这个地址上去，这就相当于是直接将图形渲染到系统帧缓冲区中去。</p>
<p>&#160; &#160; &#160; &#160;在将private_handle_t结构体hnd返回给调用者之前，还需要设置它的成员变量<strong>offset</strong>，以便可以知道它所描述的图形缓冲区的起始地址相对于系统帧缓冲区的基地址的偏移量。</p>
<p>&#160; &#160; &#160; &#160;至此，在系统帧缓冲区中分配图形缓冲区的过程就分析完成了，接下来我们再分析在内存在分析图形缓冲区的过程，即分析函数<strong>gralloc_alloc_buffer</strong>的实现。</p>
<h3 id="内存中分配图形缓冲区"><a href="#内存中分配图形缓冲区" class="headerlink" title="内存中分配图形缓冲区"></a>内存中分配图形缓冲区</h3><p> &#160; &#160; &#160; &#160;函数gralloc_alloc_buffer也是实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc_buffer</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,  </span><br><span class="line">        <span class="keyword">size_t</span> size, <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;  </span><br><span class="line">  </span><br><span class="line">    size = roundUpToPageSize(size);  </span><br><span class="line">  </span><br><span class="line">    fd = ashmem_create_region(<span class="string">"gralloc-buffer"</span>, size);  </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        LOGE(<span class="string">"couldn't create ashmem (%s)"</span>, strerror(-errno));  </span><br><span class="line">        err = -errno;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">private_handle_t</span>* hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(fd, size, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">gralloc_module_t</span>* module = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc_module_t</span>*&gt;(  </span><br><span class="line">                dev-&gt;common.module);  </span><br><span class="line">        err = mapBuffer(module, hnd);  </span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;  </span><br><span class="line">            *pHandle = hnd;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    LOGE_IF(err, <span class="string">"gralloc failed err=%s"</span>, strerror(-err));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> err;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;这个函数的实现很简单，它首先调用函数<strong>ashmem_create_region</strong>来创建一块匿名共享内存，接着再在这块匿名共享内存上分配一个图形缓冲区。注意，这个图形缓冲区也是使用一个private_handle_t结构体来描述的，不过这个图形缓冲区的标志值等于0，以区别于在系统帧缓冲区中分配的图形缓冲区。匿名共享内存的知识还没有入坑，以后再看。。。。。。</p>
<p> &#160; &#160; &#160; &#160;从匿名共享内存中分配的图形缓冲区还需要映射到进程的地址空间来，然后才可以使用，这是通过调用函数mapBuffer来实现的。</p>
<p> &#160; &#160; &#160; &#160;函数mapBuffer实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapBuffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,</span><br><span class="line">        <span class="keyword">private_handle_t</span>* hnd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">    <span class="keyword">return</span> gralloc_map(module, hnd, &amp;vaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &#160; &#160; &#160; &#160;它通过调用另外一个函数<strong>gralloc_map</strong>来将参数hnd所描述的一个图形缓冲区映射到当前进程的地址空间来。后面在分析图形缓冲区的注册过程时，我们再分析函数gralloc_map的实现。</p>
<p> &#160; &#160; &#160; &#160;<strong>注意，在Android系统中，在系统帧缓冲区中分配的图形缓冲区是在SurfaceFlinger服务中使用的，而在内存中分配的图形缓冲区既可以在SurfaceFlinger服务中使用，也可以在其它的应用程序中使用。当其它的应用程序需要使用图形缓冲区的时候，它们就会请求SurfaceFlinger服务为它们分配，因此，对于其它的应用程序来说，它们只需要将SurfaceFlinger服务返回来的图形缓冲区映射到自己的进程地址空间来使用就可以了，这就是后面我们所要分析的图形缓冲区的注册过程</strong>。</p>
<p>&#160; &#160; &#160; &#160;至此，图形缓冲区的分配过程就分析完成了，接下来我们继续分析图形缓冲区的释放过程。</p>
<h2 id="图形缓冲区的释放过程"><a href="#图形缓冲区的释放过程" class="headerlink" title="图形缓冲区的释放过程"></a>图形缓冲区的释放过程</h2><p>&#160; &#160; &#160; &#160;前面提到，用户空间的应用程序用到的图形缓冲区是由Gralloc模块中的函数gralloc_free来释放的，这个函数实现在文件hardware/libhardware/modules/gralloc/gralloc.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_free</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private_handle_t</span> <span class="keyword">const</span>* hnd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_handle_t</span> <span class="keyword">const</span>*&gt;(handle);</span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &#123;</span><br><span class="line">        <span class="comment">// free this buffer</span></span><br><span class="line">        <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">                dev-&gt;common.module);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line">        <span class="keyword">int</span> index = (hnd-&gt;base - m-&gt;framebuffer-&gt;base) / bufferSize;</span><br><span class="line">        m-&gt;bufferMask &amp;= ~(<span class="number">1</span>&lt;&lt;index); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">gralloc_module_t</span>* module = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc_module_t</span>*&gt;(</span><br><span class="line">                dev-&gt;common.module);</span><br><span class="line">        terminateBuffer(module, <span class="keyword">const_cast</span>&lt;<span class="keyword">private_handle_t</span>*&gt;(hnd));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(hnd-&gt;fd);</span><br><span class="line">    <span class="keyword">delete</span> hnd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;要释放的图形缓冲区使用参数<strong>handle</strong>来描述。前面提到，从Gralloc模块中分配的图形缓冲区是使用private_handle_t结构体来描述的，因此，这里的参数handle应该指向一个<strong>private_handle_t</strong>结构体，这是通过调用private_handle_t类的静态成员函数<strong>validate</strong>来验证的。private_handle_t类的静态成员函数validate的实现可以参考前面的内容。</p>
<p>&#160; &#160; &#160; &#160;要释放的图形缓冲区有可能是在系统帧缓冲区分配的，也有可能是在内存中分配的，这可以通过检查它的标志值flags的<strong>PRIV_FLAGS_FRAMEBUFFER</strong>位是否等于1来确认。</p>
<p>&#160; &#160; &#160; &#160;如果要释放的图形缓冲区是在系统帧缓冲区中分配的，那么首先要知道这个图形缓冲区是系统帧缓冲区的第<strong>index</strong>个位置，接着再将变量m所描述的一个private_module_t结构体的成员变量<strong>bufferMask</strong>的第index位重置为0即可。我们只需要将要释放的图形缓冲区的开始地址减去系统帧缓冲区的基地址，再除以一个图形缓冲区的大小，就可以知道要释放的图形缓冲区是系统帧缓冲区的第几个位置。这个过程刚好是在系统帧缓冲区中分配图形缓冲区的逆操作。</p>
<p>&#160; &#160; &#160; &#160;如果要释放的图形缓冲区是内存中分配的，那么只需要调用另外一个函数<strong>terminateBuffer</strong>来解除要释放的图形缓冲区在当前进程的地址空间中的映射。</p>
<p>&#160; &#160; &#160; &#160;最后，这个函数还会将用来描述要释放的图形缓冲区的private_handle_t结构体所占用的内存释放掉，并且将要要释放的图形缓冲区所在的系统帧缓冲区或者匿名共享内存的文件描述符关闭掉。</p>
<p>&#160; &#160; &#160; &#160;函数terminateBuffer实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">terminateBuffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">private_handle_t</span>* hnd)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;base) &#123;  </span><br><span class="line">        <span class="comment">// this buffer was mapped, unmap it now  </span></span><br><span class="line">        gralloc_unmap(module, hnd);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它通过调用另外一个函数<strong>gralloc_unmap</strong>来解除参数hnd所描述的一个图形缓冲区在当前进程的地址空间中的映射。后面在分析图形缓冲区的注销过程时，我们再详细分析函数gralloc_unmap的实现。</p>
<p>&#160; &#160; &#160; &#160;至此，图形缓冲区的释放过程就分析完成了，接下来我们继续分析图形缓冲区的注册过程。</p>
<h2 id="图形缓冲区的注册过程"><a href="#图形缓冲区的注册过程" class="headerlink" title="图形缓冲区的注册过程"></a>图形缓冲区的注册过程</h2><p>&#160; &#160; &#160; &#160;<strong>前面提到，在Android系统中，所有的图形缓冲区都是由SurfaceFlinger服务分配的，而当一个图形缓冲区被分配的时候，它会同时被映射到请求分配的进程的地址空间去，即分配的过程同时也包含了注册的过程。但是对用户空间的其它的应用程序来说，它们所需要的图形缓冲区是在由SurfaceFlinger服务分配的，因此，当它们得到SurfaceFlinger服务分配的图形缓冲区之后，还需要将这块图形缓冲区映射到自己的地址空间来，以便可以使用这块图形缓冲区。这个映射的过程即为我们接下来要分析的图形缓冲区注册过程</strong>。</p>
<p>&#160; &#160; &#160; &#160;前面还提到，注册图形缓冲区的操作是由Gralloc模块中的函数<strong>gralloc_register_buffer</strong>来实现的，这个函数实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_register_buffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// if this handle was created in this process, then we keep it as is.  </span></span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;pid != getpid()) &#123;  </span><br><span class="line">        <span class="keyword">void</span> *vaddr;  </span><br><span class="line">        err = gralloc_map(module, handle, &amp;vaddr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> err;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数首先验证参数<strong>handle</strong>指向的一块图形缓冲区的确是由Gralloc模块分配的，方法是调用private_handle_t类的静态成员函数validate来验证，即如果参数handle指向的是一个private_handle_t结构体，那么它所指向的一块图形缓冲区就是由Gralloc模块分配的。</p>
<p>&#160; &#160; &#160; &#160;通过了上面的检查之后，函数<strong>gralloc_register_buffer</strong>还需要检查当前进程是否就是请求Gralloc模块分配图形缓冲区hnd的进程。如果是的话，那么当前进程在请求Gralloc模块分配图形缓冲区hnd的时候，就已经将图形缓冲区hnd映射进自己的地址空间来了，因此，这时候就不需要重复在当前进程中注册这个图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;真正执行注册图形缓冲区的操作是由函数<strong>gralloc_map</strong>来实现的，这个函数也是实现文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_map</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle,  </span><br><span class="line">        <span class="keyword">void</span>** vaddr)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    <span class="keyword">if</span> (!(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER)) &#123;  </span><br><span class="line">        <span class="keyword">size_t</span> size = hnd-&gt;size;  </span><br><span class="line">        <span class="keyword">void</span>* mappedAddress = mmap(<span class="number">0</span>, size,  </span><br><span class="line">                PROT_READ|PROT_WRITE, MAP_SHARED, hnd-&gt;fd, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span> (mappedAddress == MAP_FAILED) &#123;  </span><br><span class="line">            LOGE(<span class="string">"Could not mmap %s"</span>, strerror(errno));  </span><br><span class="line">            <span class="keyword">return</span> -errno;  </span><br><span class="line">        &#125;  </span><br><span class="line">        hnd-&gt;base = <span class="keyword">intptr_t</span>(mappedAddress) + hnd-&gt;offset;  </span><br><span class="line">        <span class="comment">//LOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p",  </span></span><br><span class="line">        <span class="comment">//        hnd-&gt;fd, hnd-&gt;offset, hnd-&gt;size, mappedAddress);  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    *vaddr = (<span class="keyword">void</span>*)hnd-&gt;base;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;由于在系统帧缓冲区中分配的图形缓冲区只在SurfaceFlinger服务中使用，而SurfaceFlinger服务在初始化系统帧缓冲区的时候，已经将系统帧缓冲区映射到自己所在的进程中来了，因此，函数gralloc_map如果发现要注册的图形缓冲区是在系统帧缓冲区分配的时候，那么就不需要再执行映射图形缓冲区的操作了。</p>
<p>&#160; &#160; &#160; &#160;如果要注册的图形缓冲区是在内存中分配的，即它的标志值flags的PRIV_FLAGS_FRAMEBUFFER位等于1，那么接下来就需要将它映射到当前进程的地址空间来了。<strong>由于要注册的图形缓冲区是在文件描述符hnd-&gt;fd所描述的一块匿名共享内存中分配的，因此，我们只需要将文件描述符hnd-&gt;fd所描述的一块匿名共享内存映射到当前进程的地址空间来，就可以将参数hnd所描述的一个图形缓冲区映射到当前进程的地址空间来</strong>。</p>
<p>&#160; &#160; &#160; &#160;由于映射文件描述符hnd-&gt;fd得到的是一整块匿名共享内存在当前进程地址空间的基地址，而要注册的图形缓冲区可能只占据这块匿名共享内存的某一小部分，因此，我们还需要将要注册的图形缓冲区的在被映射的匿名共享内存中的偏移量<strong>hnd-&gt;offset</strong>加上被映射的匿名共享内存的基地址<strong>hnd-&gt;base</strong>，才可以得到要注册的图形缓冲区在当前进程中的访问地址，这个地址最终又被写入到<strong>hnd-&gt;base</strong>中去。</p>
<p>&#160; &#160; &#160; &#160;注册图形缓冲区的过程就是这么简单，接下来我们再分析图形缓冲区的注销过程。</p>
<h2 id="图形缓冲区的注销过程"><a href="#图形缓冲区的注销过程" class="headerlink" title="图形缓冲区的注销过程"></a>图形缓冲区的注销过程</h2><p>&#160; &#160; &#160; &#160;图形缓冲区使用完成之后，就需要从当前进程中注销。前面提到，注销图形缓冲区是由Gralloc模块中的函数<strong>gralloc_unregister_buffer</strong>来实现的，这个函数实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_unregister_buffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// never unmap buffers that were created in this process  </span></span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;pid != getpid()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (hnd-&gt;base) &#123;  </span><br><span class="line">            gralloc_unmap(module, handle);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数同样是首先调用private_handle_t类的静态成员函数validate来验证参数handle指向的一块图形缓冲区的确是由Gralloc模块分配的，接着再将将参数handle指向的一块图形缓冲区转换为一个private_handle_t结构体hnd来访问。</p>
<p>&#160; &#160; &#160; &#160;一块图形缓冲区只有被注册过，即被Gralloc模块中的函数gralloc_register_buffer注册过，才需要注销，而由函数gralloc_register_buffer注册的图形缓冲区都不是由当前进程分配的，因此，当前进程在注销一个图形缓冲区的时候，会检查要注销的图形缓冲区是否是由自己分配的。如果是由自己分配的话，那么它什么也不做就返回了。</p>
<p>&#160; &#160; &#160; &#160;假设要注销的图形缓冲区hnd不是由当前进程分配的，那么接下来就会调用另外一个函数<strong>galloc_unmap</strong>来注销图形缓冲区hnd。函数galloc_unmap也是实现在文件hardware/libhardware/modules/gralloc/mapper.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_unmap</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    <span class="keyword">if</span> (!(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER)) &#123;  </span><br><span class="line">        <span class="keyword">void</span>* base = (<span class="keyword">void</span>*)hnd-&gt;base;  </span><br><span class="line">        <span class="keyword">size_t</span> size = hnd-&gt;size;  </span><br><span class="line">        <span class="comment">//LOGD("unmapping from %p, size=%d", base, size);  </span></span><br><span class="line">        <span class="keyword">if</span> (munmap(base, size) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            LOGE(<span class="string">"Could not unmap %s"</span>, strerror(errno));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    hnd-&gt;base = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个函数的实现与前面所分析的函数gralloc_map的实现是类似的，只不过它执行的是相反的操作，即将解除一个指定的图形缓冲区在当前进程的地址空间中的映射，从而完成对这个图形缓冲区的注销工作。</p>
<p>&#160; &#160; &#160; &#160;这样，图形缓冲区的注销过程就分析完成了，接下来我们再继续分析一个图形缓冲区是如何被渲染到系统帧缓冲区去的，即它的内容是如何绘制在设备显示屏中的。</p>
<h2 id="图形缓冲区的渲染过程"><a href="#图形缓冲区的渲染过程" class="headerlink" title="图形缓冲区的渲染过程"></a>图形缓冲区的渲染过程</h2><p>&#160; &#160; &#160; &#160;用户空间的应用程序将画面内容写入到图形缓冲区中去之后，还需要将图形缓冲区渲染到系统帧缓冲区中去，这样才可以把画面绘制到设备显示屏中去。前面提到，渲染图形缓冲区是由Gralloc模块中的函数<strong>fb_post</strong>来实现的，这个函数实现在文件hardware/libhardware/modules/gralloc/framebuffer.cpp中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fb_post</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(buffer) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">fb_context_t</span>* ctx = (<span class="keyword">fb_context_t</span>*)dev;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private_handle_t</span> <span class="keyword">const</span>* hnd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_handle_t</span> <span class="keyword">const</span>*&gt;(buffer);  </span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(  </span><br><span class="line">            dev-&gt;common.module);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> offset = hnd-&gt;base - m-&gt;framebuffer-&gt;base;  </span><br><span class="line">        m-&gt;info.activate = FB_ACTIVATE_VBL;  </span><br><span class="line">        m-&gt;info.yoffset = offset / m-&gt;finfo.line_length;  </span><br><span class="line">        <span class="keyword">if</span> (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPUT_VSCREENINFO, &amp;m-&gt;info) == <span class="number">-1</span>) &#123;  </span><br><span class="line">            LOGE(<span class="string">"FBIOPUT_VSCREENINFO failed"</span>);  </span><br><span class="line">            m-&gt;base.unlock(&amp;m-&gt;base, buffer);  </span><br><span class="line">            <span class="keyword">return</span> -errno;  </span><br><span class="line">        &#125;  </span><br><span class="line">        m-&gt;currentBuffer = buffer;  </span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// If we can't do the page_flip, just copy the buffer to the front   </span></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> use copybit HAL instead of memcpy  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">void</span>* fb_vaddr;  </span><br><span class="line">        <span class="keyword">void</span>* buffer_vaddr;  </span><br><span class="line">  </span><br><span class="line">        m-&gt;base.lock(&amp;m-&gt;base, m-&gt;framebuffer,  </span><br><span class="line">                GRALLOC_USAGE_SW_WRITE_RARELY,  </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, m-&gt;info.xres, m-&gt;info.yres,  </span><br><span class="line">                &amp;fb_vaddr);  </span><br><span class="line">  </span><br><span class="line">        m-&gt;base.lock(&amp;m-&gt;base, buffer,  </span><br><span class="line">                GRALLOC_USAGE_SW_READ_RARELY,  </span><br><span class="line">                <span class="number">0</span>, <span class="number">0</span>, m-&gt;info.xres, m-&gt;info.yres,  </span><br><span class="line">                &amp;buffer_vaddr);  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">memcpy</span>(fb_vaddr, buffer_vaddr, m-&gt;finfo.line_length * m-&gt;info.yres);  </span><br><span class="line">  </span><br><span class="line">        m-&gt;base.unlock(&amp;m-&gt;base, buffer);  </span><br><span class="line">        m-&gt;base.unlock(&amp;m-&gt;base, m-&gt;framebuffer);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1）参数buffer用来描述要渲染的图形缓冲区，它指向的必须要是一个private_handle_t结构体，这是通过调用private_handle_t类的静态成员函数validate来验证的。验证通过之后，就可以将参数buffer所描述的一个buffer_handle_t结构体转换成一个private_handle_t结构体hnd。</p>
<p>&#160; &#160; &#160; &#160;参数<strong>*dev</strong>用来描述在Gralloc模块中的一个fb设备。从前面的内容可以知道，在打开fb设备的时候，Gralloc模块返回给调用者的实际上是一个fb_context_t结构体，因此，这里就可以将参数dev所描述的一个framebuffer_device_t结构体转换成一个<strong>fb_context_t</strong>结构体ctx。</p>
<p>&#160; &#160; &#160; &#160;参数dev的成员变量<strong>common</strong>指向了一个<strong>hw_device_t</strong>结构体，这个结构体的成员变量<strong>module</strong>指向了一个Gralloc模块。从前面的内容可以知道，一个Gralloc模块是使用一个<strong>private_module_t</strong>结构体来描述的，因此，我们可以将<strong>dev-&gt;common.moudle</strong>转换成一个private_module_t结构体m。</p>
<p>&#160; &#160; &#160; &#160;2）由于private_handle_t结构体hnd所描述的图形缓冲区可能是在系统帧缓冲区分配的，也有可能是内存中分配的，因此，我们分两种情况来讨论图形缓冲区渲染过程。</p>
<p>&#160; &#160; &#160; &#160;当private_handle_t结构体hnd所描述的图形缓冲区是在系统帧缓冲区中分配的时候，即这个图形缓冲区的标志值flags的PRIV_FLAGS_FRAMEBUFFER位等于1的时候，我们是不需要将图形缓冲区的内容拷贝到系统帧缓冲区去的，因为我们将内容写入到图形缓冲区的时候，已经相当于是将内容写入到了系统帧缓冲区中去了。虽然在这种情况下，我们不需要将图形缓冲区的内容拷贝到系统帧缓冲区去，但是我们需要告诉系统帧缓冲区设备将要渲染的图形缓冲区作为系统当前的输出图形缓冲区，这样才可以将要渲染的图形缓冲区的内容绘制到设备显示屏来。例如，假设系统帧缓冲区有2个图形缓冲区，当前是以第1个图形缓冲区作为输出图形缓冲区的，这时候如果我们需要渲染第2个图形缓冲区，那么就必须告诉系统帧绘冲区设备，将第2个图形缓冲区作为输出图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;设置系统帧缓冲区的当前输出图形缓冲区是通过IO控制命令FBIOPUT_VSCREENINFO来进行的。IO控制命令FBIOPUT_VSCREENINFO需要一个fb_var_screeninfo结构体作为参数。从前面的内容可以知道，private_module_t结构体m的成员变量<strong>info</strong>正好保存在我们所需要的这个fb_var_screeninfo结构体。有了个m-&gt;info这个fb_var_screeninfo结构体之后，我们只需要设置好它的成员变量<strong>yoffset</strong>的值（不用设置成员变量<strong>xoffset</strong>的值是因为所有的图形缓冲区的宽度是相等的），就可以将要渲染的图形缓冲区设置为系统帧缓冲区的当前输出图形缓冲区。fb_var_screeninfo结构体的成员变量<strong>yoffset</strong>保存的是当前输出图形缓冲区在整个系统帧缓冲区的纵向偏移量，即Y偏移量。我们只需要将要渲染的图形缓冲区的开始地址<strong>hnd-&gt;base</strong>的值减去系统帧缓冲区的基地址<strong>m-&gt;framebuffer-&gt;base</strong>的值，再除以图形缓冲区一行所占据的字节数<strong>m-&gt;finfo.line_length</strong>，就可以得到所需要的Y偏移量。</p>
<p>&#160; &#160; &#160; &#160;在执行IO控制命令FBIOPUT_VSCREENINFO之前，还会将作为参数的fb_var_screeninfo结构体的成员变量<strong>activate</strong>的值设置<strong>FB_ACTIVATE_VBL</strong>，表示要等到下一个垂直同步事件出现时，再将当前要渲染的图形缓冲区的内容绘制出来。这样做的目的是避免出现屏幕闪烁，即避免前后两个图形缓冲区的内容各有一部分同时出现屏幕中。</p>
<p>&#160; &#160; &#160; &#160;成功地执行完成IO控制命令FBIOPUT_VSCREENINFO之后，函数还会将当前被渲染的图形缓冲区保存在private_module_t结构体m的成员变量<strong>currentBuffer</strong>中，以便可以记录当前被渲染的图形缓冲区是哪一个。</p>
<p>&#160; &#160; &#160; &#160;当private_handle_t结构体hnd所描述的图形缓冲区是在内存中分配的时候，即这个图形缓冲区的标志值flags的PRIV_FLAGS_FRAMEBUFFER位等于0的时候，我们就需要将它的内容拷贝到系统帧缓冲区中去了。这个拷贝的工作是通过调用函数<strong>memcpy</strong>来完成的。在拷贝之前，我们需要<strong>三个参数</strong>。第一个参数是要渲染的图形缓冲区的起址地址，这个地址保存在参数<strong>buffer</strong>所指向的一个private_handle_t结构体中。第二个参数是要系统帧缓冲区的基地址，这个地址保存在private_module_t结构体m的成员变量framebuffer所指向的一个private_handle_t结构体中。第三个参数是要拷贝的内容的大小，这个大小就刚好是一个屏幕像素所占据的内存的大小。屏幕高度由m-&gt;info.yres来描述，而一行屏幕像素所占用的字节数由m-&gt;finfo.line_length来描述，将这两者相乘，就可以得到一个屏幕像素所占据的内存的大小。</p>
<p>&#160; &#160; &#160; &#160;3）在将一块内存缓冲区的内容拷贝到系统帧缓冲区中去之前，需要对这两块缓冲区进行锁定，以保证在拷贝的过程中，这两块缓冲区的内容不会被修改。这个锁定的工作是由Gralloc模块中的函数<strong>gralloc_lock</strong>来实现的。从前面第1部分的内容可以知道，Gralloc模块中的函数gralloc_lock的地址正好就保存在private_module_t结构体m的成员变量base所描述的一个gralloc_module_t结构体的成员函数lock中。</p>
<p>&#160; &#160; &#160; &#160;在调用函数gralloc_lock来锁定一块缓冲区之后，还可以通过最后一个输出参数来获得被锁定的缓冲区的开始地址，因此，通过调用函数gralloc_lock来锁定要渲染的图形缓冲区以及系统帧缓冲区，就可以得到前面所需要的第一个和第二个参数。</p>
<p>&#160; &#160; &#160; &#160;将要渲染的图形缓冲区的内容拷贝到系统帧缓冲区之后，就可以解除前面对它们的锁定了，这个解锁的工作是由Gralloc模块中的函数<strong>gralloc_unlock</strong>来实现的。从前面第1部分的内容可以知道，Gralloc模块中的函数gralloc_unlock的地址正好就保存在private_module_t结构体m的成员变量base所描述的一个gralloc_module_t结构体的成员函数unlock中。</p>
<p>&#160; &#160; &#160; &#160;这样，一个图形缓冲区的渲染过程就分析完成了。</p>
<h3 id="图形缓冲区的锁定和解锁"><a href="#图形缓冲区的锁定和解锁" class="headerlink" title="图形缓冲区的锁定和解锁"></a>图形缓冲区的锁定和解锁</h3><p>&#160; &#160; &#160; &#160;为了完整性起见，最后我们再简要分析函数gralloc_lock和gralloc_unlock的实现，以便可以了解一个图形缓冲区的锁定和解锁操作是如何实现的。</p>
<p>&#160; &#160; &#160; &#160;1）图形缓冲区的锁定：<br>&#160; &#160; &#160; &#160;函数gralloc_lock实现在文件hardware/libhardware/modules/gralloc/mapper.cpp文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_lock</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle, <span class="keyword">int</span> usage,  </span><br><span class="line">        <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> h,  </span><br><span class="line">        <span class="keyword">void</span>** vaddr)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="comment">// this is called when a buffer is being locked for software  </span></span><br><span class="line">    <span class="comment">// access. in thin implementation we have nothing to do since  </span></span><br><span class="line">    <span class="comment">// not synchronization with the h/w is needed.  </span></span><br><span class="line">    <span class="comment">// typically this is used to wait for the h/w to finish with  </span></span><br><span class="line">    <span class="comment">// this buffer if relevant. the data cache may need to be  </span></span><br><span class="line">    <span class="comment">// flushed or invalidated depending on the usage bits and the  </span></span><br><span class="line">    <span class="comment">// hardware.  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;  </span><br><span class="line">    *vaddr = (<span class="keyword">void</span>*)hnd-&gt;base;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从这里可以看出，函数gralloc_lock其实并没有执行锁定参数handle所描述的一个缓冲区的操作，它只简单地将要锁定的缓冲区的开始地址返回给调用者。</p>
<p>&#160; &#160; &#160; &#160;理论上来说，函数gralloc_lock应该检查参数handle所描述的一个缓冲区是否正在被其进程或者线程使用。如果是的话，那么函数gralloc_lock就必须要等待，直到要锁定的缓冲区被其它进程或者线程使用结束为止，以便接下来可以独占它。由于函数gralloc_lock实际上并没有作这些操作，<strong>因此，就必须要由调用者来保证要锁定的缓冲区当前是没有被其它进程或者线程使用的</strong>。</p>
<p>&#160; &#160; &#160; &#160;2）图形缓冲区的解锁：<br>&#160; &#160; &#160; &#160;函数gralloc_unlock也是实现在文件hardware/libhardware/modules/gralloc/mapper.cpp文件中，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_unlock</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* module,  </span><br><span class="line">        <span class="keyword">buffer_handle_t</span> handle)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="comment">// we're done with a software buffer. nothing to do in this  </span></span><br><span class="line">    <span class="comment">// implementation. typically this is used to flush the data cache.  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(handle) &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;函数gralloc_unlock执行的操作本来是刚好与函数gralloc_lock相反的，但是由于函数gralloc_lock并没有真实地锁定参数handle所描述的一个缓冲区的，因此，函数gralloc_unlock是不需要执行实际的解锁工作的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;至此，我们就分析完成Android帧缓冲区硬件抽象层模块Gralloc的实现原理了。从分析的过程可以知道，为了在屏幕中绘制一个指定的画面，我们需要：</p>
<ol>
<li>分配一个匹配屏幕大小的图形缓冲区</li>
<li>将分配好的图形缓冲区注册（映射）到当前进程的地址空间来</li>
<li>将要绘制的画面的内容写入到已经注册好的图形缓冲区中去，并且渲染（拷贝）到系统帧缓冲区中去<br>&#160; &#160; &#160; &#160;为了实现以上三个操作，我们还需要：</li>
<li>加载Gralloc模块</li>
<li>打开Gralloc模块中的gralloc设备和fb设备</li>
</ol>
<p>&#160; &#160; &#160; &#160;其中，gralloc设备负责分配图形缓冲区，Gralloc模块负责注册图形缓冲区，而fb设备负责渲染图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;这个系列内容还是太多了，我估计坚持不了多久。。。。。另外，求HR或者大神带我入坑，妹子图敬上~<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%80%29----Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/meizi.jpg" alt="妹子"></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2017/03/12/Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现/">Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现</a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage">windrunnerlihuan</a></p>
        <p><span>Created:</span>2017-03-12, 20:10:11</p>
        <p><span>Updated:</span>2017-03-13, 23:51:37</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2017/03/12/Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现/" title="Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现">http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现/</a>
            <span class="copy-path" data-clipboard-text="From http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现/　　By windrunnerlihuan" title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/04/28/Android性能优化之内存优化实战/">
                    Android性能优化之内存优化实战
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/01/13/Android多媒体开发-九-Video-Buffer传输与Audio-Playback流程/">
                    Android多媒体开发(九)----Video Buffer传输与Audio Playback流程
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#下载内核代码-准备工作"><span class="toc-number">1.</span> <span class="toc-text">下载内核代码(准备工作)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#更换hosts文件"><span class="toc-number">1.1.</span> <span class="toc-text">更换hosts文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下载kernel代码"><span class="toc-number">1.2.</span> <span class="toc-text">下载kernel代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初识Gralloc模块"><span class="toc-number">2.</span> <span class="toc-text">初识Gralloc模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Gralloc模块简介"><span class="toc-number">2.1.</span> <span class="toc-text">Gralloc模块简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码结构"><span class="toc-number">2.2.</span> <span class="toc-text">代码结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#功能分析"><span class="toc-number">3.</span> <span class="toc-text">功能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Gralloc模块的加载过程"><span class="toc-number">3.1.</span> <span class="toc-text">Gralloc模块的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查询对应动态库"><span class="toc-number">3.1.1.</span> <span class="toc-text">查询对应动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加载对应动态库"><span class="toc-number">3.1.2.</span> <span class="toc-text">加载对应动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构定义"><span class="toc-number">3.1.3.</span> <span class="toc-text">数据结构定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gralloc设备的打开过程"><span class="toc-number">3.2.</span> <span class="toc-text">Gralloc设备的打开过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fb设备的打开过程"><span class="toc-number">3.3.</span> <span class="toc-text">fb设备的打开过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#映射内存过程"><span class="toc-number">3.3.1.</span> <span class="toc-text">映射内存过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分配图形缓冲区"><span class="toc-number">3.4.</span> <span class="toc-text">分配图形缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统帧缓冲区中分配图形缓冲区"><span class="toc-number">3.4.1.</span> <span class="toc-text">系统帧缓冲区中分配图形缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存中分配图形缓冲区"><span class="toc-number">3.4.2.</span> <span class="toc-text">内存中分配图形缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图形缓冲区的释放过程"><span class="toc-number">3.5.</span> <span class="toc-text">图形缓冲区的释放过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图形缓冲区的注册过程"><span class="toc-number">3.6.</span> <span class="toc-text">图形缓冲区的注册过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图形缓冲区的注销过程"><span class="toc-number">3.7.</span> <span class="toc-text">图形缓冲区的注销过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图形缓冲区的渲染过程"><span class="toc-number">3.8.</span> <span class="toc-text">图形缓冲区的渲染过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图形缓冲区的锁定和解锁"><span class="toc-number">3.8.1.</span> <span class="toc-text">图形缓冲区的锁定和解锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="Hide"  title="Show or Hide Table of Contents">
<script>
    var valueHide = "Hide";
    var valueShow = "Show";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现　| April is your lie　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/04/28/Android性能优化之内存优化实战/" title="Pre: Android性能优化之内存优化实战">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/01/13/Android多媒体开发-九-Video-Buffer传输与Audio-Playback流程/" title="Next: Android多媒体开发(九)----Video Buffer传输与Audio Playback流程">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/28/Android性能优化之内存优化实战/">Android性能优化之内存优化实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/12/Android-SurfaceFlinger-学习之路-一-Android图形显示之HAL层Gralloc模块实现/">Android SurfaceFlinger 学习之路(一)----Android图形显示之HAL层Gralloc模块实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/13/Android多媒体开发-九-Video-Buffer传输与Audio-Playback流程/">Android多媒体开发(九)----Video Buffer传输与Audio Playback流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/06/Android多媒体开发-八-播放流程/">Android多媒体开发(八)----播放流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/29/Android多媒体开发-七-Android中OpenMax的实现/">Android多媒体开发(七)----Android中OpenMax的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/">Android多媒体开发(六)----Android中OpenMax的实现(preview)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/15/Android多媒体开发-五-OpenMax简介/">Android多媒体开发(五)----OpenMax简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/Android多媒体开发-四-AwesomePlayer数据源处理/">Android多媒体开发(四)----AwesomePlayer数据源处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/11/Android多媒体开发-三-从StageFright到AwesomePlayer/">Android多媒体开发(三)----从StageFright到AwesomePlayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/30/Android多媒体开发-二-MediaPlayer的C-S架构以及C-层调用步骤/">Android多媒体开发(二)----MediaPlayer的C/S架构以及C++层调用步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/Android多媒体开发-一-MediaPlayer框架开始/">Android多媒体开发(一)----MediaPlayer框架开始</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/31/JAVA线程池简单分析/">JAVA线程池简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/Android壁纸开发流程分析/">Android壁纸开发流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/18/如何实现1080P延迟低于500ms的实时超清直播传输技术/">如何实现1080P延迟低于500ms的实时超清直播传输技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/插件开发中的资源问题分析及填坑处理/">插件开发中的资源问题分析及填坑处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/智能指针简单分析/">智能指针简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/31/Android消息机制零散分析/">Android消息处理零散分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/12/浅析Bitmap占据内存大小/">浅析Bitmap占据内存大小</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/DanmakuFlameMaster简单分析/">弹幕框架DanmakuFlameMaster简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/24/Android属性动画原理分析/">Android属性动画流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/Binder简要分析/">Android跨进程通信机制Binder简要分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/移动直播技术秒开优化经验/">移动直播技术秒开优化经验</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/27/博客搭建历程/">博客搭建历程————————Github和Hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/27/新的开始/">新的开始</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 windrunnerlihuan
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.0">Yelee</a> by HuanLi & MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >Site Visitors: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">Page Hits: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>