<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="3Gndr5oonivG3ajghQU1MgL0IHoMHT4esMsPKjnbeis" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="SurfaceFlinger," />





  <link rel="alternate" href="/atom.xml" title="April is your lie" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;VSync信号的科普我们上一篇已经介绍过了，这篇我们要分析在SurfaceFlinger中的作用。（愈发觉得做笔记对自己记忆模块巩固有很多帮助，整理文章不一定是用来给别人看的，但一定是为加强自己记忆的~）">
<meta property="og:type" content="article">
<meta property="og:title" content="Android SurfaceFlinger 学习之路(五)----VSync 工作原理">
<meta property="og:url" content="http://windrunnerlihuan.com/2017/05/25/Android-SurfaceFlinger-学习之路-五-VSync-工作原理/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;VSync信号的科普我们上一篇已经介绍过了，这篇我们要分析在SurfaceFlinger中的作用。（愈发觉得做笔记对自己记忆模块巩固有很多帮助，整理文章不一定是用来给别人看的，但一定是为加强自己记忆的~）">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/systrace1.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/pipeline.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/phase.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/vsyncmake.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/vsyncall.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/vsyncsf.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/phasecatch.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/Connection.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/ConnectionTube.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/vsyncmake.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/updatemodel.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/big.jpg">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/app.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/sf.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/meizi.jpg">
<meta property="og:updated_time" content="2017-06-01T19:21:36.848Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android SurfaceFlinger 学习之路(五)----VSync 工作原理">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;VSync信号的科普我们上一篇已经介绍过了，这篇我们要分析在SurfaceFlinger中的作用。（愈发觉得做笔记对自己记忆模块巩固有很多帮助，整理文章不一定是用来给别人看的，但一定是为加强自己记忆的~）">
<meta name="twitter:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/systrace1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://windrunnerlihuan.com/2017/05/25/Android-SurfaceFlinger-学习之路-五-VSync-工作原理/"/>





  <title>Android SurfaceFlinger 学习之路(五)----VSync 工作原理 | April is your lie</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-100464707-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bb4df6db80a16ce54c1fb2c6e1767e18";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=62459705";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500465801");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>




  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1262111741&web_id=1262111741" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">April is your lie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">四月是你的谎言</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://windrunnerlihuan.com/2017/05/25/Android-SurfaceFlinger-学习之路-五-VSync-工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="windrunnerlihuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="April is your lie">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Android SurfaceFlinger 学习之路(五)----VSync 工作原理</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T16:27:02+08:00">
                2017-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android技术点/" itemprop="url" rel="index">
                    <span itemprop="name">Android技术点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2017/05/25/Android-SurfaceFlinger-学习之路-五-VSync-工作原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/05/25/Android-SurfaceFlinger-学习之路-五-VSync-工作原理/" class="leancloud_visitors" data-flag-title="Android SurfaceFlinger 学习之路(五)----VSync 工作原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&#160; &#160; &#160; &#160;VSync信号的科普我们上一篇已经介绍过了，这篇我们要分析在SurfaceFlinger中的作用。（愈发觉得做笔记对自己记忆模块巩固有很多帮助，整理文章不一定是用来给别人看的，但一定是为加强自己记忆的~）<br><a id="more"></a></p>
<h1 id="流程基础"><a href="#流程基础" class="headerlink" title="流程基础"></a>流程基础</h1><p>&#160; &#160; &#160; &#160;从上一篇得知，Android 4.1一个很大的更新是Project Butter，黄油计划，为了解决用户交互体验差的问题(Jelly Bean is crazy fast)。Project Butter对Android Display系统进行了重构，引入了三个核心元素，即VSYNC、Triple Buffer和Choreographer。</p>
<h2 id="硬件加载"><a href="#硬件加载" class="headerlink" title="硬件加载"></a>硬件加载</h2><p>&#160; &#160; &#160; &#160;上上一节我们初略分析了SurfaceFlinger的启动流程，从SurfaceFlinger类的初始化流程得知，其init方法初始化了很多参数。我们分析Vsync流程需要这些信息，位于frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp中。</p>
<h3 id="显示设备"><a href="#显示设备" class="headerlink" title="显示设备"></a>显示设备</h3><p>&#160; &#160; &#160; &#160;SurfaceFlinger中需要显示的图层（layer）将通过DisplayDevice对象传递到OpenGLES中进行合成，合成之后的图像再通过HWComposer对象传递到Framebuffer中显示。DisplayDevice对象中的成员变量mVisibleLayersSortedByZ保存了所有需要显示在本显示设备中显示的Layer对象，同时DisplayDevice对象也保存了和显示设备相关的显示方向、显示区域坐标等信息。</p>
<p>&#160; &#160; &#160; &#160;DisplayDevice是显示设备的抽象，定义了3中类型的显示设备。引用枚举类位于frameworks/native/services/surfaceflinger/DisplayDevice.h中，定义枚举位于hardware/libhardware/include/hardware/Hwcomposer_defs.h中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//DisplayDevice.h</span></span><br><span class="line">    <span class="keyword">enum</span> DisplayType &#123;</span><br><span class="line">        DISPLAY_ID_INVALID = <span class="number">-1</span>,</span><br><span class="line">        DISPLAY_PRIMARY     = HWC_DISPLAY_PRIMARY,</span><br><span class="line">        DISPLAY_EXTERNAL    = HWC_DISPLAY_EXTERNAL,</span><br><span class="line">        DISPLAY_VIRTUAL     = HWC_DISPLAY_VIRTUAL,</span><br><span class="line">        NUM_BUILTIN_DISPLAY_TYPES = HWC_NUM_PHYSICAL_DISPLAY_TYPES,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Hwcomposer_defs.h</span></span><br><span class="line">    <span class="comment">/* Display types and associated mask bits. */</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">    HWC_DISPLAY_PRIMARY     = <span class="number">0</span>,</span><br><span class="line">    HWC_DISPLAY_EXTERNAL    = <span class="number">1</span>,    <span class="comment">// HDMI, DP, etc.</span></span><br><span class="line">    HWC_DISPLAY_VIRTUAL     = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    HWC_NUM_PHYSICAL_DISPLAY_TYPES = <span class="number">2</span>,</span><br><span class="line">    HWC_NUM_DISPLAY_TYPES          = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>DISPLAY_PRIMARY：主显示设备，通常是LCD屏</li>
<li>DISPLAY_EXTERNAL：扩展显示设备。通过HDMI输出的显示信号</li>
<li>DISPLAY_VIRTUAL：虚拟显示设备，通过WIFI输出信号</li>
</ul>
<p>&#160; &#160; &#160; &#160;这三种设备，第一种就是我们手机、电视的主显示屏，另外两种需要硬件扩展。</p>
<p>&#160; &#160; &#160; &#160;初始化显示设备模块位于SurfaceFlinger中的init函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">   </span><br><span class="line">    ......</span><br><span class="line">    //初始化HWComposer硬件设备，我们下面会讲到</span><br><span class="line">    // actual hardware composer underneath.</span><br><span class="line">    mHwc = new HWComposer(this,</span><br><span class="line">            *static_cast&lt;HWComposer::EventHandler *&gt;(this));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //初始化物理显示设备</span><br><span class="line">    // initialize our non-virtual displays</span><br><span class="line">    //物理设备类型总数为2</span><br><span class="line">    for (size_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        // set-up the displays that are already connected</span><br><span class="line">        //先调用了HWComposer的isConnected来检查显示设备是否已连接，</span><br><span class="line">        //只有和显示设备连接的DisplayDevice对象才会被创建出来。</span><br><span class="line">        //即使没有任何物理显示设备被检测到，</span><br><span class="line">        //SurfaceFlinger都需要一个DisplayDevice对象才能正常工作，</span><br><span class="line">        //因此，DISPLAY_PRIMARY类型的DisplayDevice对象总是会被创建出来。</span><br><span class="line">        if (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            // All non-virtual displays are currently considered secure.</span><br><span class="line">            bool isSecure = true;</span><br><span class="line">            ////给显示设备分配一个token,一般都是一个binder</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token = mBuiltinDisplays[i];</span><br><span class="line">            //然后会调用createBufferQueue函数创建一个producer和consumer</span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">            sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                    new GraphicBufferAlloc());</span><br><span class="line">            //然后又创建了一个FramebufferSurface对象，把consumer参数传入代表是一个消费者。</span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs = new FramebufferSurface(*mHwc, i,</span><br><span class="line">                    consumer);</span><br><span class="line">            int32_t hwcId = allocateHwcDisplayId(type);</span><br><span class="line">            //创建DisplayDevice对象，代表一类显示设备</span><br><span class="line">            sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this,</span><br><span class="line">                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                    fbs, producer,</span><br><span class="line">                    mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">            //如果不是主屏幕        </span><br><span class="line">            if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                // FIXME: currently we don't get blank/unblank requests</span><br><span class="line">                // for displays other than the main display, so we always</span><br><span class="line">                // assume a connected display is unblanked.</span><br><span class="line">                ALOGD("marking display %zu as acquired/unblanked", i);</span><br><span class="line">                //通常我们不会在次屏幕获得熄灭/点亮LCD的请求，</span><br><span class="line">                //所以我们总是认为次显屏是点亮的</span><br><span class="line"></span><br><span class="line">                //设置PowerMode为HWC_POWER_MODE_NORMAL</span><br><span class="line">                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述过程就是初始化显示设备，我们分部查看。</p>
<p>&#160; &#160; &#160; &#160;1）检查设备连接：<br>&#160; &#160; &#160; &#160;所有显示设备的输出都要通过HWComposer对象完成，因此上面这段代码先调用了HWComposer的isConnected来检查显示设备是否已连接，只有和显示设备连接的DisplayDevice对象才会被创建出来。即使没有任何物理显示设备被检测到，SurfaceFlinger都需要一个DisplayDevice对象才能正常工作，因此，DISPLAY_PRIMARY类型的DisplayDevice对象总是会被创建出来。</p>
<p>&#160; &#160; &#160; &#160;createBuiltinDisplayLocked函数就是为显示设备对象创建一个BBinder类型的Token：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::createBuiltinDisplayLocked(DisplayDevice::DisplayType type) &#123;</span><br><span class="line">    ALOGW_IF(mBuiltinDisplays[type],</span><br><span class="line">            <span class="string">"Overwriting display token for display type %d"</span>, type);</span><br><span class="line">    <span class="comment">//一般这种token之类的东西，都是一个binder</span></span><br><span class="line">    mBuiltinDisplays[type] = <span class="keyword">new</span> BBinder();</span><br><span class="line">    <span class="function">DisplayDeviceState <span class="title">info</span><span class="params">(type)</span></span>;</span><br><span class="line">    <span class="comment">// All non-virtual displays are currently considered secure.</span></span><br><span class="line">    info.isSecure = <span class="literal">true</span>;</span><br><span class="line">    mCurrentState.displays.add(mBuiltinDisplays[type], info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;一般这种token之类的东西，都是一个binder，就像我们创建window需要一个token，也是new一个binder然后在WindowManagerService里注册。</p>
<p>&#160; &#160; &#160; &#160;2）初始化GraphicBuffer相关内容：（这一部分我们后续分析GraphicBuffer管理相关会仔细分析它，这里只是粗略介绍）<br>&#160; &#160; &#160; &#160;然后会调用createBufferQueue函数创建一个producer和consumer。<strong>然后又创建了一个FramebufferSurface对象。这里我们看到在新建FramebufferSurface对象时把consumer参数传入了代表是一个消费者。</strong><br>&#160; &#160; &#160; &#160;<strong>而在DisplayDevice的构造函数中（下面会讲到），会创建一个Surface对象传递给底层的OpenGL ES使用，而这个Surface是一个生产者。在OpenGl ES中合成好了图像之后会将图像数据写到Surface对象中，这将触发consumer对象的onFrameAvailable函数被调用。</strong><br>&#160; &#160; &#160; &#160;这就是Surface数据好了就通知消费者来拿数据做显示用，<strong>在onFrameAvailable函数汇总，通过nextBuffer获得图像数据，然后调用HWComposer对象mHwc的fbPost函数输出。</strong></p>
<p>&#160; &#160; &#160; &#160;FramebufferSurface类位于frameworks/native/services/surfaceflinger/displayhardware/FramebufferSurface.cpp中，我们查看它的的onFrameAvailable函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overrides ConsumerBase::onFrameAvailable(), does not call base class impl.</span></span><br><span class="line"><span class="keyword">void</span> FramebufferSurface::onFrameAvailable() &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    <span class="comment">//通过nextBuffer获得图像数据</span></span><br><span class="line">    <span class="keyword">status_t</span> err = nextBuffer(buf, acquireFence);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error latching nnext FramebufferSurface buffer: %s (%d)"</span>,</span><br><span class="line">                strerror(-err), err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用HWComposer的fbPost函数输出图像，fbPost函数最后通过调用Gralloc模块的post函数来输出图像</span></span><br><span class="line">    err = mHwc.fbPost(mDisplayType, acquireFence, buf);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error posting framebuffer: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个流程我们下几节会仔细分析，这里我们粗略过个流程：<br>&#160; &#160; &#160; &#160;通过nextBuffer获得图像数据；<br>&#160; &#160; &#160; &#160;然后调用HWComposer对象mHwc的fbPost函数输出，fbPost函数最后通过调用Gralloc模块的post函数来输出图像。这一部分我们在<a href="http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%B8%80-Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/">Android SurfaceFlinger 学习之路(一)—-Android图形显示之HAL层Gralloc模块实现</a>分析过了，可以查看这个链接。</p>
<p>&#160; &#160; &#160; &#160;3）创建DisplayDevice对象，用来描述显示设备：<br>&#160; &#160; &#160; &#160;我们再来看看DisplayDevice的构造函数，位于frameworks/native/services/surfaceflinger/DisplayDevice.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Initialize the display to the specified values.</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">DisplayDevice::DisplayDevice(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        DisplayType type,</span><br><span class="line">        <span class="keyword">int32_t</span> hwcId,</span><br><span class="line">        <span class="keyword">int</span> format,</span><br><span class="line">        <span class="keyword">bool</span> isSecure,</span><br><span class="line">        <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; displayToken,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DisplaySurface&gt;&amp; displaySurface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; producer,</span><br><span class="line">        EGLConfig config)</span><br><span class="line">    : lastCompositionHadVisibleLayers(<span class="literal">false</span>),</span><br><span class="line">      mFlinger(flinger),</span><br><span class="line">      mType(type), mHwcDisplayId(hwcId),</span><br><span class="line">      mDisplayToken(displayToken),</span><br><span class="line">      mDisplaySurface(displaySurface),</span><br><span class="line">      mDisplay(EGL_NO_DISPLAY),</span><br><span class="line">      mSurface(EGL_NO_SURFACE),</span><br><span class="line">      mDisplayWidth(), mDisplayHeight(), mFormat(),</span><br><span class="line">      mFlags(),</span><br><span class="line">      mPageFlipCount(),</span><br><span class="line">      mIsSecure(isSecure),</span><br><span class="line">      mSecureLayerVisible(<span class="literal">false</span>),</span><br><span class="line">      mLayerStack(NO_LAYER_STACK),</span><br><span class="line">      mOrientation(),</span><br><span class="line">      mPowerMode(HWC_POWER_MODE_OFF),</span><br><span class="line">      mActiveConfig(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建surface，传递给底层的OpenGL ES使用，而这个Surface是一个生产者</span></span><br><span class="line">    mNativeWindow = <span class="keyword">new</span> Surface(producer, <span class="literal">false</span>);</span><br><span class="line">    ANativeWindow* <span class="keyword">const</span> window = mNativeWindow.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Create our display's surface</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//在OpenGl ES中合成好了图像之后会将图像数据写到Surface对象中</span></span><br><span class="line">    EGLSurface surface;</span><br><span class="line">    EGLint w, h;</span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="keyword">if</span> (config == EGL_NO_CONFIG) &#123;</span><br><span class="line">        config = RenderEngine::chooseEglConfig(display, format);</span><br><span class="line">    &#125;</span><br><span class="line">    surface = eglCreateWindowSurface(display, config, window, <span class="literal">NULL</span>);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_WIDTH,  &amp;mDisplayWidth);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;mDisplayHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that composition can never be stalled by a virtual display</span></span><br><span class="line">    <span class="comment">// consumer that isn't processing buffers fast enough. We have to do this</span></span><br><span class="line">    <span class="comment">// in two places:</span></span><br><span class="line">    <span class="comment">// * Here, in case the display is composed entirely by HWC.</span></span><br><span class="line">    <span class="comment">// * In makeCurrent(), using eglSwapInterval. Some EGL drivers set the</span></span><br><span class="line">    <span class="comment">//   window's swap interval in eglMakeCurrent, so they'll override the</span></span><br><span class="line">    <span class="comment">//   interval we set here.</span></span><br><span class="line">    <span class="comment">////虚拟设备不支持图像合成  </span></span><br><span class="line">    <span class="keyword">if</span> (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL)</span><br><span class="line">        window-&gt;setSwapInterval(window, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mConfig = config;</span><br><span class="line">    mDisplay = display;</span><br><span class="line">    mSurface = surface;</span><br><span class="line">    mFormat  = format;</span><br><span class="line">    mPageFlipCount = <span class="number">0</span>;</span><br><span class="line">    mViewport.makeInvalid();</span><br><span class="line">    mFrame.makeInvalid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtual displays are always considered enabled</span></span><br><span class="line">    <span class="comment">//虚拟设备屏幕认为是不关闭的 </span></span><br><span class="line">    mPowerMode = (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL) ?</span><br><span class="line">                  HWC_POWER_MODE_NORMAL : HWC_POWER_MODE_OFF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Name the display.  The name will be replaced shortly if the display</span></span><br><span class="line">    <span class="comment">// was created with createDisplay().</span></span><br><span class="line">    <span class="comment">//根据显示设备类型赋名称</span></span><br><span class="line">    <span class="keyword">switch</span> (mType) &#123;</span><br><span class="line">        <span class="keyword">case</span> DISPLAY_PRIMARY:</span><br><span class="line">            mDisplayName = <span class="string">"Built-in Screen"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DISPLAY_EXTERNAL:</span><br><span class="line">            mDisplayName = <span class="string">"HDMI Screen"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            mDisplayName = <span class="string">"Virtual Screen"</span>;    <span class="comment">// e.g. Overlay #n</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize the display orientation transform.</span></span><br><span class="line">    <span class="comment">//调整显示设备视角的大小、位移、旋转等参数</span></span><br><span class="line">    setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DisplayDevice的构造函数初始化了一些参数，但是最重要的是：<strong>创建了一个Surface对象mNativeWindow，同时用它作为参数创建EGLSurface对象，这个EGLSurface对象是OpenGL ES中绘图需要的</strong>。</p>
<p>&#160; &#160; &#160; &#160;<strong>这样，在DisplayDevice中就建立了一个通向Framebuffer的通道，只要向DisplayDevice的mSurface写入数据。就会到消费者FrameBufferSurface的onFrameAvailable函数，然后到HWComposer在到Gralloc模块，最后输出到显示设备。</strong></p>
<p>&#160; &#160; &#160; &#160;附（以后会讲到）：DisplayDevice有个函数swapBuffers。swapBuffers函数将内部缓冲区的图像数据刷新到显示设备的Framebuffer中，它通过调用eglSwapBuffers函数来完成缓冲区刷新工作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DisplayDevice::swapBuffers(HWComposer&amp; hwc) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// We need to call eglSwapBuffers() if:</span></span><br><span class="line">    <span class="comment">//  (1) we don't have a hardware composer, or</span></span><br><span class="line">    <span class="comment">//  (2) we did GLES composition this frame, and either</span></span><br><span class="line">    <span class="comment">//    (a) we have framebuffer target support (not present on legacy</span></span><br><span class="line">    <span class="comment">//        devices, where HWComposer::commit() handles things); or</span></span><br><span class="line">    <span class="comment">//    (b) this is a virtual display</span></span><br><span class="line">    <span class="keyword">if</span> (hwc.initCheck() != NO_ERROR ||</span><br><span class="line">            (hwc.hasGlesComposition(mHwcDisplayId) &amp;&amp;</span><br><span class="line">             (hwc.supportsFramebufferTarget() || mType &gt;= DISPLAY_VIRTUAL))) &#123;</span><br><span class="line">        EGLBoolean success = eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            EGLint error = eglGetError();</span><br><span class="line">            <span class="keyword">if</span> (error == EGL_CONTEXT_LOST ||</span><br><span class="line">                    mType == DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"eglSwapBuffers(%p, %p) failed with 0x%08x"</span>,</span><br><span class="line">                        mDisplay, mSurface, error);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"eglSwapBuffers(%p, %p) failed with 0x%08x"</span>,</span><br><span class="line">                        mDisplay, mSurface, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = mDisplaySurface-&gt;advanceFrame();</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"[%s] failed pushing new frame to HWC: %d"</span>,</span><br><span class="line">                mDisplayName.<span class="built_in">string</span>(), result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>但是注意调用swapBuffers输出图像是在显示设备不支持硬件composer的情况下。</strong></p>
<h3 id="HWComposer设备"><a href="#HWComposer设备" class="headerlink" title="HWComposer设备"></a>HWComposer设备</h3><p>&#160; &#160; &#160; &#160;通过上一篇文章得知，Android通过VSync机制来提高显示效果，那么VSync是如何产生的？通常这个信号是由显示驱动产生，这样才能达到最佳效果。但是Android为了能运行在不支持VSync机制的设备上，也提供了软件模拟产生VSync信号的手段。<br>&#160; &#160; &#160; &#160;在SurfaceFlinger中，是通过HWComposer类来表示硬件设备。我们继续产看init函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Initialize the H/W composer object.  There may or may not be an</span></span><br><span class="line">    <span class="comment">// actual hardware composer underneath.</span></span><br><span class="line">    mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>,</span><br><span class="line">            *<span class="keyword">static_cast</span>&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们继续查看HWComposer的构造函数，位于frameworks/native/services/surfaceflinger/displayhardware/HWComposer.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">HWComposer::HWComposer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        EventHandler&amp; handler)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),</span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),<span class="comment">//这里直接new了一个设备上下文对象</span></span><br><span class="line">      mEventHandler(handler),</span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> needVSyncThread = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: some devices may insist that the FB HAL be opened before HWC.</span></span><br><span class="line">    <span class="comment">//装载FrameBuffer的硬件模块 </span></span><br><span class="line">    <span class="keyword">int</span> fberr = loadFbHalModule();</span><br><span class="line">    <span class="comment">//装载HWComposer的硬件模块,这个函数中会将mHwc置为true</span></span><br><span class="line">    loadHwcModule();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有FB和HWC，并且也有pre-1.1 HWC，就要先关闭FB设备</span></span><br><span class="line">    <span class="comment">//但这个是暂时的，直到HWC准备好</span></span><br><span class="line">    <span class="keyword">if</span> (mFbDev &amp;&amp; mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="comment">// close FB HAL if we don't needed it.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> this is temporary until we're not forced to open FB HAL</span></span><br><span class="line">        <span class="comment">// before HWC.</span></span><br><span class="line">        framebuffer_close(mFbDev);</span><br><span class="line">        mFbDev = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have no HWC, or a pre-1.1 HWC, an FB dev is mandatory.</span></span><br><span class="line">    <span class="comment">//如果我们没有HWC硬件支持，或者之前的pre-1.1 HWC，如hwc 1.0,那么FrameBuffer就是必须的</span></span><br><span class="line">    <span class="keyword">if</span> ((!mHwc || !hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">            &amp;&amp; !mFbDev) &#123;</span><br><span class="line">        <span class="comment">//如果没有framebuffer，就退出gg</span></span><br><span class="line">        ALOGE(<span class="string">"ERROR: failed to open framebuffer (%s), aborting"</span>,</span><br><span class="line">                strerror(-fberr));</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// these display IDs are always reserved</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;</span><br><span class="line">        mAllocatedDisplayIDs.markBit(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//硬件vsync信号</span></span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Using %s version %u.%u"</span>, HWC_HARDWARE_COMPOSER,</span><br><span class="line">              (hwcApiVersion(mHwc) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,</span><br><span class="line">              (hwcApiVersion(mHwc) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            <span class="comment">//HWComposer设备上下文变量mCBContext赋值</span></span><br><span class="line">            mCBContext-&gt;hwc = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//函数指针钩子函数hook_invalidate放入上下文</span></span><br><span class="line">            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;</span><br><span class="line">            <span class="comment">//vsync钩子函数放入上下文</span></span><br><span class="line">            mCBContext-&gt;procs.vsync = &amp;hook_vsync;</span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">                <span class="comment">//hotplug狗子函数放入上下文</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));</span><br><span class="line">            <span class="comment">//将钩子函数注册进硬件设备，硬件驱动回调这些钩子函数</span></span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't need a vsync thread if we have a hardware composer</span></span><br><span class="line">        <span class="comment">//如果有硬件vsync信号， 则不需要软件vsync实现</span></span><br><span class="line">        needVSyncThread = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mFbDev) &#123;<span class="comment">//如果mFbDev为不为null，情况为：没有hwc或者hwc是1.0老的版本</span></span><br><span class="line">        ALOG_ASSERT(!(mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)),</span><br><span class="line">                <span class="string">"should only have fbdev if no hwc or hwc is 1.0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[HWC_DISPLAY_PRIMARY])</span></span>;</span><br><span class="line">        disp.connected = <span class="literal">true</span>;</span><br><span class="line">        disp.format = mFbDev-&gt;format;</span><br><span class="line">        DisplayConfig config = DisplayConfig();</span><br><span class="line">        config.width = mFbDev-&gt;width;</span><br><span class="line">        config.height = mFbDev-&gt;height;</span><br><span class="line">        config.xdpi = mFbDev-&gt;xdpi;</span><br><span class="line">        config.ydpi = mFbDev-&gt;ydpi;</span><br><span class="line">        config.refresh = <span class="keyword">nsecs_t</span>(<span class="number">1e9</span> / mFbDev-&gt;fps);</span><br><span class="line">        disp.configs.push_back(config);</span><br><span class="line">        disp.currentConfig = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHwc) &#123;<span class="comment">//如果mFbDev为null，情况为：fb打开失败，或者暂时关闭(上面逻辑分析了)。打开了hwc</span></span><br><span class="line">        <span class="comment">// here we're guaranteed to have at least HWC 1.1</span></span><br><span class="line">        <span class="comment">//这里我们至少有HWC 1.1，上面分析过了。NUM_BUILTIN_DISPLAYS 为2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i =<span class="number">0</span> ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;</span><br><span class="line">            <span class="comment">//获取显示设备相关属性</span></span><br><span class="line">            queryDisplayProperties(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果没有硬件vsync，则需要用使用软件vsync模拟</span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;</span><br><span class="line">        <span class="comment">// we don't have VSYNC support, we need to fake it</span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造函数主要做了以下几件事情：</p>
<p>&#160; &#160; &#160; &#160;1）加载FrameBuffer硬件驱动：<br>&#160; &#160; &#160; &#160;调用loadFbHalModule函数实现，我们继续查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load and prepare the FB HAL, which uses the gralloc module.  Sets mFbDev.</span></span><br><span class="line"><span class="keyword">int</span> HWComposer::loadFbHalModule()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">hw_module_t</span> <span class="keyword">const</span>* module;</span><br><span class="line">    <span class="comment">//hal层封装的hal函数，参数GRALLOC_HARDWARE_MODULE_ID，加载gralloc模块</span></span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s module not found"</span>, GRALLOC_HARDWARE_MODULE_ID);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开fb设备</span></span><br><span class="line">    <span class="keyword">return</span> framebuffer_open(module, &amp;mFbDev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;<strong>hw_get_module</strong>函数是HAL层框架中封装的加载gralloc的函数，这个我们之前讲过，可以查看<a href="http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%B8%80-Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/">Android SurfaceFlinger 学习之路(一)—-Android图形显示之HAL层Gralloc模块实现</a>中的<strong>Gralloc模块的加载过程</strong>部分。</p>
<p>&#160; &#160; &#160; &#160;<strong>framebuffer_open</strong>函数同上，是用来打开fb设备，同样查看<code>fb设备的打开过程</code>模块。</p>
<p>&#160; &#160; &#160; &#160;2）装载HWComposer的硬件模块：<br>&#160; &#160; &#160; &#160;调用loadHwcModule函数来加载HWC模块，我们继续查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load and prepare the hardware composer module.  Sets mHwc.</span></span><br><span class="line"><span class="keyword">void</span> HWComposer::loadHwcModule()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">hw_module_t</span> <span class="keyword">const</span>* module;</span><br><span class="line">    <span class="comment">//同样是HAL层封装的函数，参数是HWC_HARDWARE_MODULE_ID，加载hwc模块</span></span><br><span class="line">    <span class="keyword">if</span> (hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;module) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s module not found"</span>, HWC_HARDWARE_MODULE_ID);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开hwc设备</span></span><br><span class="line">    <span class="keyword">int</span> err = hwc_open_1(module, &amp;mHwc);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s device failed to initialize (%s)"</span>,</span><br><span class="line">              HWC_HARDWARE_COMPOSER, strerror(-err));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0) ||</span><br><span class="line">            hwcHeaderVersion(mHwc) &lt; MIN_HWC_HEADER_VERSION ||</span><br><span class="line">            hwcHeaderVersion(mHwc) &gt; HWC_HEADER_VERSION) &#123;</span><br><span class="line">        ALOGE(<span class="string">"%s device version %#x unsupported, will not be used"</span>,</span><br><span class="line">              HWC_HARDWARE_COMPOSER, mHwc-&gt;common.version);</span><br><span class="line">        hwc_close_1(mHwc);</span><br><span class="line">        mHwc = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;同样是借助<strong>hw_get_module</strong>这个HAL函数，不过参数是HWC_HARDWARE_MODULE_ID，加载HWC模块；然后<strong>hwc_open_1</strong>函数打开hwc设备。</p>
<p>&#160; &#160; &#160; &#160;3）FB和HWC相关逻辑判断(1)：<br>&#160; &#160; &#160; &#160;如果有FB和HWC，并且也有pre-1.1 HWC，就要先关闭FB设备。这个是暂时的，直到HWC准备好；<br>&#160; &#160; &#160; &#160;如果我们没有HWC硬件支持，或者之前的pre-1.1 HWC,，如HWC 1.0，那么FrameBuffer就是必须的。如果脸FB都没有，那就GG。</p>
<p>&#160; &#160; &#160; &#160;4）硬件设备打开成功：<br>&#160; &#160; &#160; &#160;如果硬件设备打开成功，则将钩子函数<strong>hook_invalidate、hook_vsync和hook_hotplug</strong>注册进硬件设备，作为回调函数。这三个都是硬件产生事件信号，通知上层SurfaceFlinger的回调函数，用于处理这个信号。</p>
<p>&#160; &#160; &#160; &#160;因为我们本节是Vsync信号相关，所以我们只看看hook_vsync钩子函数。这里指定了vsync的回调函数是hook_vsync，如果硬件中产生了VSync信号，将通过这个函数来通知上层，看看它的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::hook_vsync(<span class="keyword">const</span> <span class="keyword">struct</span> hwc_procs* procs, <span class="keyword">int</span> disp,</span><br><span class="line">        <span class="keyword">int64_t</span> timestamp) &#123;</span><br><span class="line">    cb_context* ctx = <span class="keyword">reinterpret_cast</span>&lt;cb_context*&gt;(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">hwc_procs_t</span>*&gt;(procs));</span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;hook_vsync钩子函数会调用vsync函数，我们继续看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::vsync(<span class="keyword">int</span> disp, <span class="keyword">int64_t</span> timestamp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// There have been reports of HWCs that signal several vsync events</span></span><br><span class="line">            <span class="comment">// with the same timestamp when turning the display off and on. This</span></span><br><span class="line">            <span class="comment">// is a bug in the HWC implementation, but filter the extra events</span></span><br><span class="line">            <span class="comment">// out here so they don't cause havoc downstream.</span></span><br><span class="line">            <span class="keyword">if</span> (timestamp == mLastHwVSync[disp]) &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring duplicate VSYNC event from HWC (t=%"</span> PRId64 <span class="string">")"</span>,</span><br><span class="line">                        timestamp);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLastHwVSync[disp] = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> tag[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(tag, <span class="keyword">sizeof</span>(tag), <span class="string">"HW_VSYNC_%1u"</span>, disp);</span><br><span class="line">        ATRACE_INT(tag, ++mVSyncCounts[disp] &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这里调用EventHandler类型变量mEventHandler就是SurfaceFlinger，</span></span><br><span class="line">        <span class="comment">//所以调用了SurfaceFlinger的onVSyncReceived函数</span></span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mEventHandler对象类型为EventHandler，我们在SurfaceFlinger的init函数创建HWComposer类实例时候讲SurfaceFlinger强转为EventHandler作为构造函数的参数传入其中。再者SurfaceFlinger继承HWComposer::EventHandler，所以这里没毛病，老铁~所以最终会调用SurfaceFlinger的onVSyncReceived函数。这就是硬件vsync信号的产生，关于vsync信号流程工作我们下面马上会讲到。</p>
<p>&#160; &#160; &#160; &#160;5）FB和HWC相关逻辑判断(2)：<br>&#160; &#160; &#160; &#160;如果mFbDev为不为null，情况为：没有hwc或者hwc是1.0老的版本。此时就要设置一些FB的属性了，从主屏幕获取；<br>&#160; &#160; &#160; &#160;如果mFbDev为null，情况为：fb打开失败，或者暂时关闭(上面逻辑分析了)。仅仅打开了hwc，这里我们至少有HWC 1.1，上面分析过了。此时我们要获取显示设备相关属性，进入else if逻辑判断，里面的NUM_BUILTIN_DISPLAYS 为2，则只有主屏幕和扩展屏幕需要查询显示设备属性，调用queryDisplayProperties函数，我们可以产看这个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> HWComposer::queryDisplayProperties(<span class="keyword">int</span> disp) &#123;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!mHwc || !hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use zero as default value for unspecified attributes</span></span><br><span class="line">    <span class="keyword">int32_t</span> values[NUM_DISPLAY_ATTRIBUTES - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> MAX_NUM_CONFIGS = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> configs[MAX_NUM_CONFIGS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> numConfigs = MAX_NUM_CONFIGS;</span><br><span class="line">    <span class="comment">//hwc设备获取显屏配置信息，都是HAL层封装的函数，并保存在这些指针指向内容中</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mHwc-&gt;getDisplayConfigs(mHwc, disp, configs, &amp;numConfigs);</span><br><span class="line">    <span class="comment">//如果一个不可插入的显屏没有连接，则将connected赋值为false</span></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// this can happen if an unpluggable display is not connected</span></span><br><span class="line">        mDisplayData[disp].connected = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayData[disp].currentConfig = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取显示相关属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> c = <span class="number">0</span>; c &lt; numConfigs; ++c) &#123;</span><br><span class="line">        err = mHwc-&gt;getDisplayAttributes(mHwc, disp, configs[c],</span><br><span class="line">                DISPLAY_ATTRIBUTES, values);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// we can't get this display's info. turn it off.</span></span><br><span class="line">            mDisplayData[disp].connected = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取成功后，创建一个config对象，用于保存这些属性</span></span><br><span class="line">        DisplayConfig config = DisplayConfig();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUM_DISPLAY_ATTRIBUTES - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (DISPLAY_ATTRIBUTES[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> HWC_DISPLAY_VSYNC_PERIOD:<span class="comment">//屏幕刷新率</span></span><br><span class="line">                    config.refresh = <span class="keyword">nsecs_t</span>(values[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HWC_DISPLAY_WIDTH:<span class="comment">//屏幕宽</span></span><br><span class="line">                    config.width = values[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HWC_DISPLAY_HEIGHT:<span class="comment">//屏幕高</span></span><br><span class="line">                    config.height = values[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HWC_DISPLAY_DPI_X:<span class="comment">//DPI像素X</span></span><br><span class="line">                    config.xdpi = values[i] / <span class="number">1000.0f</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HWC_DISPLAY_DPI_Y:<span class="comment">//DPI像素Y</span></span><br><span class="line">                    config.ydpi = values[i] / <span class="number">1000.0f</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    ALOG_ASSERT(<span class="literal">false</span>, <span class="string">"unknown display attribute[%zu] %#x"</span>,</span><br><span class="line">                            i, DISPLAY_ATTRIBUTES[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有获取到DPI则给个默认的，跟进去是213或者320</span></span><br><span class="line">        <span class="keyword">if</span> (config.xdpi == <span class="number">0.0f</span> || config.ydpi == <span class="number">0.0f</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> dpi = getDefaultDensity(config.width, config.height);</span><br><span class="line">            config.xdpi = dpi;</span><br><span class="line">            config.ydpi = dpi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将每个设备的显示信息存起来</span></span><br><span class="line">        mDisplayData[disp].configs.push_back(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> what should we set the format to?</span></span><br><span class="line">    <span class="comment">//像素编码都为ARGB_8888</span></span><br><span class="line">    mDisplayData[disp].format = HAL_PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    <span class="comment">//这里讲connected复制为true</span></span><br><span class="line">    mDisplayData[disp].connected = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;queryDisplayProperties查询每个显示设备的属性，主要有以下几步：</p>
<ol>
<li>hwc设备获取显屏配置信息，都是HAL层封装的函数，并保存在这些指针指向内容中;</li>
<li>获取显示先关属性，并保存起来。</li>
</ol>
<p>&#160; &#160; &#160; &#160;这一部分注释写的比较清晰，可以查看注释。</p>
<p>&#160; &#160; &#160; &#160;6）软件VSync信号产生：<br>&#160; &#160; &#160; &#160;如果硬件设备打开失败，则需要软件vsync信号，因此<strong>needVSyncThread</strong>为true，会进入最后一个if条件判断逻辑，则会创建一个VSyncThread类实例，用来模拟软件vsync信号。</p>
<p>&#160; &#160; &#160; &#160;所以我们看看VSyncThread这个类，它集成与Thread，又是一个线程，定义位于HWComposer.h中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this class is only used to fake the VSync event on systems that don't</span></span><br><span class="line"><span class="comment">// have it.</span></span><br><span class="line"><span class="keyword">class</span> VSyncThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    HWComposer&amp; mHwc;</span><br><span class="line">    <span class="keyword">mutable</span> Mutex mLock;</span><br><span class="line">    Condition mCondition;</span><br><span class="line">    <span class="keyword">bool</span> mEnabled;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">nsecs_t</span> mNextFakeVSync;</span><br><span class="line">    <span class="keyword">nsecs_t</span> mRefreshPeriod;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VSyncThread(HWComposer&amp; hwc);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">bool</span> enabled)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造函数位于HWComposer.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::VSyncThread::VSyncThread(HWComposer&amp; hwc)</span><br><span class="line">    : mHwc(hwc), mEnabled(<span class="literal">false</span>),<span class="comment">//false</span></span><br><span class="line">      mNextFakeVSync(<span class="number">0</span>),<span class="comment">//0</span></span><br><span class="line">      mRefreshPeriod(hwc.getRefreshPeriod(HWC_DISPLAY_PRIMARY))<span class="comment">//获取主屏幕刷新率</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造函数中初始化了mEnable变量为false，mNextFakeVSync为0。还有获取了主屏幕的刷新率，并保存在mRefreshPeriod。屏幕刷新率我们在上一篇<a href="http://windrunnerlihuan.com/2017/05/21/VSync%E4%BF%A1%E5%8F%B7/">VSync信号</a>已经科普过了。<br>&#160; &#160; &#160; &#160;我们看看屏幕刷新率的获取，hwc.getRefreshPeriod(HWC_DISPLAY_PRIMARY)函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nsecs_t</span> HWComposer::getRefreshPeriod(<span class="keyword">int</span> disp) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> currentConfig = mDisplayData[disp].currentConfig;</span><br><span class="line">    <span class="keyword">return</span> mDisplayData[disp].configs[currentConfig].refresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里获取的屏幕刷新率refresh就是我们之前queryDisplayProperties函数里获取的。其实queryDisplayProperties不止在HWComposer构造函数里调用，还会在钩子函数hook_hotplug里调用，我们查看hotplug函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::hotplug(<span class="keyword">int</span> disp, <span class="keyword">int</span> connected) &#123;</span><br><span class="line">    <span class="keyword">if</span> (disp == HWC_DISPLAY_PRIMARY || disp &gt;= VIRTUAL_DISPLAY_ID_BASE) &#123;</span><br><span class="line">        ALOGE(<span class="string">"hotplug event received for invalid display: disp=%d connected=%d"</span>,</span><br><span class="line">                disp, connected);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queryDisplayProperties(disp);</span><br><span class="line">    mEventHandler.onHotplugReceived(disp, <span class="keyword">bool</span>(connected));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果是主屏幕或者虚拟设备则不会查询设备属性。<br>&#160; &#160; &#160; &#160;我猜测是插入扩展屏幕后，会重新再查询一下屏幕信息，从硬件发出的信号。</p>
<p>&#160; &#160; &#160; &#160;好了我们继续回到上面，因为VSyncThread对象付给了一个强指针，所以会调用onFirstRef函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::VSyncThread::onFirstRef() &#123;</span><br><span class="line">    run(<span class="string">"VSyncThread"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这样这个软件vsync产生线程就运行起来了，因此我们需要查看threadLoop函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HWComposer::VSyncThread::threadLoop() &#123;</span><br><span class="line">    &#123; <span class="comment">// scope for lock</span></span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        <span class="keyword">while</span> (!mEnabled) &#123;<span class="comment">//这个是false，在构造函数里赋值</span></span><br><span class="line">            <span class="comment">//因此会阻塞在这里</span></span><br><span class="line">            mCondition.wait(mLock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> period = mRefreshPeriod;<span class="comment">//屏幕刷新率</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime(CLOCK_MONOTONIC);<span class="comment">//now</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> next_vsync = mNextFakeVSync;<span class="comment">//下一次vsync时间，初始值为0</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> sleep = next_vsync - now;<span class="comment">//距离下次vsync信号中间的睡眠时间</span></span><br><span class="line">    <span class="keyword">if</span> (sleep &lt; <span class="number">0</span>) &#123;<span class="comment">//如果sleep小于0，比如第一次进来mNextFakeVSync为0；或者错过n次vsync信号</span></span><br><span class="line">        <span class="comment">// we missed, find where the next vsync should be</span></span><br><span class="line">        <span class="comment">//如果错过了，则重新计算下一次vsync的偏移时间</span></span><br><span class="line">        sleep = (period - ((now - next_vsync) % period));</span><br><span class="line">        next_vsync = now + sleep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//偏移时间加上刷新率周期时间</span></span><br><span class="line">    mNextFakeVSync = next_vsync + period;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> timespec spec;</span><br><span class="line">    spec.tv_sec  = next_vsync / <span class="number">1000000000</span>;</span><br><span class="line">    spec.tv_nsec = next_vsync % <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//然后睡眠等待下次vsync信号的时间</span></span><br><span class="line">        err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (err&lt;<span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;<span class="comment">//睡眠ok后，则去驱动SurfaceFlinger函数触发</span></span><br><span class="line">        mHwc.mEventHandler.onVSyncReceived(<span class="number">0</span>, next_vsync);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面的代码，我们需要注意两个地方： </p>
<ol>
<li>mEnabled默认为false，mCondition在这里阻塞，直到有人调用了signal()，同时mEnabled为true；</li>
<li>如果阻塞解开，则会定期休眠，然后去驱动SF，这就相当于产生了持续的Vsync信号。</li>
</ol>
<p>&#160; &#160; &#160; &#160;这个函数会间隔模拟产生VSync的信号的原理是在固定时间发送消息给HWCompoer的消息对象mEventHandler，这个其实就到SurfaceFlinger的onVSyncReceived函数了。用软件模拟VSync信号在系统比较忙的时候可能会丢失一些信号，所以才有中间的sleep小于0的情况。</p>
<p>&#160; &#160; &#160; &#160;到目前为止，HWC中新建了一个线程VSyncThread，阻塞中，下面我们看下打开Vsync开关的闸刀是如何建立的，以及何处去开闸刀。</p>
<h1 id="VSync-信号闸刀控制"><a href="#VSync-信号闸刀控制" class="headerlink" title="VSync 信号闸刀控制"></a>VSync 信号闸刀控制</h1><p>&#160; &#160; &#160; &#160;上面我分析了Vsync软件和硬件信号的产生过程，但是HWC中新建的线程VSyncThread是处于阻塞当中，因此我们需要一个闸刀去控制这个开关。</p>
<h2 id="Vsync信号开关"><a href="#Vsync信号开关" class="headerlink" title="Vsync信号开关"></a>Vsync信号开关</h2><p>&#160; &#160; &#160; &#160;这个闸刀还是在SurfaceFlinger的init函数中建立的，我们查看这个位置：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread = <span class="keyword">new</span> EventControlThread(<span class="keyword">this</span>);</span><br><span class="line">    mEventControlThread-&gt;run(<span class="string">"EventControl"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这是一个Thread线程类，因此都会实现threadLoop函数。不过我们先看看它的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventControlThread::EventControlThread(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger):</span><br><span class="line">        mFlinger(flinger),</span><br><span class="line">        mVsyncEnabled(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;比较简单，将SurfaceFlinger对象传了进来，并且将mVsyncEnabled标志初始为false。<br>&#160; &#160; &#160; &#160;然后我们看看他的threadLoop线程函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> EventControlThread::threadLoop() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vsyncEnabled = mVsyncEnabled;<span class="comment">//初始为false</span></span><br><span class="line">    <span class="comment">//先调用一遍SurfaceFlinger的eventControl函数</span></span><br><span class="line">    mFlinger-&gt;eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC,</span><br><span class="line">            mVsyncEnabled);</span><br><span class="line">    <span class="comment">//这里是个死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = mCond.wait(mMutex);<span class="comment">//会阻塞在这里</span></span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(<span class="string">"error waiting for new events: %s (%d)"</span>,</span><br><span class="line">                strerror(-err), err);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vsyncEnabled 开始和mVsyncEnabled都为false，如果有其他地方改变了mVsyncEnabled,</span></span><br><span class="line">        <span class="comment">//会去调用SF的eventControl函数</span></span><br><span class="line">        <span class="keyword">if</span> (vsyncEnabled != mVsyncEnabled) &#123;</span><br><span class="line">            mFlinger-&gt;eventControl(HWC_DISPLAY_PRIMARY,</span><br><span class="line">                    SurfaceFlinger::EVENT_VSYNC, mVsyncEnabled);</span><br><span class="line">            vsyncEnabled = mVsyncEnabled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;threadLoop函数主要逻辑分两步：<br>&#160; &#160; &#160; &#160;1.进来时候在mCond处阻塞，可以看到外面是个死循环，所以如果有其他地方对这个mCond调用了signal，执行完下面的代码又会阻塞 ；<br>&#160; &#160; &#160; &#160;2.解除阻塞后，如果vsyncEnabled != mVsyncEnabled，也就是开关状态不同，由开到关和由关到开，都回去调用mFlinger-&gt;eventControl，调用完成后把这次的开关状态保存，vsyncEnabled = mVsyncEnabled;，与下次做比较。<br>&#160; &#160; &#160; &#160;从上面我们能明显认识到EventControlThread线程，其实就起到了个闸刀的作用，等待着别人去开、关。 </p>
<p>&#160; &#160; &#160; &#160;所以这个开关操作就在SurfaceFlinger的eventControl函数，我们看看它怎么实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::eventControl(<span class="keyword">int</span> disp, <span class="keyword">int</span> event, <span class="keyword">int</span> enabled) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    getHwComposer().eventControl(disp, event, enabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它又会调用HWComposer的eventControl函数，我们继续查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::eventControl(<span class="keyword">int</span> disp, <span class="keyword">int</span> event, <span class="keyword">int</span> enabled) &#123;</span><br><span class="line">    <span class="comment">//如果是没有申请注册的设备，GG</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(disp)&gt;<span class="number">31</span> || !mAllocatedDisplayIDs.hasBit(disp)) &#123;</span><br><span class="line">        ALOGD(<span class="string">"eventControl ignoring event %d on unallocated disp %d (en=%d)"</span>,</span><br><span class="line">              event, disp, enabled);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是EVENT_VSYNC事件，GG</span></span><br><span class="line">    <span class="keyword">if</span> (event != EVENT_VSYNC) &#123;</span><br><span class="line">        ALOGW(<span class="string">"eventControl got unexpected event %d (disp=%d en=%d)"</span>,</span><br><span class="line">              event, disp, enabled);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="comment">//如果是硬件Vsync闸刀，并且不是调试软件vsync</span></span><br><span class="line">    <span class="keyword">if</span> (mHwc &amp;&amp; !mDebugForceFakeVSync) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> we use our own internal lock here because we have to call</span></span><br><span class="line">        <span class="comment">// into the HWC with the lock held, and we want to make sure</span></span><br><span class="line">        <span class="comment">// that even if HWC blocks (which it shouldn't), it won't</span></span><br><span class="line">        <span class="comment">// affect other threads.</span></span><br><span class="line">        Mutex::Autolock _l(mEventControlLock);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> eventBit = <span class="number">1U</span>L &lt;&lt; event;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> newValue = enabled ? eventBit : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> oldValue = mDisplayData[disp].events &amp; eventBit;</span><br><span class="line">        <span class="keyword">if</span> (newValue != oldValue) &#123;</span><br><span class="line">            ATRACE_CALL();</span><br><span class="line">            <span class="comment">//硬件vsync闸刀控制开关</span></span><br><span class="line">            err = mHwc-&gt;eventControl(mHwc, disp, event, enabled);</span><br><span class="line">            <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                <span class="keyword">int32_t</span>&amp; events(mDisplayData[disp].events);</span><br><span class="line">                events = (events &amp; ~eventBit) | newValue;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> tag[<span class="number">16</span>];</span><br><span class="line">                <span class="built_in">snprintf</span>(tag, <span class="keyword">sizeof</span>(tag), <span class="string">"HW_VSYNC_ON_%1u"</span>, disp);</span><br><span class="line">                ATRACE_INT(tag, enabled);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// error here should not happen -- not sure what we should</span></span><br><span class="line">        <span class="comment">// do if it does.</span></span><br><span class="line">        ALOGE_IF(err, <span class="string">"eventControl(%d, %d) failed %s"</span>,</span><br><span class="line">                event, enabled, strerror(-err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有硬件Vsync支持，则调用软件vsync信号闸刀</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR &amp;&amp; mVSyncThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVSyncThread-&gt;setEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里可以看到还是分软件闸刀和硬件闸刀：</p>
<ol>
<li>硬件闸刀控制就到了HAL层函数了，调用了mHwc-&gt;eventControl(mHwc, disp, event, enabled)这个逻辑；</li>
<li>如果没有硬件Vsync支持，则会调用软件闸刀控制手段，VsyncThread的setEnable函数。</li>
</ol>
<p>&#160; &#160; &#160; &#160;硬件就不用了看，反正也看不到代码。。。我们看看软件Vsync闸刀控制，即VsyncThread的setEnable函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::VSyncThread::setEnabled(<span class="keyword">bool</span> enabled) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mEnabled != enabled) &#123;</span><br><span class="line">        mEnabled = enabled;</span><br><span class="line">        mCondition.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;将软件模拟线程VSyncThread的mCondition释放，这时候VSyncThread就会定期产生“信号”，去驱动SF了。</p>
<h2 id="EventControlThread开关"><a href="#EventControlThread开关" class="headerlink" title="EventControlThread开关"></a>EventControlThread开关</h2><p>&#160; &#160; &#160; &#160;但是我们上边漏了东西，就是EventControlThread本身的闸刀，它自己还在mCond.wait(mMutex)这里阻塞呢。那么EventControlThread这个闸刀到底在哪儿打开呢？</p>
<p>&#160; &#160; &#160; &#160;所以我们还得的查看SurfaceFlinger的init函数，再这里它有一处逻辑：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    <span class="comment">// set initial conditions (e.g. unblank default device)</span></span><br><span class="line">    initializeDisplays();</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们查看initializeDisplays函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::initializeDisplays() &#123;</span><br><span class="line">    <span class="keyword">class</span> MessageScreenInitialized : <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageScreenInitialized(SurfaceFlinger* flinger) : flinger(flinger) &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            flinger-&gt;onInitializeDisplays();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageScreenInitialized(<span class="keyword">this</span>);</span><br><span class="line">    postMessageAsync(msg);  <span class="comment">// we may be called from main thread, use async message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里放了一个消息给SF的MessageQueue，然后消息回调onInitializeDisplays函数，我们继续查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onInitializeDisplays() &#123;</span><br><span class="line">    <span class="comment">// reset screen orientation and use primary layer stack</span></span><br><span class="line">    <span class="comment">//重置屏幕方向，并使用主屏幕图层</span></span><br><span class="line">    Vector&lt;ComposerState&gt; state;</span><br><span class="line">    Vector&lt;DisplayState&gt; displays;</span><br><span class="line">    DisplayState d;</span><br><span class="line">    d.what = DisplayState::eDisplayProjectionChanged |</span><br><span class="line">             DisplayState::eLayerStackChanged;</span><br><span class="line">    d.token = mBuiltinDisplays[DisplayDevice::DISPLAY_PRIMARY];</span><br><span class="line">    d.layerStack = <span class="number">0</span>;</span><br><span class="line">    d.orientation = DisplayState::eOrientationDefault;</span><br><span class="line">    d.frame.makeInvalid();</span><br><span class="line">    d.viewport.makeInvalid();</span><br><span class="line">    d.width = <span class="number">0</span>;</span><br><span class="line">    d.height = <span class="number">0</span>;</span><br><span class="line">    displays.add(d);</span><br><span class="line">    <span class="comment">//重设屏幕Transaction状态</span></span><br><span class="line">    setTransactionState(state, displays, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//我们要找到闸刀开关在这个里面</span></span><br><span class="line">    setPowerModeInternal(getDisplayDevice(d.token), HWC_POWER_MODE_NORMAL);</span><br><span class="line">    <span class="comment">//主显示器刷新率</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> period =</span><br><span class="line">            getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    mAnimFrameTracker.setDisplayRefreshPeriod(period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其它都不重要，重要在setPowerModeInternal函数，我们继续查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::setPowerModeInternal(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw,</span><br><span class="line">        <span class="keyword">int</span> mode) &#123;<span class="comment">//HWC_POWER_MODE_NORMAL</span></span><br><span class="line">    ALOGD(<span class="string">"Set power mode=%d, type=%d flinger=%p"</span>, mode, hw-&gt;getDisplayType(),</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">int32_t</span> type = hw-&gt;getDisplayType();<span class="comment">//DISPLAY_PRIMARY</span></span><br><span class="line">    <span class="keyword">int</span> currentMode = hw-&gt;getPowerMode();<span class="comment">//HWC_POWER_MODE_OFF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == currentMode) &#123;<span class="comment">//skip</span></span><br><span class="line">        ALOGD(<span class="string">"Screen type=%d is already mode=%d"</span>, hw-&gt;getDisplayType(), mode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hw-&gt;setPowerMode(mode);</span><br><span class="line">    <span class="keyword">if</span> (type &gt;= DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Trying to set power mode for virtual display"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentMode == HWC_POWER_MODE_OFF) &#123;<span class="comment">//会走到这里</span></span><br><span class="line">        getHwComposer().setPowerMode(type, mode);</span><br><span class="line">        <span class="keyword">if</span> (type == DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> eventthread only knows about the main display right now</span></span><br><span class="line">            <span class="comment">//EventThread是后面讲到VSync工作流程的部分，后面讲，这里影响不大</span></span><br><span class="line">            mEventThread-&gt;onScreenAcquired();</span><br><span class="line">            <span class="comment">//这里才是重点，是打开闸刀的地方</span></span><br><span class="line">            resyncToHardwareVsync(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        repaintEverything();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == HWC_POWER_MODE_OFF) &#123;<span class="comment">//不会到这里</span></span><br><span class="line">        <span class="keyword">if</span> (type == DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            disableHardwareVsync(<span class="literal">true</span>); <span class="comment">// also cancels any in-progress resync</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> eventthread only knows about the main display right now</span></span><br><span class="line">            mEventThread-&gt;onScreenReleased();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getHwComposer().setPowerMode(type, mode);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// from this point on, SF will stop drawing on this display</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//也不会到这儿</span></span><br><span class="line">        getHwComposer().setPowerMode(type, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面逻辑也不难，只要我们记住以前赋值的变量时多少就行了。<br>&#160; &#160; &#160; &#160;我们获取主显屏的信息，因为是灭的HWC_POWER_MODE_OFF模式，所以进入这个if判断里面，然后调用resyncToHardwareVsync函数。我们继续查看它：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::resyncToHardwareVsync(<span class="keyword">bool</span> makeAvailable) &#123;<span class="comment">//true</span></span><br><span class="line">    Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">    <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">        mHWVsyncAvailable = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">        ALOGE(<span class="string">"resyncToHardwareVsync called when HW vsync unavailable"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主屏幕硬件刷新率</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> period =</span><br><span class="line">            getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    <span class="comment">//设置硬件刷新率</span></span><br><span class="line">    mPrimaryDispSync.reset();</span><br><span class="line">    mPrimaryDispSync.setPeriod(period);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;<span class="comment">//false,进入</span></span><br><span class="line">        mPrimaryDispSync.beginResync();</span><br><span class="line">        <span class="comment">//eventControl(HWC_DISPLAY_PRIMARY, SurfaceFlinger::EVENT_VSYNC, true);</span></span><br><span class="line">        <span class="comment">//打开闸刀</span></span><br><span class="line">        mEventControlThread-&gt;setVsyncEnabled(<span class="literal">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先将mHWVsyncAvailable 标志位置为true，然后设置硬件刷新周期，最后打开mEventControlThread闸刀，我们可以查看它的setVsyncEnabled函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventControlThread::setVsyncEnabled(<span class="keyword">bool</span> enabled) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mVsyncEnabled = enabled;</span><br><span class="line">    mCond.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;可以看到，在这里释放了前面的mCond，让EventControlThread去调用mFlinger-&gt;eventControl()函数，从而去HWC中打开Vsync开关。</p>
<h1 id="VSync信号构成"><a href="#VSync信号构成" class="headerlink" title="VSync信号构成"></a>VSync信号构成</h1><p>&#160; &#160; &#160; &#160;本来我们应该继续顺着代码去跟踪vsync信号的分发过程，但是在这之前我们有必要了解一下vsync信号的构成，以便我们后续分析没有盲点。</p>
<p>&#160; &#160; &#160; &#160;我们知道Android是用Vsync来驱动系统的画面更新包括APPview draw ,surfaceflinger 画面的合成,display把surfaceflinger合成的画面呈现在LCD上。要分析Vsync信号的组成，可以了解一下<strong>systrace工具</strong>。</p>
<h2 id="Systrace简介"><a href="#Systrace简介" class="headerlink" title="Systrace简介"></a>Systrace简介</h2><p>&#160; &#160; &#160; &#160;Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>&#160; &#160; &#160; &#160;systrace的使用可以查看官网，或者问<code>娘</code>问<code>哥</code>。<br>&#160; &#160; &#160; &#160;官网使用教程如下：<br>&#160; &#160; &#160; &#160;<a href="https://developer.android.com/studio/profile/systrace-walkthru.html" target="_blank" rel="external">https://developer.android.com/studio/profile/systrace-walkthru.html</a></p>
<p>&#160; &#160; &#160; &#160;命令行使用方式：<br>&#160; &#160; &#160; &#160;<a href="https://developer.android.com/studio/profile/systrace-commandline.html" target="_blank" rel="external">https://developer.android.com/studio/profile/systrace-commandline.html</a></p>
<p>&#160; &#160; &#160; &#160;生成html分析：<br>&#160; &#160; &#160; &#160;<a href="https://developer.android.com/studio/profile/systrace.html" target="_blank" rel="external">https://developer.android.com/studio/profile/systrace.html</a></p>
<p>&#160; &#160; &#160; &#160;分析systrace生成文件，要在eng版本rom，其他的要么无法生成，要么没有权限。</p>
<p>&#160; &#160; &#160; &#160;下面我抄一个例子分析。</p>
<h2 id="VSync的构成"><a href="#VSync的构成" class="headerlink" title="VSync的构成"></a>VSync的构成</h2><p>&#160; &#160; &#160; &#160;就挑一个<code>相册</code>这个应用，是系统自带的system app，包名是com.android.gallery3d。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/systrace1.png" alt="Systrace1"></p>
<p>&#160; &#160; &#160; &#160;在systrace中,我们经常可以看到如上图的信息。</p>
<ul>
<li>红色框1是与Vsync相关event信息.这些Vsync event构成了android系统画面更新基础；</li>
<li>红色框2和红色框3是Vsync-app的信息.我们可以看到红色框2比红色框3稀疏.我们将会在本文说明其原因；</li>
<li>红色框4和红色框5是Vsync-sf的信息.我们可以看到红色框4比红色框5稀疏.我们将会在本文说明其原因。</li>
</ul>
<p>&#160; &#160; &#160; &#160;从上图可以看出来，VSync信号由HW_VSYNC_ON_0,HW_VSYNC_0, Vsync-app和Vsync-sf四部分构成：</p>
<ul>
<li><strong>HW_VSYNC_ON_0</strong>：代表PrimaryDisplay的VSync被enable或disable。0这个数字代表的是display的编号, 0是PrimaryDisplay,如果是Externalmonitor,就会是HW_VSYNC_ON_1。当SF要求HWComposer将Display的VSync打开或关掉时,这个event就会记录下来；</li>
<li><strong>HW_VSYNC_0</strong>：代表PrimaryDisplay的VSync发生时间点, 0同样代表display编号。其用来调节Vsync-app和Vsync-sfevent的输出；</li>
<li><strong>Vsync-app</strong>：App,SystemUI和systemserver 等viewdraw的触发器；</li>
<li><strong>Vsync-sf</strong>：Surfaceflinger合成画面的触发器。</li>
</ul>
<p>&#160; &#160; &#160; &#160;通常为了避免Tearing的现象，画面更新(Flip)的动作通常会在VSync开始的时候才做，因为在VSync开始到它结束前，Display不会把framebuffer资料显示在display上，所以在这段时间做Flip可以避免使用者同时看到前后两个部份画面的现象。<strong>目前user看到画面呈现的过程是这样的，app更新它的画面后，它需要透过BufferQueue通知SF，SF再将更新过的app画面与其它的App或SystemUI组合后，再显示在User面前</strong>。在这个过程里,有3个component牵涉进来，分别是App、SF、与Display。以目前Android的设计，这三个Component都是在VSync发生的时候才开始做事。我们将它们想成一个有3个stage的pipeline，这个pipeline的clock就LCD的TE信号(60HZ)也即HW_VSYNC_0。</p>
<p>&#160; &#160; &#160; &#160;我们来看看android draw的pipeline，如下：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/pipeline.png" alt="pipeline"></p>
<ol>
<li>T = 0时, App正在画N, SF与Display都没内容可用</li>
<li>T = 1时, App正在画N+1, SF组合N, Display没Buffer可显示</li>
<li>T = 2时, App正在画N+2, SF组合N+1, Display显示N</li>
<li>T = 3时, App正在画N, SF组合N+2, Display显示N+1</li>
<li>……</li>
</ol>
<p>&#160; &#160; &#160; &#160;如果按照这个步骤，当user改变一个画面时，要等到2个VSync后，画面才会显示在user面前，latency大概是33ms (2个frame的时间)。但是对大部份的操作来讲，可能app加SF画的时间一个frame(16.6ms)就可以完成。因此，Android就从HW_VSYNC_0中产生出两个VSync信号，VSYNC-app是给App用的，VSYNC-sf是给SF用的， Display则是使用HW_VSYNC_0。VSYNC-app与VSYNC-sf可以分别给定一个phase，简单的说：</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;VSYNC-app = HW_VSYNC_0 + phase_app<br>&#160; &#160; &#160; &#160;VSYNC-sf =HW_VSYNC_0 + phase_sf</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;从而使App draw和surfaceflinger的合成，错开时间运行。这样就有可能整个系统draw的pipeline更加有效率，从而提高用户体验。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/phase.jpg" alt="phase"></p>
<p>&#160; &#160; &#160; &#160;也就是说，如果phase_app与phase_sf设定的好的话，可能大部份user使用的状况， App+SF可以在一个frame里完成，然后在下一个HW_VSYNC_0来的时候,显示在display上。</p>
<p>&#160; &#160; &#160; &#160;<strong>理论上透过VSYNC-sf与VSYNC-app的确是可以有机会在一个frame里把App+SF做完，但是实际上不是一定可以在一个frame里完成。因为有可能因为CPU调度，GPUperformance不够，以致App或SF没办法及时做完。</strong>但是即便如此，把app，surfaceflinger和displayVsync分开也比用一个Vsync来trigger appdraw，surfaceflinger合成，display在LCD上draw的性能要好很多(FPS更高)。因为如果放在同一时间，CPU调度压力更大，可能会卡顿、延迟。</p>
<p>&#160; &#160; &#160; &#160;那么是否我们收到LCD的Vsync event就会触发Vsync-app和Vsync-SF呢？如果是这样我们就不会看到本文开头的Vsync-app和Vsync-SF的节奏不一致的情况(红色框2比红色框3稀疏)。事实上，在大多数情况下，APP的画面并不需要一直更新。比如我们看一篇文章，大部份时间，画面是维持一样的，如果我们在每个LCD的VSYNC来的时候都触发SF或APP，就会浪费时间和Power。可是在画面持续更新的情况下，我们又需要触发SF和App的Vsync event。例如玩game或播影片时。就是说我们需要根据是否有内容的更新来选择Vsync event出现的机制。<br>&#160; &#160; &#160; &#160;<strong>Vsync event 的触发需要按需出现。</strong>所以在Android里，HW_VSYNC_0，Vsync-sf和Vsync-app都会按需出现。HW_VSYNC_0是根据是否需要调节sf和app的Vsync event而出现，而SF和App则会call requestNextVsync()来告诉系统我要在下一个VSYNC需要被trigger。也是虽然系统每秒有60个HW VSYNC，但不代表APP和SF在每个VSYNC都要更新画面。<strong>因此，在Android里，是根据SoftwareVSYNC(Vsync-sf，Vsync-app)来更新画面</strong>。Software VSYNC是根据HWVSYNC过去发生的时间，推测未来会发生的时间。因此，当APP或SF利用requestNextVsync时，Software VSYNC才会触发VSYNC-sf或VSYNC-app。</p>
<p>&#160; &#160; &#160; &#160;下面我们就继续跟着代码，分析VSync信号工作流程。</p>
<h1 id="VSync工作流程"><a href="#VSync工作流程" class="headerlink" title="VSync工作流程"></a>VSync工作流程</h1><h2 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h2><p>&#160; &#160; &#160; &#160;我们知道Vsync是android display系统的重要基石,其驱动android display系统不断的更新App侧的绘画,并把相关内容及时的更新到LCD上.其包含的主要代码如下:<br>&#160; &#160; &#160; &#160;frameworks\native\services\surfaceflinger\DispSync.cpp<br>&#160; &#160; &#160; &#160;frameworks\native\services\surfaceflinger\SurfaceFlinger.cpp<br>&#160; &#160; &#160; &#160;frameworks\native\services\surfaceflinger\SurfaceFlinger.cpp$DispSyncSource<br>&#160; &#160; &#160; &#160;frameworks\native\services\surfaceflinger\EventThread.cpp<br>&#160; &#160; &#160; &#160;frameworks\native\services\surfaceflinger\MessageQueue.cpp<br>&#160; &#160; &#160; &#160;frameworks\native\libs\gui\BitTube.cpp<br>&#160; &#160; &#160; &#160;frameworks\native\libs\gui\BufferQueueProducer.cpp</p>
<ul>
<li>DispSync.cpp：这个class包含了DispSyncThread，是SW-SYNC的心脏，所有的SW-SYNCevent均由其产生。在Android系统中,只有一个DispSync；</li>
<li>SurfaceFlinger.cpp：这个类主要处理layer的合成，它合成好相关的layer后发送command给HW display进行进行显示；</li>
<li>DispSyncSource：Vsync source 在Android系统中有两个instance，一是Vsync-app，另一个Vsync-sf。当SW-SYNC发生时，Vsyncsource会callback到其相应的EventThread，并且会在Systrace上显示出Vsync-sf和Vsync-app的跳变；</li>
<li>EventThread.cpp：Vsync event处理线程，在系统中有两个EventThread，一个用于Vsync-app，另一个用于Vsync-sf。其记录App和SurfaceFlinger的requestnextVsync()请求，当SW-VSYNCevent触发时，EventThread线程通过BitTube通知App或SurfaceFlinger，App开始drawview，SurfaceFlinger 开始合成 dirty layer；</li>
<li>MessageQueue.cpp：MessageQueue 主要处理surfaceflinger的Vsync请求和发生Vsync事件给surfaceFlinger；</li>
<li>BitTube.cpp：Vsync 事件的传输通道。App或Surfaceflinger首先与EventThread建立DisplayEventConnection(EventThread::Connection::Connection,Connection 是BnDisplayEventConnection子类，BitTube是其dataChannel)。App或surfaceFlinger通过call DisplayEventConnection::requestNextVsync()(binder 通信)向EventThread请求Vsync event，当EventThread收到SW-VSYNCevent时，其通过BitTube把Vsync evnet发送给App或SufaceFlinger；</li>
<li>BufferQueueProducer.cpp：在Vsync架构中，其主要作用是向EventThread请求Vsync-sfevent。当App画完一个frame后，其会把画完的buffer放到bufferqueue中通过call BufferQueueProducer::queueBuffer()，进而surfaceflinger进程会通过call DisplayEventConnection:: requestNextVsync()向EventThread请求Vsync event。</li>
</ul>
<p>&#160; &#160; &#160; &#160;Vsyncevent产生的示意图如下：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/vsyncmake.jpg" alt="vsync产生"></p>
<p>&#160; &#160; &#160; &#160;App需要draw一个frame时，其会向EventThread(appEventThread)请求Vysncevent，当EventThread收到Vsync event时，EventThread通过BitTueb把Vsync event通知到App，同时跳变systrace中的Vsync-app。App收到Vsync-app，开始draw frame。当App画完一个frame后，把画好的内容放到bufferqueue中，就会要求一个Vsync-sf event，以便surfaceflinger在收到Vsync-sf event时合成相关的dirty的内容并通知DisplayHW。Display HW 会在下一个HWvsync时间点，把相关的内容更新到LCD上完成内容的更新。</p>
<p>&#160; &#160; &#160; &#160;下面是其大概的流程图：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/vsyncall.png" alt="Vsync时序图"></p>
<ol>
<li>(SF-1)APP 画完一个frame以后,就会把其绘画的buffer放到buffer queue中.从生产者和消费者的关系来看,App是生产者,surfaceflinger进程是消费者.</li>
<li>(SF-2)在SurfaceFlinger 进程内,当收到有更新的可用的frame时(需要render到LCD ),就会向EventThread请求Vsync event(requestNextVsync()).EventThread会记录下此请求,当下次Vsync event到来时,便会triggerVsync-sf event.</li>
<li>DispSync 不断产生SW-VSYNCEVENT.当SW-VSYNCEVENT产生时,会检查是否有EventListener关心该event(SF和APP请求Vsync 时会在DispSync中创建EventListener并把其相应的DispSyncSource作为EventListener的callback),如有则调用EventListenercallback(DispSyncSource)的onDispSyncEvent.(callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime)).</li>
<li>DispSyncSource会引起Vsync-sf或Vsync-app跳变,当onDispSyncEvent()被调用时,并且会直接调用EventThread的onVSyncEvent().</li>
<li>EventThread会把Vsync-sf或Vsync-app event通知到App或surfaceFlinger当Vsync-sfevent产生时(callonDispSyncEvent),surfaceflinger进程合成dirty layer的内容(SF-5)并通知Display HW把相关的更新到LCD上.App则在Vsync-ap时开始drawview.</li>
<li>Display HW 便会在HW 的vsync 到来时,更新LCD 的内容(SF-6).</li>
<li>如果有Layer 的内容需要更新,surfaceflinger 便会把相关内容合成在一起,并且通知DisplayHW ,有相关的更新内容.</li>
</ol>
<h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><p>&#160; &#160; &#160; &#160;我们来看看其代码的实现，继续回到SurfaceFlinger.cpp中的init函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">    mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);</span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">    mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc);</span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line"></span><br><span class="line">    mEventControlThread = <span class="keyword">new</span> EventControlThread(<span class="keyword">this</span>);</span><br><span class="line">    mEventControlThread-&gt;run(<span class="string">"EventControl"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set a fake vsync period if there is no HWComposer</span></span><br><span class="line">    <span class="keyword">if</span> (mHwc-&gt;initCheck() != NO_ERROR) &#123;</span><br><span class="line">        mPrimaryDispSync.setPeriod(<span class="number">16666667</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;当surfaceFlinger初始化时，其创建了两个DispSyncSource和两个EventThread，一个用于APP，而另一个用于SurfaceFlinger本身。我们知道DispSyncSource和DispSync协同工作，共同完成Vsyncevent的fire。而EventThread会trigger App draw frame和surfaceFlinger合成”dirty” layer在SW-VSYNCevent产生时。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/vsyncsf.jpg" alt="vsyncsf"></p>
<p>&#160; &#160; &#160; &#160;上面图形是Vsync信号从产生到驱动SF去工作的一个过程，其中绿色部分是HWC中的Vsync信号软件模拟进程，其他都是SF中的：<br>&#160; &#160; &#160; &#160;其中包含4个线程，EventControlThread，就像是Vsync信号产生的闸刀，当然闸刀肯定需要人去打开和关闭，这个人就是SF；<br>&#160; &#160; &#160; &#160;VsyncThread，下面的代码只介绍软件模拟的Vsync信号，这个线程主要工作就是循环定期产生信号，然后调用SF中的函数，这就相当于触发了；<br>&#160; &#160; &#160; &#160;DispSyncThread，是Vsync信号的模型，VsyncThread首先触发DispSyncThread，然后DispSyncThread再去驱动其他事件，它就是Vsync在SF中的代表；<br>&#160; &#160; &#160; &#160;EventThread，具体的事件线程，由DispSyncThread去驱动。</p>
<p>&#160; &#160; &#160; &#160;我们接下来根据Vsync-sf先关分析一下流程。</p>
<h3 id="DispSync和DispSyncThread"><a href="#DispSync和DispSyncThread" class="headerlink" title="DispSync和DispSyncThread"></a>DispSync和DispSyncThread</h3><p>&#160; &#160; &#160; &#160;从上面SurfaceFlinger的init函数中，在构造DispSyncSource会传入一个mPrimaryDispSync的引用，它是SF类中有一个field为DispSync mPrimaryDispSync，因此在SF类创建时会在栈上生成这个对象。我们首先看看这个类的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DispSync::DispSync() :</span><br><span class="line">        mRefreshSkipCount(<span class="number">0</span>),</span><br><span class="line">        mThread(<span class="keyword">new</span> DispSyncThread()) &#123;</span><br><span class="line">    <span class="comment">//创建DispSyncThread线程，并运行</span></span><br><span class="line">    mThread-&gt;run(<span class="string">"DispSync"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">    <span class="comment">//清除一些变量为0</span></span><br><span class="line">    reset();</span><br><span class="line">    beginResync();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在DispSync 构造函数中，创建了DispSyncThread线程，并运行。DispSyncThread实现也位于DispSync.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DispSyncThread():</span><br><span class="line">        mStop(<span class="literal">false</span>),</span><br><span class="line">        mPeriod(<span class="number">0</span>),</span><br><span class="line">        mPhase(<span class="number">0</span>),</span><br><span class="line">        mWakeupLatency(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里面将mStop设置为false，mPeriod设置为0，还有其他的也置为0。因为DispSyncThread是Thread派生的，所以我们需要看看它的线程函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextEventTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;<span class="comment">//false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;<span class="comment">//0</span></span><br><span class="line">                <span class="comment">//mCond阻塞，当signal，同时mPeriod 不为0时，继续往下执行，</span></span><br><span class="line">                err = mCond.wait(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"error waiting for new events: %s (%d)"</span>,</span><br><span class="line">                            strerror(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算下一次vsync信号时间时间</span></span><br><span class="line">            nextEventTime = computeNextEventTimeLocked(now);</span><br><span class="line">            targetTime = nextEventTime;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> isWakeup = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//如果还没到下一次vsync时间，则等待中间间隔时间</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line">                err = mCond.waitRelative(mMutex, targetTime - now);</span><br><span class="line">                <span class="comment">//等待超时，则唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (err == TIMED_OUT) &#123;</span><br><span class="line">                    isWakeup = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"error waiting for next event: %s (%d)"</span>,</span><br><span class="line">                            strerror(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            <span class="comment">//唤醒触发</span></span><br><span class="line">            <span class="keyword">if</span> (isWakeup) &#123;</span><br><span class="line">                <span class="comment">//如果唤醒了，则计算Latency，如果Latency大于500000则强制Latency为500000</span></span><br><span class="line">                mWakeupLatency = ((mWakeupLatency * <span class="number">63</span>) +</span><br><span class="line">                        (now - targetTime)) / <span class="number">64</span>;</span><br><span class="line">                <span class="keyword">if</span> (mWakeupLatency &gt; <span class="number">500000</span>) &#123;</span><br><span class="line">                    <span class="comment">// Don't correct by more than 500 us</span></span><br><span class="line">                    mWakeupLatency = <span class="number">500000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                    ATRACE_INT64(<span class="string">"DispSync:WakeupLat"</span>, now - nextEventTime);</span><br><span class="line">                    ATRACE_INT64(<span class="string">"DispSync:AvgWakeupLat"</span>, mWakeupLatency);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//gatherCallbackInvocationsLocked函数获取本次VSync信号的回调函数列表</span></span><br><span class="line">            <span class="comment">//些回调函数是通过DispSync类的addEventListener函数加入的</span></span><br><span class="line">            callbackInvocations = gatherCallbackInvocationsLocked(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接着就调用fireCallbackInvocations来依次调用列表中所有对象的onDispSyncEvent函数</span></span><br><span class="line">        <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fireCallbackInvocations(callbackInvocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DispSyncThread的threadLoop函数，主要这个函数比较计算时间来决定是否要发送信号。主要工作如下：<br>&#160; &#160; &#160; &#160;1. 模型线程DispSyncThread阻塞在mCond，等待别人给mPeriod 赋值和signal；<br>&#160; &#160; &#160; &#160;2. gatherCallbackInvocationsLocked函数获取本次VSync信号的回调函数列表，这些回调函数是通过DispSync类的addEventListener函数加入的；<br>&#160; &#160; &#160; &#160;3. 接着就调用fireCallbackInvocations来依次调用列表中所有对象的onDispSyncEvent函数。</p>
<p>&#160; &#160; &#160; &#160;<strong>新建的DispSyncThread线程，目前被<code>阻塞</code></strong>，先不管，我们先看模型DispSync和要驱动的事件(DispSyncSource，EventThread等)是如何联系起来的。</p>
<h3 id="DispSyncSource和EventThread"><a href="#DispSyncSource和EventThread" class="headerlink" title="DispSyncSource和EventThread"></a>DispSyncSource和EventThread</h3><p>&#160; &#160; &#160; &#160;在SF的init函数中，有如下代码，涉及到了DispSync，DispSyncSource，EventThread和mEventQueue的纠缠关系。我们可以看到在驱动事件DispSyncSource的构造中，我们输入了模型DispSync，这样就为回调创造了机会，下面看具体如何实现的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// start the EventThread</span></span><br><span class="line">        <span class="comment">//把模型mPrimaryDispSync(DispSync)保存在DispSyncSource中</span></span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">    mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc);</span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">    mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc);</span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个我们分布分析：<br>&#160; &#160; &#160; &#160;1）先看下DispSyncSource对象的建立，其实这个对象从名字上看就是模型所驱动的事件。我们看看它的构造函数，也位于SurfaceFlinger.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DispSyncSource(DispSync* dispSync, <span class="keyword">nsecs_t</span> phaseOffset, <span class="keyword">bool</span> traceVsync,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* label) :</span><br><span class="line">        mValue(<span class="number">0</span>),</span><br><span class="line">        mPhaseOffset(phaseOffset),</span><br><span class="line">        mTraceVsync(traceVsync),</span><br><span class="line">        mVsyncOnLabel(String8::format(<span class="string">"VsyncOn-%s"</span>, label)),</span><br><span class="line">        mVsyncEventLabel(String8::format(<span class="string">"VSYNC-%s"</span>, label)),</span><br><span class="line">        mDispSync(dispSync) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造函数中主要设置了模型mDispSync(dispSync)，以及触发时间的偏移量mPhaseOffset(phaseOffset)。这个实参vsyncPhaseOffsetNs和sfVsyncPhaseOffsetNs定义如下，也位于SurfaceFlinger.cpp中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the phase offset in nanoseconds of the software vsync event</span></span><br><span class="line"><span class="comment">// relative to the vsync event reported by HWComposer.  The software vsync</span></span><br><span class="line"><span class="comment">// event is when SurfaceFlinger and Choreographer-based applications run each</span></span><br><span class="line"><span class="comment">// frame.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This phase offset allows adjustment of the minimum latency from application</span></span><br><span class="line"><span class="comment">// wake-up (by Choregographer) time to the time at which the resulting window</span></span><br><span class="line"><span class="comment">// image is displayed.  This value may be either positive (after the HW vsync)</span></span><br><span class="line"><span class="comment">// or negative (before the HW vsync).  Setting it to 0 will result in a</span></span><br><span class="line"><span class="comment">// minimum latency of two vsync periods because the app and SurfaceFlinger</span></span><br><span class="line"><span class="comment">// will run just after the HW vsync.  Setting it to a positive number will</span></span><br><span class="line"><span class="comment">// result in the minimum latency being:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     (2 * VSYNC_PERIOD - (vsyncPhaseOffsetNs % VSYNC_PERIOD))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that reducing this latency makes it more likely for the applications</span></span><br><span class="line"><span class="comment">// to not have their window content image ready in time.  When this happens</span></span><br><span class="line"><span class="comment">// the latency will end up being an additional vsync period, and animations</span></span><br><span class="line"><span class="comment">// will hiccup.  Therefore, this latency should be tuned somewhat</span></span><br><span class="line"><span class="comment">// conservatively (or at least with awareness of the trade-off being made).</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int64_t</span> vsyncPhaseOffsetNs = VSYNC_EVENT_PHASE_OFFSET_NS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the phase offset at which SurfaceFlinger's composition runs.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int64_t</span> sfVsyncPhaseOffsetNs = SF_VSYNC_EVENT_PHASE_OFFSET_NS;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个phase就是用来调节vsync信号latency 时间，其定义我也是搜了整个工程才找到如下定义：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/phasecatch.png" alt="phase"></p>
<p>&#160; &#160; &#160; &#160;generic版本中phase-app为0，phase-sf为5000000。（不知道对不对=。=）</p>
<p>&#160; &#160; &#160; &#160;2）我们继续往下看，mSFEventThread = new EventThread(sfVsyncSrc);先看看EventThread的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EventThread::EventThread(<span class="keyword">const</span> sp&lt;VSyncSource&gt;&amp; src)</span><br><span class="line">    : mVSyncSource(src),</span><br><span class="line">      mUseSoftwareVSync(<span class="literal">false</span>),<span class="comment">//软vsync初始为false</span></span><br><span class="line">      mVsyncEnabled(<span class="literal">false</span>),<span class="comment">//vsync使能初始为false</span></span><br><span class="line">      mDebugVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mVsyncHintSent(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">//i&lt;2,只遍历主屏幕和扩展屏幕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        mVSyncEvent[i].header.id = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].vsync.count =  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> sigevent se;</span><br><span class="line">    se.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    se.sigev_value.sival_ptr = <span class="keyword">this</span>;</span><br><span class="line">    se.sigev_notify_function = vsyncOffCallback;</span><br><span class="line">    se.sigev_notify_attributes = <span class="literal">NULL</span>;</span><br><span class="line">    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;EventThread是Thread的派生类，还是RefBase的间接派生类，所以我们需要产看它的onFirstRef函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::onFirstRef() &#123;</span><br><span class="line">    run(<span class="string">"EventThread"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;将这个线程启动了起来，那么我们需要看下线程循环函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    <span class="comment">//等待事件到来</span></span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...</span></span><br><span class="line">    <span class="comment">//把事件分发给listener</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        <span class="comment">// now see if we still need to report this event</span></span><br><span class="line">        <span class="comment">//然后调用每个连接的postEvent来发送Event</span></span><br><span class="line">        <span class="keyword">status_t</span> err = conn-&gt;postEvent(event);</span><br><span class="line">        <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="comment">// The destination doesn't accept events anymore, it's probably</span></span><br><span class="line">            <span class="comment">// full. For now, we just drop the events on the floor.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> Note that some events cannot be dropped and would have</span></span><br><span class="line">            <span class="comment">// to be re-sent later.</span></span><br><span class="line">            <span class="comment">// Right-now we don't have the ability to do this.</span></span><br><span class="line">            ALOGW(<span class="string">"EventThread: dropping event (%08x) for connection %p"</span>,</span><br><span class="line">                    event.header.type, conn.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// handle any other error on the pipe as fatal. the only</span></span><br><span class="line">            <span class="comment">// reasonable thing to do is to clean-up this connection.</span></span><br><span class="line">            <span class="comment">// The most common error we'll get here is -EPIPE.</span></span><br><span class="line">            removeDisplayEventConnection(signalConnections[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个线程函数里面主要做了三件事：<br>&#160; &#160; &#160; &#160;1. 调用waitForEvent等待事件到来；<br>&#160; &#160; &#160; &#160;2. 把事件分发给listener；<br>&#160; &#160; &#160; &#160;3. 然后调用每个连接的postEvent来发送Event。</p>
<p>&#160; &#160; &#160; &#160;我们分部查看，先看看waitForEvent实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line"><span class="comment">// This will return when (1) a vsync event has been received, and (2) there was</span></span><br><span class="line"><span class="comment">// at least one connection interested in receiving it when we started waiting.</span></span><br><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">bool</span> eventPending = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> waitForVSync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> vsyncCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">nsecs_t</span> timestamp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//上面初始化EventThread时候，都是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                <span class="comment">// we have a vsync event to dispatch</span></span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timestamp) &#123;<span class="comment">//0</span></span><br><span class="line">            <span class="comment">// no vsync event, see if there are some other event</span></span><br><span class="line">            eventPending = !mPendingEvents.isEmpty();</span><br><span class="line">            <span class="keyword">if</span> (eventPending) &#123;<span class="comment">//初始时候为false</span></span><br><span class="line">                <span class="comment">// we have some other event to dispatch</span></span><br><span class="line">                *event = mPendingEvents[<span class="number">0</span>];</span><br><span class="line">                mPendingEvents.removeAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find out connections waiting for events</span></span><br><span class="line">        <span class="comment">//// 初始也是空的 SortedVector&lt; wp&lt;Connection&gt; &gt; mDisplayEventConnections;</span></span><br><span class="line">        <span class="keyword">size_t</span> count = mDisplayEventConnections.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection(mDisplayEventConnections[i].promote());</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> added = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// we need vsync events because at least</span></span><br><span class="line">                    <span class="comment">// one connection is waiting for it</span></span><br><span class="line">                    waitForVSync = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                        <span class="comment">// we consume the event only if it's time</span></span><br><span class="line">                        <span class="comment">// (ie: we received a vsync event)</span></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line">                            connection-&gt;count = <span class="number">-1</span>;</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> ||</span><br><span class="line">                                (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    <span class="comment">// we don't have a vsync event to process</span></span><br><span class="line">                    <span class="comment">// (timestamp==0), but we have some pending</span></span><br><span class="line">                    <span class="comment">// messages.</span></span><br><span class="line">                    signalConnections.add(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we couldn't promote this reference, the connection has</span></span><br><span class="line">                <span class="comment">// died, so clean-up!</span></span><br><span class="line">                mDisplayEventConnections.removeAt(i);</span><br><span class="line">                --i; --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we figure out if we need to enable or disable vsyncs</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// we received a VSYNC but we have no clients</span></span><br><span class="line">            <span class="comment">// don't report it, and disable VSYNC events</span></span><br><span class="line">            disableVSyncLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// we have at least one client, so we want vsync enabled</span></span><br><span class="line">            <span class="comment">// (<span class="doctag">TODO:</span> this function is called right after we finish</span></span><br><span class="line">            <span class="comment">// notifying clients of a vsync, so this call will be made</span></span><br><span class="line">            <span class="comment">// at the vsync rate, e.g. 60fps.  If we can accurately</span></span><br><span class="line">            <span class="comment">// track the current state we could avoid making this call</span></span><br><span class="line">            <span class="comment">// so often.)</span></span><br><span class="line">            enableVSyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note: !timestamp implies signalConnections.isEmpty(), because we</span></span><br><span class="line">        <span class="comment">// don't populate signalConnections if there's no vsync pending</span></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            <span class="comment">// wait for something to happen</span></span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123;</span><br><span class="line">                <span class="comment">// This is where we spend most of our time, waiting</span></span><br><span class="line">                <span class="comment">// for vsync events and new client registrations.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// If the screen is off, we can't use h/w vsync, so we</span></span><br><span class="line">                <span class="comment">// use a 16ms timeout instead.  It doesn't need to be</span></span><br><span class="line">                <span class="comment">// precise, we just need to keep feeding our clients.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// We don't want to stall if there's a driver bug, so we</span></span><br><span class="line">                <span class="comment">// use a (long) timeout when waiting for h/w vsync, and</span></span><br><span class="line">                <span class="comment">// generate fake events when necessary.</span></span><br><span class="line">                <span class="keyword">bool</span> softwareSync = mUseSoftwareVSync;</span><br><span class="line">                <span class="keyword">nsecs_t</span> timeout = softwareSync ? ms2ns(<span class="number">16</span>) : ms2ns(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!softwareSync) &#123;</span><br><span class="line">                        ALOGW(<span class="string">"Timed out waiting for hw vsync; faking it"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> how do we decide which display id the fake</span></span><br><span class="line">                    <span class="comment">// vsync came from ?</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Nobody is interested in vsync, so we just want to sleep.</span></span><br><span class="line">                <span class="comment">// h/w vsync should be disabled, so this will wait until we</span></span><br><span class="line">                <span class="comment">// get a new connection, or an existing connection becomes</span></span><br><span class="line">                <span class="comment">// interested in receiving vsync again.</span></span><br><span class="line">                <span class="comment">//所以EventThread初始的时候会在这阻塞</span></span><br><span class="line">                mCondition.wait(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (signalConnections.isEmpty());</span><br><span class="line">    <span class="comment">//因为mCondition有可能异常返回，所以要看下这个while，就知道何时mCondition被正常的signal</span></span><br><span class="line">    <span class="comment">//如果signalConnections不为空了，这时候就会从while中退出来</span></span><br><span class="line">    <span class="comment">//也就是上面的mDisplayEventConnections有东西了</span></span><br><span class="line">    <span class="comment">// here we're guaranteed to have a timestamp and some connections to signal</span></span><br><span class="line">    <span class="comment">// (The connections might have dropped out of mDisplayEventConnections</span></span><br><span class="line">    <span class="comment">// while we were asleep, but we'll still have strong references to them.)</span></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;waitForEvent函数中下面代码段，timestamp为0表示没有时间，waitForSync为true表示至少有一个客户和EventThread建立了连接。这段代码一旦有客户连接，就调用enableVSyncLocked接收DispSyncSource的VSync信号。如果在接受信号中，所有客户都断开了连接，则调用disableVSyncLocked函数停止接受DispSyncSource对象的信号。</p>
<p>&#160; &#160; &#160; &#160;<strong>虽然代码量有些多，但是我们是初始化时候，所以省去了很多判断逻辑。</strong>因此主要工作就不多了，主要如下：<br>&#160; &#160; &#160; &#160;①初始的时候，mCondition会阻塞；<br>&#160; &#160; &#160; &#160;② 因为mCondition有可能异常返回，所以要看下外围的while循环，就知道何时mCondition会被signal。即使mCondition异常返回，也会再去判断signalConnections是否为空。空的话继续阻塞，如果signalConnections不为空了，这时候就会从while中退出来，也就是上面的mDisplayEventConnections有东西了。所以mDisplayEventConnections需要留意何时赋值啦。</p>
<p>&#160; &#160; &#160; &#160;至此，<strong>创建了一个mSFEventThread = new EventThread(sfVsyncSrc);，也<code>阻塞</code>着了</strong>。。</p>
<p>&#160; &#160; &#160; &#160;至于下面的 2. 把事件分发给listener；3. 然后调用每个连接的postEvent来发送Event。这两个步骤我们下面会讲到，这里先不看它。</p>
<p>&#160; &#160; &#160; &#160;3）从上面得知在DsipSync里面创建的DispSyncThread线程阻塞等待着；还有上面的EventThread线程，也阻塞等待了。<br>&#160; &#160; &#160; &#160;下面我们继续看mEventQueue.setEventThread(mSFEventThread);会不会解除阻塞。这里EventThread和SF主线程的MessageQueue又纠缠到了一起：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::setEventThread(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">&#123;</span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    <span class="comment">//SF与EventThread建立连接</span></span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();</span><br><span class="line">    <span class="comment">//创建通信通道</span></span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();</span><br><span class="line">    <span class="comment">//Looper连接通道，进行消息循环</span></span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们依然分部查看：<br>&#160; &#160; &#160; &#160;1. 首先， eventThread-&gt;createEventConnection()，新建了一个Connection对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Connection对象如下图所示:</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/Connection.jpg" alt="Connection"></p>
<p>&#160; &#160; &#160; &#160;Connection中保存了了一个EventThread对象，和一个生成的BitTube对象mChannel，下面看下Connection的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventThread::Connection::Connection(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;调用了BitTube的无参构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BitTube::BitTube()</span><br><span class="line">    : mSendFd(<span class="number">-1</span>), mReceiveFd(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    init(DEFAULT_SOCKET_BUFFER_SIZE, DEFAULT_SOCKET_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造函数里调用了init函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BitTube::init(<span class="keyword">size_t</span> rcvbuf, <span class="keyword">size_t</span> sndbuf) &#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;</span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="keyword">sizeof</span>(rcvbuf));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line">        <span class="comment">// sine we don't use the "return channel", we keep it small...</span></span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        fcntl(sockets[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        fcntl(sockets[<span class="number">1</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        mReceiveFd = sockets[<span class="number">0</span>];</span><br><span class="line">        mSendFd = sockets[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mReceiveFd = -errno;</span><br><span class="line">        ALOGE(<span class="string">"BitTube: pipe creation failed (%s)"</span>, strerror(-mReceiveFd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;建立一个域套接字，用fcntl设置成非阻塞模式，然后两个fd，一个读一个写，mSendFd和mReceiveFd。</p>
<p>&#160; &#160; &#160; &#160;我们上面创建一个Connection，但是又是一个sp指针，所以就得看看它的onFirstRef函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::Connection::onFirstRef() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn't hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里又调用EventThread的registerDisplayEventConnection函数，我们继续查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventThread::registerDisplayEventConnection(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">//把connection添加到mDisplayEventConnections</span></span><br><span class="line">    mDisplayEventConnections.add(connection);</span><br><span class="line">    <span class="comment">//mCondition解除</span></span><br><span class="line">    mCondition.broadcast();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;前面提到，EventThread一直阻塞在waitForEvent中，正是这个mCondition，这里也对mDisplayEventConnections添加了东西，不为空了。<br>&#160; &#160; &#160; &#160;为了方便分析，我们再把前面的waitForEvent函数列出来，这次就是另一套逻辑了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will return when (1) a vsync event has been received, and (2) there was</span></span><br><span class="line"><span class="comment">// at least one connection interested in receiving it when we started waiting.</span></span><br><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEvent(</span><br><span class="line">        DisplayEventReceiver::Event* event)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">bool</span> eventPending = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> waitForVSync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> vsyncCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">nsecs_t</span> timestamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                <span class="comment">// we have a vsync event to dispatch</span></span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timestamp) &#123;<span class="comment">//这次这里还是0</span></span><br><span class="line">            <span class="comment">// no vsync event, see if there are some other event</span></span><br><span class="line">            eventPending = !mPendingEvents.isEmpty();</span><br><span class="line">            <span class="keyword">if</span> (eventPending) &#123;</span><br><span class="line">                <span class="comment">// we have some other event to dispatch</span></span><br><span class="line">                *event = mPendingEvents[<span class="number">0</span>];</span><br><span class="line">                mPendingEvents.removeAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find out connections waiting for events</span></span><br><span class="line">        <span class="comment">//有东西了，就是保存的Connection</span></span><br><span class="line">        <span class="keyword">size_t</span> count = mDisplayEventConnections.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection(mDisplayEventConnections[i].promote());</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> added = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// we need vsync events because at least</span></span><br><span class="line">                    <span class="comment">// one connection is waiting for it</span></span><br><span class="line">                    waitForVSync = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                        <span class="comment">// we consume the event only if it's time</span></span><br><span class="line">                        <span class="comment">// (ie: we received a vsync event)</span></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line">                            connection-&gt;count = <span class="number">-1</span>;</span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> ||</span><br><span class="line">                                (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line">                            signalConnections.add(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    <span class="comment">// we don't have a vsync event to process</span></span><br><span class="line">                    <span class="comment">// (timestamp==0), but we have some pending</span></span><br><span class="line">                    <span class="comment">// messages.</span></span><br><span class="line">                    signalConnections.add(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we couldn't promote this reference, the connection has</span></span><br><span class="line">                <span class="comment">// died, so clean-up!</span></span><br><span class="line">                mDisplayEventConnections.removeAt(i);</span><br><span class="line">                --i; --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we figure out if we need to enable or disable vsyncs</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;<span class="comment">//0 true</span></span><br><span class="line">            <span class="comment">// we received a VSYNC but we have no clients</span></span><br><span class="line">            <span class="comment">// don't report it, and disable VSYNC events</span></span><br><span class="line">            disableVSyncLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;<span class="comment">//所以走到了这里</span></span><br><span class="line">            <span class="comment">// we have at least one client, so we want vsync enabled</span></span><br><span class="line">            <span class="comment">// (<span class="doctag">TODO:</span> this function is called right after we finish</span></span><br><span class="line">            <span class="comment">// notifying clients of a vsync, so this call will be made</span></span><br><span class="line">            <span class="comment">// at the vsync rate, e.g. 60fps.  If we can accurately</span></span><br><span class="line">            <span class="comment">// track the current state we could avoid making this call</span></span><br><span class="line">            <span class="comment">// so often.)</span></span><br><span class="line">            <span class="comment">//这次走到了这里</span></span><br><span class="line">            enableVSyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note: !timestamp implies signalConnections.isEmpty(), because we</span></span><br><span class="line">        <span class="comment">// don't populate signalConnections if there's no vsync pending</span></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;<span class="comment">//0 false</span></span><br><span class="line">            <span class="comment">// wait for something to happen</span></span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123;<span class="comment">//true</span></span><br><span class="line">                <span class="comment">// This is where we spend most of our time, waiting</span></span><br><span class="line">                <span class="comment">// for vsync events and new client registrations.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// If the screen is off, we can't use h/w vsync, so we</span></span><br><span class="line">                <span class="comment">// use a 16ms timeout instead.  It doesn't need to be</span></span><br><span class="line">                <span class="comment">// precise, we just need to keep feeding our clients.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// We don't want to stall if there's a driver bug, so we</span></span><br><span class="line">                <span class="comment">// use a (long) timeout when waiting for h/w vsync, and</span></span><br><span class="line">                <span class="comment">// generate fake events when necessary.</span></span><br><span class="line">                <span class="keyword">bool</span> softwareSync = mUseSoftwareVSync;</span><br><span class="line">                <span class="keyword">nsecs_t</span> timeout = softwareSync ? ms2ns(<span class="number">16</span>) : ms2ns(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!softwareSync) &#123;</span><br><span class="line">                        ALOGW(<span class="string">"Timed out waiting for hw vsync; faking it"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> how do we decide which display id the fake</span></span><br><span class="line">                    <span class="comment">// vsync came from ?</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Nobody is interested in vsync, so we just want to sleep.</span></span><br><span class="line">                <span class="comment">// h/w vsync should be disabled, so this will wait until we</span></span><br><span class="line">                <span class="comment">// get a new connection, or an existing connection becomes</span></span><br><span class="line">                <span class="comment">// interested in receiving vsync again.</span></span><br><span class="line">                mCondition.wait(mLock);<span class="comment">//这个之前的wait已经解开了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (signalConnections.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here we're guaranteed to have a timestamp and some connections to signal</span></span><br><span class="line">    <span class="comment">// (The connections might have dropped out of mDisplayEventConnections</span></span><br><span class="line">    <span class="comment">// while we were asleep, but we'll still have strong references to them.)</span></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;所以在waitEvent里，这次的逻辑和上次不同了，主要是一下几点：<br>&#160; &#160; &#160; &#160;①建立Connection后，mCondition返回了；<br>&#160; &#160; &#160; &#160;②这里timestamp 还是0 ;<br>&#160; &#160; &#160; &#160;③mDisplayEventConnections非空了，将waitForVSync = true;<br>&#160; &#160; &#160; &#160;④所以会执行到enableVSyncLocked();。</p>
<p>&#160; &#160; &#160; &#160;那么我们看看enableVSyncLocked函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::enableVSyncLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mUseSoftwareVSync) &#123;<span class="comment">//false</span></span><br><span class="line">        <span class="comment">// never enable h/w VSYNC when screen is off</span></span><br><span class="line">        <span class="keyword">if</span> (!mVsyncEnabled) &#123;<span class="comment">//false</span></span><br><span class="line">            mVsyncEnabled = <span class="literal">true</span>;<span class="comment">//将mVsyncEnabled 置为true</span></span><br><span class="line">            <span class="comment">//DispSyncSource的setCallback，把mCallback设置为EventThread</span></span><br><span class="line">            mVSyncSource-&gt;setCallback(<span class="keyword">static_cast</span>&lt;VSyncSource::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line">            <span class="comment">//调用DispSyncSource的setVSyncEnabled</span></span><br><span class="line">            mVSyncSource-&gt;setVSyncEnabled(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mDebugVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    sendVsyncHintOnLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个也分两步：<br>&#160; &#160; &#160; &#160;①将mVsyncEnabled 设为true，调用mVSyncSource-&gt;setCallback(static_cast<vsyncsource::callback*>(this));，this为EventThread，既是调用DispSyncSource的setCallback，把mCallback设置为EventThread：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">const</span> sp&lt;VSyncSource::Callback&gt;&amp; callback)</span> </span>&#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></vsyncsource::callback*></p>
<p>&#160; &#160; &#160; &#160;②调用mVSyncSource-&gt;setVSyncEnabled(true);，既是调用DispSyncSource的setVSyncEnabled：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setVSyncEnabled</span><span class="params">(<span class="keyword">bool</span> enable)</span> </span>&#123;<span class="comment">//true</span></span><br><span class="line">    <span class="comment">// Do NOT lock the mutex here so as to avoid any mutex ordering issues</span></span><br><span class="line">    <span class="comment">// with locking it in the onDispSyncEvent callback.</span></span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        <span class="comment">////在硬件模型mDispSync中添加addEventListener，一个参数为偏移量，一个为DispSyncSource</span></span><br><span class="line">        <span class="keyword">status_t</span> err = mDispSync-&gt;addEventListener(mPhaseOffset,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(<span class="string">"error registering vsync callback: %s (%d)"</span>,</span><br><span class="line">                    strerror(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ATRACE_INT(mVsyncOnLabel.string(), 1);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = mDispSync-&gt;removeEventListener(</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            ALOGE(<span class="string">"error unregistering vsync callback: %s (%d)"</span>,</span><br><span class="line">                    strerror(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ATRACE_INT(mVsyncOnLabel.string(), 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;从上面的代码可以看出，这里是将驱动事件DispSyncSource和硬件模型mDispSync建立起关系。既然调用了DispSync的addEventListener，那么我们就继续查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DispSync的addEventListener</span></span><br><span class="line"><span class="keyword">status_t</span> DispSync::addEventListener(<span class="keyword">nsecs_t</span> phase,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Callback&gt;&amp; callback) &#123;</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> mThread-&gt;addEventListener(phase, callback);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//DispSyncThread的addEventListener</span></span><br><span class="line">    <span class="keyword">status_t</span> addEventListener(<span class="keyword">nsecs_t</span> phase, <span class="keyword">const</span> sp&lt;DispSync::Callback&gt;&amp; callback) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mEventListeners[i].mCallback == callback) &#123;</span><br><span class="line">                <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventListener listener;</span><br><span class="line">        listener.mPhase = phase;</span><br><span class="line">        listener.mCallback = callback;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to allow the firstmost future event to fire without</span></span><br><span class="line">        <span class="comment">// allowing any past events to fire.  Because</span></span><br><span class="line">        <span class="comment">// computeListenerNextEventTimeLocked filters out events within a half</span></span><br><span class="line">        <span class="comment">// a period of the last event time, we need to initialize the last</span></span><br><span class="line">        <span class="comment">// event time to a half a period in the past.</span></span><br><span class="line">        listener.mLastEventTime = systemTime(SYSTEM_TIME_MONOTONIC) - mPeriod / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">////把listener放到mEventListeners中</span></span><br><span class="line">        mEventListeners.push(listener);</span><br><span class="line">        <span class="comment">////释放mCond</span></span><br><span class="line">        mCond.signal();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里可以看出，驱动事件DispSyncSource是硬件模型DispSync的“listener”，监听者，把两者联系了起来。并把DispSyncThread线程中的阻塞mCond解除，但是，前面我们分析过，还要mPeriod 非0。我们可以回顾一下上面的代码片段，DispSyncThread的threadLoop函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                    err = mCond.wait(mMutex);</span><br><span class="line">                    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                        ALOGE(<span class="string">"error waiting for new events: %s (%d)"</span>,</span><br><span class="line">                                strerror(-err), err);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;那么哪里给mPeriod 赋值呢？我们上面讲EventControlThread闸刀控制线程的时候，initializeDisplays()函数会被调用，最终会调用resyncToHardwareVsync函数，这个里面会获取mPeriod屏幕刷新率，然后给mPeriod 赋值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::resyncToHardwareVsync(<span class="keyword">bool</span> makeAvailable) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> period =</span><br><span class="line">            getHwComposer().getRefreshPeriod(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">    mPrimaryDispSync.reset();</span><br><span class="line">    mPrimaryDispSync.setPeriod(period);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后调用DispSync的setPeriod函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DispSync::setPeriod(<span class="keyword">nsecs_t</span> period) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;<span class="comment">//mPeriod 赋值后，已经不为0</span></span><br><span class="line">    mPhase = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//调用线程的更新模型函数</span></span><br><span class="line">    mThread-&gt;updateModel(mPeriod, mPhase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mPeriod 赋值后，已经不为0；然后调用线程的更新模型函数updateModel：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateModel</span><span class="params">(<span class="keyword">nsecs_t</span> period, <span class="keyword">nsecs_t</span> phase)</span> </span>&#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = phase;</span><br><span class="line">    <span class="comment">//mCond阻塞解除</span></span><br><span class="line">    mCond.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;至此，DispSync中设置了监听者DispSyncSource，mPeriod 也不为0，硬件模型线程不再阻塞，不阻塞就会去处理vsync事件，这个我们后面会讲。</p>
<p>&#160; &#160; &#160; &#160;经过调用mEvents = eventThread-&gt;createEventConnection();完成了一下几个功能：<br>&#160; &#160; &#160; &#160;①MessageQueue中保存了一个Connection，mEvents ；<br>&#160; &#160; &#160; &#160;②EventThread中保存了这个Connection，mDisplayEventConnections.add(connection);<br>&#160; &#160; &#160; &#160;③mVSyncSource-&gt;setCallback 把mCallback = callback 设置为EventThread；<br>&#160; &#160; &#160; &#160;④在mDispSync中注册listener， 放到DispSyncthread的mEventListeners中，这个listener的callback就是mVSyncSource。</p>
<p>&#160; &#160; &#160; &#160;2. 然后就是创建通信通道。接着继续MessageQueue::setEventThread()函数，调用mEventTube = mEvents-&gt;getDataChannel()。<br>&#160; &#160; &#160; &#160;mEvents类型为sp&lt; IDisplayEventConnection &gt; ;在上一步mEvents = eventThread-&gt;createEventConnection();返回的直接是Connection对象。Connection继承于BnDisplayEventConnection，BnDisplayEventConnection继承于BnInterface&lt; IDisplayEventConnection &gt;。因此我们找到bp端的getDataChannel函数，位于BpDisplayEventConnection类当中，继承于BpInterface&lt; IDisplayEventConnection &gt;位于frameworks/native/libs/gui/IDisplayEventConnection.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> sp&lt;BitTube&gt; getDataChannel() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(IDisplayEventConnection::getInterfaceDescriptor());</span><br><span class="line">    remote()-&gt;transact(GET_DATA_CHANNEL, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitTube(reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;相应的bn端位onTransact方法于也位于IDisplayEventConnection.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BnDisplayEventConnection::onTransact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        <span class="keyword">case</span> GET_DATA_CHANNEL: &#123;</span><br><span class="line">            CHECK_INTERFACE(IDisplayEventConnection, data, reply);</span><br><span class="line">            sp&lt;BitTube&gt; channel(getDataChannel());<span class="comment">//这个getDataChannel是Connection类的函数</span></span><br><span class="line">            channel-&gt;writeToParcel(reply);</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面那个getDataChannel是Connection类的函数，我们看看Connection的getDataChannel函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;BitTube&gt; EventThread::Connection::getDataChannel() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mChannel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mChannel就是我们在构造函数里面的new BitTube()。<br>&#160; &#160; &#160; &#160;这样mEventTube 中只包含了读fd，而mEvents这个connection中的mChannel只剩下写fd，两个依然是一对读写，，但是分开了，如下图所示：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/ConnectionTube.jpg" alt="ConnectionTube"></p>
<p>&#160; &#160; &#160; &#160;3.  继续调用，这里就是把mEventTube这个读tube注册到SF主线程的Looper中去，回调函数为MessageQueue::cb_eventReceiver：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT,</span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里用到了<a href="http://windrunnerlihuan.com/2016/07/31/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/">Android消息处理零散分析</a>的内容，如果忘记了，可以翻一翻。<br>&#160; &#160; &#160; &#160;因为注册了回调事件，因此我们需要查看MessageQueue::cb_eventReceiver函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::cb_eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    MessageQueue* <span class="built_in">queue</span> = <span class="keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后是eventReceiver函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::eventReceiver(<span class="keyword">int</span> <span class="comment">/*fd*/</span>, <span class="keyword">int</span> <span class="comment">/*events*/</span>) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INVALIDATE_ON_VSYNC <span class="comment">//1</span></span></span><br><span class="line">                mHandler-&gt;dispatchInvalidate();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                mHandler-&gt;dispatchRefresh();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里会从MessageQueue的读BitTube中读出event，然后调用mHandler-&gt;dispatchInvalidate():<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接收消息就是handleMessage函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION:</span><br><span class="line">            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;进而去调用SF的onMessageReceived函数，最终每次Vsync信号来了，SF都会去执行handleMessageTransaction()等函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::TRANSACTION:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        handleMessageInvalidate();</span><br><span class="line">        signalRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH:</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;至此我们对于vsync消息的准备逻辑工作都做完了。但是细心的读者应该发现了，我们还没有按正常流程处理一遍vsync信号，就是当vsync产生后，SurfaceFlinger的回调函数onVSyncReceived处理过程。接下来我们就分析一下这个过程。</p>
<h1 id="VSync信号处理"><a href="#VSync信号处理" class="headerlink" title="VSync信号处理"></a>VSync信号处理</h1><h2 id="矫正VSync时间"><a href="#矫正VSync时间" class="headerlink" title="矫正VSync时间"></a>矫正VSync时间</h2><p>&#160; &#160; &#160; &#160;我们再次借助上面那幅Vsync event产生的示意图：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/vsyncmake.jpg" alt="Vsync时序图"></p>
<p>&#160; &#160; &#160; &#160;这里HW_VSYNC就是HW_VSYNC_0。</p>
<p>&#160; &#160; &#160; &#160;当SF从HWComposer收到VSYNC(HW_VSYNC_0)时，会调用onVSyncReceived函数处理：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onVSyncReceived(<span class="keyword">int</span> type, <span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="keyword">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;<span class="comment">//将新的VSYNC时间交给DispSync</span></span><br><span class="line">            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;<span class="comment">//是否还需要vsync</span></span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disableHardwareVsync(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它会利用DispSync::addResyncSample将新的VSYNC时间交给DispSync。addResyncSample决定是否还需要HW_VSYNC的输入,如果不需要,就会将HW_VSYNC关掉。</p>
<p>&#160; &#160; &#160; &#160;然后我们继续查看DispSync::addResyncSample：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DispSync::addResyncSample(<span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="comment">//MAX_RESYNC_SAMPLES = 32</span></span><br><span class="line">    <span class="keyword">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    mResyncSamples[idx] = timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;</span><br><span class="line">        mNumResyncSamples++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFirstResyncSample = (mFirstResyncSample + <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个函数很重要，用来计算SW_VSYNC的值，直到误差小于threshold</span></span><br><span class="line">    updateModelLocked();</span><br><span class="line">    <span class="comment">//MAX_RESYNC_SAMPLES_WITHOUT_PRESENT = 12</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123;</span><br><span class="line">        resetErrorLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kIgnorePresentFences) &#123;</span><br><span class="line">        <span class="comment">// If we don't have the sync framework we will never have</span></span><br><span class="line">        <span class="comment">// addPresentFence called.  This means we have no way to know whether</span></span><br><span class="line">        <span class="comment">// or not we're synchronized with the HW vsyncs, so we just request</span></span><br><span class="line">        <span class="comment">// that the HW vsync events be turned on whenever we need to generate</span></span><br><span class="line">        <span class="comment">// SW vsync events.</span></span><br><span class="line">        <span class="keyword">return</span> mThread-&gt;hasAnyEventListeners();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mPeriod == <span class="number">0</span> || mError &gt; kErrorThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;DispSync是利用HW_VSYNC和PresentFence来判断是否需要开启HW_VSYNC。HW_VSYNC最少要3个，最多是32个，实际上要用几个则不一定，DispSync拿到3个HW_VSYNC后就会计算出SW_VSYNC，只要收到的PresentFence没有超过误差，则HW_VSYNC就会关掉，以便节省功耗.不然会继续开启HW_VSYNC计算SW_VSYNC的值，直到误差小于threshold。其计算的方法是DispSync::updateModelLocked()：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DispSync::updateModelLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> durationSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="keyword">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            durationSum += mResyncSamples[idx] - mResyncSamples[prev];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> sampleAvgX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> sampleAvgY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> scale = <span class="number">2.0</span> * M_PI / <span class="keyword">double</span>(mPeriod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="keyword">nsecs_t</span> sample = mResyncSamples[idx];</span><br><span class="line">            <span class="keyword">double</span> samplePhase = <span class="keyword">double</span>(sample % mPeriod) * scale;</span><br><span class="line">            sampleAvgX += <span class="built_in">cos</span>(samplePhase);</span><br><span class="line">            sampleAvgY += <span class="built_in">sin</span>(samplePhase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sampleAvgX /= <span class="keyword">double</span>(mNumResyncSamples);</span><br><span class="line">        sampleAvgY /= <span class="keyword">double</span>(mNumResyncSamples);</span><br><span class="line"></span><br><span class="line">        mPhase = <span class="keyword">nsecs_t</span>(<span class="built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPhase &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPhase += mPeriod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">            ATRACE_INT64(<span class="string">"DispSync:Period"</span>, mPeriod);</span><br><span class="line">            ATRACE_INT64(<span class="string">"DispSync:Phase"</span>, mPhase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Artificially inflate the period if requested.</span></span><br><span class="line">        mPeriod += mPeriod * mRefreshSkipCount;</span><br><span class="line"></span><br><span class="line">        mThread-&gt;updateModel(mPeriod, mPhase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;基本思想如下:</p>
<ol>
<li>计算目前收到HW_VSYNC间隔,取平均值(AvgPeriod) HW_VSYNC;</li>
<li>将每个收到的VSYNC时间与AvgPeriod算出误差. (Delta = Time %AvgPeriod);</li>
<li>将Delta转换成角度(DeltaPhase),如果AvgPeriod是360度,DeltaPhase = 2<em>PI</em>Delta/AvgPeriod;</li>
<li>从DeltaPhase可以得到DeltaX与DeltaY (DeltaX =cos(DeltaPhase), DeltaY = sin(DeltaPhase));</li>
<li>将每个收到的VSYNC的DeltaX与DeltaY取平均,可以得到AvgX与AvgY;</li>
<li>利用atan与AvgX, AvgY可以得到平圴的phase (AvgPhase);</li>
<li>AvgPeriod + AvgPhase就是SW_VSYNC。</li>
</ol>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/updatemodel.png" alt="updatemodel"></p>
<p>&#160; &#160; &#160; &#160;当DispSync收到addPresentFence时(最多记录8个sample)，每一个fence的时间算出(Time% AvgPeriod)的平方当作误差，将所有的Fence误差加总起来如果大于某个Threshold，就表示需要校正(DispSync::updateErrorLocked)。校正的方法是呼叫DispSync::beginResync()将所有的HW_VSYNC清掉,开启HW_VSYNC。等至少3个HW_VSYNC再重新计算。</p>
<h2 id="处理VSync消息"><a href="#处理VSync消息" class="headerlink" title="处理VSync消息"></a>处理VSync消息</h2><p>&#160; &#160; &#160; &#160;消息处理流程依然需要分步骤：<br>&#160; &#160; &#160; &#160;1）我们继续回到DispSync的threadLoop函数中，回顾上面的内容，因为在这里我们需要搜集vsync触发事件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">            ......</span><br><span class="line">            callbackInvocations = gatherCallbackInvocationsLocked(now);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                fireCallbackInvocations(callbackInvocations);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;mPeriod 不为0，也有signal，DispSyncThread线程不阻塞了，执行gatherCallbackInvocationsLocked(now)和fireCallbackInvocations(callbackInvocations)。我们先查看gatherCallbackInvocationsLocked函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(<span class="keyword">nsecs_t</span> now) &#123;</span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">    <span class="keyword">nsecs_t</span> ref = now - mPeriod;</span><br><span class="line">    <span class="comment">//这里的mEventListeners[i].mCallback都是驱动的事件DispSyncSource</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> t = computeListenerNextEventTimeLocked(mEventListeners[i],</span><br><span class="line">                ref);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;</span><br><span class="line">            CallbackInvocation ci;</span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line">            ci.mEventTime = t;</span><br><span class="line">            callbackInvocations.push(ci);</span><br><span class="line">            mEventListeners.editItemAt(i).mLastEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然后发送事件，fireCallbackInvocations函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireCallbackInvocations</span><span class="params">(<span class="keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;</span><br><span class="line">        <span class="comment">//这里的callbacks[i].mCallback，就是驱动的事件DispSyncSource</span></span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里会回调DispSyncSource的onDispSyncEvent函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDispSyncEvent</span><span class="params">(<span class="keyword">nsecs_t</span> when)</span> </span>&#123;</span><br><span class="line">    sp&lt;VSyncSource::Callback&gt; callback;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        callback = mCallback;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTraceVsync) &#123;</span><br><span class="line">            mValue = (mValue + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">            ATRACE_INT(mVsyncEventLabel.<span class="built_in">string</span>(), mValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">////这里的callback为EventThread</span></span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        callback-&gt;onVSyncEvent(when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;继续调用，这里已经从驱动事件，转化到驱动事件的线程EventThread中，填充EventThread的mVSyncEvent，因此我们查看onVSyncEvent函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::onVSyncEvent(<span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp;</span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">    mCondition.broadcast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里将mVSyncEvent事件相关属性复制，且threadLoop等待阻塞唤醒，以便往下继续执行。</p>
<p>&#160; &#160; &#160; &#160;2）EventThread的waitForEvent()，返回signalConnections，就是开始建立的Connection，这个Connection里面有个BitTube的写fd，另外的读fd在MessageQueue中。</p>
<p>&#160; &#160; &#160; &#160;此时我们回到上面没有讲的，当waitForEvent返回后，<strong>2. 把事件分发给listener；3. 然后调用每个连接的postEvent来发送Event。</strong>这两个步骤。<br>&#160; &#160; &#160; &#160;waitForEvent返回，调用conn-&gt;postEvent(event)，我们查看Connection的postEvent函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventThread::Connection::postEvent(</span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="keyword">status_t</span>(size) : <span class="keyword">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//位于frameworks/native/libs/gui/DisplayEventReceiver.cpp中</span></span><br><span class="line"><span class="keyword">ssize_t</span> DisplayEventReceiver::sendEvents(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; dataChannel,</span><br><span class="line">        Event <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> BitTube::sendObjects(dataChannel, events, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也就是通过Connection的写fd将event发送给MessageQueue。<br>&#160; &#160; &#160; &#160;这时候MessageQueue的looper epoll返回，最终会去调用response.request.callback-&gt;handleEvent，最终调用的是mCallback(fd, events, data);而这个mCallback，既是MessageQueue::cb_eventReceiver。这一步可以查看<a href="http://windrunnerlihuan.com/2016/07/31/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E9%9B%B6%E6%95%A3%E5%88%86%E6%9E%90/">Android消息处理零散分析</a>的内容，如果忘记了，可以翻一翻。<br>&#160; &#160; &#160; &#160;所以最终还是回到了MessageQueue::cb_eventReceiver：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::cb_eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    MessageQueue* <span class="built_in">queue</span> = <span class="keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个步骤上面分析过了。最终去调用SF的onMessageReceived函数，最终每次Vsync信号来了，SF都会去执行handleMessageTransaction()等函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::TRANSACTION:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE:</span><br><span class="line">        handleMessageTransaction();</span><br><span class="line">        handleMessageInvalidate();</span><br><span class="line">        signalRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH:</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这就是vsync信号的处理过程，和上面章节的结合在了一起。</p>
<h1 id="VSync实例"><a href="#VSync实例" class="headerlink" title="VSync实例"></a>VSync实例</h1><h2 id="重要点小结"><a href="#重要点小结" class="headerlink" title="重要点小结"></a>重要点小结</h2><p>&#160; &#160; &#160; &#160;我们列出了EventThread的重要function.下面一一说明其功能：</p>
<ul>
<li><strong>EventThread::Connection::Connection()：</strong>Connection的构造函数.用于进程间的通信by BitTube..在此处主要是搭建一个通路(BitTube)来完成client(App或SurfaceFlinger)对Vsync event事件的请求(通过requestNextVsync())和EventThread把SW-Vsync event callback到其感兴趣的client。需要注意的是App是通过SurfaceFlinger::createDisplayEventConnection()创建此连接的，而sufaceflinge是在其初始化时call EventQueue.setEventThread(mSFEventThread)创建的。所以对App 的EventThread 来说可能有多个connection ,也有可能没有，而对sufaceflinger目前来说有且只有一个；</li>
<li><strong>sp<eventthread::connection>EventThread::createEventConnection()：</eventthread::connection></strong>创建 Connection连接；</li>
<li><strong>status_tEventThread::registerDisplayEventConnection()：</strong>如其名所描述.其功能是把创建的Connection注册到一个容器中。当SW-VSYNCevent发生时，EventThread会从Connection注册的容器中，找到那些对SW-VSYNC event感兴趣的connection并把vsyncevent通过BitTube传到client；</li>
<li><strong>void EventThread::requestNextVsync()：</strong>Clinet 端通过Connection call 这函数通知EventThread，其对SW-SYNCevent的请求；</li>
<li><strong>voidEventThread::onVSyncEvent(nsecs_t timestamp)：</strong>SW-VSYNCEVENT 发生时，DispSyncSource 会call此函数，告知EventThread，Vsync event已经发生，如果此时有connect对Vsync感兴趣，EventThread便会通过connect-&gt;postEvent(event)把Vsync事件发送到client端(App或surfaceflinger)；</li>
<li><strong>bool EventThread::threadLoop()：</strong>线程的主体函数.其完成两件事，一是把对SW-VSYNC event有请求并且还没有处理的connect找出来，二是把Vsyncevent通过connect通知到client；</li>
<li><strong>Vector&lt; sp<eventthread::connection>&gt; EventThread::waitForEvent()：</eventthread::connection></strong>EventThread 的主要功能都在此函数里，此函数由threadLoop()调用。EventThread在大部分时间里是sleep的，如果系统的性能比较好，那么其sleep的节奏是和SW-VSYNC event的节奏一致，即16.6mssleep一次。然而由于其App或surfaceflinger没有Vsync的请求，其sleep的时间为更长。此函数的名为waitForEvent，其到底在等什么event？原来此函数在等待的event就是Dispsync产生的SW-SYNC event，其功能check所有的connect是否有Vsync事件请求根据不同的情况做如下处理。</li>
</ul>
<ol>
<li>所有的connect都没有Vsync请求，则其通过disableVSyncLocked()，disableVsync event，那么此EventThread将不会收到SW-SYNCevent，一直sleep直到有connect有Vsync请求为止。</li>
<li>在所有的connect中，有SW-SYNC event请求，但是当其请求SW-SYNCevent时，SW-SYNCevent还没有fire，则其通过enableVSyncLocked() enable Vsync并进入sleep。当下一个SW-SYNCevent来到时，便把所有有SW-SYNCevent请求的connection返回给threadLoop。</li>
</ol>
<p>&#160; &#160; &#160; &#160;下图是整个流程的大图：</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/big.jpg" alt="big"></p>
<p>&#160; &#160; &#160; &#160;我们接下来依然以gallery3d（相册）为例子，分析Vsync-app和Vsync-sf的工作流程。</p>
<h2 id="Vsync-app实例"><a href="#Vsync-app实例" class="headerlink" title="Vsync-app实例"></a>Vsync-app实例</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/app.png" alt="app"></p>
<ol>
<li>App 通过Connection向EventThread请求SW-VSYNCevent(最终并且通过callEventThread::requestNextVsync()).一般来说App是通过Choreographer.doScheduleVsync()来请求Vsyncevent.</li>
<li>DispSync 产生SW-VSYNC event并call DispSyncSource的onDispSyncEvent().</li>
<li>DispSyncSource产生VSYNC-app信号跳变.</li>
<li>同时DispSyncSource使EventThread(app)的waitForEvent()结束sleep,并把VSYNC-app通知到App进程(gallery3d).</li>
<li>Gallery3d 进程收到VSYNC-app信号,在其main线程(UI Thread)中开始draw一个frame(发送draw command给GL thread).</li>
<li>GL Thread 开始draw view.</li>
<li>当GL thread 线程Draw 完一frame后,把draw buffer放到buffer queue中.</li>
<li>SufaceView中画好的buffer 数据增加为1.这个buffer 将被surfaceflinger 在适当的时候合成.</li>
</ol>
<h2 id="Vsync-sf实例"><a href="#Vsync-sf实例" class="headerlink" title="Vsync-sf实例"></a>Vsync-sf实例</h2><p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/sf.png" alt="sf"></p>
<ol>
<li>App draw 完一个frame (SurfaceView) 并且把此frame通过调用BufferQueueProducer::queueBuffer()放到 bufferqueue中,并且通过call EventThread::requestNextVsync(),请求SW-VSYNCevent.此时由于DispSync没有fireSW-Sync event所以EventThread在EventThread::waitForEvent()中sleep.</li>
<li>DispSync触发SW-SYNC event信号并且call DispSyncSource::onDispSyncEvent().</li>
<li>在DispSyncSource::onDispSyncEvent()中首先引起Vsync-sf跳变,然后在call EventThread::onVSyncEvent(nsecs_ttimestamp).</li>
<li>在EventThread::onVSyncEvent(nsecs_ttimestamp)中,会唤醒EventThread::waitForEvent()中的sleep,从而发送消息到Surfaceflinger.</li>
<li>SurfaceFlinger收到EventThread发过来的Vsync-sf跳变信息,开始合成dirty layer, 本例是SurfaceView.合成完以后发送更新的消息到DisplayHW.</li>
<li>Display HW 收到更新的消息时,HW vsync event还没有来,因此DisplayHW sleep了一段事件.当HWvsync event到来时,DisplayHW 便更新其LCD的内容.把最新的内容显示在LCD上.</li>
</ol>
<p>&#160; &#160; &#160; &#160;自此我们完成了Vsync子系统的分析。</p>
<h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><p>&#160; &#160; &#160; &#160;回到系统性能上,我们可以看出系统的性能(FPS)可能于如下因素有关：</p>
<ol>
<li>DispSync的调度. DispSync是Vsync系统的心脏,如果DispSync来不及调度,则有可能由于去SW-SYNC event的产生不及时而影响系统的性能.</li>
<li>View Draw 花费了过多的时间也会引性能问题, 如果其不能在一个SW-SYNC时间内完成, 那么此应用就会有一个Janks.由于现在的Androd系统都采用了HWUI,viewdraw往往是GPU直接draw,所以很多时候是GPUperformance问题.</li>
<li>HW display 的性能问题.LCD 上所绘画的内容, 最终需要HW display在HW vsync触发是把其内容显示在LCD上.</li>
<li>Binder 的调度问题, 我们可以看到无论是requestNextVsync () 还是queueBuffer()都是App通过binder与surfaceflinger进程通信的.而这些binder在大多数时间是sleep的.如果binder由于CPU调度而错过了一个Vsync跳变点,那么就有一个frame发生Janks.</li>
</ol>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;对于VSync信号的学习就到这里，我们可以看到还是十分复杂的。</p>
<p><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----VSync%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/meizi.jpg" alt="meizi"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat.jpg" alt="windrunnerlihuan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="windrunnerlihuan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SurfaceFlinger/" rel="tag"># SurfaceFlinger</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/21/VSync信号/" rel="next" title="VSync信号">
                <i class="fa fa-chevron-left"></i> VSync信号
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/17/Android-SurfaceFlinger-学习之路-六-SurfaceFlinger创建Surface/" rel="prev" title="Android SurfaceFlinger 学习之路(六)----SurfaceFlinger创建Surface">
                Android SurfaceFlinger 学习之路(六)----SurfaceFlinger创建Surface <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="windrunnerlihuan" />
          <p class="site-author-name" itemprop="name">windrunnerlihuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="mailto:937874128@qq.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope-o"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/windrunnerlihuan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://gank.io/" title="干货集中营" target="_blank">干货集中营</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jcodecraeer.com/" title="泡在网上的日子" target="_blank">泡在网上的日子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#流程基础"><span class="nav-number">1.</span> <span class="nav-text">流程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件加载"><span class="nav-number">1.1.</span> <span class="nav-text">硬件加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#显示设备"><span class="nav-number">1.1.1.</span> <span class="nav-text">显示设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HWComposer设备"><span class="nav-number">1.1.2.</span> <span class="nav-text">HWComposer设备</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VSync-信号闸刀控制"><span class="nav-number">2.</span> <span class="nav-text">VSync 信号闸刀控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vsync信号开关"><span class="nav-number">2.1.</span> <span class="nav-text">Vsync信号开关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventControlThread开关"><span class="nav-number">2.2.</span> <span class="nav-text">EventControlThread开关</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VSync信号构成"><span class="nav-number">3.</span> <span class="nav-text">VSync信号构成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Systrace简介"><span class="nav-number">3.1.</span> <span class="nav-text">Systrace简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VSync的构成"><span class="nav-number">3.2.</span> <span class="nav-text">VSync的构成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VSync工作流程"><span class="nav-number">4.</span> <span class="nav-text">VSync工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整体概述"><span class="nav-number">4.1.</span> <span class="nav-text">整体概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序实现"><span class="nav-number">4.2.</span> <span class="nav-text">程序实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DispSync和DispSyncThread"><span class="nav-number">4.2.1.</span> <span class="nav-text">DispSync和DispSyncThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DispSyncSource和EventThread"><span class="nav-number">4.2.2.</span> <span class="nav-text">DispSyncSource和EventThread</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VSync信号处理"><span class="nav-number">5.</span> <span class="nav-text">VSync信号处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#矫正VSync时间"><span class="nav-number">5.1.</span> <span class="nav-text">矫正VSync时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理VSync消息"><span class="nav-number">5.2.</span> <span class="nav-text">处理VSync消息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VSync实例"><span class="nav-number">6.</span> <span class="nav-text">VSync实例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重要点小结"><span class="nav-number">6.1.</span> <span class="nav-text">重要点小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vsync-app实例"><span class="nav-number">6.2.</span> <span class="nav-text">Vsync-app实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vsync-sf实例"><span class="nav-number">6.3.</span> <span class="nav-text">Vsync-sf实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能影响"><span class="nav-number">6.4.</span> <span class="nav-text">性能影响</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结语"><span class="nav-number">7.</span> <span class="nav-text">结语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">windrunnerlihuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "8d52b6e0ec984fd8aa832e1dd0341885",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("bJlEg1N9ed75pssz1m514avl-gzGzoHsz", "Swtq2cOp8A7KYeJ9lpD5nKAy");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
