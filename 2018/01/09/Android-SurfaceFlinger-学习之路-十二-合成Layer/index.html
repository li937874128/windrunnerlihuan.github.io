<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="3Gndr5oonivG3ajghQU1MgL0IHoMHT4esMsPKjnbeis" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="SurfaceFlinger," />





  <link rel="alternate" href="/atom.xml" title="April is your lie" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;脱更许久，慢慢步入咸鱼阶段。虽非我愿，但事事不如愿。一切尽在不言中，可与言者无一二。&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一节讲了合成Layer之前的准备工作，主要是就算可视化区域和初始化硬件合成环境，本节就讲讲最后的内容，合成Layer。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android SurfaceFlinger 学习之路(十二)----合成Layer">
<meta property="og:url" content="http://windrunnerlihuan.com/2018/01/09/Android-SurfaceFlinger-学习之路-十二-合成Layer/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;脱更许久，慢慢步入咸鱼阶段。虽非我愿，但事事不如愿。一切尽在不言中，可与言者无一二。&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一节讲了合成Layer之前的准备工作，主要是就算可视化区域和初始化硬件合成环境，本节就讲讲最后的内容，合成Layer。">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/offline.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/opengl.png">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/FrameBufferSurface.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/image.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/flow.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/meizi.jpg">
<meta property="og:updated_time" content="2019-01-06T07:29:47.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android SurfaceFlinger 学习之路(十二)----合成Layer">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;脱更许久，慢慢步入咸鱼阶段。虽非我愿，但事事不如愿。一切尽在不言中，可与言者无一二。&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一节讲了合成Layer之前的准备工作，主要是就算可视化区域和初始化硬件合成环境，本节就讲讲最后的内容，合成Layer。">
<meta name="twitter:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/offline.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://windrunnerlihuan.com/2018/01/09/Android-SurfaceFlinger-学习之路-十二-合成Layer/"/>





  <title>Android SurfaceFlinger 学习之路(十二)----合成Layer | April is your lie</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-100464707-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bb4df6db80a16ce54c1fb2c6e1767e18";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=62459705";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500465801");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>




  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1262111741&web_id=1262111741" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">April is your lie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">四月是你的谎言</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://windrunnerlihuan.com/2018/01/09/Android-SurfaceFlinger-学习之路-十二-合成Layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="windrunnerlihuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="April is your lie">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Android SurfaceFlinger 学习之路(十二)----合成Layer</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-09T17:28:11+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android技术点/" itemprop="url" rel="index">
                    <span itemprop="name">Android技术点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/01/09/Android-SurfaceFlinger-学习之路-十二-合成Layer/" class="leancloud_visitors" data-flag-title="Android SurfaceFlinger 学习之路(十二)----合成Layer">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&#160; &#160; &#160; &#160;脱更许久，慢慢步入咸鱼阶段。虽非我愿，但事事不如愿。一切尽在不言中，可与言者无一二。<br>&#160; &#160; &#160; &#160;上一节讲了合成Layer之前的准备工作，主要是就算可视化区域和初始化硬件合成环境，本节就讲讲最后的内容，合成Layer。<br><a id="more"></a></p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>&#160; &#160; &#160; &#160;上一节讲合成的时候说过，合成分为两种，离线合成和在线合成：</p>
<ul>
<li>先将所有图层画到一个最终层（FrameBuffer）上，再将FrameBuffer送到LCD显示。由于合成FrameBuffer与送LCD显示一般是异步的（线下生成FrameBuffer，需要时线上的LCD去取），因此叫离线合成。</li>
<li>不使用FrameBuffer，在LCD需要显示某一行的像素时，用显示控制器将所有图层与该行相关的数据取出，合成一行像素送过去。只有一个图层时，又叫Overlay技术。<br>由于省去合成FrameBuffer时读图层，写FrameBuffer的步骤，大幅降低了内存传输量，减少了功耗，但这个需要硬件支持。</li>
</ul>
<p>&#160; &#160; &#160; &#160;决定Layer的合成方式是在HWC硬件部分决定的，一般上层看不到代码，不过有幸Intel、三星等等开源了一部分我们还能窥一窥源码。</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/offline.jpg" alt="offline"></p>
<p>&#160; &#160; &#160; &#160;如果是Overlay的图层，直接交给显示器硬件系统去在线合成；如果是FRAME_BUFFER类型的图层，需要经过OpenGL处理，然后交给FrameBuffer送给显示器。</p>
<h1 id="合成流程"><a href="#合成流程" class="headerlink" title="合成流程"></a>合成流程</h1><p>&#160; &#160; &#160; &#160;我们接着上一节的内容，SurfaceFlinger的handleMessageRefresh函数最后的内容。frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp，我们先来看看doComposition函数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::doComposition() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    //将mRepaintEverything置为0，不用重绘所有区域</span><br><span class="line">    const bool repaintEverything = android_atomic_and(0, &amp;mRepaintEverything);</span><br><span class="line">    //遍历所有的DisplayDevice然后调用doDisplayComposition函数</span><br><span class="line">    for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">        if (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            // transform the dirty region into this screen's coordinate space</span><br><span class="line">            //获得屏幕的脏区域</span><br><span class="line">            const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything));</span><br><span class="line">            //合成，重绘framebuffer</span><br><span class="line">            // repaint the framebuffer (if needed)</span><br><span class="line">            doDisplayComposition(hw, dirtyRegion);</span><br><span class="line">            //清除屏幕脏区域</span><br><span class="line">            hw-&gt;dirtyRegion.clear();</span><br><span class="line">            //判断系统是否支持软件部分更新</span><br><span class="line">            hw-&gt;flip(hw-&gt;swapRegion);</span><br><span class="line">            //清除交换区域</span><br><span class="line">            hw-&gt;swapRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        // inform the h/w that we're done compositing</span><br><span class="line">        //通知hwc硬件合成结束</span><br><span class="line">        hw-&gt;compositionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    //主要是调用hwc硬件的set函数</span><br><span class="line">    //此方法将完成各个图层的合成与显示，等效于EGL标准里面的eglSwapBuffers，</span><br><span class="line">    //不过eglSwapBuffers是对OpenGL标准/GPU有效，此方法是对硬件合成器有效</span><br><span class="line">    postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上述代码流程每个模块功能也很清晰，分步骤就是如下：<br>&#160; &#160; &#160; &#160;1）遍历所有的DisplayDevice然后调用合成相关函数；<br>&#160; &#160; &#160; &#160;2）获取每一个屏幕的脏区域；<br>&#160; &#160; &#160; &#160;3）最重要的一步：合成；<br>&#160; &#160; &#160; &#160;4）清除交换区域和屏幕脏区域；<br>&#160; &#160; &#160; &#160;5）通知hwc硬件合成结束；<br>&#160; &#160; &#160; &#160;6）最后主要是调用hwc硬件的set函数。此方法将完成各个图层的合成与显示，等效于EGL标准里面的eglSwapBuffers，不过eglSwapBuffers是对OpenGL标准/GPU有效，此方法是对硬件合成器有效。</p>
<p>&#160; &#160; &#160; &#160;其中核心的就是合成步骤。我们先看看其他几个模块：</p>
<p>&#160; &#160; &#160; &#160;获取每一个屏幕的脏区域。frameworks/native/services/surfaceflinger/DisplayDevice.cpp中的getDirtyRegion函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Region DisplayDevice::getDirtyRegion(<span class="keyword">bool</span> repaintEverything) <span class="keyword">const</span> &#123;</span><br><span class="line">    Region dirty;</span><br><span class="line">    <span class="keyword">if</span> (repaintEverything) &#123;<span class="comment">//0</span></span><br><span class="line">        dirty.<span class="built_in">set</span>(getBounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Transform&amp; planeTransform(mGlobalTransform);</span><br><span class="line">        dirty = planeTransform.transform(<span class="keyword">this</span>-&gt;dirtyRegion);</span><br><span class="line">        dirty.andSelf(getBounds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dirty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果需要重绘所有内容，就讲脏区域设为整个屏幕（但事实我们的repaintEverything是0，所以不会）；如果不要重绘所有，先对脏区域作矩阵变换（如果屏幕有过几何变换的transform），然后用脏区域与上屏幕大小，求出脏区域在屏幕上大小。</p>
<p>&#160; &#160; &#160; &#160;获取了屏幕的脏区域之后，就开始合成了。</p>
<h2 id="开始合成"><a href="#开始合成" class="headerlink" title="开始合成"></a>开始合成</h2><p>&#160; &#160; &#160; &#160;我们继续查看doDisplayComposition函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doDisplayComposition(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">        <span class="keyword">const</span> Region&amp; inDirtyRegion)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We only need to actually compose the display if:</span></span><br><span class="line">    <span class="comment">// 1) It is being handled by hardware composer, which may need this to</span></span><br><span class="line">    <span class="comment">//    keep its virtual display state machine in sync, or</span></span><br><span class="line">    <span class="comment">// 2) There is work to be done (the dirty region isn't empty)</span></span><br><span class="line">    <span class="comment">//以下两种情况我们需要去合成显示：</span></span><br><span class="line">    <span class="comment">//1）需要报保持虚拟显示屏和物理显示屏同步显示的情况；</span></span><br><span class="line">    <span class="comment">//2）SF需要去渲染的脏区域不为空。</span></span><br><span class="line">    <span class="keyword">bool</span> isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SF需要渲染的脏区域</span></span><br><span class="line">    <span class="function">Region <span class="title">dirtyRegion</span><span class="params">(inDirtyRegion)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the invalid region</span></span><br><span class="line">    <span class="comment">//需要渲染到硬件帧缓冲区中去的脏区域的</span></span><br><span class="line">    hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = hw-&gt;getFlags();</span><br><span class="line">    <span class="comment">//在这种情况下，系统在软件上支持部分区域更新功能，</span></span><br><span class="line">    <span class="comment">//同样，这个部分被更新的区域必须要是一个矩形区域。</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123;</span><br><span class="line">        <span class="comment">// we can redraw only what's dirty, but since SWAP_RECTANGLE only</span></span><br><span class="line">        <span class="comment">// takes a rectangle, we must make sure to update that whole</span></span><br><span class="line">        <span class="comment">// rectangle in that case</span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//在这种情况下，系统在硬件上直接支持部分区域更新功能，</span></span><br><span class="line">        <span class="comment">//不过，这个部分被更新的区域必须要是一个矩形区域。</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;</span><br><span class="line">            <span class="comment">// We need to redraw the rectangle that will be updated</span></span><br><span class="line">            <span class="comment">// (pushed to the framebuffer).</span></span><br><span class="line">            <span class="comment">// This is needed because PARTIAL_UPDATES only takes one</span></span><br><span class="line">            <span class="comment">// rectangle instead of a region (see DisplayDevice::flip())</span></span><br><span class="line">            dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在这种情况下，系统不支持部分更新区域，这时候就需要更新整个屏幕的内容</span></span><br><span class="line">            <span class="comment">// we need to redraw everything (the whole screen)</span></span><br><span class="line">            dirtyRegion.<span class="built_in">set</span>(hw-&gt;bounds());</span><br><span class="line">            hw-&gt;swapRegion = dirtyRegion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有开启Daltonize辅助功能（高对比性文字/色彩校正/颜色反转）</span></span><br><span class="line">    <span class="comment">//并且没有颜色矩阵去混合</span></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(!mDaltonize &amp;&amp; !mHasColorMatrix)) &#123;</span><br><span class="line">        <span class="comment">//合成</span></span><br><span class="line">        <span class="keyword">if</span> (!doComposeSurfaces(hw, dirtyRegion)) <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//需要处理一下高对比性文字/色彩校正/颜色反转功能</span></span><br><span class="line">        RenderEngine&amp; engine(getRenderEngine());</span><br><span class="line">        mat4 colorMatrix = mColorMatrix;</span><br><span class="line">        <span class="keyword">if</span> (mDaltonize) &#123;</span><br><span class="line">            colorMatrix = colorMatrix * mDaltonizer();</span><br><span class="line">        &#125;</span><br><span class="line">        engine.beginGroup(colorMatrix);</span><br><span class="line">        doComposeSurfaces(hw, dirtyRegion);</span><br><span class="line">        engine.endGroup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the swap region and clear the dirty region</span></span><br><span class="line">    <span class="comment">//更新与framebuffer交换的脏区域，并清除应用脏区域</span></span><br><span class="line">    hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap buffers (presentation)</span></span><br><span class="line">    <span class="comment">//与fb交换脏区域，会调用eglSwapBuffer函数</span></span><br><span class="line">    <span class="comment">//使用egl将egl中的合成好的图像，输出到DisplayDevice的mSurface中 </span></span><br><span class="line">    hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160; DisplayDevice类的成员变量swapRegion用来描述SurfaceFlinger服务需要渲染到硬件帧缓冲区中去的脏区域的。前面提到，inDirtyRegion也是用来描述SurfaceFlinger服务需要渲染的脏区域的，不过，它的作用是用来合成系统中各个应用程序窗口的图形缓冲区的，也就是说，当系统中各个应用程序窗口的图形缓冲区被合成之后，这个成员变量所描述的区域就会被清空，swapRegion会一直等到它的内容被渲染到硬件帧缓冲区中去之后，才会被清空。这样就可能会出现这种情况：上一次合成的图形缓冲区还未被渲染到硬件帧缓冲区中去，SurfaceFlinger服务又会执行新一轮的系统中各个应用程序窗口的图形缓冲区的合并操作。在这种情况下，SurfaceFlinger服务就需要将前面两次需要渲染到硬件帧缓冲区中去的区域合并在一起，以便可以正确地反映被刷新的UI。因此，函数在开头的地方，inDirtyRegion所描述的区域组合到成员变量swapRegion所描述的区域中去。</p>
<p>&#160; &#160; &#160; &#160; 函数接下来调用用来描述系统主显示屏的一个DisplayDevice对象hw的成员函数getFlags来获得系统所支持的渲染方式，并且保存在一个uint32_t变量flags中。接下来，我们就分三种情况来讨论系统所支持的渲染方式：</p>
<ol>
<li>变量flags的DisplayDevice::SWAP_RECTANGLE位等于1。在这种情况下，系统在软件上支持部分区域更新功能，同样，这个部分被更新的区域必须要是一个矩形区域。</li>
<li>变量flags的DisplayDevice::PARTIAL_UPDATES位等于1。在这种情况下，系统在硬件上直接支持部分区域更新功能，不过，这个部分被更新的区域必须要是一个矩形区域。</li>
<li>变量flags的值等于0。在这种情况下，系统不支持部分更新区域，这时候就需要更新整个屏幕的内容。</li>
</ol>
<p>&#160; &#160; &#160; &#160; 在第1种和第2种情况中，由于被更新的区域都必须是一个矩形区域，因此，函数就需要变量inDirtyRegion所描述的一个区域设置为包含了所有脏区域的一个最小矩形区域。在第3种情况中，由于需要更新的是整个屏幕的内容，因此，函数就需要inDirtyRegion所描述的一个区域设置为等于屏幕大小的一个矩形区域。</p>
<p>&#160; &#160; &#160; &#160;(在老的版本代码中，比如android2.3，部分更新还支持BUFFER_PRESERVED不规则区域更新。在保留后端图形缓冲区的内容的情况下，系统就可以支持仅仅渲染那些需要更新的脏区域，这些区域可以是不规则的。然而，实现不规则区域部分更新功能是有代价的，因为每次在渲染UI时，都要将后端图形缓冲区的内容拷贝回那些不在那些需要更新的区域中去，这会导致性能低下。因此，系统一般都不支持不规则区域部分更新功能。)</p>
<p>&#160; &#160; &#160; &#160; 在安卓L版本中，辅助设置中新加了3个功能，分别是高对比性文字，颜色反转，色彩校正。</p>
<blockquote>
<p>This information applies only to devices running Android 5.0 and higher.</p>
<p>High contrast makes text easier to read on your device. This feature fixes the text color as either black or white, depending on the original text color.</p>
<p>To enable or disable high contrast text, follow these steps:<br>Go to Settings &gt; Accessibility.<br>Select High contrast text.</p>
<p>High-contrast text is currently an experimental feature, so it might not work correctly everywhere on your device.</p>
</blockquote>
<p>&#160; &#160; &#160; &#160; google说，这个功能就是让文字更容易阅读，也就是有点类似与文字高亮。最后的效果就是，把文字变成白色或黑色，把背景文字背景变成黑色或白色。也就是说，如果你之前的文字是白色，背景是黑色，就不会去应用这个功能。</p>
<p>&#160; &#160; &#160; &#160;如果没有开启这个辅助功能，mDaltonize和mHasColorMatrix为null，那么直接调用doComposeSurfaces函数去合成图层；如果开启了辅助功能，那么就需要OpenGL引擎去处理颜色矩阵（高对比性文字主要是修改控件，颜色反转和颜色校正主要是通过操作gpu修改显示效果），这一部分有机会我们以后会研究研究。</p>
<p>&#160; &#160; &#160; &#160;那么接下来两部就是合成图层和交换FrameBuffer了，我们逐步分析。</p>
<h1 id="合成图层"><a href="#合成图层" class="headerlink" title="合成图层"></a>合成图层</h1><h2 id="doComposeSurfaces"><a href="#doComposeSurfaces" class="headerlink" title="doComposeSurfaces"></a>doComposeSurfaces</h2><p>&#160; &#160; &#160; &#160;合成图层的函数是doComposeSurfaces，这个函数比较长，我们分段查看：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">bool SurfaceFlinger::doComposeSurfaces(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; dirty)  </span><br><span class="line">&#123;  </span><br><span class="line">    RenderEngine&amp; engine(getRenderEngine());  </span><br><span class="line">    const int32_t id = hw-&gt;getHwcDisplayId();  </span><br><span class="line">    HWComposer&amp; hwc(getHwComposer());  </span><br><span class="line">    HWComposer::LayerListIterator cur = hwc.begin(id);  </span><br><span class="line">    const HWComposer::LayerListIterator end = hwc.end(id);  </span><br><span class="line">  </span><br><span class="line">    bool hasGlesComposition = hwc.hasGlesComposition(id);  </span><br><span class="line">    if (hasGlesComposition) &#123;//是否有egl合成  </span><br><span class="line">        //DisplayDevice类的成员函数makeCurrent的实现很简单，</span><br><span class="line">        //它只是通过调用函数eglMakeCurrent来将前面已经创建好的绘图表面以及绘图上下文设置为当前线程的绘图表面以及绘图上下文，</span><br><span class="line">        //即设置为SurfaceFlinger服务的UI渲染线程的绘图表面以及绘图上下文</span><br><span class="line">        if (!hw-&gt;makeCurrent(mEGLDisplay, mEGLContext)) &#123;  </span><br><span class="line">            ALOGW("DisplayDevice::makeCurrent failed. Aborting surface composition for display %s",  </span><br><span class="line">                  hw-&gt;getDisplayName().string());  </span><br><span class="line">            //如果绑定失败了，就要取消设置OpenGL库在当前线程的绘图表面以及绘图上下文</span><br><span class="line">            eglMakeCurrent(mEGLDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);  </span><br><span class="line">            //那么就要去设置默认屏幕创建好的绘图表面和上下文为当前线程的内容</span><br><span class="line">            if(!getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext)) &#123;  </span><br><span class="line">              ALOGE("DisplayDevice::makeCurrent on default display failed. Aborting.");  </span><br><span class="line">            &#125;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // Never touch the framebuffer if we don't have any framebuffer layers  </span><br><span class="line">        const bool hasHwcComposition = hwc.hasHwcComposition(id);  </span><br><span class="line">        if (hasHwcComposition) &#123;//是否有hwc合成  </span><br><span class="line">            // when using overlays, we assume a fully transparent framebuffer  </span><br><span class="line">            // NOTE: we could reduce how much we need to clear, for instance  </span><br><span class="line">            // remove where there are opaque FB layers. however, on some  </span><br><span class="line">            // GPUs doing a "clean slate" clear might be more efficient.  </span><br><span class="line">            // We'll revisit later if needed.  </span><br><span class="line">            //如果使用OverLay硬件合成，就要把FrameBuffer全都清除为透明色</span><br><span class="line">            engine.clearWithColor(0, 0, 0, 0);  </span><br><span class="line">        &#125; else &#123;//是否有OpenGL合成</span><br><span class="line">            //letterbox(信箱模式)</span><br><span class="line">            // we start with the whole screen area  </span><br><span class="line">            const Region bounds(hw-&gt;getBounds());  </span><br><span class="line">  </span><br><span class="line">            // we remove the scissor part  </span><br><span class="line">            // we're left with the letterbox region  </span><br><span class="line">            // (common case is that letterbox ends-up being empty) </span><br><span class="line">            //移除内容区域，只留下大黑边（剪裁区域） </span><br><span class="line">            const Region letterbox(bounds.subtract(hw-&gt;getScissor()));  </span><br><span class="line">  </span><br><span class="line">            // compute the area to clear  </span><br><span class="line">            //计算大黑边区域</span><br><span class="line">            Region region(hw-&gt;undefinedRegion.merge(letterbox));  </span><br><span class="line">  </span><br><span class="line">            // but limit it to the dirty region  </span><br><span class="line">            //还要限制到更新的脏区域范围内</span><br><span class="line">            region.andSelf(dirty);  </span><br><span class="line">  </span><br><span class="line">            // screen is already cleared here  </span><br><span class="line">            //对大黑边进行挖洞处理，使用OpenGL填成黑色</span><br><span class="line">            if (!region.isEmpty()) &#123;  </span><br><span class="line">                // can happen with SurfaceView  </span><br><span class="line">                //SurfaceView的实现原理就是打洞覆盖：另起一个图层（即新建一个Surface），</span><br><span class="line">                //并把主图层的相应区域置为透明，然后渲染就发生在新图层中，</span><br><span class="line">                //最终显示效果自然是依赖SurfaceFlinger的叠加</span><br><span class="line">                drawWormhole(hw, region);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //如果不是主显屏</span><br><span class="line">        if (hw-&gt;getDisplayType() != DisplayDevice::DISPLAY_PRIMARY) &#123;  </span><br><span class="line">            // just to be on the safe side, we don't set the  </span><br><span class="line">            // scissor on the main display. It should never be needed  </span><br><span class="line">            // anyways (though in theory it could since the API allows it).  </span><br><span class="line">            //为了安全起见，这个操作不会在主显屏发生</span><br><span class="line">            const Rect&amp; bounds(hw-&gt;getBounds());  </span><br><span class="line">            const Rect&amp; scissor(hw-&gt;getScissor());  </span><br><span class="line">            if (scissor != bounds) &#123;  </span><br><span class="line">                //如果剪裁区域和屏幕尺寸不匹配，就要清除所有塔之外的内容</span><br><span class="line">                //并且enble GL剪裁器，在我们不需要绘制的地方不绘制任何内容</span><br><span class="line">                // scissor doesn't match the screen's dimensions, so we  </span><br><span class="line">                // need to clear everything outside of it and enable  </span><br><span class="line">                // the GL scissor so we don't draw anything where we shouldn't  </span><br><span class="line">  </span><br><span class="line">                // enable scissor for this frame  </span><br><span class="line">                const uint32_t height = hw-&gt;getHeight();  </span><br><span class="line">                engine.setScissor(scissor.left, height - scissor.bottom,  </span><br><span class="line">                        scissor.getWidth(), scissor.getHeight());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">//...... </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这部分先调用hasGlesComposition函数和hasHwcComposition函数，就是看其对应的DisplayData中是否有hasFbComp和hasOvComp，对应有无OpenGL合成或者OverLay硬件合成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HWComposer::hasGlesComposition(<span class="keyword">int32_t</span> id) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!mHwc || <span class="keyword">uint32_t</span>(id)&gt;<span class="number">31</span> || !mAllocatedDisplayIDs.hasBit(id))  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">return</span> mDisplayData[id].hasFbComp;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">bool</span> HWComposer::hasHwcComposition(<span class="keyword">int32_t</span> id) <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!mHwc || <span class="keyword">uint32_t</span>(id)&gt;<span class="number">31</span> || !mAllocatedDisplayIDs.hasBit(id))  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">return</span> mDisplayData[id].hasOvComp;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们在<a href="http://windrunnerlihuan.com/2017/12/01/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%81%E4%B8%80-%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/">Android SurfaceFlinger 学习之路(十一)—-合成Layer之准备合成</a>中讲过，而这两个值是在prepare中调用Hwc的prepare函数之后赋值的，具体原理是在<a href="http://windrunnerlihuan.com/2017/12/19/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%81%E4%B8%80-PostView-%E9%99%84%EF%BC%9A%E7%A1%AC%E4%BB%B6HWC%E9%80%89%E5%8F%96%E5%90%88%E6%88%90%E7%B1%BB%E5%9E%8B%EF%BC%88Intel%EF%BC%89/">Android SurfaceFlinger 学习之路(十一)(PostView)–附：硬件HWC选取合成类型（Intel）
</a>中实现的，如果忘记了可以翻翻上一篇的内容。</p>
<p>&#160; &#160; &#160; &#160;如果有OpenGL的合成，先调用DisplayDevice类的成员函数makeCurrent，通过调用函数eglMakeCurrent来将前面已经创建好的绘图表面以及绘图上下文设置为当前线程的绘图表面以及绘图上下文，即设置为SurfaceFlinger服务的UI渲染线程的绘图表面以及绘图上下文。如果绑定失败了，就要取消设置OpenGL库在当前线程的绘图表面以及绘图上下文。那么就要去设置默认屏幕创建好的绘图表面和上下文为当前线程的内容。</p>
<p>&#160; &#160; &#160; &#160;因为合成有可能是混合合成，所以还要判断是否也有Overlay合成方式。如果有，就要把FrameBuffer全都清除为透明黑色。<br>&#160; &#160; &#160; &#160;如果没有，就是OpenGL单独合成，就要使用<code>信箱模式</code>。<br>&#160; &#160; &#160; &#160;这个只是一种比喻，信箱模式可以查一查资料，比如<a href="https://en.wikipedia.org/wiki/Letterboxing_(filming" target="_blank" rel="external">维基百科</a>)中的解释。我们这里理解为图层的宽高比大于电视的宽高比的情况。从名字来看，letterbox就像邮筒一样，中间是有内容的，上下是没用的。letterbox目标就是保存原有胶片的宽高比，使内容完整的展现在屏幕上。由于内容宽高比较大，所以上下会有黑屏。采用的技术就是：抽调部分扫描线，以满足宽高比，不利的结果就是图像质量下降。</p>
<p>&#160; &#160; &#160; &#160;所以对于这种情况，我们需要对大黑边进行处理：<br>&#160; &#160; &#160; &#160;1）移除内容区域，只留下大黑边（剪裁区域）；<br>&#160; &#160; &#160; &#160;2）计算大黑边区域；<br>&#160; &#160; &#160; &#160;3）还要限制到更新的脏区域范围内；<br>&#160; &#160; &#160; &#160;4）对大黑边进行挖洞处理，使用OpenGL填成黑色<br>&#160; &#160; &#160; &#160;SurfaceView的实现原理就是打洞覆盖：另起一个图层（即新建一个Surface），并把主图层的相应区域置为透明，然后渲染就发生在新图层中，最终显示效果自然是依赖SurfaceFlinger的叠加。</p>
<p>&#160; &#160; &#160; &#160;最后就是一个特殊处理，对于不是主显屏（为了安全起见，这个操作不会在主显屏发生），如果剪裁区域和屏幕尺寸不匹配，就要清除所有塔之外的内容，并且enble GL剪裁器，在我们不需要绘制的地方不绘制任何内容。</p>
<p>&#160; &#160; &#160; &#160;继续往下看：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * and then, render the layers targeted at the framebuffer</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    const Vector&lt; sp&lt;Layer&gt; &gt;&amp; layers(hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">    const size_t count = layers.size();</span><br><span class="line">    const Transform&amp; tr = hw-&gt;getTransform();</span><br><span class="line">    if (cur != end) &#123;//代表起码有两个以上图层  </span><br><span class="line">        // we're using h/w composer</span><br><span class="line">        for (size_t i=0 ; i&lt;count &amp;&amp; cur!=end ; ++i, ++cur) &#123;//遍历图层 </span><br><span class="line">            const sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">            //clip用来描述要绘制的区域，而要绘制的区域即为当前需要指定的裁剪区域</span><br><span class="line">            //就是全部图层的总体脏区域和这个图层的可视区域的交集</span><br><span class="line">            const Region clip(dirty.intersect(tr.transform(layer-&gt;visibleRegion)));</span><br><span class="line">            if (!clip.isEmpty()) &#123;</span><br><span class="line">                switch (cur-&gt;getCompositionType()) &#123;</span><br><span class="line">                    //overlay不做处理</span><br><span class="line">                    case HWC_CURSOR_OVERLAY:</span><br><span class="line">                    case HWC_OVERLAY: &#123;</span><br><span class="line">                        const Layer::State&amp; state(layer-&gt;getDrawingState());</span><br><span class="line">                        if ((cur-&gt;getHints() &amp; HWC_HINT_CLEAR_FB)</span><br><span class="line">                                &amp;&amp; i</span><br><span class="line">                                &amp;&amp; layer-&gt;isOpaque(state) &amp;&amp; (state.alpha == 0xFF)</span><br><span class="line">                                &amp;&amp; hasGlesComposition) &#123;</span><br><span class="line">                            // never clear the very first layer since we're</span><br><span class="line">                            // guaranteed the FB is already cleared</span><br><span class="line">                            //上面说过，如果是Overlay合成，就要清除FrameBuffer</span><br><span class="line">                            //这里以防万一，确保FB要被清除</span><br><span class="line">                            layer-&gt;clearWithOpenGL(hw, clip);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果是OpenGL合成，就调用Layer的draw函数</span><br><span class="line">                    case HWC_FRAMEBUFFER: &#123;</span><br><span class="line">                        layer-&gt;draw(hw, clip);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //HWC_FRAMEBUFFER_TARGET是OpenGL合成后使用的目标层，直接就跳了</span><br><span class="line">                    case HWC_FRAMEBUFFER_TARGET: &#123;</span><br><span class="line">                        // this should not happen as the iterator shouldn't</span><br><span class="line">                        // let us get there.</span><br><span class="line">                        ALOGW("HWC_FRAMEBUFFER_TARGET found in hwc list (index=%zu)", i);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            layer-&gt;setAcquireFence(hw, *cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;//只有一个或者没有图层  就直接使用OpenGL合成，调用Layer的draw</span><br><span class="line">        // we're not using h/w composer</span><br><span class="line">        for (size_t i=0 ; i&lt;count ; ++i) &#123;</span><br><span class="line">            const sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">            const Region clip(dirty.intersect(</span><br><span class="line">                    tr.transform(layer-&gt;visibleRegion)));</span><br><span class="line">            if (!clip.isEmpty()) &#123;</span><br><span class="line">                layer-&gt;draw(hw, clip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // disable scissor at the end of the frame</span><br><span class="line">    engine.disableScissor();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一段看注释就知道合成步骤。先根据z-order拿到所有的可视图层，然后分两种情况：<br>&#160; &#160; &#160; &#160;1）起码有两个以上图层 ：遍历图层，用全部图层的总体脏区域和这个图层的可视区域求交集，计算出clip区域。如果clip区域不为空，根据Layer的合成类型分别进行处理：</p>
<ul>
<li>overlay不做处理，但是上面说过，如果是Overlay合成，就要清除FrameBuffer，这里以防万一，确保FB要被清除。</li>
<li>如果是OpenGL合成，就调用Layer的draw函数。</li>
<li>HWC_FRAMEBUFFER_TARGET是OpenGL合成后使用的目标层，直接就跳了。</li>
</ul>
<p>&#160; &#160; &#160; &#160;2）只有一个或者没有图层  就直接使用OpenGL合成，调用Layer的draw。</p>
<p>&#160; &#160; &#160; &#160;所以合成主要是OpenGL处理，Layer的draw函数。</p>
<h2 id="OpenGL处理合成"><a href="#OpenGL处理合成" class="headerlink" title="OpenGL处理合成"></a>OpenGL处理合成</h2><p>&#160; &#160; &#160; &#160;我们看看Layer的draw函数实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::draw(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw, <span class="keyword">const</span> Region&amp; clip) <span class="keyword">const</span> &#123;</span><br><span class="line">    onDraw(hw, clip, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;draw内部又调用了onDraw函数，这个函数有一点点小长，我们依然分段查看：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void Layer::onDraw(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; clip,</span><br><span class="line">        bool useIdentityTransform) const</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    //在纹理未创建好的情况下，一个应用程序窗口是不应该被渲染的</span><br><span class="line">    if (CC_UNLIKELY(mActiveBuffer == 0)) &#123;</span><br><span class="line">        // the texture has not been created yet, this Layer has</span><br><span class="line">        // in fact never been drawn into. This happens frequently with</span><br><span class="line">        // SurfaceView because the WindowManager can't know when the client</span><br><span class="line">        // has drawn the first time.</span><br><span class="line"></span><br><span class="line">        // If there is nothing under us, we paint the screen in black, otherwise</span><br><span class="line">        // we just skip this update.</span><br><span class="line"></span><br><span class="line">        // figure out if there is something below us</span><br><span class="line">        //在纹理未创建好的情况下，一个应用程序窗口是不应该被渲染的</span><br><span class="line">        //这种情况频繁的发生在SurfaceView身上，因为WindowManger不知道它第一次绘制的时间</span><br><span class="line">        //如果没有内容在它下面，我们把整个屏幕都画成黑色</span><br><span class="line">        //否则就跳过这次更新</span><br><span class="line">        //所以我们需要计算出在它下面的内容</span><br><span class="line">        Region under;</span><br><span class="line">        const SurfaceFlinger::LayerVector&amp; drawingLayers(</span><br><span class="line">                mFlinger-&gt;mDrawingState.layersSortedByZ);</span><br><span class="line">        const size_t count = drawingLayers.size();</span><br><span class="line">        for (size_t i=0 ; i&lt;count ; ++i) &#123;</span><br><span class="line">            const sp&lt;Layer&gt;&amp; layer(drawingLayers[i]);</span><br><span class="line">            if (layer.get() == static_cast&lt;Layer const*&gt;(this))</span><br><span class="line">                break;</span><br><span class="line">            //这时候函数首先将位于当前正在处理的应用程序窗口下面的所有其它应用程序窗口的可见区域组合起来，</span><br><span class="line">            //并且保存在变量under所描述的区域中    </span><br><span class="line">            under.orSelf( hw-&gt;getTransform().transform(layer-&gt;visibleRegion) );</span><br><span class="line">        &#125;</span><br><span class="line">        // if not everything below us is covered, we plug the holes!</span><br><span class="line">        //由于这时候当前正在处理的应用程序窗口不会被绘制，</span><br><span class="line">        //因此，如果变量under所描述的区域小于参数clip所描述的区域，即变量holes所描述的区域不为空，</span><br><span class="line">        //那么SurfaceFlinger服务所要求缓制的区域clip就会留下一个洞</span><br><span class="line">        Region holes(clip.subtract(under));</span><br><span class="line">        //这个洞会被绘制成黑色，这是通过调用函数clearWithOpenGL来实现的</span><br><span class="line">        if (!holes.isEmpty()) &#123;</span><br><span class="line">            clearWithOpenGL(hw, holes, 0, 0, 0, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码主要是用来处应用程序窗口的纹理尚未创建好的情况。<br>&#160; &#160; &#160; &#160;在纹理未创建好的情况下，一个应用程序窗口是不应该被渲染的。这时候函数首先将位于当前正在处理的应用程序窗口下面的所有其它应用程序窗口的可见区域组合起来，并且保存在变量under所描述的区域中。由于这时候当前正在处理的应用程序窗口不会被绘制，因此，如果变量under所描述的区域小于参数clip所描述的区域，即变量holes所描述的区域不为空，那么SurfaceFlinger服务所要求缓制的区域clip就会留下一个洞。这个洞会被绘制成黑色，这是通过调用函数clearWithOpenGL来实现的。绘制完成之后，函数就可以直接返回了。<br>&#160; &#160; &#160; &#160;这里mActiveBuffer我们在<a href="http://windrunnerlihuan.com/2017/11/09/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%81-SurfaceFlinger%E5%A4%84%E7%90%86Layer%E6%9B%B4%E6%96%B0/">Android SurfaceFlinger 学习之路(十)—-SurfaceFlinger处理Layer更新</a>里面的更新纹理讲过，会为其赋值。</p>
<h2 id="绑定纹理"><a href="#绑定纹理" class="headerlink" title="绑定纹理"></a>绑定纹理</h2><p>&#160; &#160; &#160; &#160;接着看onDraw函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bind the current buffer to the GL texture, and wait for it to be</span></span><br><span class="line">    <span class="comment">// ready for us to draw into.</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mSurfaceFlingerConsumer-&gt;bindTextureImage();</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGW(<span class="string">"onDraw: bindTextureImage failed (err=%d)"</span>, err);</span><br><span class="line">        <span class="comment">// Go ahead and draw the buffer anyway; no matter what we do the screen</span></span><br><span class="line">        <span class="comment">// is probably going to have something visibly wrong.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码首先，将buffer加入到GL texture，然后等待底层OpenGL调用GPU绘制完成纹理给我们上层返回。<br>&#160; &#160; &#160; &#160;我们看看SurfaceFlingerConsumer的bindTextureImage函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlingerConsumer::bindTextureImage()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> bindTextureImageLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;又调用了父类的GLConsumer的bindTextureImageLocked函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> GLConsumer::bindTextureImageLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mEglDisplay == EGL_NO_DISPLAY) &#123;</span><br><span class="line">        ALOGE(<span class="string">"bindTextureImage: invalid display"</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GLint error;</span><br><span class="line">    <span class="keyword">while</span> ((error = glGetError()) != GL_NO_ERROR) &#123;</span><br><span class="line">        ST_LOGW(<span class="string">"bindTextureImage: clearing GL error: %#04x"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定一个Texture纹理，如果没有就创建</span></span><br><span class="line">    glBindTexture(mTexTarget, mTexName);</span><br><span class="line">    <span class="keyword">if</span> (mCurrentTexture == BufferQueue::INVALID_BUFFER_SLOT &amp;&amp;</span><br><span class="line">            mCurrentTextureImage == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ST_LOGE(<span class="string">"bindTextureImage: no currently-bound texture"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个Image绘制</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mCurrentTextureImage-&gt;createIfNeeded(mEglDisplay,</span><br><span class="line">                                                        mCurrentCrop);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ST_LOGW(<span class="string">"bindTextureImage: can't create image on display=%p slot=%d"</span>,</span><br><span class="line">                mEglDisplay, mCurrentTexture);</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将Image绑定到Texure</span></span><br><span class="line">    mCurrentTextureImage-&gt;bindToTextureTarget(mTexTarget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In the rare case that the display is terminated and then initialized</span></span><br><span class="line">    <span class="comment">// again, we can't detect that the display changed (it didn't), but the</span></span><br><span class="line">    <span class="comment">// image is invalid. In this case, repeat the exact same steps while</span></span><br><span class="line">    <span class="comment">// forcing the creation of a new image.</span></span><br><span class="line">    <span class="keyword">if</span> ((error = glGetError()) != GL_NO_ERROR) &#123;</span><br><span class="line">        glBindTexture(mTexTarget, mTexName);</span><br><span class="line">        <span class="keyword">status_t</span> err = mCurrentTextureImage-&gt;createIfNeeded(mEglDisplay,</span><br><span class="line">                                                            mCurrentCrop,</span><br><span class="line">                                                            <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            ST_LOGW(<span class="string">"bindTextureImage: can't create image on display=%p slot=%d"</span>,</span><br><span class="line">                    mEglDisplay, mCurrentTexture);</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentTextureImage-&gt;bindToTextureTarget(mTexTarget);</span><br><span class="line">        <span class="keyword">if</span> ((error = glGetError()) != GL_NO_ERROR) &#123;</span><br><span class="line">            ST_LOGE(<span class="string">"bindTextureImage: error binding external image: %#04x"</span>, error);</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the new buffer to be ready.</span></span><br><span class="line">    <span class="comment">//等待OpenGL处理完成，返回fence</span></span><br><span class="line">    <span class="keyword">return</span> doGLFenceWaitLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OpenGL绑定纹理需要四步：<br>&#160; &#160; &#160; &#160;1）绑定一个Texture纹理，如果没有就创建；<br>&#160; &#160; &#160; &#160;2）创建一个Image用于绘制；<br>&#160; &#160; &#160; &#160;3）将Image绑定到Texure；<br>&#160; &#160; &#160; &#160;4）等待OpenGL处理完成，返回fence。</p>
<p>&#160; &#160; &#160; &#160;我们依然分不查看：<br>&#160; &#160; &#160; &#160;1）绑定纹理：glBindTexture。<br>&#160; &#160; &#160; &#160;这里有一个特别尴尬的地方，就是我们这里的代码也看不到，因为这和GPU硬件相关，厂商不会开放这些代码的ToT。。。之前我们能看看高通、TI、甚至Intel的硬件模块代码实属运气，Google将其也放入了AOSP部分。但是对于GPU的源代码却看不到了，想想就明白了，现在显卡卖的一点都不比CPU便宜，尤其这两年人工智能、机器学习火起来，还有比特币的高涨，挖矿越来越猛烈，这些都需要超高速密集运算硬件支持，所以GPU价值和价格也有水涨船高之势头。所以指望这些厂商开发源代码实属异想天开=。=<br>&#160; &#160; &#160; &#160;虽然硬件代码看不到，但是我们可以曲线救国，从软件实现去分析功能。软件实现位于/frameworks/native/opengl/libagl/texture.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glBindTexture</span><span class="params">(GLenum target, GLuint texture)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">ogles_context_t</span>* c = <span class="keyword">ogles_context_t</span>::get();</span><br><span class="line">    <span class="keyword">if</span> (target != GL_TEXTURE_2D &amp;&amp; target != GL_TEXTURE_EXTERNAL_OES) &#123;</span><br><span class="line">        ogles_error(c, GL_INVALID_ENUM);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind or create a texture</span></span><br><span class="line">    <span class="comment">//绑定或创建一个纹理</span></span><br><span class="line">    sp&lt;EGLTextureObject&gt; tex;</span><br><span class="line">    <span class="keyword">if</span> (texture == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 is our local texture object</span></span><br><span class="line">        <span class="comment">//0表示是本地的纹理对象</span></span><br><span class="line">        tex = c-&gt;textures.defaultTexture;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tex = c-&gt;surfaceManager-&gt;texture(texture);</span><br><span class="line">        <span class="keyword">if</span> (ggl_unlikely(tex == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//创建一个纹理</span></span><br><span class="line">            tex = c-&gt;surfaceManager-&gt;createTexture(texture);</span><br><span class="line">            <span class="keyword">if</span> (tex == <span class="number">0</span>) &#123;</span><br><span class="line">                ogles_error(c, GL_OUT_OF_MEMORY);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bindTextureTmu(c, c-&gt;textures.active, texture, tex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bindTextureTmu</span><span class="params">(</span><br><span class="line">    <span class="keyword">ogles_context_t</span>* c, <span class="keyword">int</span> tmu, GLuint texture, <span class="keyword">const</span> sp&lt;EGLTextureObject&gt;&amp; tex)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tex.get() == c-&gt;textures.tmu[tmu].texture)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the reference to the previously bound object</span></span><br><span class="line">    <span class="comment">//释放对之前纹理对象的引用</span></span><br><span class="line">    <span class="keyword">texture_unit_t</span>&amp; u(c-&gt;textures.tmu[tmu]);</span><br><span class="line">    <span class="keyword">if</span> (u.texture)</span><br><span class="line">        u.texture-&gt;decStrong(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind this texture to the current active texture unit</span></span><br><span class="line">    <span class="comment">// and add a reference to this texture object</span></span><br><span class="line">    <span class="comment">//绑定这个纹理对象到当前活跃的纹理单元</span></span><br><span class="line">    <span class="comment">//并且增加引用计数</span></span><br><span class="line">    u.texture = tex.get();</span><br><span class="line">    u.texture-&gt;incStrong(c);</span><br><span class="line">    u.name = texture;</span><br><span class="line">    invalidate_texture(c, tmu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">void</span> <span class="title">invalidate_texture</span><span class="params">(<span class="keyword">ogles_context_t</span>* c, <span class="keyword">int</span> tmu, <span class="keyword">uint8_t</span> flags = <span class="number">0xFF</span>)</span> </span>&#123;</span><br><span class="line">    c-&gt;textures.tmu[tmu].dirty = flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;软件实现也是先创建一个纹理texture对象，然后释放掉对之前纹理对象的引用，然后将引用指向新得纹理，再将引用计数加一，这样完成对当前纹理的绑定操作。</p>
<p>&#160; &#160; &#160; &#160;2）创建一个Image用于绘制：<br>&#160; &#160; &#160; &#160;mCurrentTextureImage是一个 EglImage，我们在<a href="http://windrunnerlihuan.com/2017/11/09/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%81-SurfaceFlinger%E5%A4%84%E7%90%86Layer%E6%9B%B4%E6%96%B0/">Android SurfaceFlinger 学习之路(十)—-SurfaceFlinger处理Layer更新</a>里面的更新纹理讲过，acquireBuffer时候会创建一个EglImage。所以这里调用EglImage的createIfNeeded函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> GLConsumer::EglImage::createIfNeeded(EGLDisplay eglDisplay,</span><br><span class="line">                                              <span class="keyword">const</span> Rect&amp; cropRect,</span><br><span class="line">                                              <span class="keyword">bool</span> forceCreation) &#123;</span><br><span class="line">    <span class="comment">// If there's an image and it's no longer valid, destroy it.</span></span><br><span class="line">    <span class="comment">//如果之前的image不在有效了，就要销毁它</span></span><br><span class="line">    <span class="keyword">bool</span> haveImage = mEglImage != EGL_NO_IMAGE_KHR;</span><br><span class="line">    <span class="keyword">bool</span> displayInvalid = mEglDisplay != eglDisplay;</span><br><span class="line">    <span class="keyword">bool</span> cropInvalid = hasEglAndroidImageCrop() &amp;&amp; mCropRect != cropRect;</span><br><span class="line">    <span class="keyword">if</span> (haveImage &amp;&amp; (displayInvalid || cropInvalid || forceCreation)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!eglDestroyImageKHR(mEglDisplay, mEglImage)) &#123;</span><br><span class="line">           ALOGE(<span class="string">"createIfNeeded: eglDestroyImageKHR failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mEglImage = EGL_NO_IMAGE_KHR;</span><br><span class="line">        mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there's no image, create one.</span></span><br><span class="line">    <span class="comment">//如果没有image，就要创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (mEglImage == EGL_NO_IMAGE_KHR) &#123;</span><br><span class="line">        mEglDisplay = eglDisplay;</span><br><span class="line">        mCropRect = cropRect;</span><br><span class="line">        mEglImage = createImage(mEglDisplay, mGraphicBuffer, mCropRect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fail if we can't create a valid image.</span></span><br><span class="line">    <span class="comment">//创建失败了，就只能GG了</span></span><br><span class="line">    <span class="keyword">if</span> (mEglImage == EGL_NO_IMAGE_KHR) &#123;</span><br><span class="line">        mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line">        mCropRect.makeInvalid();</span><br><span class="line">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer = mGraphicBuffer;</span><br><span class="line">        ALOGE(<span class="string">"Failed to create image. size=%ux%u st=%u usage=0x%x fmt=%d"</span>,</span><br><span class="line">            buffer-&gt;getWidth(), buffer-&gt;getHeight(), buffer-&gt;getStride(),</span><br><span class="line">            buffer-&gt;getUsage(), buffer-&gt;getPixelFormat());</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果之前的image不在有效了，就要销毁它；如果没有image，就要创建一个；创建失败了，就只能GG了。<br>&#160; &#160; &#160; &#160;我们可以继续看createImage函数，如何去创建一个image：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">EGLImageKHR GLConsumer::EglImage::createImage(EGLDisplay dpy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; graphicBuffer, <span class="keyword">const</span> Rect&amp; crop) &#123;</span><br><span class="line">    EGLClientBuffer cbuf = (EGLClientBuffer)graphicBuffer-&gt;getNativeBuffer();</span><br><span class="line">    EGLint attrs[] = &#123;</span><br><span class="line">        EGL_IMAGE_PRESERVED_KHR,        EGL_TRUE,</span><br><span class="line">        EGL_IMAGE_CROP_LEFT_ANDROID,    crop.left,</span><br><span class="line">        EGL_IMAGE_CROP_TOP_ANDROID,     crop.top,</span><br><span class="line">        EGL_IMAGE_CROP_RIGHT_ANDROID,   crop.right,</span><br><span class="line">        EGL_IMAGE_CROP_BOTTOM_ANDROID,  crop.bottom,</span><br><span class="line">        EGL_NONE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!crop.isValid()) &#123;</span><br><span class="line">        <span class="comment">// No crop rect to set, so terminate the attrib array before the crop.</span></span><br><span class="line">        attrs[<span class="number">2</span>] = EGL_NONE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isEglImageCroppable(crop)) &#123;</span><br><span class="line">        <span class="comment">// The crop rect is not at the origin, so we can't set the crop on the</span></span><br><span class="line">        <span class="comment">// EGLImage because that's not allowed by the EGL_ANDROID_image_crop</span></span><br><span class="line">        <span class="comment">// extension.  In the future we can add a layered extension that</span></span><br><span class="line">        <span class="comment">// removes this restriction if there is hardware that can support it.</span></span><br><span class="line">        attrs[<span class="number">2</span>] = EGL_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*此句为创建Image的代码*/</span></span><br><span class="line">    EGLImageKHR image = eglCreateImageKHR(dpy, EGL_NO_CONTEXT,</span><br><span class="line">            EGL_NATIVE_BUFFER_ANDROID, cbuf, attrs);</span><br><span class="line">    <span class="keyword">if</span> (image == EGL_NO_IMAGE_KHR) &#123;</span><br><span class="line">        EGLint error = eglGetError();</span><br><span class="line">        ALOGE(<span class="string">"error creating EGLImage: %#x"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面创建Image主要代码就是eglCreateImageKHR函数，不过依然很悲催，还是和GPU相关的硬件代码。我们只能继续曲线救国了，查看软件创建Image的实现，位于/frameworks/native/opengl/libagl/egl.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EGLImageKHR <span class="title">eglCreateImageKHR</span><span class="params">(EGLDisplay dpy, EGLContext ctx, EGLenum target,</span><br><span class="line">        EGLClientBuffer buffer, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_NO_IMAGE_KHR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ctx != EGL_NO_CONTEXT) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_CONTEXT, EGL_NO_IMAGE_KHR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target != EGL_NATIVE_BUFFER_ANDROID) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_IMAGE_KHR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个buffer还是我们上层acquireBuffer时候获取的图形缓冲区buffer</span></span><br><span class="line">    ANativeWindowBuffer* native_buffer = (ANativeWindowBuffer*)buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (native_buffer-&gt;common.magic != ANDROID_NATIVE_BUFFER_MAGIC)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_IMAGE_KHR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (native_buffer-&gt;common.version != <span class="keyword">sizeof</span>(ANativeWindowBuffer))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_IMAGE_KHR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (native_buffer-&gt;format) &#123;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBA_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBX_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_565:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_BGRA_8888:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_IMAGE_KHR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    native_buffer-&gt;common.incRef(&amp;native_buffer-&gt;common);</span><br><span class="line">    <span class="keyword">return</span> (EGLImageKHR)native_buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;说是创建一个EGLImageKHR，其实还是对我们上层acquireBuffer时候获取的图形缓冲区buffer，进行一些处理包装。因为这是软件实现，所以参考价值不大吧。</p>
<p>&#160; &#160; &#160; &#160;3）将Image绑定到Texure：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GLConsumer::EglImage::bindToTextureTarget(<span class="keyword">uint32_t</span> texTarget) &#123;</span><br><span class="line">    glEGLImageTargetTexture2DOES(texTarget, (GLeglImageOES)mEglImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这次就真尴尬了，别说没硬件实现了，连软件都没得看了。。。。。。曲线救国没戏了，大清要亡啊。。。。。<br>&#160; &#160; &#160; &#160;中华民国到来，学医救不了中国。。。。。。java救不了中国，但是php能=。=<br>&#160; &#160; &#160; &#160;沦落到看模拟器实现绑定，看看goldfish的实现，位于device/generic/goldfish/opengl/system/GLESv2/gl2.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GL extensions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glEGLImageTargetTexture2DOES</span><span class="params">(<span class="keyword">void</span> * self, GLenum target, GLeglImageOES image)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    DBG(<span class="string">"glEGLImageTargetTexture2DOES v2 target=%#x img=%p\n"</span>, target, image);</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> check error - we don't have a way to set gl error</span></span><br><span class="line">    <span class="keyword">android_native_buffer_t</span>* native_buffer = (<span class="keyword">android_native_buffer_t</span>*)image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (native_buffer-&gt;common.magic != ANDROID_NATIVE_BUFFER_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (native_buffer-&gt;common.version != <span class="keyword">sizeof</span>(<span class="keyword">android_native_buffer_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GET_CONTEXT;</span><br><span class="line">    DEFINE_AND_VALIDATE_HOST_CONNECTION();</span><br><span class="line">    <span class="comment">//openGL的context上下文覆盖纹理坐标</span></span><br><span class="line">    ctx-&gt;override2DTextureTarget(target);</span><br><span class="line">    <span class="comment">//然后用渲染引擎绑定Image的缓冲区引用</span></span><br><span class="line">    rcEnc-&gt;rcBindTexture(rcEnc, ((<span class="keyword">cb_handle_t</span> *)(native_buffer-&gt;handle))-&gt;hostHandle);</span><br><span class="line">    <span class="comment">//然后恢复纹理</span></span><br><span class="line">    ctx-&gt;restore2DTextureTarget();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;看代码核心也是三步：openGL的context上下文覆盖纹理坐标；然后用渲染引擎绑定Image的缓冲区引用；然后恢复纹理。</p>
<p>&#160; &#160; &#160; &#160;4）等待OpenGL处理完成，返回fence：<br>&#160; &#160; &#160; &#160;上一节更新纹理时候讲过，里面调用acquireBufferLocked，buffer状态迁移到acquire，获得要显示出来的Buffer。这里会创建一个Fence，目前acquire fencefd还没使用，因为还未去合成这个layer，没到用layer中数据的时候。<br>&#160; &#160; &#160; &#160;如果到了合成步骤，这个Fence才是使用的时机，就是接下来第四部做的操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待生产者的acquire fence触发</span></span><br><span class="line"><span class="keyword">status_t</span> GLConsumer::doGLFenceWaitLocked() <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">    EGLDisplay dpy = eglGetCurrentDisplay();</span><br><span class="line">    EGLContext ctx = eglGetCurrentContext();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEglDisplay != dpy || mEglDisplay == EGL_NO_DISPLAY) &#123;</span><br><span class="line">        ST_LOGE(<span class="string">"doGLFenceWait: invalid current EGLDisplay"</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEglContext != ctx || mEglContext == EGL_NO_CONTEXT) &#123;</span><br><span class="line">        ST_LOGE(<span class="string">"doGLFenceWait: invalid current EGLContext"</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//等待生产者的acquire fence触发，</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentFence-&gt;isValid()) &#123;</span><br><span class="line">        <span class="comment">//检查EGL库是否支持EGL_ANDROID_native_fence_sync或者EGL_KHR_fence_sync属性的fence</span></span><br><span class="line">        <span class="keyword">if</span> (SyncFeatures::getInstance().useWaitSync()) &#123;</span><br><span class="line">            <span class="comment">// Create an EGLSyncKHR from the current fence.</span></span><br><span class="line">            <span class="comment">//dup一份上层传来的fence</span></span><br><span class="line">            <span class="keyword">int</span> fenceFd = mCurrentFence-&gt;dup();</span><br><span class="line">            <span class="keyword">if</span> (fenceFd == <span class="number">-1</span>) &#123;</span><br><span class="line">                ST_LOGE(<span class="string">"doGLFenceWait: error dup'ing fence fd: %d"</span>, errno);</span><br><span class="line">                <span class="keyword">return</span> -errno;</span><br><span class="line">            &#125;</span><br><span class="line">            EGLint attribs[] = &#123;</span><br><span class="line">                EGL_SYNC_NATIVE_FENCE_FD_ANDROID, fenceFd,</span><br><span class="line">                EGL_NONE</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//创建一个GPU的fence</span></span><br><span class="line">            EGLSyncKHR sync = eglCreateSyncKHR(dpy,</span><br><span class="line">                    EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);</span><br><span class="line">            <span class="keyword">if</span> (sync == EGL_NO_SYNC_KHR) &#123;</span><br><span class="line">                close(fenceFd);</span><br><span class="line">                ST_LOGE(<span class="string">"doGLFenceWait: error creating EGL fence: %#x"</span>,</span><br><span class="line">                        eglGetError());</span><br><span class="line">                <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">XXX:</span> The spec draft is inconsistent as to whether this should</span></span><br><span class="line">            <span class="comment">// return an EGLint or void.  Ignore the return value for now, as</span></span><br><span class="line">            <span class="comment">// it's not strictly needed.</span></span><br><span class="line">            <span class="comment">//GPU的fence等待，绘制完成会唤醒</span></span><br><span class="line">            eglWaitSyncKHR(dpy, sync, <span class="number">0</span>);</span><br><span class="line">            EGLint eglErr = eglGetError();</span><br><span class="line">            <span class="comment">//唤醒后移除fence围栏</span></span><br><span class="line">            eglDestroySyncKHR(dpy, sync);</span><br><span class="line">            <span class="keyword">if</span> (eglErr != EGL_SUCCESS) &#123;</span><br><span class="line">                ST_LOGE(<span class="string">"doGLFenceWait: error waiting for EGL fence: %#x"</span>,</span><br><span class="line">                        eglErr);</span><br><span class="line">                <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//不支持则上层fence去wait，一般都是-1</span></span><br><span class="line">            <span class="keyword">status_t</span> err = mCurrentFence-&gt;waitForever(</span><br><span class="line">                    <span class="string">"GLConsumer::doGLFenceWaitLocked"</span>);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                ST_LOGE(<span class="string">"doGLFenceWait: error waiting for fence: %d"</span>, err);</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;等待逻辑步骤如下：<br>&#160; &#160; &#160; &#160;1）这里会先等待生产者的acquire fence触发，检查这个Fence是否生效；<br>&#160; &#160; &#160; &#160;2）然后查询EGL库是否支持EGL_ANDROID_native_fence_sync或者EGL_KHR_fence_sync属性的fence，这些都是从OpenGL相关的so库中获取，我们看看实现，位于frameworks/native/libs/gui/SyncFeatures.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">SyncFeatures::SyncFeatures() : Singleton&lt;SyncFeatures&gt;(),</span><br><span class="line">        mHasNativeFenceSync(<span class="literal">false</span>),</span><br><span class="line">        mHasFenceSync(<span class="literal">false</span>),</span><br><span class="line">        mHasWaitSync(<span class="literal">false</span>) &#123;</span><br><span class="line">    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="comment">// This can only be called after EGL has been initialized; otherwise the</span></span><br><span class="line">    <span class="comment">// check below will abort.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* exts = eglQueryStringImplementationANDROID(dpy, EGL_EXTENSIONS);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(exts == <span class="literal">NULL</span>, <span class="string">"eglQueryStringImplementationANDROID failed"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(exts, <span class="string">"EGL_ANDROID_native_fence_sync"</span>)) &#123;</span><br><span class="line">        <span class="comment">// This makes GLConsumer use the EGL_ANDROID_native_fence_sync</span></span><br><span class="line">        <span class="comment">// extension to create Android native fences to signal when all</span></span><br><span class="line">        <span class="comment">// GLES reads for a given buffer have completed.</span></span><br><span class="line">        mHasNativeFenceSync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(exts, <span class="string">"EGL_KHR_fence_sync"</span>)) &#123;</span><br><span class="line">        mHasFenceSync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(exts, <span class="string">"EGL_KHR_wait_sync"</span>)) &#123;</span><br><span class="line">        mHasWaitSync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mString.append(<span class="string">"[using:"</span>);</span><br><span class="line">    <span class="keyword">if</span> (useNativeFenceSync()) &#123;</span><br><span class="line">        mString.append(<span class="string">" EGL_ANDROID_native_fence_sync"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (useFenceSync()) &#123;</span><br><span class="line">        mString.append(<span class="string">" EGL_KHR_fence_sync"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (useWaitSync()) &#123;</span><br><span class="line">        mString.append(<span class="string">" EGL_KHR_wait_sync"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mString.append(<span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> SyncFeatures::useNativeFenceSync() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// EGL_ANDROID_native_fence_sync is not compatible with using the</span></span><br><span class="line">    <span class="comment">// EGL_KHR_fence_sync extension for the same purpose.</span></span><br><span class="line">    <span class="keyword">return</span> mHasNativeFenceSync;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> SyncFeatures::useFenceSync() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DONT_USE_FENCE_SYNC</span></span><br><span class="line">    <span class="comment">// on some devices it's better to not use EGL_KHR_fence_sync</span></span><br><span class="line">    <span class="comment">// even if they have it</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// currently we shall only attempt to use EGL_KHR_fence_sync if</span></span><br><span class="line">    <span class="comment">// USE_FENCE_SYNC is set in our makefile</span></span><br><span class="line">    <span class="keyword">return</span> !mHasNativeFenceSync &amp;&amp; mHasFenceSync;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> SyncFeatures::useWaitSync() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (useNativeFenceSync() || useFenceSync()) &amp;&amp; mHasWaitSync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;查询GPU相关属性在eglQueryStringImplementationANDROID函数，不过这次我们曲线救国都没用了，中华民国也GG了=。=想想也是，Fence实现每家GPU都不同，并且也算比较重要的技术，肯定不会给我们开放的。。。</p>
<p>&#160; &#160; &#160; &#160;3）如果支持硬件Fence围栏，那么就用上层传入的fence去dup一份copy，然后根据这个copy创建一个GPU的fence。eglCreateSyncKHR依然GG，php也救不了中国～</p>
<p>&#160; &#160; &#160; &#160;4）GPU的fence等待，绘制完成会唤醒。等待操作GG。。。唤醒后就要销毁这个fence，放开栅栏；</p>
<p>&#160; &#160; &#160; &#160;5）fence的合法性验证为是否为-1，如果上层使用OpenGL绘制，那么fence就不为-1，下层也需要OpenGL绘制纹理；如果上层使用canvas绘制，那么fence就为-1，则gpu不等待，直接合成ok。</p>
<p>&#160; &#160; &#160; &#160;这就是OpenGL绑定纹理的操作，其中比较重要的是Fence在中间穿插的作用，这里只是简单分析，如果有机会，我会抽出一章专门分析一下。</p>
<h2 id="drawWithOpenGL"><a href="#drawWithOpenGL" class="headerlink" title="drawWithOpenGL"></a>drawWithOpenGL</h2><p>&#160; &#160; &#160; &#160;我们继续回到Layer的onDraw函数，继续分析合成步骤。<br>&#160; &#160; &#160; &#160;继续看下一部分：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//这个Layer是否是受保护的，比如截屏的Layer</span><br><span class="line">bool blackOutLayer = isProtected() || (isSecure() &amp;&amp; !hw-&gt;isSecure());</span><br><span class="line"></span><br><span class="line">    RenderEngine&amp; engine(mFlinger-&gt;getRenderEngine());</span><br><span class="line">    //不是受保护的Layer</span><br><span class="line">    if (!blackOutLayer) &#123;</span><br><span class="line">        // TODO: we could be more subtle with isFixedSize()</span><br><span class="line">        //是否是规则的形状，或者上层应用程序有能力确认缓冲区的有效性</span><br><span class="line">        //如果isFixedSize为true，那么就很容易处理图形的变换</span><br><span class="line">        const bool useFiltering = getFiltering() || needsFiltering(hw) || isFixedSize();</span><br><span class="line"></span><br><span class="line">        // Query the texture matrix given our current filtering mode.</span><br><span class="line">        float textureMatrix[16];</span><br><span class="line">        mSurfaceFlingerConsumer-&gt;setFilteringEnabled(useFiltering);</span><br><span class="line">        mSurfaceFlingerConsumer-&gt;getTransformMatrix(textureMatrix);</span><br><span class="line">        //如果这个图形缓冲区之前曾经被旋转过，例如，被水平翻转或者垂直翻转过，</span><br><span class="line">        //那么在对它进行合并之前，还需要将它的旋转方向恢复回来</span><br><span class="line">        if (mSurfaceFlingerConsumer-&gt;getTransformToDisplayInverse()) &#123;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">             * the code below applies the display's inverse transform to the texture transform</span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line">            // create a 4x4 transform matrix from the display transform flags</span><br><span class="line">            const mat4 flipH(-1,0,0,0,  0,1,0,0, 0,0,1,0, 1,0,0,1);</span><br><span class="line">            const mat4 flipV( 1,0,0,0, 0,-1,0,0, 0,0,1,0, 0,1,0,1);</span><br><span class="line">            const mat4 rot90( 0,1,0,0, -1,0,0,0, 0,0,1,0, 1,0,0,1);</span><br><span class="line"></span><br><span class="line">            mat4 tr;</span><br><span class="line">            uint32_t transform = hw-&gt;getOrientationTransform();</span><br><span class="line">            if (transform &amp; NATIVE_WINDOW_TRANSFORM_ROT_90)</span><br><span class="line">                tr = tr * rot90;</span><br><span class="line">            if (transform &amp; NATIVE_WINDOW_TRANSFORM_FLIP_H)</span><br><span class="line">                tr = tr * flipH;</span><br><span class="line">            if (transform &amp; NATIVE_WINDOW_TRANSFORM_FLIP_V)</span><br><span class="line">                tr = tr * flipV;</span><br><span class="line"></span><br><span class="line">            // calculate the inverse</span><br><span class="line">            //对它进行合并之前，还需要将它的旋转方向恢复回来</span><br><span class="line">            //所以需要反转变换矩阵</span><br><span class="line">            tr = inverse(tr);</span><br><span class="line"></span><br><span class="line">            // and finally apply it to the original texture matrix</span><br><span class="line">            //然后将它应用到纹理中</span><br><span class="line">            const mat4 texTransform(mat4(static_cast&lt;const float*&gt;(textureMatrix)) * tr);</span><br><span class="line">            memcpy(textureMatrix, texTransform.asArray(), sizeof(textureMatrix));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Set things up for texturing.</span><br><span class="line">        //将上面对纹理的配置设置进来</span><br><span class="line">        mTexture.setDimensions(mActiveBuffer-&gt;getWidth(), mActiveBuffer-&gt;getHeight());</span><br><span class="line">        mTexture.setFiltering(useFiltering);</span><br><span class="line">        mTexture.setMatrix(textureMatrix);</span><br><span class="line"></span><br><span class="line">        engine.setupLayerTexturing(mTexture);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        engine.setupLayerBlackedOut();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们处理合成的Layer一般都是不受保护的Layer，如果是截屏或者其他被保护的Layer，blackOutLayer就为true。<br>&#160; &#160; &#160; &#160;这里再说一下isFixedSize，这个在讲<a href="http://windrunnerlihuan.com/2017/10/24/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%B9%9D-SurfaceFlinger%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/">Android SurfaceFlinger 学习之路(九)—-SurfaceFlinger事务处理</a>的时候提到过，我们再复习一下。<br> &#160; &#160; &#160; &#160;Layer类的成员变量mFixedSize是一个布尔变量，它的值可以通过Layer类的成员函数isFixedSize来获得。从前面<a href="http://windrunnerlihuan.com/2017/06/17/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%AD-SurfaceFlinger%E5%88%9B%E5%BB%BASurface/">Android SurfaceFlinger 学习之路(六)—-SurfaceFlinger创建Surface</a>可以知道，当Android应用程序请求SurfaceFlinger服务分配一块图形缓冲区时，Android应用程序会传递两个参数reqWidth和reqHeight过来，表示请求分配的图形缓冲区的宽度和高度。这两个参数是可以同时等于0的，表示使用默认的宽度和高度值来创建所请求的图形缓冲区。这两个默认的宽度和高度值即等于当前所处理的应用程序窗口的宽度和高度值，而后者的宽度和高度值是在其创建的时候指定的。<br>&#160; &#160; &#160; &#160;Layer类的成员函数requestBuffer的参数reqWidth和reqHeight的值等于0意味着什么呢？从前面<a href="http://windrunnerlihuan.com/2017/07/03/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%AB-Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/">Android SurfaceFlinger 学习之路(八)—-Surface管理图形缓冲区</a>可以知道，Android应用程序在请求SurfaceFlinger服务分配一块图形缓冲区之前，会通过在Surface类内部来检查当前所处理的应用程序窗口的大小是否发生了变化。如果发生了变化，那么Android应用程序就会忽略掉缓存自己一侧的图形缓冲区，而去SurfaceFlinger服务请求新的图形缓冲区，因为那些缓存的图形缓冲区由于与它们所关联的应用程序窗口大小发生了变化而变为无效了。但是有一种特殊情况，在Android应用程序这一侧，用来描述应用程序窗口的Surface类可以不维护应用程序窗口的大小值。在这种情况下，Surface类就会将与它所关联的应用程序窗口的大小值设置为0，这意味着Android应用程序每次为这个应用程序窗口向SurfaceFlinger服务请求分配图形缓冲区之前，都认为这个应用程序窗口的大小值没有发生变化，同时传递给Layer类的参数reqWidth和reqHeight的值会等于0。事实上，一个应用程序窗口的大小是随时都可以发生变化的，比如，我们可以通过调用用来在Android应用程序和SurfaceFlinger服务建立连接的一个类型为Client的Binder对象的成员函数setState来改变一个应用程序窗口的大小，而一旦一个应用程序窗口的大小发生了变化，Layer类的成员函数doTransaction就会被调用。<br>&#160; &#160; &#160; &#160;Layer类的成员函数doTransaction在处理应用程序窗口大小变化时，需要考虑Android应用程序每次在为该应用程序窗口向SurfaceFlinger服务请求分配图形缓冲区之前，是否有能力去判断之前为该应用程序窗口缓存的图形缓冲区的有效性。如果没有的话，那么Layer类的成员函数doTransaction就需要将为该应用程序窗口缓存的图形缓冲区设置为无效，以便以后Android应用程序可以请求SurfaceFlinger服务分配新的、大小正确的图形缓冲区。从前面的分析还可以知道，当Android应用程序没有能力去判断之前为一个应用程序窗口所缓存的图形缓冲区的有效性时，那么之前在请求分配这些图形缓冲区时，传递给Layer类的的参数reqWidth和reqHeight的值就会等于0，这时候Layer类就会将Layer类的成员变量mFixedSize的值设置为false。<br>&#160; &#160; &#160; &#160;当Layer类的成员变量mFixedSize的值等于false时，由于Android应用程序没有能力去判断之前为一个应用程序窗口所缓存的图形缓冲区的有效性，因此，Layer类的成员函数doTransaction除了会调用外一个成员函数setBuffers来将新的应用程序窗口大小记录下来之外，还会通知BufferQueueProducer将当前正在处理的应用程序窗口所缓存的图形缓冲区设置为无效。<br>&#160; &#160; &#160; &#160;当Layer类的成员变量mFixedSize的值等于false时，Layer类的成员函数doTransaction还会提前将成员变量mCurrentState所描述的一个State对象的成员变量requested_w和requested_h的值保存到成员变量mDrawingState所描述的一个State对象的成员变量requested_w和requested_h中去，这是为了避免后面调用父类Layer的成员函数doTransaction时，会返回一个Layer::eVisibleRegion位不等于0的标志值给前面，而这将会导致SurfaceFlinger服务马上重新计算各个应用程序窗口的可见区域。现在不返回一个Layer::eVisibleRegion位不等于0的标志值给前面，就会等到下次渲染当前正在处理的应用程序窗口时再重新计算各个应用程序窗口的可见区域。</p>
<p>&#160; &#160; &#160; &#160;太长了，跳过~<br>&#160; &#160; &#160; &#160;GLConsumer的构造函数中mFilteringEnabled(true)，所以filter为true。filter参数是OpenGL中使用纹理坐标映射到纹素数组，比如我们在doTransatin时候提到的线性滤波方法(linear filtering)。要理解这个也是需要OpenGL基础啊，奈何我也是小白=。=不过我们知道这里就是打开了滤波设置。</p>
<p>&#160; &#160; &#160; &#160;接下来代码用来检查当前正在处理的应用程序窗口的图形缓冲区是否是一个可以跳过合成阶段的图形缓冲区。本来这种图形缓冲区是可以直接渲染到硬件帧缓冲区中去的，但是由于它不是全屏显示的，因此就需要与其它应用程序窗口的图形缓冲区进行合并操作。如果这个图形缓冲区之前曾经被旋转过，例如，被水平翻转或者垂直翻转过，那么在对它进行合并之前，还需要将它的旋转方向恢复回来。<br>&#160; &#160; &#160; &#160;当用来描述一个图形缓冲区的一个GraphicBuffer对象的成员变量transform的值不等于0时，那么就说明这个图形缓冲区是被旋转过的，这时候函数就会对这个成员变量的值的NATIVE_WINDOW_TRANSFORM_FLIP_H位或者NATIVE_WINDOW_TRANSFORM_FLIP_V位进行取反，目的就是为了恢复它之前的旋转方向。</p>
<p>&#160; &#160; &#160; &#160;然后进入最后一部分，drawWithOpenGL：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drawWithOpenGL(hw, clip, useIdentityTransform);</span><br><span class="line">engine.disableTexturing();</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;drawWithOpenGL来将这个图形缓冲区的内容绘制在系统的主显示屏的指定区域上来，这个图形缓冲区的内容是使用mesh对象来描述的，包括顶点缓冲,索引缓冲,纹理对象等，而指定的主显示屏区域是由参数clip来描述的。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void Layer::drawWithOpenGL(const sp&lt;const DisplayDevice&gt;&amp; hw,</span><br><span class="line">        const Region&amp; /* clip */, bool useIdentityTransform) const &#123;</span><br><span class="line">    const uint32_t fbHeight = hw-&gt;getHeight();</span><br><span class="line">    const State&amp; s(getDrawingState());</span><br><span class="line"></span><br><span class="line">    computeGeometry(hw, mMesh, useIdentityTransform);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * NOTE: the way we compute the texture coordinates here produces</span><br><span class="line">     * different results than when we take the HWC path -- in the later case</span><br><span class="line">     * the "source crop" is rounded to texel boundaries.</span><br><span class="line">     * This can produce significantly different results when the texture</span><br><span class="line">     * is scaled by a large amount.</span><br><span class="line">     *</span><br><span class="line">     * The GL code below is more logical (imho), and the difference with</span><br><span class="line">     * HWC is due to a limitation of the HWC API to integers -- a question</span><br><span class="line">     * is suspend is whether we should ignore this problem or revert to</span><br><span class="line">     * GL composition when a buffer scaling is applied (maybe with some</span><br><span class="line">     * minimal value)? Or, we could make GL behave like HWC -- but this feel</span><br><span class="line">     * like more of a hack.</span><br><span class="line">     */</span><br><span class="line">    const Rect win(computeBounds());</span><br><span class="line"></span><br><span class="line">    float left   = float(win.left)   / float(s.active.w);</span><br><span class="line">    float top    = float(win.top)    / float(s.active.h);</span><br><span class="line">    float right  = float(win.right)  / float(s.active.w);</span><br><span class="line">    float bottom = float(win.bottom) / float(s.active.h);</span><br><span class="line"></span><br><span class="line">    // TODO: we probably want to generate the texture coords with the mesh</span><br><span class="line">    // here we assume that we only have 4 vertices</span><br><span class="line">    Mesh::VertexArray&lt;vec2&gt; texCoords(mMesh.getTexCoordArray&lt;vec2&gt;());</span><br><span class="line">    texCoords[0] = vec2(left, 1.0f - top);</span><br><span class="line">    texCoords[1] = vec2(left, 1.0f - bottom);</span><br><span class="line">    texCoords[2] = vec2(right, 1.0f - bottom);</span><br><span class="line">    texCoords[3] = vec2(right, 1.0f - top);</span><br><span class="line"></span><br><span class="line">    RenderEngine&amp; engine(mFlinger-&gt;getRenderEngine());</span><br><span class="line">    engine.setupLayerBlending(mPremultipliedAlpha, isOpaque(s), s.alpha);</span><br><span class="line">    engine.drawMesh(mMesh);</span><br><span class="line">    engine.disableBlending();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个我们也是分步查看：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    //主显示屏高度</span><br><span class="line">    const uint32_t fbHeight = hw-&gt;getHeight();</span><br><span class="line">    //当前正在处理的应用程序窗口状态的一个State对象s</span><br><span class="line">    const State&amp; s(getDrawingState());</span><br><span class="line">    computeGeometry(hw, mMesh, useIdentityTransform);</span><br><span class="line"></span><br><span class="line">/*-----------------*/</span><br><span class="line">void Layer::computeGeometry(const sp&lt;const DisplayDevice&gt;&amp; hw, Mesh&amp; mesh,</span><br><span class="line">        bool useIdentityTransform) const</span><br><span class="line">&#123;</span><br><span class="line">    const Layer::State&amp; s(getDrawingState());</span><br><span class="line">    //上一步反转后的变换transform</span><br><span class="line">    const Transform tr(useIdentityTransform ?</span><br><span class="line">            hw-&gt;getTransform() : hw-&gt;getTransform() * s.transform);</span><br><span class="line">    const uint32_t hw_h = hw-&gt;getHeight();</span><br><span class="line">    Rect win(s.active.w, s.active.h);</span><br><span class="line">    if (!s.active.crop.isEmpty()) &#123;</span><br><span class="line">        win.intersect(s.active.crop, &amp;win);</span><br><span class="line">    &#125;</span><br><span class="line">    // subtract the transparent region and snap to the bounds</span><br><span class="line">    //应用程序窗口减去透明区域</span><br><span class="line">    win = reduce(win, s.activeTransparentRegion);</span><br><span class="line">    //获取纹理的位置坐标</span><br><span class="line">    Mesh::VertexArray&lt;vec2&gt; position(mesh.getPositionArray&lt;vec2&gt;());</span><br><span class="line">    position[0] = tr.transform(win.left,  win.top);</span><br><span class="line">    position[1] = tr.transform(win.left,  win.bottom);</span><br><span class="line">    position[2] = tr.transform(win.right, win.bottom);</span><br><span class="line">    position[3] = tr.transform(win.right, win.top);</span><br><span class="line">    for (size_t i=0 ; i&lt;4 ; i++) &#123;</span><br><span class="line">        position[i].y = hw_h - position[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码首先得到主显示屏的高度fbHeight、要绘制的区域mesh的位置坐标，以及用来描述当前正在处理的应用程序窗口状态的一个State对象s。</p>
<p>&#160; &#160; &#160; &#160;接着往下看：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> const Rect win(computeBounds());</span><br><span class="line"></span><br><span class="line">    float left   = float(win.left)   / float(s.active.w);</span><br><span class="line">    float top    = float(win.top)    / float(s.active.h);</span><br><span class="line">    float right  = float(win.right)  / float(s.active.w);</span><br><span class="line">    float bottom = float(win.bottom) / float(s.active.h);</span><br><span class="line"></span><br><span class="line">    // TODO: we probably want to generate the texture coords with the mesh</span><br><span class="line">    // here we assume that we only have 4 vertices</span><br><span class="line">    Mesh::VertexArray&lt;vec2&gt; texCoords(mMesh.getTexCoordArray&lt;vec2&gt;());</span><br><span class="line">    texCoords[0] = vec2(left, 1.0f - top);</span><br><span class="line">    texCoords[1] = vec2(left, 1.0f - bottom);</span><br><span class="line">    texCoords[2] = vec2(right, 1.0f - bottom);</span><br><span class="line">    texCoords[3] = vec2(right, 1.0f - top);</span><br><span class="line">/*-----------------*/</span><br><span class="line">Rect Layer::computeBounds() const &#123;</span><br><span class="line">    const Layer::State&amp; s(getDrawingState());</span><br><span class="line">    Rect win(s.active.w, s.active.h);</span><br><span class="line">    if (!s.active.crop.isEmpty()) &#123;</span><br><span class="line">        win.intersect(s.active.crop, &amp;win);</span><br><span class="line">    &#125;</span><br><span class="line">    // subtract the transparent region and snap to the bounds</span><br><span class="line">    return reduce(win, s.activeTransparentRegion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面是根据mesh的位置计算出纹理顶点的坐标。<br>&#160; &#160; &#160; &#160;如果Android应用程序没有指定一个窗口的纹理坐标，那么这个窗口的纹理坐标的默认值就使用要绘制的纹理的四个角的坐标来描述。注意，在计算纹理坐标的时候，还要考虑纹理的大小，以及纹理本身所设置的缩放因子，以便可以正确地将纹理绘制在应用程序窗口中。</p>
<p>&#160; &#160; &#160; &#160;继续往下，先看看这一步：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RenderEngine&amp; engine(mFlinger-&gt;getRenderEngine());</span><br><span class="line">engine.setupLayerBlending(mPremultipliedAlpha, isOpaque(s), s.alpha);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Android在此新增一个RenderEngine类，用来屏蔽OpenGL ES1.0、1.1和2.0的用法差异。基本用法和opengl是一样的，没有简化太多。<br>&#160; &#160; &#160; &#160;这一步是对颜色的处理，我们看看OpenGL E2.0的实现，位于frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GLES20RenderEngine::setupDimLayerBlending(<span class="keyword">int</span> alpha) &#123;</span><br><span class="line">    mState.setPlaneAlpha(<span class="number">1.0f</span>);</span><br><span class="line">    mState.setPremultipliedAlpha(<span class="literal">true</span>);</span><br><span class="line">    mState.setOpaque(<span class="literal">false</span>);</span><br><span class="line">    mState.setColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, alpha/<span class="number">255.0f</span>);</span><br><span class="line">    mState.disableTexture();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alpha == <span class="number">0xFF</span>) &#123;</span><br><span class="line">        glDisable(GL_BLEND);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        glEnable(GL_BLEND);</span><br><span class="line">        glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里是设定图层混合的模式（mPremultipliedAlpha表示该图层是否已经做过预乘处理，Opaque表示该图层像素是否无视本图层的透明度，s.alpha表示该图层的整体透明度）。是否需要以混合模式来绘制，这是通过调用函数glEnable(GL_BLEND)来实现的。在需要混合模式来绘制纹理texture的情况下，还需要调用函数glBlendFunc来指定混合函数。<br>&#160; &#160; &#160; &#160;当前正在处理的应用程序窗口的Alpha通道的值小于0xFF，即State对象s的成员变量alpha的值小于0xFF，这表明该窗口的背景是半透明的。此时就需要使用混合模式来绘制纹理。</p>
<p>&#160; &#160; &#160; &#160;我们看最后一部分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    engine.drawMesh(mMesh);</span><br><span class="line">    engine.disableBlending();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------GLES20RenderEngine.cpp---------*/</span></span><br><span class="line"><span class="keyword">void</span> GLES20RenderEngine::drawMesh(<span class="keyword">const</span> Mesh&amp; mesh) &#123;</span><br><span class="line"></span><br><span class="line">    ProgramCache::getInstance().useProgram(mState);</span><br><span class="line">    <span class="comment">//指定要绘制的顶点数组</span></span><br><span class="line">    <span class="keyword">if</span> (mesh.getTexCoordsSize()) &#123;</span><br><span class="line">        glEnableVertexAttribArray(Program::texCoords);</span><br><span class="line">        glVertexAttribPointer(Program::texCoords,</span><br><span class="line">                mesh.getTexCoordsSize(),</span><br><span class="line">                GL_FLOAT, GL_FALSE,</span><br><span class="line">                mesh.getByteStride(),</span><br><span class="line">                mesh.getTexCoords());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定要绘制的纹理坐标</span></span><br><span class="line">    glVertexAttribPointer(Program::position,</span><br><span class="line">            mesh.getVertexSize(),</span><br><span class="line">            GL_FLOAT, GL_FALSE,</span><br><span class="line">            mesh.getByteStride(),</span><br><span class="line">            mesh.getPositions());</span><br><span class="line">    <span class="comment">//绘制前面指定的顶点数组以及纹理</span></span><br><span class="line">    glDrawArrays(mesh.getPrimitive(), <span class="number">0</span>, mesh.getVertexCount());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mesh.getTexCoordsSize()) &#123;</span><br><span class="line">        glDisableVertexAttribArray(Program::texCoords);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> GLES20RenderEngine::disableBlending() &#123;</span><br><span class="line">    glDisable(GL_BLEND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;分别调用函数glVertexPointer和glTexCoordPointer来指定要绘制的顶点数组以及纹理坐标。设置好要绘制的顶点数组以及纹理坐标之后，最后调用函数glDrawArrays来绘制前面指定的顶点数组以及纹理。<br>&#160; &#160; &#160; &#160;其中这三个函数依然让我们曲线救国失败啊，大清彻底亡了=。=</p>
<p>&#160; &#160; &#160; &#160;doComposeSurfaces流程就分析完了，我们回到SF的doDisplayComposition函数继续。</p>
<p>&#160; &#160; &#160; &#160;到此合成流程就完了，接下来到了和FB交换buffer。</p>
<h1 id="交换合成缓冲区"><a href="#交换合成缓冲区" class="headerlink" title="交换合成缓冲区"></a>交换合成缓冲区</h1><p>&#160; &#160; &#160; &#160;沿着上面到了doDisplayComposition的最后一步。 与fb交换脏区域，会调用eglSwapBuffer函数，使用egl将egl中的合成好的图像，输出到DisplayDevice的mSurface中。<br>&#160; &#160; &#160; &#160;继续查看，调用DisplayDevice的swapBuffers函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DisplayDevice::swapBuffers(HWComposer&amp; hwc) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// We need to call eglSwapBuffers() if:</span></span><br><span class="line">    <span class="comment">//  (1) we don't have a hardware composer, or</span></span><br><span class="line">    <span class="comment">//  (2) we did GLES composition this frame, and either</span></span><br><span class="line">    <span class="comment">//    (a) we have framebuffer target support (not present on legacy</span></span><br><span class="line">    <span class="comment">//        devices, where HWComposer::commit() handles things); or</span></span><br><span class="line">    <span class="comment">//    (b) this is a virtual display</span></span><br><span class="line">    <span class="comment">//当以下几种情况我们会调用eglSwapBuffers：</span></span><br><span class="line">    <span class="comment">//1.没有硬件合成器</span></span><br><span class="line">    <span class="comment">//2.使用OpenGL合成这一帧时候，以下两种情况之一</span></span><br><span class="line">    <span class="comment">//a.有FRAME_BUFFER_TARGET支持（overlay合成时候还有遗留的设备）</span></span><br><span class="line">    <span class="comment">//b.这是一个虚拟显屏</span></span><br><span class="line">    <span class="keyword">if</span> (hwc.initCheck() != NO_ERROR ||</span><br><span class="line">            (hwc.hasGlesComposition(mHwcDisplayId) &amp;&amp;</span><br><span class="line">             (hwc.supportsFramebufferTarget() || mType &gt;= DISPLAY_VIRTUAL))) &#123;</span><br><span class="line">        <span class="comment">//调用OpenGL库中的函数eglSwapBuffers来将系统的UI渲染到系统的主绘图表面上去的</span></span><br><span class="line">        EGLBoolean success = eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            EGLint error = eglGetError();</span><br><span class="line">            <span class="keyword">if</span> (error == EGL_CONTEXT_LOST ||</span><br><span class="line">                    mType == DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"eglSwapBuffers(%p, %p) failed with 0x%08x"</span>,</span><br><span class="line">                        mDisplay, mSurface, error);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"eglSwapBuffers(%p, %p) failed with 0x%08x"</span>,</span><br><span class="line">                        mDisplay, mSurface, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = mDisplaySurface-&gt;advanceFrame();</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"[%s] failed pushing new frame to HWC: %d"</span>,</span><br><span class="line">                mDisplayName.<span class="built_in">string</span>(), result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;调用OpenGL库中的函数eglSwapBuffers来将系统的UI渲染到系统的主绘图表面上去的，即渲染到系统的硬件帧缓冲区上去的。<br>&#160; &#160; &#160; &#160;这里天不亡大清~~继续曲线救国，我们看看软件的实现，位于frameworks/native/opengl/libagl/egl.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EGLBoolean <span class="title">eglSwapBuffers</span><span class="params">(EGLDisplay dpy, EGLSurface draw)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    <span class="comment">//将EGLSurface 强转为egl_surface_t结构体指针</span></span><br><span class="line">    <span class="keyword">egl_surface_t</span>* d = <span class="keyword">static_cast</span>&lt;<span class="keyword">egl_surface_t</span>*&gt;(draw);</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;isValid())</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;dpy != dpy)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// post the surface</span></span><br><span class="line">    <span class="comment">//然后调用swapBuffers完成交换操作</span></span><br><span class="line">    d-&gt;swapBuffers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if it's bound to a context, update the buffer</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ctx != EGL_NO_CONTEXT) &#123;</span><br><span class="line">        d-&gt;bindDrawSurface((<span class="keyword">ogles_context_t</span>*)d-&gt;ctx);</span><br><span class="line">        <span class="comment">// if this surface is also the read surface of the context</span></span><br><span class="line">        <span class="comment">// it is bound to, make sure to update the read buffer as well.</span></span><br><span class="line">        <span class="comment">// The EGL spec is a little unclear about this.</span></span><br><span class="line">        <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(d-&gt;ctx);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;read == draw) &#123;</span><br><span class="line">            d-&gt;bindReadSurface((<span class="keyword">ogles_context_t</span>*)d-&gt;ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先将将EGLSurface 强转为egl_surface_t结构体指针，这里为什么能强转，我们下面一个小节会讲到。接着调用swapBuffers无参函数完成交换。同样位于frameworks/native/opengl/libagl/egl.cpp下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">EGLBoolean egl_window_surface_v2_t::swapBuffers()</span><br><span class="line">&#123;</span><br><span class="line">    if (!buffer) &#123;</span><br><span class="line">        return setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * Handle eglSetSwapRectangleANDROID()</span><br><span class="line">     * We copyback from the front buffer </span><br><span class="line">     */</span><br><span class="line">     //如果合成区域的脏区域不为空</span><br><span class="line">    if (!dirtyRegion.isEmpty()) &#123;</span><br><span class="line">        //首先通过andSelf（）函数，算出在buffer中的dirtyRegion的区域</span><br><span class="line">        dirtyRegion.andSelf(Rect(buffer-&gt;width, buffer-&gt;height));</span><br><span class="line">        //如果上一次buffer不为空</span><br><span class="line">        if (previousBuffer) &#123;</span><br><span class="line">            // This was const Region copyBack, but that causes an</span><br><span class="line">            // internal compile error on simulator builds</span><br><span class="line">            //然后调用subtract将oldDirtyRegion中去掉了dirtyRegion区域，</span><br><span class="line">            //然后见这块区域从previousBuffer拷贝到当前的buffer中。</span><br><span class="line">            /*const*/ Region copyBack(Region::subtract(oldDirtyRegion, dirtyRegion));</span><br><span class="line">            if (!copyBack.isEmpty()) &#123;</span><br><span class="line">                void* prevBits;</span><br><span class="line">                if (lock(previousBuffer, </span><br><span class="line">                        GRALLOC_USAGE_SW_READ_OFTEN, &amp;prevBits) == NO_ERROR) &#123;</span><br><span class="line">                    // copy from previousBuffer to buffer</span><br><span class="line">                    copyBlt(buffer, bits, previousBuffer, prevBits, copyBack);</span><br><span class="line">                    unlock(previousBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将新的脏区域赋值给oldDirtyRegion</span><br><span class="line">        oldDirtyRegion = dirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line">    //将少之前buffer的对gralloc的引用</span><br><span class="line">    if (previousBuffer) &#123;</span><br><span class="line">        previousBuffer-&gt;common.decRef(&amp;previousBuffer-&gt;common); </span><br><span class="line">        previousBuffer = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unlock(buffer);</span><br><span class="line">    //完成buffer内容的填充，然后将previousBuffer指向buffer</span><br><span class="line">    previousBuffer = buffer;</span><br><span class="line">    //这里的nativeWindow是egl_window_surface_v2_t结构体的成员变量</span><br><span class="line">    //是一个ANativeWindow*类型</span><br><span class="line">    //在DisplayDevice构造函数里调用eglCreateWindowSurface创建egl_window_surface_v2_t实例时候，</span><br><span class="line">    //new了一个Surface传入的</span><br><span class="line">    //这里还调用了Surface的queueBuffer函数</span><br><span class="line">    //从之前将Surface管理缓冲区得知，这会回调consumer的onFrameAvailable函数</span><br><span class="line">    //调用surface的queueBuffer，agl的实现fencefd输入为-1</span><br><span class="line">    //硬件平台不为-1，比如抓高通的log</span><br><span class="line">    //肯定在前面先创建了fence同步对象，经过merge后肯定不再为-1了</span><br><span class="line">    nativeWindow-&gt;queueBuffer(nativeWindow, buffer, -1);</span><br><span class="line">    buffer = 0;</span><br><span class="line"></span><br><span class="line">    // dequeue a new buffer</span><br><span class="line">    int fenceFd = -1;</span><br><span class="line">    //然后dequeue一个新的buffer，并等待fence</span><br><span class="line">    ///第一次被申请的buffer slot。返回-1</span><br><span class="line">    //假设不是。有release fence，则会dup该fencefd</span><br><span class="line">    if (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer, &amp;fenceFd) == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;Fence&gt; fence(new Fence(fenceFd));</span><br><span class="line">        //wait，等待release fence触发</span><br><span class="line">        //如果fence超时，就把buffer cancel掉。</span><br><span class="line">        if (fence-&gt;wait(Fence::TIMEOUT_NEVER)) &#123;</span><br><span class="line">            nativeWindow-&gt;cancelBuffer(nativeWindow, buffer, fenceFd);</span><br><span class="line">            return setError(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // reallocate the depth-buffer if needed</span><br><span class="line">        //按需重新计算buffer</span><br><span class="line">        if ((width != buffer-&gt;width) || (height != buffer-&gt;height)) &#123;</span><br><span class="line">            // TODO: we probably should reset the swap rect here</span><br><span class="line">            // if the window size has changed</span><br><span class="line">            width = buffer-&gt;width;</span><br><span class="line">            height = buffer-&gt;height;</span><br><span class="line">            if (depth.data) &#123;</span><br><span class="line">                free(depth.data);</span><br><span class="line">                depth.width   = width;</span><br><span class="line">                depth.height  = height;</span><br><span class="line">                depth.stride  = buffer-&gt;stride;</span><br><span class="line">                depth.data    = (GGLubyte*)malloc(depth.stride*depth.height*2);</span><br><span class="line">                if (depth.data == 0) &#123;</span><br><span class="line">                    setError(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">                    return EGL_FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // keep a reference on the buffer</span><br><span class="line">        buffer-&gt;common.incRef(&amp;buffer-&gt;common);</span><br><span class="line"></span><br><span class="line">        // finally pin the buffer down</span><br><span class="line">        if (lock(buffer, GRALLOC_USAGE_SW_READ_OFTEN |</span><br><span class="line">                GRALLOC_USAGE_SW_WRITE_OFTEN, &amp;bits) != NO_ERROR) &#123;</span><br><span class="line">            ALOGE("eglSwapBuffers() failed to lock buffer %p (%ux%u)",</span><br><span class="line">                    buffer, buffer-&gt;width, buffer-&gt;height);</span><br><span class="line">            return setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">            // FIXME: we should make sure we're not accessing the buffer anymore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return setError(EGL_BAD_CURRENT_SURFACE, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;软件实现大致如下：<br>&#160; &#160; &#160; &#160;1）如果合成区域的脏区域不为空，首先通过andSelf（）函数，算出在buffer中的dirtyRegion的区域，然后调用subtract将oldDirtyRegion中去掉了dirtyRegion区域，然后见这块区域从previousBuffer拷贝到当前的buffer中。这一部分和我门之前讲<a href="http://windrunnerlihuan.com/2017/07/03/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%AB-Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/">Android SurfaceFlinger 学习之路(八)—-Surface管理图形缓冲区</a>中Surface申请图形缓冲区过程类似，也是没有变化的区域就用copyBlt拷贝像素。<br>&#160; &#160; &#160; &#160;2）将新的脏区域赋值给oldDirtyRegion，将少之前buffer的对gralloc的引用（这个我们在讲<a href="http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%B8%80-Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/">Android SurfaceFlinger 学习之路(一)—-Android图形显示之HAL层Gralloc模块实现</a>中提到过，这是C语言中的一种继承方式），完成buffer内容的填充，然后将previousBuffer指向buffer。<br>&#160; &#160; &#160; &#160;3）接着调用调用nativeBuffer变量的queueBuffer。这里的nativeWindow是egl_window_surface_v2_t结构体的成员变量，是一个ANativeWindow*类型。在DisplayDevice构造函数里调用eglCreateWindowSurface创建egl_window_surface_v2_t实例时候，new了一个Surface传入的。之前<a href="http://windrunnerlihuan.com/2017/06/17/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%AD-SurfaceFlinger%E5%88%9B%E5%BB%BASurface/">Android SurfaceFlinger 学习之路(六)—-SurfaceFlinger创建Surface</a>讲过，Surface间接继承与ANativeWindow。<br>&#160; &#160; &#160; &#160;从之前将Surface管理缓冲区得知，这会回调consumer的onFrameAvailable函数，后面会讲到，这会触发FrameBufferSurface的onFrameAvailable函数回调。<br>&#160; &#160; &#160; &#160;调用surface的queueBuffer，agl的实现fencefd输入为-1。硬件平台不为-1，比如抓高通的log，肯定在前面先创建了fence同步对象，经过merge后肯定不再为-1了。<br>&#160; &#160; &#160; &#160;4）Dequeue一块新的buffer，并wait，等待release fence触发。如果等待超时，就将buffer cancel掉。第一次被申请的buffer slot，返回-1。假设不是。有release fence，则会dup该fencefd。<br>&#160; &#160; &#160; &#160;5）按需重新计算buffer。</p>
<p>&#160; &#160; &#160; &#160;既然提到交换缓冲区，就是讲生产者的内容post到消费者去，所以我们应该关注nativeWindow的queueBuffer过程。在讲这一部分之前，我们要看看之前讲到的DisplayDevice和FrameBufferSurface关系，还要引入一点OpenGL相关的内容。</p>
<h2 id="OpenGL环境创建"><a href="#OpenGL环境创建" class="headerlink" title="OpenGL环境创建"></a>OpenGL环境创建</h2><p>&#160; &#160; &#160; &#160;使用OpenGL标准，用GPU把图层画到统一的FrameBuffer上，然后送显。毫无疑问这是离线合成的一种。EGL标准下，OpenGL环境创建的一般流程如下图所示： </p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/opengl.png" alt="opengl"></p>
<p>&#160; &#160; &#160; &#160;这部分工作在SurfaceFlinger::init函数完成，也即服务初起之时。我们在讲<a href="http://windrunnerlihuan.com/2017/05/25/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%94-VSync-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">Android SurfaceFlinger 学习之路(五)—-VSync 工作原理</a>时候提到过这一部分：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// initialize EGL for the default display</span><br><span class="line">mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">eglInitialize(mEGLDisplay, NULL, NULL);</span><br><span class="line"></span><br><span class="line">//初始化硬件合成器（这个和3D合成无关）</span><br><span class="line">mHwc = new HWComposer(this,</span><br><span class="line">        *static_cast&lt;HWComposer::EventHandler *&gt;(this));</span><br><span class="line"></span><br><span class="line">//创建渲染引擎，主要是选择EGL配置，选择OpenGL版本，创建OpenGL上下文</span><br><span class="line">mRenderEngine = RenderEngine::create(mEGLDisplay, mHwc-&gt;getVisualID());</span><br><span class="line">// retrieve the EGL context that was selected/created</span><br><span class="line">mEGLContext = mRenderEngine-&gt;getEGLContext();</span><br><span class="line"></span><br><span class="line">LOG_ALWAYS_FATAL_IF(mEGLContext == EGL_NO_CONTEXT,</span><br><span class="line">        "couldn't create EGLContext");</span><br><span class="line"></span><br><span class="line">//创建OpenGL的渲染目标Surface</span><br><span class="line">for (size_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">    DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">    // set-up the displays that are already connected</span><br><span class="line">    if (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">        // All non-virtual displays are currently considered secure.</span><br><span class="line">        bool isSecure = true;</span><br><span class="line">        createBuiltinDisplayLocked(type);</span><br><span class="line">        wp&lt;IBinder&gt; token = mBuiltinDisplays[i];</span><br><span class="line"></span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">        sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">        BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                new GraphicBufferAlloc());</span><br><span class="line">        /*创建窗口Surface所需要的window句柄，注意这里面window句柄是FramebufferSurface*/</span><br><span class="line">        sp&lt;FramebufferSurface&gt; fbs = new FramebufferSurface(*mHwc, i,</span><br><span class="line">                consumer);</span><br><span class="line">        int32_t hwcId = allocateHwcDisplayId(type);</span><br><span class="line">        /*在构造函数中，调用 eglCreateSurface 创建了OpenGL渲染的目标Surface*/</span><br><span class="line">        sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this,</span><br><span class="line">                type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                fbs, producer,</span><br><span class="line">                mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">        if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            // FIXME: currently we don't get blank/unblank requests</span><br><span class="line">            // for displays other than the main display, so we always</span><br><span class="line">            // assume a connected display is unblanked.</span><br><span class="line">            ALOGD("marking display %zu as acquired/unblanked", i);</span><br><span class="line">            hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        mDisplays.add(token, hw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// make the GLContext current so that we can create textures when creating Layers</span><br><span class="line">// (which may happens before we render something)</span><br><span class="line">/*绑定上下文和Surface，以便绘制，这一步在调用OpenGL的drawcall之前就可以，这里调一次貌似是没必要的*/</span><br><span class="line">getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;对使用opengl合成的layer将合成结果放置到HWC_FRAMEBUFFER_TARGET layer中，然后再交给HWComposer处理。在surfaceflinger的init函数中，定义了HWC_FRAMEBUFFER_TARGET layer合成时相应的生成者和消费者，每一个display相应有一个DisplayDevice作为生产者(opengl合成数据)，而FramebufferSurface是相应的消费者(注意这个消费者仅仅是处理opengl合成相关的，overlay全然由HAL层的hwcomposer处理)。<br>&#160; &#160; &#160; &#160;注意到，创建的窗口是FramebufferSurface。为了更直观的查看Surface创建流程，我们再把DisplayDevice构造函数贴出来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">DisplayDevice::DisplayDevice(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        DisplayType type,</span><br><span class="line">        <span class="keyword">int32_t</span> hwcId,</span><br><span class="line">        <span class="keyword">bool</span> isSecure,</span><br><span class="line">        <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; displayToken,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DisplaySurface&gt;&amp; displaySurface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; producer,</span><br><span class="line">        EGLConfig config)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mType(type), mHwcDisplayId(hwcId),</span><br><span class="line">      mDisplayToken(displayToken),</span><br><span class="line">      mDisplaySurface(displaySurface),</span><br><span class="line">      mDisplay(EGL_NO_DISPLAY),</span><br><span class="line">      mSurface(EGL_NO_SURFACE),</span><br><span class="line">      mDisplayWidth(), mDisplayHeight(), mFormat(),</span><br><span class="line">      mFlags(),</span><br><span class="line">      mPageFlipCount(),</span><br><span class="line">      mIsSecure(isSecure),</span><br><span class="line">      mSecureLayerVisible(<span class="literal">false</span>),</span><br><span class="line">      mScreenAcquired(<span class="literal">false</span>),</span><br><span class="line">      mLayerStack(NO_LAYER_STACK),</span><br><span class="line">      mOrientation()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//利用bq创建surface</span></span><br><span class="line">    mNativeWindow = <span class="keyword">new</span> Surface(producer, <span class="literal">false</span>);</span><br><span class="line">    ANativeWindow* <span class="keyword">const</span> window = mNativeWindow.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line">    window-&gt;query(window, NATIVE_WINDOW_FORMAT, &amp;format);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that composition can never be stalled by a virtual display</span></span><br><span class="line">    <span class="comment">// consumer that isn't processing buffers fast enough. We have to do this</span></span><br><span class="line">    <span class="comment">// in two places:</span></span><br><span class="line">    <span class="comment">// * Here, in case the display is composed entirely by HWC.</span></span><br><span class="line">    <span class="comment">// * In makeCurrent(), using eglSwapInterval. Some EGL drivers set the</span></span><br><span class="line">    <span class="comment">//   window's swap interval in eglMakeCurrent, so they'll override the</span></span><br><span class="line">    <span class="comment">//   interval we set here.</span></span><br><span class="line">    <span class="keyword">if</span> (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL)</span><br><span class="line">        window-&gt;setSwapInterval(window, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Create our display's surface</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 利用EGL创建本地opengl环境，要用opengl 合成layer</span></span><br><span class="line">    EGLSurface surface;</span><br><span class="line">    EGLint w, h;</span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="comment">//调用eglCreateWindowSurface创建EGLSurface</span></span><br><span class="line">    surface = eglCreateWindowSurface(display, config, window, <span class="literal">NULL</span>);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_WIDTH,  &amp;mDisplayWidth);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;mDisplayHeight);</span><br><span class="line"></span><br><span class="line">    mDisplay = display;</span><br><span class="line">    mSurface = surface;</span><br><span class="line">    mFormat  = format;</span><br><span class="line">    mPageFlipCount = <span class="number">0</span>;</span><br><span class="line">    mViewport.makeInvalid();</span><br><span class="line">    mFrame.makeInvalid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtual displays are always considered enabled</span></span><br><span class="line">    mScreenAcquired = (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Name the display.  The name will be replaced shortly if the display</span></span><br><span class="line">    <span class="comment">// was created with createDisplay().</span></span><br><span class="line">    <span class="keyword">switch</span> (mType) &#123;</span><br><span class="line">        <span class="keyword">case</span> DISPLAY_PRIMARY:</span><br><span class="line">            mDisplayName = <span class="string">"Built-in Screen"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DISPLAY_EXTERNAL:</span><br><span class="line">            mDisplayName = <span class="string">"HDMI Screen"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            mDisplayName = <span class="string">"Virtual Screen"</span>;    <span class="comment">// e.g. Overlay #n</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在DisplayDevice构造函数里，利用从SF的init 函数里传入的BufferQueueProducer构造了一个Surface，然后调用eglCreateWindowSurface创建EGLSurface。<br>&#160; &#160; &#160; &#160;我们知道surface继承了RefBase，所以get()实际上RefBase提供的函数。返回了surface的对象引用。而surface继承了ANativeObjectBase模版，通过ANativeObjectBase模版，可以理解成surface类也继承了AnativeWindow和RefBase。那么surface.get()作为AnativeWindow的类型参数传递给CreateWindowSurface也就好理解咯。也就是window本质上就是surface。<br>&#160; &#160; &#160; &#160;为了解决上面留下的迷惑，我们看看eglCreateWindowSurface的实现。依然需要曲线救国，看看软件实现，位于frameworks/native/opengl/libagl/egl.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EGLSurface <span class="title">eglCreateWindowSurface</span><span class="params">(  EGLDisplay dpy, EGLConfig config,</span><br><span class="line">                                    NativeWindowType window,</span><br><span class="line">                                    <span class="keyword">const</span> EGLint *attrib_list)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createWindowSurface(dpy, config, window, attrib_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLSurface <span class="title">createWindowSurface</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span><br><span class="line">        NativeWindowType window, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/*------前面都是一些错误检查------*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    EGLint surfaceType;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_SURFACE_TYPE, &amp;surfaceType) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(surfaceType &amp; EGL_WINDOW_BIT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window)-&gt;common.magic !=</span><br><span class="line">            ANDROID_NATIVE_WINDOW_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    EGLint configID;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> depthFormat;</span><br><span class="line">    <span class="keyword">int32_t</span> pixelFormat;</span><br><span class="line">    <span class="keyword">if</span> (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> we don't have access to the pixelFormat here just yet.</span></span><br><span class="line">    <span class="comment">// (it's possible that the surface is not fully initialized)</span></span><br><span class="line">    <span class="comment">// maybe this should be done after the page-flip</span></span><br><span class="line">    <span class="comment">//if (EGLint(info.format) != pixelFormat)</span></span><br><span class="line">    <span class="comment">//    return setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">egl_surface_t</span>* surface;</span><br><span class="line">    <span class="comment">//egl_surface_t的详细实现为egl_window_surface_v2_t</span></span><br><span class="line">    surface = <span class="keyword">new</span> <span class="keyword">egl_window_surface_v2_t</span>(dpy, config, depthFormat,</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!surface-&gt;initCheck()) &#123;</span><br><span class="line">        <span class="comment">// there was a problem in the ctor, the error</span></span><br><span class="line">        <span class="comment">// flag has been set.</span></span><br><span class="line">        <span class="keyword">delete</span> surface;</span><br><span class="line">        surface = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;前面都是一些错误检测，最后面new了一个egl_window_surface_v2_t结构体实现，egl_surface_t的详细实现为egl_window_surface_v2_t。<br>&#160; &#160; &#160; &#160;我们再看看这个结构体部分内容：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">egl_window_surface_v2_t</span> : <span class="keyword">public</span> <span class="keyword">egl_surface_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">egl_window_surface_v2_t</span>(</span><br><span class="line">            EGLDisplay dpy, EGLConfig config,</span><br><span class="line">            <span class="keyword">int32_t</span> depthFormat,</span><br><span class="line">            ANativeWindow* window);</span><br><span class="line"></span><br><span class="line">    ~<span class="keyword">egl_window_surface_v2_t</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">status_t</span> lock(ANativeWindowBuffer* buf, <span class="keyword">int</span> usage, <span class="keyword">void</span>** vaddr);</span><br><span class="line">    <span class="keyword">status_t</span> unlock(ANativeWindowBuffer* buf);</span><br><span class="line">    ANativeWindow*   nativeWindow;</span><br><span class="line">    ANativeWindowBuffer*   buffer;</span><br><span class="line">    ANativeWindowBuffer*   previousBuffer;</span><br><span class="line">    <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>*    module;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">void</span>* bits;</span><br><span class="line">    GGLFormat <span class="keyword">const</span>* pixelFormatTable;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">egl_window_surface_v2_t</span>::<span class="keyword">egl_window_surface_v2_t</span>(EGLDisplay dpy,</span><br><span class="line">        EGLConfig config,</span><br><span class="line">        <span class="keyword">int32_t</span> depthFormat,</span><br><span class="line">        ANativeWindow* window)</span><br><span class="line">    : <span class="keyword">egl_surface_t</span>(dpy, config, depthFormat), </span><br><span class="line">    nativeWindow(window), buffer(<span class="number">0</span>), previousBuffer(<span class="number">0</span>), module(<span class="number">0</span>),</span><br><span class="line">    bits(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">hw_module_t</span> <span class="keyword">const</span>* pModule;</span><br><span class="line">    hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;pModule);</span><br><span class="line">    module = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>*&gt;(pModule);</span><br><span class="line"></span><br><span class="line">    pixelFormatTable = gglGetPixelFormatTable();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// keep a reference on the window</span></span><br><span class="line">    nativeWindow-&gt;common.incRef(&amp;nativeWindow-&gt;common);</span><br><span class="line">    nativeWindow-&gt;query(nativeWindow, NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">    nativeWindow-&gt;query(nativeWindow, NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上面提到了，这里的nativeWindow是egl_window_surface_v2_t结构体的成员变量，是一个ANativeWindow*类型。在DisplayDevice构造函数里调用eglCreateWindowSurface创建egl_window_surface_v2_t实例时候，new了一个Surface传入的。<br>&#160; &#160; &#160; &#160;然后就是上面调用Surface的dequeueBuffer，忘了的话可以往上翻=。=</p>
<p>&#160; &#160; &#160; &#160;前面提到过。eglSwapBuffers会触发DisplayDevice这个producer去dequeue buffer和queue buffer。这里的opengl合成和上层的opengl画图相似，在queuebuffer中就会为该buffer设置一个acquire buffer，传递给消费者consumer。从SF的init函数中得知，创建的窗口是FramebufferSurface，这个FrameBufferSurface包了一个BufferQueueConsumer，就像我们在<a href="http://windrunnerlihuan.com/2017/07/03/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%AB-Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/">Android SurfaceFlinger 学习之路(八)—-Surface管理图形缓冲区</a>中讲到上层绘制通知SF消费时候的SurfaceFlingerConsumer类的功能一样。所以最后queue buffer会触发FramebufferSurface::onFrameAvailable()。<br>&#160; &#160; &#160; &#160;FrameBufrerSurface的类图如下：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/FrameBufferSurface.jpg" alt="FrameBufferSurface"></p>
<p>&#160; &#160; &#160; &#160;我们再看看FrameBufferSurface的构造函数，位于frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NUM_FRAMEBUFFER_SURFACE_BUFFERS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_FRAMEBUFFER_SURFACE_BUFFERS (2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">FramebufferSurface::FramebufferSurface(HWComposer&amp; hwc, <span class="keyword">int</span> disp,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferConsumer&gt;&amp; consumer) :</span><br><span class="line">    ConsumerBase(consumer),</span><br><span class="line">    mDisplayType(disp),</span><br><span class="line">    mCurrentBufferSlot(<span class="number">-1</span>),</span><br><span class="line">    mCurrentBuffer(<span class="number">0</span>),</span><br><span class="line">    mHwc(hwc)</span><br><span class="line">&#123;</span><br><span class="line">    mName = <span class="string">"FramebufferSurface"</span>;</span><br><span class="line">    mConsumer-&gt;setConsumerName(mName);</span><br><span class="line">    mConsumer-&gt;setConsumerUsageBits(GRALLOC_USAGE_HW_FB |</span><br><span class="line">                                       GRALLOC_USAGE_HW_RENDER |</span><br><span class="line">                                       GRALLOC_USAGE_HW_COMPOSER);</span><br><span class="line">    mConsumer-&gt;setDefaultBufferFormat(mHwc.getFormat(disp));</span><br><span class="line">    mConsumer-&gt;setDefaultBufferSize(mHwc.getWidth(disp),  mHwc.getHeight(disp));</span><br><span class="line">    mConsumer-&gt;setDefaultMaxBufferCount(NUM_FRAMEBUFFER_SURFACE_BUFFERS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们注意到mConsumer的setConsumerUsageBits函数中设置的标志位：GRALLOC_USAGE_HW_FB | GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_COMPOSER。从之前的<a href="http://windrunnerlihuan.com/2017/07/03/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%AB-Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/">Android SurfaceFlinger 学习之路(八)—-Surface管理图形缓冲区</a>讲过，如果是上层应用程序申请图形缓冲区，应用程序进程使用的图形缓冲区一般都是在匿名共享内存里面分配的，这个图形缓冲区填好数据之后，就会再交给SurfaceFlinger服务来合成到硬件帧缓冲区上去渲染。因此，从前面传过来给函数gralloc_alloc的参数usage的GRALLOC_USAGE_HW_FB位会被设置为0，以便可以在匿名共享内存中分配一个图形缓冲区。<br>&#160; &#160; &#160; &#160;而这里使用的标志位不同，GRALLOC_USAGE_HW_FB | GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_COMPOSER，从之前<a href="http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%B8%80-Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/">Android SurfaceFlinger 学习之路(一)—-Android图形显示之HAL层Gralloc模块实现</a>可以得知，FrameBufferSurface类使用的图形缓冲区是直接在硬件帧缓冲区分配的，并且它可以直接将这些图形缓冲区渲染到硬件帧缓冲区中去。要从硬件帧缓冲区中分配和渲染图形缓冲区，就必须要将HAL层中的Gralloc模块加载到当前的进程空间来，并且打开里面的gralloc设备和fb设备，其中，gralloc设备用来分配图形缓冲区，而fb设备用来渲染图形缓冲区。</p>
<p>&#160; &#160; &#160; &#160;还有一个注意点就是consumer的setDefaultMaxBufferCount函数，设置大小为NUM_FRAMEBUFFER_SURFACE_BUFFERS，为2。硬件帧缓冲区能够提供的图形缓冲区的个数等于2，这意味着Android系统可以使用双缓冲区技术来渲染系统的UI。<br>&#160; &#160; &#160; &#160;这里有个误区，上面说的双缓冲并不是指4.1之后的Triple Buffer。三缓冲是对于Producer这一侧的生产者来说，我们在Layer的onFirstRef函数中有设置过，在<a href="http://windrunnerlihuan.com/2017/06/17/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%85%AD-SurfaceFlinger%E5%88%9B%E5%BB%BASurface/">Android SurfaceFlinger 学习之路(六)—-SurfaceFlinger创建Surface</a>中也分析过，回顾一下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;</span><br><span class="line">    <span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">    <span class="comment">//BufferQueue创建图形缓冲区管理成员，我们以后分析图形缓冲区管理会讲到</span></span><br><span class="line">    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">    <span class="comment">//mProducer 不为空了，赋值</span></span><br><span class="line">    mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger);</span><br><span class="line">    <span class="comment">//mSurfaceFlingerConsumer 不为空了，赋值</span></span><br><span class="line">    mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName);</span><br><span class="line">    <span class="comment">//设置消费者相关设置</span></span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// TARGET_DISABLE_TRIPLE_BUFFERING为false，所以使用了三缓冲，project butter计划嘛</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_DISABLE_TRIPLE_BUFFERING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> <span class="string">"disabling triple buffering"</span></span></span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultMaxBufferCount(<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//获取默认显示器</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">    <span class="comment">//更新显示图像方向</span></span><br><span class="line">    updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;根据“黄油计划”定义了三缓冲。因为Producer定义了三缓冲，为了避免junk现象，让屏幕始终有一块buffer拉去离屏渲染。所以在producer这一侧，一块给cpu调度，一块给gpu绘制，看看谁有空闲的送给显示屏。如果默认的cpu调度和gpu性能都没有问题，在一个vsync周期内都能完成各自工作，那么以前仅有两块buffer情况下都不会出问题，因为，等他们用完后，总会空出一块buffer送给显示屏。但是如果其中任何一个出了问题，占用时间周期超过了一个vsync，或者更严重，两个都拖堂了，那么显示屏就没有空闲buffer拉取了，就会有很严重的掉帧。所以从4.1之后又加了一块buffer在producer这一侧，保证出问题时候还有一块buffer送显屏幕，即使从时间周期的pipeline来看，就这一个出问题的帧多显示了一下，但是后续的都显示正常，虽然仅仅延时了一帧，但是整体不会像以前那样严重的连续掉下帧。<br>&#160; &#160; &#160; &#160;这就是triple buffer的简单概述，如果有机会，后面专门讲讲。如果我理解有问题，也欢迎大家指正。</p>
<p>&#160; &#160; &#160; &#160;因为对于屏幕显示器来说，上层app和SF都是属于producer生产者，而自己display才是消费者。屏幕是双缓冲显示，一块back buffer作为离屏渲染，一块front buffer作为在线显示，然后用完了又回到后台拉去producer送显的内容作为离屏渲染，同时之前的back buffer交换到前台作为front buffer在线显示，这样周而复始不挺循环。</p>
<p>&#160; &#160; &#160; &#160;这里扯的有点多，如果有误请轻喷，欢迎指出，我会在第一时间修改。</p>
<h2 id="触发渲染"><a href="#触发渲染" class="headerlink" title="触发渲染"></a>触发渲染</h2><p>&#160; &#160; &#160; &#160;继续回到上面内容，由eglSwapBuffers触发queueBuffer，进而触发FramebufferSurface中的onFrameAvailable方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FramebufferSurface::onFrameAvailable() &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    <span class="comment">/*acquireBuffer，取得一块生产完成（OpenGL合成好）的Buffer*/</span></span><br><span class="line">    <span class="keyword">status_t</span> err = nextBuffer(buf, acquireFence);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error latching nnext FramebufferSurface buffer: %s (%d)"</span>,</span><br><span class="line">                strerror(-err), err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*最终调用 gralloc 模块中的 post方法，该此Buffer送显*/</span></span><br><span class="line">    err = mHwc.fbPost(mDisplayType, acquireFence, buf);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error posting framebuffer: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;我们先看看nextBuffer函数，取得一块生产完成（OpenGL合成好）的Buffer。（由于surfaceflinger是用opengl合成HWC_FRAMEBUFFER_TARGET layer的，所以有可能“合成”这个生产还未完毕）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> FramebufferSurface::nextBuffer(sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    BufferQueue::BufferItem item;</span><br><span class="line">    <span class="comment">//通过acquireBufferLocked获取BufferItem，其中的mBuf就是buffer了</span></span><br><span class="line">    <span class="comment">//acquireBufferLocked由之前父类传入的BufferQueueConsumer调用</span></span><br><span class="line">    <span class="keyword">status_t</span> err = acquireBufferLocked(&amp;item, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == BufferQueue::NO_BUFFER_AVAILABLE) &#123;</span><br><span class="line">        outBuffer = mCurrentBuffer;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error acquiring buffer: %s (%d)"</span>, strerror(-err), err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the BufferQueue has freed and reallocated a buffer in mCurrentSlot</span></span><br><span class="line">    <span class="comment">// then we may have acquired the slot we already own.  If we had released</span></span><br><span class="line">    <span class="comment">// our current buffer before we call acquireBuffer then that release call</span></span><br><span class="line">    <span class="comment">// would have returned STALE_BUFFER_SLOT, and we would have called</span></span><br><span class="line">    <span class="comment">// freeBufferLocked on that slot.  Because the buffer slot has already</span></span><br><span class="line">    <span class="comment">// been overwritten with the new buffer all we have to do is skip the</span></span><br><span class="line">    <span class="comment">// releaseBuffer call and we should be in the same state we'd be in if we</span></span><br><span class="line">    <span class="comment">// had released the old buffer first.</span></span><br><span class="line">    <span class="comment">//把老的buffer先release掉，还给BufferQueue，release时肯定得加入个release fence</span></span><br><span class="line">    <span class="comment">//如果在acquireBuffer之前调用releaseBuffer，就会返回一个STALE_BUFFER_SLOT状态，就不得不调用freeBufferLocked释放掉那个过时的buffer回到slot中。</span></span><br><span class="line">    <span class="comment">//为了避免获老的buffer被新的buffer内容覆盖，就要先acquire新的buffer然后release旧的buffer</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT &amp;&amp;</span><br><span class="line">        item.mBuf != mCurrentBufferSlot) &#123;</span><br><span class="line">        <span class="comment">// Release the previous buffer.</span></span><br><span class="line">        err = releaseBufferLocked(mCurrentBufferSlot, mCurrentBuffer,</span><br><span class="line">                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) &#123;</span><br><span class="line">            ALOGE(<span class="string">"error releasing buffer: %s (%d)"</span>, strerror(-err), err);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentBufferSlot = item.mBuf;</span><br><span class="line">    mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer;</span><br><span class="line">    outFence = item.mFence;</span><br><span class="line">    outBuffer = mCurrentBuffer;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;获取一块合成好的buffer，就是之前HWC_FRAMEBUFFER标志的所有layer合成到HWC_FRAMEBUFFER_TARGET这个图层（有可能还没有合成好）。通过acquireBufferLocked获取BufferItem，其中的mBuf就是buffer了，acquireBufferLocked由之前父类传入的BufferQueueConsumer调用。<br>&#160; &#160; &#160; &#160;然后把老的buffer先release掉，还给BufferQueue，release时肯定得加入个release fence。如果在acquireBuffer之前调用releaseBuffer，就会返回一个STALE_BUFFER_SLOT状态，就不得不调用freeBufferLocked释放掉那个过时的buffer回到slot中。为了避免获老的buffer被新的buffer内容覆盖，就要先acquire新的buffer然后release旧的buffer。这个我们在<a href="http://windrunnerlihuan.com/2017/11/09/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%81-SurfaceFlinger%E5%A4%84%E7%90%86Layer%E6%9B%B4%E6%96%B0/">Android SurfaceFlinger 学习之路(十)—-SurfaceFlinger处理Layer更新</a>讲过。</p>
<p>&#160; &#160; &#160; &#160;继续回到剩下的内容，最终调用 gralloc 模块中的 post方法，该此Buffer送显。这一部分可以参考<a href="http://windrunnerlihuan.com/2017/03/12/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%B8%80-Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8BHAL%E5%B1%82Gralloc%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/">Android SurfaceFlinger 学习之路(一)—-Android图形显示之HAL层Gralloc模块实现</a>，其中的图形缓冲区的渲染过程模块。</p>
<p>&#160; &#160; &#160; &#160;到这里万里长征终于快到尽头了，doDisplayComposition函数流程分析完了。合成和送显示差不多完成了，还剩下最后一点杂物。</p>
<h2 id="硬件模块渲染过程"><a href="#硬件模块渲染过程" class="headerlink" title="硬件模块渲染过程"></a>硬件模块渲染过程</h2><p>&#160; &#160; &#160; &#160;我们回到SF的doComposition函数，查看剩下内容：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">//清除屏幕脏区域</span></span><br><span class="line">            hw-&gt;dirtyRegion.clear();</span><br><span class="line">            <span class="comment">//判断系统是否支持软件部分更新</span></span><br><span class="line">            hw-&gt;flip(hw-&gt;swapRegion);</span><br><span class="line">            <span class="comment">//清除交换区域</span></span><br><span class="line">            hw-&gt;swapRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// inform the h/w that we're done compositing</span></span><br><span class="line">        <span class="comment">//通知hwc硬件合成结束</span></span><br><span class="line">        hw-&gt;compositionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主要是调用hwc硬件的set函数</span></span><br><span class="line">    <span class="comment">//此方法将完成各个图层的合成与显示，等效于EGL标准里面的eglSwapBuffers，</span></span><br><span class="line">    <span class="comment">//不过eglSwapBuffers是对OpenGL标准/GPU有效，此方法是对硬件合成器有效</span></span><br><span class="line">    postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;主要就三个功能：<br>&#160; &#160; &#160; &#160;1）判断系统是否支持软件部分更新；<br>&#160; &#160; &#160; &#160;2）通知hwc硬件合成结束；<br>&#160; &#160; &#160; &#160;3）调用hwc硬件的set函数，各个overlay图层的合成与显示。</p>
<p>&#160; &#160; &#160; &#160;老规矩，分步骤分析：<br>&#160; &#160; &#160; &#160;1）判断系统是否支持软件部分更新。调用了DisplayDevice的flip函数，参数时要交换的合成区域：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void DisplayDevice::flip(const Region&amp; dirty) const</span><br><span class="line">&#123;</span><br><span class="line">    mFlinger-&gt;getRenderEngine().checkErrors();</span><br><span class="line"></span><br><span class="line">    EGLDisplay dpy = mDisplay;</span><br><span class="line">    EGLSurface surface = mSurface;</span><br><span class="line"></span><br><span class="line">#ifdef EGL_ANDROID_swap_rectangle</span><br><span class="line">    if (mFlags &amp; SWAP_RECTANGLE) &#123;</span><br><span class="line">        const Region newDirty(dirty.intersect(bounds()));</span><br><span class="line">        const Rect b(newDirty.getBounds());</span><br><span class="line">        eglSetSwapRectangleANDROID(dpy, surface,</span><br><span class="line">                b.left, b.top, b.width(), b.height());</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    (void) dirty; // Eliminate unused parameter warning</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    mPageFlipCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这段代码主要用来检查系统的主绘图表面是否支持EGL_ANDROID_swap_rectangle扩展属性。如果支持的话，那么每次在调用函数eglSwapBuffers来渲染UI时，都会使用软件的方式来支持部分更新区域功能，即：先得到不在新脏区域里面的那部分旧脏区域的内容，然后再将得到的这部分旧脏区域的内容拷贝回到要渲染的新图形缓冲区中去，这要求每次在渲染UI时，都要将被渲染的图形缓冲区以及对应的脏区域保存下来。<br>&#160; &#160; &#160; &#160;函数会首先判断系统的主绘图表面是否支持EGL_ANDROID_swap_rectangle扩展属性。如果支持EGL_ANDROID_swap_rectangle扩展属性，即DisplayDevice类的成员变量mFlags的SWAP_RECTANGLE位等于1，那么就需要调用函数eglSetSwapRectangleANDROID来设置要渲染的区域，以便在渲染UI时，可以通过软件的方式来支持部分更新。<br>&#160; &#160; &#160; &#160;不过从上一段选择部分更新的内容来看，是直接在硬件上支持部分更新，因而性能会更好。这一段软件的eglSetSwapRectangleANDROID就不看了曲线救国了，大清亡就亡了=。=</p>
<p>&#160; &#160; &#160; &#160;2）通知hwc硬件合成结束。go on：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> DisplayDevice::compositionComplete() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mDisplaySurface-&gt;compositionComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;之前从SF的init函数和DisplayDevice的构造函数得知，mDisplaySurface是一个FrameBufferSurface对象，所以我们继续看看它的compositionComplete函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> FramebufferSurface::compositionComplete()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mHwc.fbCompositionComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;它又调用了HWComposer的fbCompositionComplete函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> HWComposer::fbCompositionComplete() &#123;</span><br><span class="line">    <span class="comment">//如果支持HWC硬件1.1版本，就不用通知任何消息</span></span><br><span class="line">    <span class="keyword">if</span> (mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    <span class="comment">//否则通知FrameBuffer驱动FrameBufferTarget合成结束</span></span><br><span class="line">    <span class="keyword">if</span> (mFbDev-&gt;compositionComplete) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFbDev-&gt;compositionComplete(mFbDev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果支持HWC硬件1.1版本，就不用通知任何消息，否则通知FrameBuffer驱动FrameBufferTarget合成结束。</p>
<p>&#160; &#160; &#160; &#160;3）调用hwc硬件的set函数，各个overlay图层的合成与显示。这一步是postFramebuffer函数内完成的，我们看看实现：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::postFramebuffer()</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    const nsecs_t now = systemTime();</span><br><span class="line">    mDebugInSwapBuffers = now;</span><br><span class="line"></span><br><span class="line">    HWComposer&amp; hwc(getHwComposer());</span><br><span class="line">    if (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        if (!hwc.supportsFramebufferTarget()) &#123;</span><br><span class="line">            // EGL spec says:</span><br><span class="line">            //   "surface must be bound to the calling thread's current context,</span><br><span class="line">            //    for the current rendering API."</span><br><span class="line">            getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">        &#125;</span><br><span class="line">        //调用HWComposer的commit函数</span><br><span class="line">        hwc.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // make the default display current because the VirtualDisplayDevice code cannot</span><br><span class="line">    // deal with dequeueBuffer() being called outside of the composition loop; however</span><br><span class="line">    // the code below can call glFlush() which is allowed (and does in some case) call</span><br><span class="line">    // dequeueBuffer().</span><br><span class="line">    //为了虚拟显示屏做的规避</span><br><span class="line">    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line">    for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">        //完毕了framebuffertarget layer的swapbuffers。</span><br><span class="line">        hw-&gt;onSwapBuffersCompleted(hwc);</span><br><span class="line">        const size_t count = currentLayers.size();</span><br><span class="line">        int32_t id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        if (id &gt;=0 &amp;&amp; hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            const HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            for (size_t i = 0; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;</span><br><span class="line">                //最后回调每个Layer的onLayerDisplayed函数</span><br><span class="line">                currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                currentLayers[i]-&gt;onLayerDisplayed(hw, NULL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastSwapBufferTime = systemTime() - now;</span><br><span class="line">    mDebugInSwapBuffers = 0;</span><br><span class="line"></span><br><span class="line">    uint32_t flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();</span><br><span class="line">    if (flipCount % LOG_FRAME_STATS_PERIOD == 0) &#123;</span><br><span class="line">        logFrameStats();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;也是三部操作：1）调用调用HWComposer的commit函数完成OverLay合成；2）完毕了framebuffertarget layer的swapbuffers；3）最后回调每个Layer的onLayerDisplayed函数。<br>&#160; &#160; &#160; &#160;我们先看第一步：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> HWComposer::commit() &#123;</span><br><span class="line">    <span class="keyword">int</span> err = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">            <span class="comment">// On version 1.0, the OpenGL ES target surface is communicated</span></span><br><span class="line">            <span class="comment">// by the (dpy, sur) fields and we are guaranteed to have only</span></span><br><span class="line">            <span class="comment">// a single display.</span></span><br><span class="line">            mLists[<span class="number">0</span>]-&gt;dpy = eglGetCurrentDisplay();</span><br><span class="line">            mLists[<span class="number">0</span>]-&gt;sur = eglGetCurrentSurface(EGL_DRAW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123;</span><br><span class="line">            <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (disp.outbufHandle) &#123;</span><br><span class="line">                mLists[i]-&gt;outbuf = disp.outbufHandle;</span><br><span class="line">                mLists[i]-&gt;outbufAcquireFenceFd =</span><br><span class="line">                        disp.outbufAcquireFence-&gt;dup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主要是调用hwc硬件的set函数</span></span><br><span class="line">        <span class="comment">//此方法将完成各个图层的合成与显示，等效于EGL标准里面的eglSwapBuffers，</span></span><br><span class="line">        <span class="comment">//不过eglSwapBuffers是对OpenGL标准/GPU有效，此方法是对硬件合成器有效</span></span><br><span class="line">        err = mHwc-&gt;<span class="built_in">set</span>(mHwc, mNumDisplays, mLists);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">            <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">            disp.lastDisplayFence = disp.lastRetireFence;</span><br><span class="line">            disp.lastRetireFence = Fence::NO_FENCE;</span><br><span class="line">            <span class="keyword">if</span> (disp.<span class="built_in">list</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (disp.<span class="built_in">list</span>-&gt;retireFenceFd != <span class="number">-1</span>) &#123;</span><br><span class="line">                    disp.lastRetireFence = <span class="keyword">new</span> Fence(disp.<span class="built_in">list</span>-&gt;retireFenceFd);</span><br><span class="line">                    disp.<span class="built_in">list</span>-&gt;retireFenceFd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                disp.<span class="built_in">list</span>-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">status_t</span>)err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;主要是调用hwc硬件的set函数，此方法将完成各个图层的合成与显示，等效于EGL标准里面的eglSwapBuffers，不过eglSwapBuffers是对OpenGL标准/GPU有效，此方法是对硬件合成器有效。<br>&#160; &#160; &#160; &#160;不过这是hwc硬件的实现，我们也看不到代码。感兴趣的同学可以搜一搜AOSP里qcom、boardcom、ti、intel、samsung等公司开源出来的实现。</p>
<p>&#160; &#160; &#160; &#160;后两部都是和Fence相关，这里不是重点：<br>&#160; &#160; &#160; &#160;第二步是完毕了framebuffertarget layer的swapbuffers，调用DisplayDevice的onSwapBuffersCompleted函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DisplayDevice::onSwapBuffersCompleted(HWComposer&amp; hwc) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        mDisplaySurface-&gt;onFrameCommitted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;依然调用FrameBufferSurface的onFrameCommitted函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FramebufferSurface::onFrameCommitted() &#123;</span><br><span class="line">    sp&lt;Fence&gt; fence = mHwc.getAndResetReleaseFence(mDisplayType);</span><br><span class="line">    <span class="keyword">if</span> (fence-&gt;isValid() &amp;&amp;</span><br><span class="line">            mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = addReleaseFence(mCurrentBufferSlot,</span><br><span class="line">                mCurrentBuffer, fence);</span><br><span class="line">        ALOGE_IF(err, <span class="string">"setReleaseFenceFd: failed to add the fence: %s (%d)"</span>,</span><br><span class="line">                strerror(-err), err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;Fence&gt; HWComposer::getAndResetReleaseFence(<span class="keyword">int32_t</span> id) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(id)&gt;<span class="number">31</span> || !mAllocatedDisplayIDs.hasBit(id))</span><br><span class="line">        <span class="keyword">return</span> Fence::NO_FENCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = INVALID_OPERATION;</span><br><span class="line">    <span class="keyword">if</span> (mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[id])</span></span>;</span><br><span class="line">        <span class="comment">// 这里的disp.framebufferTarget-&gt;releaseFenceFd应该就是底层hwcomposer设置的 </span></span><br><span class="line">        <span class="keyword">if</span> (disp.framebufferTarget) &#123;</span><br><span class="line">            fd = disp.framebufferTarget-&gt;releaseFenceFd;</span><br><span class="line">            disp.framebufferTarget-&gt;acquireFenceFd = <span class="number">-1</span>;</span><br><span class="line">            disp.framebufferTarget-&gt;releaseFenceFd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd &gt;= <span class="number">0</span> ? <span class="keyword">new</span> Fence(fd) : Fence::NO_FENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;onFrameCommitted主要就是获取hwcomposer设置的release fence，然后设置到slot中。</p>
<p>&#160; &#160; &#160; &#160;第三部回调Layer的onLayerDisplayed函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onLayerDisplayed(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">        HWComposer::HWCLayerInterface* layer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (layer) &#123;</span><br><span class="line">        <span class="comment">//HWCLayerVersion1的onDisplayed函数，位于HWComposer.cpp中</span></span><br><span class="line">        layer-&gt;onDisplayed();</span><br><span class="line">        <span class="comment">//将fence设置到slot中</span></span><br><span class="line">        mSurfaceFlingerConsumer-&gt;setReleaseFence(layer-&gt;getAndResetReleaseFence());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------- HWCLayerVersion1 ----------*/</span></span><br><span class="line"><span class="keyword">virtual</span> sp&lt;Fence&gt; getAndResetReleaseFence() &#123;</span><br><span class="line">        <span class="comment">//获取layer的releaseFenceFd</span></span><br><span class="line">        <span class="keyword">int</span> fd = getLayer()-&gt;releaseFenceFd;</span><br><span class="line">        getLayer()-&gt;releaseFenceFd = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//new 一个Fence</span></span><br><span class="line">        <span class="keyword">return</span> fd &gt;= <span class="number">0</span> ? <span class="keyword">new</span> Fence(fd) : Fence::NO_FENCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDisplayed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">hwc_region_t</span>&amp; visibleRegion = getLayer()-&gt;visibleRegionScreen;</span><br><span class="line">        SharedBuffer <span class="keyword">const</span>* sb = SharedBuffer::bufferFromData(visibleRegion.rects);</span><br><span class="line">        <span class="keyword">if</span> (sb) &#123;</span><br><span class="line">            sb-&gt;release();</span><br><span class="line">            <span class="comment">// not technically needed but safer</span></span><br><span class="line">            visibleRegion.numRects = <span class="number">0</span>;</span><br><span class="line">            visibleRegion.rects = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getLayer()-&gt;acquireFenceFd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;而对overlay相应的layer而言，前面仅仅设置了acquire fence，在hwcomposer HAL处理后肯定会给加入一个release fence，而这一部分代码我们看不到实现。</p>
<p>&#160; &#160; &#160; &#160;到此硬件模块渲染过程就分析完了。SF的doComposition函数的流程就结束了。</p>
<h1 id="更新SW-Vsync误差"><a href="#更新SW-Vsync误差" class="headerlink" title="更新SW Vsync误差"></a>更新SW Vsync误差</h1><p>&#160; &#160; &#160; &#160;最后一部分就是SF中handleMessageRefresh最后一部，postComposition。主要用于调试，调Layer的onPostComposition方法。我们看看实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::postComposition()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="comment">//调Layer的onPostComposition方法</span></span><br><span class="line">        layers[i]-&gt;onPostComposition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 HWComposer 获得 Fence</span></span><br><span class="line">    <span class="keyword">const</span> HWComposer&amp; hwc = getHwComposer();</span><br><span class="line">    sp&lt;Fence&gt; presentFence = hwc.getDisplayFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    <span class="comment">//注意，如果硬件vsync已经被打开了，那么fence是无效了，只有它在关闭的情况下，它才有效</span></span><br><span class="line">    <span class="comment">//矫正更新Vsync，是否打开或关闭vsync信号</span></span><br><span class="line">    <span class="keyword">if</span> (presentFence-&gt;isValid()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPrimaryDispSync.addPresentFence(presentFence)) &#123;</span><br><span class="line">            enableHardwareVsync();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disableHardwareVsync(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kIgnorePresentFences) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(getDefaultDisplayDevice());</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            enableHardwareVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动画相关</span></span><br><span class="line">    <span class="keyword">if</span> (mAnimCompositionPending) &#123;</span><br><span class="line">        mAnimCompositionPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (presentFence-&gt;isValid()) &#123;</span><br><span class="line">            mAnimFrameTracker.setActualPresentFence(presentFence);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The HWC doesn't support present fences, so use the refresh</span></span><br><span class="line">            <span class="comment">// timestamp instead.</span></span><br><span class="line">            <span class="keyword">nsecs_t</span> presentTime = hwc.getRefreshTimestamp(HWC_DISPLAY_PRIMARY);</span><br><span class="line">            mAnimFrameTracker.setActualPresentTime(presentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        mAnimFrameTracker.advanceFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------Layer.cpp--------*/</span></span><br><span class="line"><span class="keyword">void</span> Layer::onPostComposition() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFrameLatencyNeeded) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> desiredPresentTime = mSurfaceFlingerConsumer-&gt;getTimestamp();</span><br><span class="line">        mFrameTracker.setDesiredPresentTime(desiredPresentTime);</span><br><span class="line"></span><br><span class="line">        sp&lt;Fence&gt; frameReadyFence = mSurfaceFlingerConsumer-&gt;getCurrentFence();</span><br><span class="line">        <span class="keyword">if</span> (frameReadyFence-&gt;isValid()) &#123;</span><br><span class="line">            mFrameTracker.setFrameReadyFence(frameReadyFence);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There was no fence for this frame, so assume that it was ready</span></span><br><span class="line">            <span class="comment">// to be presented at the desired present time.</span></span><br><span class="line">            mFrameTracker.setFrameReadyTime(desiredPresentTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> HWComposer&amp; hwc = mFlinger-&gt;getHwComposer();</span><br><span class="line">        sp&lt;Fence&gt; presentFence = hwc.getDisplayFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line">        <span class="keyword">if</span> (presentFence-&gt;isValid()) &#123;</span><br><span class="line">            mFrameTracker.setActualPresentFence(presentFence);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The HWC doesn't support present fences, so use the refresh</span></span><br><span class="line">            <span class="comment">// timestamp instead.</span></span><br><span class="line">            <span class="keyword">nsecs_t</span> presentTime = hwc.getRefreshTimestamp(HWC_DISPLAY_PRIMARY);</span><br><span class="line">            mFrameTracker.setActualPresentTime(presentTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFrameTracker.advanceFrame();</span><br><span class="line">        mFrameLatencyNeeded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;postComposition函数中比较重要的是更新SW Vsync的误差值。注意，如果硬件vsync已经被打开了，那么fence是无效了，只有它在关闭的情况下，它才有效。当更新SW Vsync模型后，就会关闭硬件Vsync信号，这时候Fence就有效了。所以我们进入第一个if条件内部，查看DispSync的addPresentFence函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DispSync::addPresentFence(<span class="keyword">const</span> sp&lt;Fence&gt;&amp; fence) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将当前硬件vsync的fence保存在 mPresentFences里, 目的是为了计算偏移</span></span><br><span class="line">  <span class="comment">// mPresentFences 最多保存8个硬件 偏移</span></span><br><span class="line">    mPresentFences[mPresentSampleOffset] = fence;</span><br><span class="line">    mPresentTimes[mPresentSampleOffset] = <span class="number">0</span>; </span><br><span class="line">    mPresentSampleOffset = (mPresentSampleOffset + <span class="number">1</span>) % NUM_PRESENT_SAMPLES;</span><br><span class="line">    mNumResyncSamplesSincePresent = <span class="number">0</span>; <span class="comment">// 将 mNumResyncSamplesSincePresent 置为0，</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUM_PRESENT_SAMPLES; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; f(mPresentFences[i]);</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">NULL</span>) &#123;  <span class="comment">//这里 f 是有可能为NULL, 即只有一个 硬件 vsync 偏移时</span></span><br><span class="line">            <span class="keyword">nsecs_t</span> t = f-&gt;getSignalTime();  <span class="comment">//猜测这个就是硬件 vsync的时间</span></span><br><span class="line">            <span class="keyword">if</span> (t &lt; INT64_MAX) &#123;</span><br><span class="line">                mPresentFences[i].clear();</span><br><span class="line">              <span class="comment">//将每个vsync时间戳记录在 mPresentTimes 里，这里 kPresentTimeOffset是可以配置的，即可调的</span></span><br><span class="line">                mPresentTimes[i] = t + kPresentTimeOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//更新错误信息</span></span><br><span class="line">    updateErrorLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里，一般的情况是 mModelUpdated 已经被更新了，然后硬件vsync被disable了，</span></span><br><span class="line">    <span class="comment">// 所以这里只需要看SW vsync的真实的硬件vsync的误差是否在可</span></span><br><span class="line">    <span class="comment">// 允许的范围内即可</span></span><br><span class="line">    <span class="keyword">return</span> !mModelUpdated || mError &gt; kErrorThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;ddPresentFence最后的返回, mError是方差，见下面分析，当方差大于 kErrorThreshold后就返回true：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DispSync::updateErrorLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mModelUpdated) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to compare present fences against the un-adjusted refresh period,</span></span><br><span class="line">    <span class="comment">// since they might arrive between two events.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到真实的 period, 具体见 5.2.4 updateModelLocked 里的分析</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> period = mPeriod / (<span class="number">1</span> + mRefreshSkipCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numErrSamples = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">nsecs_t</span> sqErrSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里的 mReferenceTime 是第一个硬件vsync的时间戳 见 addResyncSample里的 mReferenceTime</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUM_PRESENT_SAMPLES; i++) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> sample = mPresentTimes[i] - mReferenceTime;</span><br><span class="line">       <span class="comment">// 这里 sample 一般来说是大于偏移的</span></span><br><span class="line">        <span class="keyword">if</span> (sample &gt; mPhase) &#123;</span><br><span class="line">            <span class="keyword">nsecs_t</span> sampleErr = (sample - mPhase) % period;</span><br><span class="line">            <span class="keyword">if</span> (sampleErr &gt; period / <span class="number">2</span>) &#123;</span><br><span class="line">                sampleErr -= period;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录 偏移差的平方和</span></span><br><span class="line">            sqErrSum += sampleErr * sampleErr;</span><br><span class="line">            numErrSamples++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 说到底mError就是方差</span></span><br><span class="line">    <span class="keyword">if</span> (numErrSamples &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mError = sqErrSum / numErrSamples;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mError = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">        ATRACE_INT64(<span class="string">"DispSync:Error"</span>, mError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;如果 addPresentFence返回true, 那么就说明SW vsync和硬件Vsync的误差已经无法接受了，那么这时就得重新打开硬件Vsync，来重新调节SW vsync模型了。</p>
<p>&#160; &#160; &#160; &#160;合成全部流程到此结束，打完收工~~</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;合成流程中比较重要的就是Layer与纹理，我们贴两幅图，一张是GraphicBuffer上传为纹理，一张为更新纹理：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/image.jpg" alt="image"><br>&#160; &#160; &#160; &#160;GraphicBuffer上传为纹理</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/flow.jpg" alt="flow"><br>&#160; &#160; &#160; &#160;更新纹理</p>
<p>&#160; &#160; &#160; &#160;合成流程是整个SurfaceFlinger中最重要的环节，这个大山我们推到之后，对于Android显示系统的理解豁然开朗。后面我们有机会继续研究研究其他内容，比如Fence相关的东西（可能没有时间=。=）<br>&#160; &#160; &#160; &#160;细数2017年每一件事，真是事事不如意。这一年，也是我整个人生中最动荡的一年，尝遍酸甜苦辣，受尽世态炎凉ToT~<br>&#160; &#160; &#160; &#160;希望2018年能对我好一点。。。。。。</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%20SurfaceFlinger%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E5%8D%81%E4%BA%8C%29----%E5%90%88%E6%88%90Layer/meizi.jpg" alt="meizi"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat.jpg" alt="windrunnerlihuan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="windrunnerlihuan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SurfaceFlinger/" rel="tag"># SurfaceFlinger</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/19/Android-SurfaceFlinger-学习之路-十一-PostView-附：硬件HWC选取合成类型（Intel）/" rel="next" title="Android SurfaceFlinger 学习之路(十一)(PostView)--附：硬件HWC选取合成类型（Intel）">
                <i class="fa fa-chevron-left"></i> Android SurfaceFlinger 学习之路(十一)(PostView)--附：硬件HWC选取合成类型（Intel）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/24/PHOENIX/" rel="prev" title="PHOENIX">
                PHOENIX <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTQwMC83OTYz"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="windrunnerlihuan" />
          <p class="site-author-name" itemprop="name">windrunnerlihuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="mailto:937874128@qq.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope-o"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/windrunnerlihuan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://gank.io/" title="干货集中营" target="_blank">干货集中营</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jcodecraeer.com/" title="泡在网上的日子" target="_blank">泡在网上的日子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#回顾"><span class="nav-number">1.</span> <span class="nav-text">回顾</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#合成流程"><span class="nav-number">2.</span> <span class="nav-text">合成流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#开始合成"><span class="nav-number">2.1.</span> <span class="nav-text">开始合成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#合成图层"><span class="nav-number">3.</span> <span class="nav-text">合成图层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#doComposeSurfaces"><span class="nav-number">3.1.</span> <span class="nav-text">doComposeSurfaces</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenGL处理合成"><span class="nav-number">3.2.</span> <span class="nav-text">OpenGL处理合成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定纹理"><span class="nav-number">3.3.</span> <span class="nav-text">绑定纹理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#drawWithOpenGL"><span class="nav-number">3.4.</span> <span class="nav-text">drawWithOpenGL</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#交换合成缓冲区"><span class="nav-number">4.</span> <span class="nav-text">交换合成缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenGL环境创建"><span class="nav-number">4.1.</span> <span class="nav-text">OpenGL环境创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#触发渲染"><span class="nav-number">4.2.</span> <span class="nav-text">触发渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件模块渲染过程"><span class="nav-number">4.3.</span> <span class="nav-text">硬件模块渲染过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更新SW-Vsync误差"><span class="nav-number">5.</span> <span class="nav-text">更新SW Vsync误差</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">windrunnerlihuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("bJlEg1N9ed75pssz1m514avl-gzGzoHsz", "Swtq2cOp8A7KYeJ9lpD5nKAy");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
