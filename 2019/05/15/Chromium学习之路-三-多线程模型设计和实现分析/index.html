<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="3Gndr5oonivG3ajghQU1MgL0IHoMHT4esMsPKjnbeis" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Chromium,多线程," />





  <link rel="alternate" href="/atom.xml" title="April is your lie" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近工作中用到了较多的webrtc的内容，其中很多模块都是用到了Chromium的多线程设计，之前对这个也是一知半解，加上自己是个C++新手，因此痛下决心要认真学习一下多线程模型设计和实现分析。&amp;#160; &amp;#160; &amp;#160; &amp;#160;另一方面，学习Chromium也是为了以后跨平台开发打下坚实基础。虽然最近的工作已经渐渐偏移动移动">
<meta property="og:type" content="article">
<meta property="og:title" content="Chromium学习之路(三)----多线程模型设计和实现分析">
<meta property="og:url" content="http://windrunnerlihuan.com/2019/05/15/Chromium学习之路-三-多线程模型设计和实现分析/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近工作中用到了较多的webrtc的内容，其中很多模块都是用到了Chromium的多线程设计，之前对这个也是一知半解，加上自己是个C++新手，因此痛下决心要认真学习一下多线程模型设计和实现分析。&amp;#160; &amp;#160; &amp;#160; &amp;#160;另一方面，学习Chromium也是为了以后跨平台开发打下坚实基础。虽然最近的工作已经渐渐偏移动移动">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/async.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/threadlife.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/Thread.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/MessageLoopProxy.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/meizi.jpeg">
<meta property="og:updated_time" content="2019-05-22T17:38:43.545Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chromium学习之路(三)----多线程模型设计和实现分析">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;最近工作中用到了较多的webrtc的内容，其中很多模块都是用到了Chromium的多线程设计，之前对这个也是一知半解，加上自己是个C++新手，因此痛下决心要认真学习一下多线程模型设计和实现分析。&amp;#160; &amp;#160; &amp;#160; &amp;#160;另一方面，学习Chromium也是为了以后跨平台开发打下坚实基础。虽然最近的工作已经渐渐偏移动移动">
<meta name="twitter:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/async.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://windrunnerlihuan.com/2019/05/15/Chromium学习之路-三-多线程模型设计和实现分析/"/>





  <title>Chromium学习之路(三)----多线程模型设计和实现分析 | April is your lie</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-100464707-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bb4df6db80a16ce54c1fb2c6e1767e18";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=62459705";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500465801");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>




  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1262111741&web_id=1262111741" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">April is your lie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">四月是你的谎言</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://windrunnerlihuan.com/2019/05/15/Chromium学习之路-三-多线程模型设计和实现分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="windrunnerlihuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="April is your lie">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Chromium学习之路(三)----多线程模型设计和实现分析</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T17:16:00+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Chromium/" itemprop="url" rel="index">
                    <span itemprop="name">Chromium</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/05/15/Chromium学习之路-三-多线程模型设计和实现分析/" class="leancloud_visitors" data-flag-title="Chromium学习之路(三)----多线程模型设计和实现分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&#160; &#160; &#160; &#160;最近工作中用到了较多的webrtc的内容，其中很多模块都是用到了Chromium的多线程设计，之前对这个也是一知半解，加上自己是个C++新手，因此痛下决心要认真学习一下多线程模型设计和实现分析。<br>&#160; &#160; &#160; &#160;另一方面，学习Chromium也是为了以后跨平台开发打下坚实基础。虽然最近的工作已经渐渐偏移动移动应用开发，但是内心依然向往以前愉快的写自己app的日子，毕竟能够直接看到结果，所见即所得，因为相信，所以看见嘛。<br><a id="more"></a></p>
<h1 id="异步通信概述"><a href="#异步通信概述" class="headerlink" title="异步通信概述"></a>异步通信概述</h1><p>&#160; &#160; &#160; &#160;Chromium除了远近闻名的多进程架构之外，它的多线程模型也相当引人注目的。Chromium的多进程架构是为了解决网页的稳定性问题，而多线程模型则是为了解决网页的卡顿问题。为了达到这个目的，Chromium的多线程模型是基于异步通信的。也就是说，一个线程请求另外一个线程执行一个任务的时候，不需要等待该任务完成就可以去做其它事情，从而避免了卡顿。本文就分析Chromium的多线程模型的设计和实现。</p>
<p>&#160; &#160; &#160; &#160;有同学看到这里可能会有疑问，如果一个线程请求另外一个线程执行一个任务的时候，就是要等该任务完成之后才能做其它事情，那么使用异步通信有什么用呢？的确如此，但是Chromium提供这种基于异步通信的多线程模型，就是希望作为开发者的你在实现一个模块的时候，尽最大努力地设计好各个子模块及其对应的数据结构，使得它们在协作时可以最大程度地进行异步通信。因此，Chromium基于异步通信的多线程模型更多的是体现一种设计哲学。</p>
<p>&#160; &#160; &#160; &#160;一个典型的异步通信过程如图1所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/async.jpg" alt="async"></p>
<p>&#160; &#160; &#160; &#160;Task-1被分解成三个子任务Task-1(1)、Task-1(2)和Task-1(3)。其中，Task-1(1)由Thread-1执行。Task-1(1)执行完成后，Thread-1通过我们在前面Chromium多线程通信的Closure机制分析一文分析的Closure请求Thread-2执行Task-1(2)。Task-1(2)执行完成后，Thread-2又通过一个Closure请求Thread-1执行Task-1(3)。至此，Task-1就执行完成。我们可以将第一个Closure看作是一个Request操作，而第二个Closure是一个Reply操作。这是一个典型的异步通信过程。当然，如果不需要知道异步通信结果，那么第二个Closure和Task-1(3)就是不需要的。</p>
<p>&#160; &#160; &#160; &#160;假设Thread-1需要知道异步通信的结果，那么在图1中我们可以看到一个非常关键的点：Thread-1并不是什么也不干就只是等着Thread-2执行完成Task-1(2)，它趁着这个等待的空隙，干了另外一件事情——Task-2。如果我们将Thread-1看作是一个UI线程，那么就意味着这种异步通信模式是可以提高它的响应性的。</p>
<p>&#160; &#160; &#160; &#160;为了能够完成上述的异步通信过程，一个线程的生命周期如图2所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/threadlife.jpg" alt="threadlife"></p>
<p>&#160; &#160; &#160; &#160;线程经过短暂的启动之后（Start），就围绕着一个任务队列（TaskQueue）不断地进行循环，直到被通知停止为止（Stop）。在围绕任务队列循环期间，它会不断地检查任务队列是否为空。如果不为空，那么就会将里面的任务（Task）取出来，并且进行处理。这样，一个线程如果要请求另外一个线程执行某一个操作，那么只需要将该操作封装成一个任务，并且发送到目标线程的任务队列去即可。</p>
<h2 id="基于任务队列的线程运行模式"><a href="#基于任务队列的线程运行模式" class="headerlink" title="基于任务队列的线程运行模式"></a>基于任务队列的线程运行模式</h2><p>&#160; &#160; &#160; &#160;为了更好地理解这种基于任务队列的线程运行模式，我们脑补一下另外一种常用的基于锁的线程运行模式。一个线程要执行某一个操作的时候，就直接调用一个代表该操作的一个函数。如果该函数需要访问全局数据或者共享数据，那么就需要进行加锁，避免其它线程也正在访问这些全局数据或者共享数据。这样做的一个好处是我们只需要关心问题的建模，而不需要关心问题是由谁来执行的，只要保证逻辑正确并且数据完整即可。当然坏处也是显然的。首先是为了保持数据完整性，也就是避免访问数据时出现竞争条件，代码里面充斥着各种锁。其次，如果多个线程同时获取同一个锁，那么就会产生竞争。这种锁竞争会带来额外的开销，从而降低线程的响应性。</p>
<p>&#160; &#160; &#160; &#160;基于任务队列的线程运行模式，要求在对问题进行建模时，要提前知道谁是执行者。也就是说，在对问题进行建模时，需要指派好每一个子问题的执行者。这样我们为子问题设计数据结构时，就规定这些数据结构仅仅会被子问题的执行者访问。这样执行者在解决指派给它的问题时，就不需要进行加锁操作，因为在解决问题过程中需要访问的数据不会同时被其它执行者访问。这就是通过任务队列来实现异步通信的多线程模型的设计哲学。</p>
<p>&#160; &#160; &#160; &#160;当然，这并不是说，基于任务队列的线程运行模式可以完全避免使用锁，因为任务队列本身就是一个线程间的共享资源。想象一下，一个线程要往里面添加任务，另一个线程要从里面将任务提取出来处理。因此，所有涉及到任务队列访问的地方都是需要加锁的。但是如果我们再仔细想想，那么就会发现，任务队列只是一个基础设施，它与具体的问题是无关的。因此，只要我们遵循上述设计哲学，就可以将代码里面需要加锁的地方仅限于访问任务队列的地方，从而就可以减少锁竞争带来的额外的开销。</p>
<p>&#160; &#160; &#160; &#160;这样说来，似乎基于任务队列的线程运行模式很好，但是实际上它对问题建模提出了更高的要求，也就是进行子问题划分时，要求划分出来的子问题是正交的，这样我们才有可能为这些子问题设计出不会同时被访问的数据结构。看到“正交”两个字，是不是想起高数里面的向量空间的正交基了？或者傅里叶变换用到的一组三角函数了？其实道理就是一样一样的。</p>
<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>&#160; &#160; &#160; &#160;好了，说了这么多，我们就步入到正题，分析Chromium多线程模型的设计和实现，也就是基于任务队列的线程运行模式涉及到核心类图，如图3所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/Thread.jpg" alt="Thread"></p>
<h2 id="属性概述"><a href="#属性概述" class="headerlink" title="属性概述"></a>属性概述</h2><p>&#160; &#160; &#160; &#160;Thread是一个用来创建带消息循环的类。当我们创建一个Thread对象后，调用它的成员函数Start或者StartWithOptions就可以启动一个带消息循环的线程。其中，成员函数StartWithOptions可以指定线程创建参数。当我们不需要这个线程时，就可以调用之前创建的Thread对象的成员函数Stop。</p>
<p>&#160; &#160; &#160; &#160;Thread类继承了PlatformThread::Delegate类，并且重写了它的成员函数ThreadMain。我们知道，Chromium是跨平台的，这样各个平台创建线程使用的API有可能是不一样的。不过，我们可以通过PlatformThread::Delegate类为各个平台创建的线程提供一个入口点。这个入口点就是PlatformThread::Delegate类的成员函数ThreadMain。由于Thread类重写了父类PlatformThread::Delegate的成员函数ThreadMain，因此无论是哪一个平台，当它创建完成一个线程后，都会以Thread类的成员函数ThreadMain作为线程的入口点。</p>
<p>&#160; &#160; &#160; &#160;Thread类有一个重要的成员变量message<em>loop</em>，它指向的是一个MessageLoop对象。这个MessageLoop对象就是用来描述线程的消息循环的。MessageLoop类内部通过成员变量run<em>loop</em>指向的一个RunLoop对象和成员变量pump_指向的一个MessagePump对象来描述一个线程的消息循环。</p>
<p>&#160; &#160; &#160; &#160;一个线程在运行的过程中，可以有若干个消息循环，也就是一个消息循环可以运行在另外一个消息循环里面。除了最外层的消息循环，其余的消息的消息循环称为嵌套消息循环。我们为什么需要嵌套消息循环呢？这主要是跟模式对话框有关。</p>
<p>&#160; &#160; &#160; &#160;考虑一个情景，我们在一个窗口弹出一个文件选择对话框。窗口必须要等到用户在文件选择对话框选择了文件之后，才能去做其它事情。窗口是在消息循环过程中打开文件对话框的，它要等待用户在文件选择对话框中选择文件 ，就意味着消息循环被中止了。由于文件选择对话框也是通过消息循环来响应用户输入的，因此如果打开的它窗口中止了消息循环，就会导致它无法响应用户输入。为了解决这个问题，就要求打开文件选择的窗口不能中止消息循环。方法就是该窗口创建一个子消息循环，该子消息循环负责处理文件选择对应框的输入事件，直到用户选择了一个文件为止。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员变量run<em>loop</em>指向的一个RunLoop对象就是用来记录线程当使用的消息循环的。RunLoop类有三个重要的成员变量：</p>
<ol>
<li>message<em>loop</em>，记录一个RunLoop对象关联的MessageLoop对象。</li>
<li>previous<em>loop</em>，记录前一个消息循环，当就是包含当前消息循环的消息循环。</li>
<li>run<em>depth</em>，记录消息循环的嵌套深度。</li>
</ol>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员变量pump_指向的一个MessagePump对象是用来进行消息循环的，也就是说，Thread类描述的线程通过MessagePump类进入到消息循环中去。</p>
<p>&#160; &#160; &#160; &#160;Thread类将消息划分为三类，分别通过以下三个成员变量来描述：</p>
<ol>
<li>work<em>queue</em>，指向一个TaskQueue对象，用来保存那些需要马上处理的消息。</li>
<li>delayed_work<em>queue</em>，指向一个DelayedTaskQueue，用来保存那些需要延迟一段时间再处理的消息。</li>
<li>deferred_non_nestable_work<em>queue</em>，指向一个TaskQueue对象，用来保存那些不能够在嵌套消息循环中处理的消息。</li>
</ol>
<p>&#160; &#160; &#160; &#160;一个MessagePump对象在进行消息循环时，如果发现消息队列中有消息，那么就需要通知关联的MessageLoop对象进行处理。通知使用的接口就通过MessagePump::Delegate类来描述。</p>
<p>&#160; &#160; &#160; &#160;MessagePump::Delegate类定义了四个成员函数，如下所示：</p>
<ol>
<li>DoWork，用来通知MessageLoop类处理其成员变量work<em>queue</em>保存的消息。</li>
<li>DoDelayedWork，用来通知MessageLoop类处理其成员变量delayed_work<em>queue</em>保存的消息。</li>
<li>DoIdleWork，用来通知MessageLoop类当前无消息需要处理，MessageLoop类可以利用该间隙做一些Idle Work。</li>
<li>GetQueueingInformation，用来获取MessageLoop类内部维护的消息队列的信息，例如消息队列的大小，以及下一个延迟消息的处理时间。</li>
</ol>
<p>&#160; &#160; &#160; &#160;有了前面的基础知识，接下来我们就可以大概描述Thread类描述的线程的执行过程。</p>
<h2 id="线程的执行过程概述"><a href="#线程的执行过程概述" class="headerlink" title="线程的执行过程概述"></a>线程的执行过程概述</h2><p>&#160; &#160; &#160; &#160;首先是线程的启动过程：</p>
<ol>
<li>调用Thread类的成员函数Start或者StartWithOptions启动一个线程，并且以Thread类的成员函数ThreadMain作为入口点。</li>
<li>Thread类的成员函数ThreadMain负责创建消息循环，也就是通过MessageLoop类创建消息循环。</li>
<li>MessageLoop类在创建消息循环的过程中，会通过成员函数Init创建用来一个用来消息循环的MessagePump对象。</li>
<li>消息循环创建完成之后，调用MessageLoop类的成员函数Run进入消息循环。</li>
<li>MessageLoop类的成员函数Run创建一个RunLoop对象，并且调用它的成员函数Run进入消息循环。注意，该RunLoop对象在创建的过程，会关联上当前线程使用的消息循环，也就是创建它的MessageLoop对象。</li>
<li>RunLoop类的成员函数Run负责建立好消息循环的嵌套关系，也就是设置好它的成员变量previous<em>loop</em>和run<em>depth</em>等，然后就会调用其关联的MessageLoop对象的成员函数RunHandler进入消息循环。</li>
<li>MessageLoop类的成员函数RunHandler调用成员变量pump_描述的一个MessagePump对象的成员函数Run进入消息循环。</li>
</ol>
<p>&#160; &#160; &#160; &#160;接下来是向线程的消息队列发送消息的过程。这是通过MessageLoop类的以下四个成员函数向消息队列发送消息的：</p>
<ol>
<li>PostTask，发送需要马上进行处理的并且可以在嵌套消息循环中处理的消息。</li>
<li>PostDelayedTask，发送需要延迟处理的并且可以在嵌套消息循环中处理的消息。</li>
<li>PostNonNestableTask，发送需要马上进行处理的并且不可以在嵌套消息循环中处理的消息。</li>
<li>PostNonNestableDelayedTask，发送需要延迟处理的并且不可以在嵌套消息循环中处理的消息。</li>
</ol>
<p>&#160; &#160; &#160; &#160;向线程的消息队列发送了新的消息之后，需要唤醒线程，这是通过调用MessagePump类的成员函数Schedule进行的。线程被唤醒之后 ，就会分别调用MessageLoop类重写父类MessagePump::Delegate的两个成员函数DoWork和DoDelayedWork对消息队列的消息进行处理。如果没有消息可以处理，就调用MessageLoop类重写父类MessagePump::Delegate的成员函数DoIdleWork通知线程进入Idle状态，这时候线程就可以做一些Idle Work。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数DoWork在处理消息的过程中，按照以下三个类别进行处理：</p>
<ol>
<li>对于可以马上处理的消息，即保存在成员变量work<em>queue</em>描述的消息队列的消息，执行它们的成员函数Run。</li>
<li>对于需要延迟处理的消息，将它们保存在成员变量delayed_work<em>queue</em>描述的消息队列中，并且调用成员变量pump_指向的一个MessagePump对象的成员函数ScheduleDelayedWork设置最早一个需要处理的延迟消息的处理时间，以便该MessagePump对象可以优化消息循环逻辑。</li>
<li>对于可以马上处理但是不可以在嵌套消息循环中处理的消息，如果线程是处理嵌套消息循环中，那么将它们保存在成员变量deferred_non_nestable_work<em>queue</em>描述的消息队列中，这些消息将会在线程进入Idle状态时，并且是处理最外层消息循环时，得到处理。</li>
</ol>
<p>&#160; &#160; &#160; &#160;以上就是Thread类描述的线程的大概执行过程，接下来我们通过源码分析详细描述这些过程。</p>
<h1 id="线程执行过程"><a href="#线程执行过程" class="headerlink" title="线程执行过程"></a>线程执行过程</h1><p>&#160; &#160; &#160; &#160;我们首先看线程的启动过程，即Thread类的成员函数Start的实现，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Thread::Start() &#123;</span><br><span class="line">  Options options;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> StartWithOptions(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/thread.cc中。</p>
<p>&#160; &#160; &#160; &#160;Thread类的成员函数Start调用另外一个成员函数StartWithOptions来启动一个线程，后者可以通过一个类型为Options的参数指定线程的启动参数，这里没有指定，意味着采用默认参数启动一个线程。</p>
<p>&#160; &#160; &#160; &#160;Thread类的成员函数StartWithOptions的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Thread::StartWithOptions(<span class="keyword">const</span> Options&amp; options) &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="function">StartupData <span class="title">startup_data</span><span class="params">(options)</span></span>;</span><br><span class="line">  startup_data_ = &amp;startup_data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是创建线程的方法，调用PlatformThread的Create函数</span></span><br><span class="line">  <span class="keyword">if</span> (!PlatformThread::Create(options.stack_size, <span class="keyword">this</span>, &amp;thread_)) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Wait for the thread to start and initialize message_loop_</span></span><br><span class="line">  base::ThreadRestrictions::ScopedAllowWait allow_wait;</span><br><span class="line">  <span class="comment">//如果线程还没创建完毕，startup_data已经释放了，那么就无法访问这些参数了</span></span><br><span class="line">  <span class="comment">//因此需要等待</span></span><br><span class="line">  startup_data.event.Wait();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// set it to NULL so we don't keep a pointer to some object on the stack.</span></span><br><span class="line">  startup_data_ = <span class="literal">NULL</span>;</span><br><span class="line">  started_ = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/thread.cc中。</p>
<p>&#160; &#160; &#160; &#160;Thread类的成员函数StartWithOptions首先是将线程启动参数封装一个在栈上分配的StartupData对象中，并且这个StartupData对象的地址会保存在Thread类的成员变量startup<em>data</em>中。接下来再调用由平台实现的PlatformThread类的静态成员函数Create创建一个线程。最后通过上面封装的StartupData对象的成员变量event描述的一个WaitableEvent对象等待上述创建的线程启动完成。</p>
<p>&#160; &#160; &#160; &#160;一般情况下，线程是不可以进入等待状态的，因为这样会降低线程的响应性。但是有时候线程不得不进入等待状态，例如现在这个情况，当前线程必须要等新创建的线程启动完成之后才能返回，否则的话有可能新创建的线程还没有启动完成，前面在栈上分配的StartupData对象就已经被释放，这样会导致新创建的线程无法访问它的启动参数。</p>
<p>&#160; &#160; &#160; &#160;当新创建的线程启动完成之后，就会通过上述的WaitableEvent对象唤醒当前线程，当前线程将Thread类的成员变量startup<em>data</em>置为NULL，避免它引用一个即将无效的在栈上分配的StartupData对象，并且将Thread类的成员变量started_的值设置为true，表示新创建的线程已经启动完毕。</p>
<p>&#160; &#160; &#160; &#160;接下来我们继续分析PlatformThread类的静态成员函数Create的实现。以Android平台为例，它的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PlatformThread::Create(<span class="keyword">size_t</span> stack_size, Delegate* delegate,</span><br><span class="line">                            PlatformThreadHandle* thread_handle) &#123;</span><br><span class="line">  base::ThreadRestrictions::ScopedAllowWait allow_wait;</span><br><span class="line">  <span class="keyword">return</span> CreateThread(stack_size, <span class="literal">true</span> <span class="comment">/* joinable thread */</span>,</span><br><span class="line">                      delegate, thread_handle, kThreadPriority_Normal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/platform_thread_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;PlatformThread类的静态成员函数Create调用了另外一个函数CreateThread来创建一个线程，后者的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateThread</span><span class="params">(<span class="keyword">size_t</span> stack_size, <span class="keyword">bool</span> joinable,</span><br><span class="line">                  PlatformThread::Delegate* delegate,</span><br><span class="line">                  PlatformThreadHandle* thread_handle,</span><br><span class="line">                  ThreadPriority priority)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">pthread_attr_t</span> attributes;</span><br><span class="line">  pthread_attr_init(&amp;attributes);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Pthreads are joinable by default, so only specify the detached</span></span><br><span class="line">  <span class="comment">// attribute if the thread should be non-joinable.</span></span><br><span class="line">  <span class="keyword">if</span> (!joinable) &#123;</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attributes, PTHREAD_CREATE_DETACHED);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Get a better default if available.</span></span><br><span class="line">  <span class="keyword">if</span> (stack_size == <span class="number">0</span>)</span><br><span class="line">    stack_size = base::GetDefaultThreadStackSize(attributes);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (stack_size &gt; <span class="number">0</span>)</span><br><span class="line">    pthread_attr_setstacksize(&amp;attributes, stack_size);</span><br><span class="line"> </span><br><span class="line">  ThreadParams params;</span><br><span class="line">  params.delegate = delegate;</span><br><span class="line">  params.joinable = joinable;</span><br><span class="line">  params.priority = priority;</span><br><span class="line">  params.handle = thread_handle;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">pthread_t</span> handle;</span><br><span class="line">  <span class="comment">//平台调用POSIX线程库中的函数pthread_create创建了一个线程，</span></span><br><span class="line">  <span class="comment">//并且指定新创建的线程的入口点函数为ThreadFunc</span></span><br><span class="line">  <span class="keyword">int</span> err = pthread_create(&amp;handle,</span><br><span class="line">                           &amp;attributes,</span><br><span class="line">                           ThreadFunc,</span><br><span class="line">                           &amp;ms);</span><br><span class="line">  success = !err;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  pthread_attr_destroy(&amp;attributes);</span><br><span class="line"> </span><br><span class="line">  .....</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/platform_thread_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里就可以看到，Android平台调用POSIX线程库中的函数pthread_create创建了一个线程，并且指定新创建的线程的入口点函数为ThreadFunc，同时传递给该入口点函数的参数为一个ThreadParams对象，该ThreadParams对象封装了线程启动过程中需要使用到的一系列参数。    </p>
<p>&#160; &#160; &#160; &#160;新创建线程的入口点函数ThreadFunc的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">void</span>* params)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  ThreadParams* thread_params = <span class="keyword">static_cast</span>&lt;ThreadParams*&gt;(params);</span><br><span class="line"> </span><br><span class="line">  PlatformThread::Delegate* delegate = thread_params-&gt;delegate;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  delegate-&gt;ThreadMain();</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/platform_thread_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;函数ThreadFunc首先将参数params转换为一个ThreadParams对象。有了这个ThreadParams对象之后，就可以通过它的成员变量delegate获得一个PlatformThread::Delegate对象。从前面的调用过程可以知道，这个PlatformThread::Delegate对象实际上是一个Thread对象，用来描述新创建的线程。得到了用来描述新创建线程的Thread对象之后，就可以调用它的成员函数ThreadMain继续启动线程了。</p>
<p>&#160; &#160; &#160; &#160;Thread类的成员函数ThreadMain的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::ThreadMain() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line">    scoped_ptr&lt;MessageLoop&gt; message_loop;</span><br><span class="line">    <span class="comment">//当Options类的成员变量message_pump_factory不等于NULL时，</span></span><br><span class="line">    <span class="comment">//就表示新创建线程使用的Message Pump通过该成员变量描述的一个Callback对象来创建</span></span><br><span class="line">    <span class="keyword">if</span> (!startup_data_-&gt;options.message_pump_factory.is_null()) &#123;</span><br><span class="line">      message_loop.reset(</span><br><span class="line">          <span class="keyword">new</span> MessageLoop(startup_data_-&gt;options.message_pump_factory.Run()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//通过另外一个成员变量message_loop_type来创建指定Message Loop的类型</span></span><br><span class="line">      message_loop.reset(</span><br><span class="line">          <span class="keyword">new</span> MessageLoop(startup_data_-&gt;options.message_loop_type));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    message_loop_ = message_loop.get();</span><br><span class="line">    <span class="comment">//调用Init进行初始化</span></span><br><span class="line">    Init();</span><br><span class="line">    <span class="comment">//表示线程正在运行</span></span><br><span class="line">    running_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//通过Thread类的成员变量startup_data_指向的一个StartupData对象的成员变量event描述的一个WaitableEvent唤醒请求创建新线程的线程</span></span><br><span class="line">    startup_data_-&gt;event.Signal();</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//线程运行过程</span></span><br><span class="line">    Run(message_loop_);</span><br><span class="line">    <span class="comment">//线程运行结束</span></span><br><span class="line">    running_ = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    message_loop_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/thread.cc中。</p>
<p>&#160; &#160; &#160; &#160;回忆前面分析的Thread类的成员函数StartWithOptions，它已经将用来描述线程启动参数的一个Options对象保存在成员变量startup<em>data</em>描述的一个StartupData对象中，因此我们就可以重新获取这个Options对象。</p>
<p>&#160; &#160; &#160; &#160;当Options类的成员变量message_pump_factory不等于NULL时，就表示新创建线程使用的Message Pump通过该成员变量描述的一个Callback对象来创建，也就是调用该Callback对象的成员函数Run来创建。关于Chromium的Callback机制，可以参考前面Chromium多线程通信的Closure机制分析一文。有了Message Pump之后，就可以创建一个Message Loop了。该Message Loop最终会保存在Thread类的成员变量message<em>loop</em>中。</p>
<p>&#160; &#160; &#160; &#160;一般我们不通过Options类的成员变量message_pump_factory来创建Message Pump，而是通过另外一个成员变量message_loop_type来创建指定Message Loop的类型 ，从而确定要创建的Message Pump，这些逻辑都封装在MessageLoop类的构造函数中。</p>
<p>&#160; &#160; &#160; &#160;创建好Message Loop之后，线程的启动工作就完成了，接下来新创建的线程就需要进入到初始化状态，这是通过调用Thread类的成员函数Init实现的。Thread类的成员函数Init一般由子类重写，这样子类就有机会执行一些线程初始化工作。</p>
<p>&#160; &#160; &#160; &#160;再接下来，新创建的线程就需要进入运行状态，这是通过调用Thread类的成员函数Run实现的。不过在新创建线程进入运行状态之前，还会做两件事情。第一件事情是将Thread类的成员变量running_设置为true，表示新创建的线程正在运行。第二件事情是通过Thread类的成员变量startup<em>data</em>指向的一个StartupData对象的成员变量event描述的一个WaitableEvent唤醒请求创建新线程的线程。</p>
<p> &#160; &#160; &#160; &#160;最后，当Thread类的成员函数Run执行完成返回后，需要将Thread类的成员变量running_和message<em>loop</em>分别重置为false和NULL，表示新创建的线程已经运行结束了，因此就不再需要Message Loop了。</p>
<p>&#160; &#160; &#160; &#160;接下来我们首先分析线程的Message Loop的创建过程，也就是MessageLoop类的构造函数的实现，以完成线程的启动过程，然后再分析线程的运行过程，也就是Thread类的成员函数Run的实现。</p>
<h2 id="MessageLoop创建"><a href="#MessageLoop创建" class="headerlink" title="MessageLoop创建"></a>MessageLoop创建</h2><p>&#160; &#160; &#160; &#160;我们假设线程的Message Loop是通过Message Loop Type来创建的，对应的MessageLoop类构造函数的实现如下所示： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MessageLoop::MessageLoop(Type type)</span><br><span class="line">    : type_(type),</span><br><span class="line">      nestable_tasks_allowed_(<span class="literal">true</span>),<span class="comment">//默认允许消息嵌套</span></span><br><span class="line">      ......</span><br><span class="line">      run_loop_(<span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  Init();</span><br><span class="line">  <span class="comment">//创建一个消息泵</span></span><br><span class="line">  pump_ = CreateMessagePumpForType(type).Pass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc。 </p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员变量type_描述的是消息循环的类型，nestable_tasks<em>allowed</em>描述当前是否允许处理嵌套消息，runn<em>loop</em>描述的是当前使用的消息循环。 </p>
<p>&#160; &#160; &#160; &#160;MessageLoop类构造函数首先是调用成员函数Init执行初始化工作，接着再调用成员函数CreateMessagePumpForType根据消息循环的类型创建一个Message Pump。接下来我们就分别分析这两个成员函数的实现。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数Init的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LazyInstance&lt;base::ThreadLocalPointer&lt;MessageLoop&gt; &gt;::Leaky lazy_tls_ptr =</span><br><span class="line">    LAZY_INSTANCE_INITIALIZER;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> MessageLoop::Init() &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//将创建的MessageLoop保存在一个线程局部变量中</span></span><br><span class="line">  lazy_tls_ptr.Pointer()-&gt;Set(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//创建一个IncomingTaskQueue</span></span><br><span class="line">  incoming_task_queue_ = <span class="keyword">new</span> internal::IncomingTaskQueue(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//利用incoming_task_queue_再创建一个MessageLoopProxyImpl</span></span><br><span class="line">  message_loop_proxy_ =</span><br><span class="line">      <span class="keyword">new</span> internal::MessageLoopProxyImpl(incoming_task_queue_);</span><br><span class="line">  <span class="comment">//再利用message_loop_proxy_创建一个ThreadTaskRunnerHandle的智能指针</span></span><br><span class="line">  thread_task_runner_handle_.reset(</span><br><span class="line">      <span class="keyword">new</span> ThreadTaskRunnerHandle(message_loop_proxy_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数Init首先将当前创建的MessageLoop对象保存在全局变量lazy_tls_ptr指向一块线程局部存储中，这样我们就可以通过MessageLoop类的静态成员函数current获得当前线程的消息循环，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MessageLoop* MessageLoop::current() &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> lazy_tls_ptr.Pointer()-&gt;Get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;回到MessageLoop类的成员函数Init中，接下来它创建了一个任务队列，并且保存在成员变量incoming<em>queue</em>中。这个任务队列通过IncomingQueue类来描述，它的定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT IncomingTaskQueue</span><br><span class="line">    : <span class="keyword">public</span> RefCountedThreadSafe&lt;IncomingTaskQueue&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">AddToIncomingQueue</span><span class="params">(<span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line">                          <span class="keyword">const</span> Closure&amp; task,</span><br><span class="line">                          TimeDelta delay,</span><br><span class="line">                          <span class="keyword">bool</span> nestable)</span></span>;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReloadWorkQueue</span><span class="params">(TaskQueue* work_queue)</span></span>;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WillDestroyCurrentMessageLoop</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  TaskQueue incoming_queue_;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  MessageLoop* message_loop_;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个类定义在external/chromium_org/base/message_loop/incoming_task_queue.h中。</p>
<p>&#160; &#160; &#160; &#160;IncomingQueue类有两个重要的成员变量：</p>
<ol>
<li>incoming<em>queue</em>，它描述的是一个TaskQueue，代表的是线程的消息队列，也就是所有发送给线程的消息都保存在这里。</li>
<li>message<em>loop</em>，它指向一个MessageLoop对象，描述的是线程的消息循环。</li>
</ol>
<p>&#160; &#160; &#160; &#160;IncomingQueue类有三个重要的成员函数：</p>
<ol>
<li>AddToIncomingQueue，用来向成员变量incoming<em>queue</em>描述的消息队列发送一个消息，并且唤醒线程进行处理。</li>
<li>ReloadWorkQueue，用来提取成员变量incoming<em>queue</em>描述的消息队列中的消息，并且保存在参数work_queue中。</li>
<li>WillDestroyCurrentMessageLoop，当该函数被调用时，会将成员变量message<em>loop</em>的值设置为NULL，使得我们不能够再向线程发送消息，也就是请求线程执行某一个操作。</li>
</ol>
<p>&#160; &#160; &#160; &#160;IncomingQueue类的上述成员变量和成员函数我们后面分析消息的发送和处理再详细分析。现在返回到MessageLoop类的成员函数Init中，它接下来创建了一个MessageLoopProxyImpl对象和一个ThreadTaskRunnerHandle对象，分别保存在成员变量message_loop<em>proxy</em>和thread_task_runner_handle中，前者封装了当前线程的消息队列，后者又封装了前者。它们与MessageLoop类一样，都是可以用来向线程的消息队列发送消息，这意味着我们有三种方式向线程的消息队列发送消息，后面分析消息的发送过程时我们再详细分析。</p>
<h3 id="创建消息泵"><a href="#创建消息泵" class="headerlink" title="创建消息泵"></a>创建消息泵</h3><p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数Init执行完成后，回到MessageLoop类的构造函数中，接下来它调用另外一个成员函数CreateMessagePumpForType根据消息循环的类型创建一个消息泵（Message Pump），并且保存在成员变量pump_中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数CreateMessagePumpForType的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_IOS)</span></span><br><span class="line"><span class="keyword">typedef</span> MessagePumpIOSForIO MessagePumpForIO;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_NACL)</span></span><br><span class="line"><span class="keyword">typedef</span> MessagePumpDefault MessagePumpForIO;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_POSIX)</span></span><br><span class="line"><span class="keyword">typedef</span> MessagePumpLibevent MessagePumpForIO;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line">scoped_ptr&lt;MessagePump&gt; MessageLoop::CreateMessagePumpForType(Type type) &#123;</span><br><span class="line">  ......</span><br><span class="line"><span class="comment">//如果是IOS或者MAC平台，就使用MessagePumpMac创建消息泵</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_IOS) || defined(OS_MACOSX)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE_PUMP_UI scoped_ptr<span class="meta-string">&lt;MessagePump&gt;</span>(MessagePumpMac::Create())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_NACL)<span class="comment">//Native Client是一种允许在浏览器中运行native compiled code 的技术</span></span></span><br><span class="line"><span class="comment">//氯化钠不需要UI线程消息泵</span></span><br><span class="line"><span class="comment">// Currently NaCl doesn't have a UI MessageLoop.</span></span><br><span class="line"><span class="comment">// TODO(abarth): Figure out if we need this.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE_PUMP_UI scoped_ptr<span class="meta-string">&lt;MessagePump&gt;</span>()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//对于Android平台来说MessagePumpLibevent是这个消息泵的类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE_PUMP_UI scoped_ptr<span class="meta-string">&lt;MessagePump&gt;</span>(new MessagePumpForUI())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//消息循环类型为MessageLoop::TYPE_UI的线程称为UI线程</span></span><br><span class="line">  <span class="keyword">if</span> (type == MessageLoop::TYPE_UI) &#123;</span><br><span class="line">    <span class="comment">//但是一般不设置函数指针message_pump_for_ui_factory_</span></span><br><span class="line">    <span class="keyword">if</span> (message_pump_for_ui_factory_)</span><br><span class="line">      <span class="keyword">return</span> message_pump_for_ui_factory_();</span><br><span class="line">    <span class="comment">//因此类型为MessageLoop::TYPE_UI的消息循环对应的消息泵为MessagePumpForUI</span></span><br><span class="line">    <span class="keyword">return</span> MESSAGE_PUMP_UI;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//消息循环类型为MessageLoop::TYPE_IO的线程称为IO线程</span></span><br><span class="line">  <span class="keyword">if</span> (type == MessageLoop::TYPE_IO)</span><br><span class="line">    <span class="keyword">return</span> scoped_ptr&lt;MessagePump&gt;(<span class="keyword">new</span> MessagePumpForIO());</span><br><span class="line">    </span><br><span class="line"><span class="comment">//消息循环类型为MessageLoop::TYPE_JAVA的线程称为JAVA线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">  <span class="keyword">if</span> (type == MessageLoop::TYPE_JAVA)</span><br><span class="line">    <span class="keyword">return</span> scoped_ptr&lt;MessagePump&gt;(<span class="keyword">new</span> MessagePumpForUI());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> scoped_ptr&lt;MessagePump&gt;(<span class="keyword">new</span> MessagePumpDefault());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;上面的代码通过一系列宏来适配不同的平台，这里我们只考虑Android平台，这意味着MessagePumpForIO定义为MessagePumpLibevent，MESSAGE_PUMP_UI定义为scoped_ptr&lt; MessagePump &gt;(new MessagePumpForUI())。</p>
<p>&#160; &#160; &#160; &#160;从MessageLoop类的成员函数CreateMessagePumpForType的实现可以知道：</p>
<ol>
<li>如果消息循环的类型为MessageLoop::TYPE_UI，那么对应的消息泵为MessagePumpForUI，或者由函数指针message_pump_for_ui<em>factory</em>指向的函数创建。但是一般不设置函数指针message_pump_for_ui<em>factory</em>，因此，类型为MessageLoop::TYPE_UI的消息循环对应的消息泵为MessagePumpForUI。在Chromium中，消息循环类型为MessageLoop::TYPE_UI的线程称为UI线程，也就是应用程序的主线程。</li>
<li>如果消息循环的类型为MessageLoop::TYPE_IO，那么对应的消息泵为MessagePumpForIO，即MessagePumpLibevent。在Chromium中，消息循环类型为MessageLoop::TYPE_IO的线程称为IO线程，但是这里的IO不是读写文件的意思，而是执行IPC的意思。</li>
<li>如果消息循环的类型为MessageLoop::TYPE_JAVA，那么对应的消息泵为MessagePumpForUI。在Chromium中，消息循环类型为MessageLoop::TYPE_JAVA的线程称为JAVA线程，它们与UI线程一样，在JAVA层具有自己的消息循环。</li>
<li>其余类型的消息循环，对应的消息泵为MessagePumpDefault。</li>
</ol>
<p>&#160; &#160; &#160; &#160;总结来说，就是在Android平台上，涉及到的消息泵有MessagePumpForUI、MessagePumpForIO和MessagePumpDefault三种，各自有不同的用途，其中MessagePumpForUI适用于在Java层具有自己的消息循环的UI线程和Java线程，MessagePumpLibevent适用于用来负责执行IPC的IO线程，MessagePumpDefault适用于其它的一般线程。</p>
<p>&#160; &#160; &#160; &#160;我们先从一般性出发，分析MessagePumpDefault的实现，后面再分析MessagePumpForUI和MessagePumpForIO的实现。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpDefault类继承于MessagePump类，它的定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MessagePumpDefault : <span class="keyword">public</span> MessagePump &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  MessagePumpDefault();</span><br><span class="line">  <span class="keyword">virtual</span> ~MessagePumpDefault();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// MessagePump methods:</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">(Delegate* delegate)</span> OVERRIDE</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Quit</span><span class="params">()</span> OVERRIDE</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ScheduleWork</span><span class="params">()</span> OVERRIDE</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ScheduleDelayedWork</span><span class="params">(<span class="keyword">const</span> TimeTicks&amp; delayed_work_time)</span> OVERRIDE</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// This flag is set to false when Run should return.</span></span><br><span class="line">  <span class="keyword">bool</span> keep_running_;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Used to sleep until there is more work to do.</span></span><br><span class="line">  WaitableEvent event_;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The time at which we should call DoDelayedWork.</span></span><br><span class="line">  TimeTicks delayed_work_time_;</span><br><span class="line"> </span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(MessagePumpDefault);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个类定义在文件external/chromium_org/base/message_loop/message_pump_default.h 。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpDefault类重写了父类MessagePump的成员函数Run、Quit、ScheduleWork和ScheduleDelayedWork，后面我们分析消息循环的执行过程和消息的发送过程时，会看到它们的具体实现。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpDefault类具有三个成员变量：</p>
<ol>
<li>keep<em>running</em>，类型为bool，表示消息循环是否需要继续执行。只要线程不退出，消息循环就要持续执行。</li>
<li>event_，类型为WaitableEvent，表示一个可以进行Wait/Wake的事件变量。当线程的消息队列为空时，线程就通过它进入到Wait状态，而当向线程的消息队列发送了一个消息时，就通过它唤醒线程。</li>
<li>delayed_work<em>time</em>，类型为TimeTicks，表示线程进入Wait状态的超时时间。达到超时时间之后，线程就会自动唤醒，然后处理那些延迟消息。</li>
</ol>
<p>&#160; &#160; &#160; &#160;这样，一个消息循环及其对应的消息泵就创建完毕，回到Thread类的成员函数ThreadMain中，接下来它调用成员函数Run使得线程进入到运行状态，也就是围绕消息队列进行不断的循环，直到线程退出为止。</p>
<h2 id="线程的运行过程"><a href="#线程的运行过程" class="headerlink" title="线程的运行过程"></a>线程的运行过程</h2><p>&#160; &#160; &#160; &#160;Thread类的成员函数Run的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::Run(MessageLoop* message_loop) &#123;</span><br><span class="line">  message_loop-&gt;Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/thread.cc中。</p>
<p>&#160; &#160; &#160; &#160;Thread类的成员函数Run调用参数message_loop指向的一个MessageLoop对象的成员函数Run使得线程进入运行状态。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数Run的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::Run() &#123;</span><br><span class="line">  RunLoop run_loop;</span><br><span class="line">  run_loop.Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数Run在栈上创建了一个RunLoop对象，然后通过调用该RunLoop对象的成员函数Run使得线程进入运行状态。</p>
<p>&#160; &#160; &#160; &#160;前面提到，RunLoop的作用是用来建立消息循环的层次关系的，主要是通过它的两个成员变量previous_run<em>loop</em>和run<em>depth</em>来实现，此外，它还有一个成员变量loop_，用来关联它所对应的消息循环。</p>
<p>&#160; &#160; &#160; &#160;RunLoop类的上述三个成员变量的定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT RunLoop &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  MessageLoop* loop_;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Parent RunLoop or NULL if this is the top-most RunLoop.</span></span><br><span class="line">  RunLoop* previous_run_loop_;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Used to count how many nested Run() invocations are on the stack.</span></span><br><span class="line">  <span class="keyword">int</span> run_depth_;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这三个成员变量定义在文件external/chromium_org/base/run_loop.h中。</p>
<p>&#160; &#160; &#160; &#160;它们在RunLoop类的构造函数被初始化，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RunLoop::RunLoop()</span><br><span class="line">    : loop_(MessageLoop::current()),</span><br><span class="line">      previous_run_loop_(<span class="literal">NULL</span>),</span><br><span class="line">      run_depth_(<span class="number">0</span>),</span><br><span class="line">      ...... &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/run_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里我们就可以看到，一个RunLoop关联的消息循环就是当前线程使用的消息循环。这个消息循环可以通过调用前面提到的MessageLoop类的静态成员函数current获得。</p>
<p>&#160; &#160; &#160; &#160;RunLoop类的成员变量previous_run<em>loop</em>和run<em>depth</em>分别被初始化为NULL和0，表示还没有建立好层次关系，但是当RunLoop类的成员函数Run被调用时，它们就会被设置，从而形成层次关系。</p>
<p>&#160; &#160; &#160; &#160;从前面的调用过程可以知道，RunLoop类的成员函数Run在MessageLoop类的成员函数Run中调用，它的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RunLoop::Run() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!BeforeRun())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  loop_-&gt;RunHandler();</span><br><span class="line">  AfterRun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/run_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;在调用成员变量loop_指向的一个MessageLoop对象的成员函数RunHandler进入消息循环前后，RunLoop类的成员函数Run分别调用了BeforeRun和AfterRun两个成员函数，目的就是为了建立好消息循环的层次关系，它们的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RunLoop::BeforeRun() &#123;</span><br><span class="line">  DCHECK(!run_called_);</span><br><span class="line">  run_called_ = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Allow Quit to be called before Run.</span></span><br><span class="line">  <span class="comment">//一个Run Loop在即将被消息循环使用之前，就已经收到了退出请求</span></span><br><span class="line">  <span class="keyword">if</span> (quit_called_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Push RunLoop stack:</span></span><br><span class="line">  <span class="comment">//RunLoop类的成员函数BeforeRun会将当前正在处理的RunLoop对象记录在其成员变量loop_指向的一个MessageLoop对象的成员变量run_loop_中</span></span><br><span class="line">  <span class="comment">//而该MessageLoop对象的成员变量run_loop_原来指向的RunLoop对象则记录在当前正在处理的RunLoop对象的成员变量previous_run_loop_中</span></span><br><span class="line">  <span class="comment">//从而就形成一个Run Loop调用栈</span></span><br><span class="line">  previous_run_loop_ = loop_-&gt;run_loop_;</span><br><span class="line">  <span class="comment">//第一个RunLoop为null，因此run_depth_为1，往后以此+1</span></span><br><span class="line">  run_depth_ = previous_run_loop_? previous_run_loop_-&gt;run_depth_ + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  loop_-&gt;run_loop_ = <span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">  running_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> RunLoop::AfterRun() &#123;</span><br><span class="line">  running_ = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Pop RunLoop stack:</span></span><br><span class="line">  <span class="comment">//RunLoop类的成员函数AfterRun执行的是一个Run Loop出栈操作</span></span><br><span class="line">  <span class="comment">//它将消息循环当前使用的Run Loop恢复为前一个Run Loop</span></span><br><span class="line">  loop_-&gt;run_loop_ = previous_run_loop_;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Execute deferred QuitNow, if any:</span></span><br><span class="line">  <span class="comment">//一个Run Loop在被消息循环使用期间，前一个Run Loop收到了退出请求</span></span><br><span class="line">  <span class="keyword">if</span> (previous_run_loop_ &amp;&amp; previous_run_loop_-&gt;quit_called_)</span><br><span class="line">    loop_-&gt;QuitNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这两个函数定义在文件external/chromium_org/base/run_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员变量run<em>loop</em>记录的是消息循环当前使用的Run Loop，因此，RunLoop类的成员函数BeforeRun会将当前正在处理的RunLoop对象记录在其成员变量loop_指向的一个MessageLoop对象的成员变量run<em>loop</em>中，而该MessageLoop对象的成员变量run<em>loop</em>原来指向的RunLoop对象则记录在当前正在处理的RunLoop对象的成员变量previous_run<em>loop</em>中，从而就形成一个Run Loop调用栈。此外，第一个Run Loop的Run Depth被设置为1，后面的Run Loop的Run Depth依次增加1。</p>
<p>&#160; &#160; &#160; &#160;从上面的分析就可以看出，RunLoop类的成员函数BeforeRun执行的是一个Run Loop入栈操作，相应地，RunLoop类的成员函数AfterRun执行的是一个Run Loop出栈操作，它将消息循环当前使用的Run Loop恢复为前一个Run Loop。</p>
<p>&#160; &#160; &#160; &#160;RunLoop类的成员变量running_描述的是一个Run Loop当前是否正在被消息循环使用，因此，在RunLoop类的成员函数BeforeRun和AfterRun中，它的值分别被设置为true和false。</p>
<p>&#160; &#160; &#160; &#160;RunLoop类的成员变量quit<em>called</em>描述的是一个Run Loop是否收到退出请求。如果一个Run Loop当前正在消息循环使用，并且又收到了退出请求，那么就将会导致消息循环退出。这样就会导致以下两种情况：</p>
<ol>
<li>一个Run Loop在即将被消息循环使用之前，就已经收到了退出请求，那么就不会被消息循环使用，表现就为在RunLoop类的成员函数BeforeRun中，如果当前正在处理的RunLoop对象的成员变量quit<em>called</em>的值等于true，那么就返回一个false值给调用者，表示当前正在处理的RunLoop对象不能够进入消息循环。</li>
<li>一个Run Loop在被消息循环使用期间，前一个Run Loop收到了退出请求，那么当前Run Loop结束使用之后，禁止返回到前一个Run Loop。这意味着要结束消息循环，表现就为在RunLoop类的成员函数AfterRun中，如果发现当前正在处理的RunLoop对象的成员变量previous_run<em>loop</em>不为NULL，并且它指向的一个RunLoop对象的成员变量quit<em>called的值被设置为true，那么就会调用当前正在处理的RunLoop对象的成员变量loop</em>指向的一个MessageLoop对象的成员函数QuitNow退出消息循环。</li>
</ol>
<p>&#160; &#160; &#160; &#160;回到RunLoop类的成员函数Run中，在调用成员函数BeforeRun成功建立好消息循环的层次关系之后，就通过当前正在处理的RunLoop对象进入到下一层消息循环中，这是通过调用当前正在处理的RunLoop对象的成员变量loop_指向的一个MessageLoop对象的成员函数RunHandler实现的。从前面的分析可以知道，该MessageLoop对象描述的是就是当前线程使用的消息循环。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数RunHandler的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::RunHandler() &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  pump_-&gt;Run(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数RunHandler通过调用成员变量pump_指向的一个MessagePump对象的成员函数Run进入消息循环。前面我们假设该MessagePump对象是一个MessagePumpDefault对象，因此接下来我们继续分析MessagePumpDefault类的成员函数Run的实现，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessagePumpDefault::Run(Delegate* delegate) &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;<span class="comment">//无限for循环，不断取出消息处理</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//处理任务队列中的任务</span></span><br><span class="line">    <span class="keyword">bool</span> did_work = delegate-&gt;DoWork();</span><br><span class="line">    <span class="keyword">if</span> (!keep_running_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//处理延时任务队列中的任务</span></span><br><span class="line">    <span class="comment">//delayed_work_time_描述的是最早的延时点</span></span><br><span class="line">    did_work |= delegate-&gt;DoDelayedWork(&amp;delayed_work_time_);</span><br><span class="line">    <span class="keyword">if</span> (!keep_running_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (did_work)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">    did_work = delegate-&gt;DoIdleWork();</span><br><span class="line">    <span class="keyword">if</span> (!keep_running_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//当这个布尔值等于true的时候，就表示线程处理了一些任务。</span></span><br><span class="line">    <span class="comment">//在这种情况下，就需要重新执行一遍for循环，</span></span><br><span class="line">    <span class="comment">//这是因为上述三个函数在处理任务的过程中，</span></span><br><span class="line">    <span class="comment">//可能又往线程的消息队列发送了新的任务，</span></span><br><span class="line">    <span class="comment">//因此需要for循环检查进行检查，以及新发送的任务能够得到及时处理。</span></span><br><span class="line">    <span class="keyword">if</span> (did_work)</span><br><span class="line">      <span class="keyword">continue</span>;<span class="comment">//返回值均为false，那就表示线程当前实在是无事可做</span></span><br><span class="line"> </span><br><span class="line">    ThreadRestrictions::ScopedAllowWait allow_wait;</span><br><span class="line">    <span class="comment">//delayed_work_time_就表示该消息在将来执行的时间点</span></span><br><span class="line">    <span class="comment">//如果线程无事可做</span></span><br><span class="line">    <span class="comment">//在这种情况下，最好的方式就是让线程进入睡眠状态，以便将CPU释放出来</span></span><br><span class="line">    <span class="keyword">if</span> (delayed_work_time_.is_null()) &#123;</span><br><span class="line">      event_.Wait();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TimeDelta delay = delayed_work_time_ - TimeTicks::Now();</span><br><span class="line">      <span class="comment">//还没有到线程唤醒事件，需要睡眠delay时间点</span></span><br><span class="line">      <span class="keyword">if</span> (delay &gt; TimeDelta()) &#123;</span><br><span class="line">        event_.TimedWait(delay);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It looks like delayed_work_time_ indicates a time in the past, so we</span></span><br><span class="line">        <span class="comment">// need to call DoDelayedWork now.</span></span><br><span class="line">        如果最早的延时点小于系统的当前时间，</span><br><span class="line">        <span class="comment">//那么线程就不可以睡眠，而要马上重新执行for循环，</span></span><br><span class="line">        <span class="comment">//以便可以对已经超过了时间点处理的消息进行处理。</span></span><br><span class="line">        delayed_work_time_ = TimeTicks();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Since event_ is auto-reset, we don't need to do anything special here</span></span><br><span class="line">    <span class="comment">// other than service each delegate method.</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  keep_running_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_default.cc中。</p>
<p>&#160; &#160; &#160; &#160;参数delegate是一个Delegate类型的指针，但是从上面的调用过程可以知道，它指向的是一个MessageLoop对象。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpDefault类的成员函数Run在一个for循环中不断地通过调用参数delegate指向的一个MessageLoop对象的成员函数DoWork和DoDelayedWork检查线程的消息队列是否有任务需要处理。如果没有，再调用该MessageLoop对象的成员函数DoIdleWork处理一些适用在线程空闲时进行的任务。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数DoWork、DoDelayedWork和DoIdleWork的返回值均为一个布尔值。当这个布尔值等于true的时候，就表示线程处理了一些任务。在这种情况下，就需要重新执行一遍for循环，这是因为上述三个函数在处理任务的过程中，可能又往线程的消息队列发送了新的任务，因此需要for循环检查进行检查，以及新发送的任务能够得到及时处理。</p>
<p>&#160; &#160; &#160; &#160;另一方面，如果MessageLoop类的成员函数DoWork、DoDelayedWork和DoIdleWork的返回值均为false，那就表示线程当前实在是无事可做。这时候就不适合重新执行一遍for循环，因此这会使得线程在空转。在这种情况下，最好的方式就是让线程进入睡眠状态，以便将CPU释放出来。那么线程什么时候需要唤醒呢？</p>
<p>&#160; &#160; &#160; &#160;在两种情况下，线程需要从睡眠状态唤醒过来。第一种情况是线程的消息队列有新的消息加入的时候，这时候由发送消息的线程进行唤醒。第二种情况是，线程有一个延时消息需要处理，那么当系统达到该消息的处理时间时，线程就需要自动唤醒过来。</p>
<p>&#160; &#160; &#160; &#160;如果线程有一个延时消息需要处理，那么MessagePumpDefault类的成员变量delayed_work<em>time</em>就表示该消息在将来执行的时间点。注意，如果线程具有多个延时消息，那么MessagePumpDefault类的成员变量delayed_work<em>time</em>描述的是最早的延时点，这时候线程最多就只能睡眠到该时间点，然后自动唤醒过来。还有一点需要注意的是，如果最早的延时点小于系统的当前时间，那么线程就不可以睡眠，而要马上重新执行for循环，以便可以对已经超过了时间点处理的消息进行处理。如果线程没有延时消息需要处理，那么线程就不会设置自动唤醒时间，而是一直处理睡眠状态，直到被其它线程唤醒为止。</p>
<p>&#160; &#160; &#160; &#160;无论线程是通过哪一种情况下进行睡眠状态，都是通过MessagePumpDefault类的成员变量event_描述的一个WaitableEvent对象进行，即通过调用它的成员函数Wait和TimedWait进行的。</p>
<p>&#160; &#160; &#160; &#160;WaitableEvent是有效地实现线程消息循环的一个重要类。通过WaitableEvent类，线程可以在无消息处理时进入睡眠状态，并且在有消息处理时从睡眠状态唤醒过来，从而避免了不断地轮循消息队列是否有消息处理的操作。因为消息队列可能在大多数情况下都是空的，对它进行不断轮循将会浪费CPU周期。</p>
<p>&#160; &#160; &#160; &#160;因为WaitableEvent类是如此重要，因此接下来我们先分析它的实现，然后再继续分析线程处理消息的过程，也就是MessageLoop类的成员函数DoWork、DoDelayedWork和DoIdleWork的实现。</p>
<h3 id="WaitableEvent线程睡眠变量"><a href="#WaitableEvent线程睡眠变量" class="headerlink" title="WaitableEvent线程睡眠变量"></a>WaitableEvent线程睡眠变量</h3><p>&#160; &#160; &#160; &#160;WaitableEvent类的定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT WaitableEvent &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ......</span><br><span class="line">  WaitableEvent(<span class="keyword">bool</span> manual_reset, <span class="keyword">bool</span> initially_signaled);</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Signal</span><span class="params">()</span></span>;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Wait</span><span class="params">()</span></span>;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">TimedWait</span><span class="params">(<span class="keyword">const</span> TimeDelta&amp; max_time)</span></span>;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">class</span> Waiter &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Fire</span><span class="params">(WaitableEvent* signaling_event)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">void</span>* tag)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">struct</span> WaitableEventKernel :</span><br><span class="line">      <span class="keyword">public</span> RefCountedThreadSafe&lt;WaitableEventKernel&gt; &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    WaitableEventKernel(<span class="keyword">bool</span> manual_reset, <span class="keyword">bool</span> initially_signaled);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Dequeue</span><span class="params">(Waiter* waiter, <span class="keyword">void</span>* tag)</span></span>;</span><br><span class="line"> </span><br><span class="line">    base::Lock lock_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> manual_reset_;</span><br><span class="line">    <span class="keyword">bool</span> signaled_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Waiter*&gt; waiters_;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SignalAll</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SignalOne</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(Waiter* waiter)</span></span>;</span><br><span class="line"> </span><br><span class="line">  scoped_refptr&lt;WaitableEventKernel&gt; kernel_;</span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个类定义在文件external/chromium_org/base/synchronization/waitable_event.h中。</p>
<p>&#160; &#160; &#160; &#160;这里我们只讨论Android平台相关的实现。WaitableEvent类提供两个最基本的功能：Wait和Signal。Wait操作使得线程进入睡眠状态，而Signal操作使得线程从睡眠状态唤醒过来。</p>
<p>&#160; &#160; &#160; &#160;在WaitableEvent类中，Wait操作对应的两个成员函数为Wait和TimedWait。前者使得线程一直处理唤醒状态，直到被其它线程唤醒为止，而后者使得线程进入到睡眠状态的时间为有限时间，并且在超过该时间后，线程自动唤醒。</p>
<p>&#160; &#160; &#160; &#160;在WaitableEvent类中，Signal操作对应的成员函数为Signal，内部通成员函数SignalAll和SignalOne实现。前者唤醒所有的等待者，而后者只唤醒其中一个等待者。</p>
<p>&#160; &#160; &#160; &#160;等待者通过内部类Waiter描述，它有Fire和Compare两个成员函数。一个Waiter需要唤醒时，它的成员函数Fire就会被调用。Waiter类的成员函数Compare用来比较一个Waiter与另外一个Waiter是否相同。</p>
<p>&#160; &#160; &#160; &#160;一个WaitableEvent可以有若干个Waiter，这些Waiter通过WaitableEvent类的成员函数Enqueue加入到成员变量kernel<em>指向的一个WaitableEventKernel对象的成员变量waiters</em>描述的一个列表中。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventKernel类除了上述的成员变量waiters_之外，还具有以下三个成员变量：</p>
<ol>
<li>lock<em>，一个互斥锁，用来保护成员变量waiters</em>的并发访问。</li>
<li>manual<em>reset</em>，一个布尔变量，用来表示一个WaitableEvent被唤醒的时候，是否需要手动设置才变为Signaled状态。</li>
<li>signaled_，一个布尔变量，用来表示一个WaitableEvent是否处于Signaled状态。</li>
</ol>
<blockquote>
<p>&#160; &#160; &#160; &#160;上述三个成员变量以及成员变量waiters_都是用来描述一个WaitableEvent的状态的。为什么不将这些成员变量直接作为WaitableEvent类的成员变量呢?这是为了模拟Windows系统的HANDLE语意的。在Windows平台，一个描述WaitableEvent对象的HANDLE处理等待状态时，是可以关闭的，即可以被Close。Windows平台认为这种情况会出现未定义行为，但是不会导致程序Crash。Android平台的WaitableEvent为具有这样的语意，就将描述WaitableEvent状态的成员变量保存一个WaitableEventKernel对象中，然后通过一个scoped<em>refptr智能指针kernel</em>引用它。这样，当一个WaitableEvent被Close时，它本身是被销毁了，但是它的成员变量kernel_指向的WaitableEventKernel对象却未必会被销毁，这取决于其宿主WaitableEvent的使用情况。例如，如果这个WaitableEventKernel对象同时也被另外一个scoped<em>refptr智能指针引用时，由于它的引用计数大于1，那么它就不会被销毁。这意味着在我们可以有一种方式，使得一个WaitableEvent被销毁时，我们仍然可以通过其成员变量kernel</em>描述的WaitableEventKernel对象操作该WaitableEvent，而且可以避免程序Crash。</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;我们先看WaitableEvent类的构造函数的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WaitableEvent::WaitableEvent(<span class="keyword">bool</span> manual_reset, <span class="keyword">bool</span> initially_signaled)</span><br><span class="line">: kernel_(<span class="keyword">new</span> WaitableEventKernel(manual_reset, initially_signaled)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;WaitableEvent的构造函数主要就是创建了一个WaitableEventKernel对象，并且保存在成员变量kernel_中。</p>
<h3 id="Wait实现"><a href="#Wait实现" class="headerlink" title="Wait实现"></a>Wait实现</h3><p>&#160; &#160; &#160; &#160;我们接下来继续分析WaitableEvent类的成员函数Wait的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WaitableEvent::Wait() &#123;</span><br><span class="line"><span class="keyword">bool</span> result = TimedWait(TimeDelta::FromSeconds(<span class="number">-1</span>));</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;WaitableEvent类的成员函数Wait通过调用另外一个成员函数TimedWait使得线程进入睡眠状态，并且指定进入睡眠状态的时间为-1，即无限地进入睡眠状态，直到被其它线程唤醒为止。</p>
<p>&#160; &#160; &#160; &#160;WaitableEvent类的成员函数TimedWait的实现如下所示:所示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool WaitableEvent::TimedWait(const TimeDelta&amp; max_time) &#123;</span><br><span class="line">......</span><br><span class="line">const TimeTicks end_time(TimeTicks::Now() + max_time);</span><br><span class="line">const bool finite_time = max_time.ToInternalValue() &gt;= 0;</span><br><span class="line">kernel_-&gt;lock_.Acquire();</span><br><span class="line">if (kernel_-&gt;signaled_) &#123;</span><br><span class="line">if (!kernel_-&gt;manual_reset_) &#123;</span><br><span class="line">// In this case we were signaled when we had no waiters. Now that</span><br><span class="line">// someone has waited upon us, we can automatically reset.</span><br><span class="line">kernel_-&gt;signaled_ = false;</span><br><span class="line">&#125;</span><br><span class="line">kernel_-&gt;lock_.Release();</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">SyncWaiter sw;</span><br><span class="line">sw.lock()-&gt;Acquire();</span><br><span class="line">Enqueue(&amp;sw);</span><br><span class="line">kernel_-&gt;lock_.Release();</span><br><span class="line">for (;;) &#123;</span><br><span class="line">const TimeTicks current_time(TimeTicks::Now());</span><br><span class="line">if (sw.fired() || (finite_time &amp;&amp; current_time &gt;= end_time)) &#123;</span><br><span class="line">const bool return_value = sw.fired();</span><br><span class="line">......</span><br><span class="line">sw.lock()-&gt;Release();</span><br><span class="line">kernel_-&gt;lock_.Acquire();</span><br><span class="line">kernel_-&gt;Dequeue(&amp;sw, &amp;sw);</span><br><span class="line">kernel_-&gt;lock_.Release();</span><br><span class="line">return return_value;</span><br><span class="line">&#125;</span><br><span class="line">if (finite_time) &#123;</span><br><span class="line">const TimeDelta max_wait(end_time - current_time);</span><br><span class="line">sw.cv()-&gt;TimedWait(max_wait);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">sw.cv()-&gt;Wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;我们分段来阅读WaitableEvent类的成员函数TimedWait的代码。</p>
<p>&#160; &#160; &#160; &#160;第一段代码如下所示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const TimeTicks end_time(TimeTicks::Now() + max_time);</span><br><span class="line">const bool finite_time = max_time.ToInternalValue() &gt;= 0;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;第一行代码计算线程进入睡眠状态的结束时间，保存在变量end_time中。第二行代码判断参数max_time是否大于等于0。如果大于等于0，就意味着参数max_time描述的是一个有限的时间，即线程不能无限进入睡眠状态。在这种情况下，变量finite_time的值等于true。否则的话，变量finite_time的值等于false。</p>
<p>&#160; &#160; &#160; &#160;第二段代码如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel_-&gt;lock_.Acquire();</span><br><span class="line"><span class="keyword">if</span> (kernel_-&gt;signaled_) &#123;</span><br><span class="line"><span class="keyword">if</span> (!kernel_-&gt;manual_reset_) &#123;</span><br><span class="line"><span class="comment">// In this case we were signaled when we had no waiters. Now that</span></span><br><span class="line"><span class="comment">// someone has waited upon us, we can automatically reset.</span></span><br><span class="line">kernel_-&gt;signaled_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">kernel_-&gt;lock_.Release();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这段代码判断当前处理的WaitableEvent是否已经处于Signaled状态。如果是的话，当前线程就不需要进入睡眠状态了，因为当前线程本来就是要等待当前处理的WaitableEvent处于Signaled状态的。在这种情况下，WaitableEvent类的成员函数TimedWait就直接返回一个true值给调用者，表示已经成功地等待当前处理的WaitableEvent处于Signaled状态。</p>
<p>&#160; &#160; &#160; &#160;不过在返回之前，会判断当前处理的WaitableEvent在创建时是否指定了当它处于Signaled状态时，可以自动Reset为非Signaled状态。从这里我们就可以看出，一个WaitableEvent的状态可以从Signaled自动Reset为非Signaled，指的就是一个当其在Signaled状态时被执行Wait操作时，会自动变为非Signaled状态。这样在下一次执行Wait操作时，就要等到该WaitableEvent的状态变为Signaled之后，WaitableEvent类的成员函数TimedWait才会返回。</p>
<p>&#160; &#160; &#160; &#160;从这里我们就可以看到，WaitableEvent类的成员函数TimedWait是通过成员变量kernel_指向的一个WaitableEventKernel对象来获得Signaled状态的，从而可以避免一个WaitableEvent被销毁的时候，我们仍然可以访问它的状态，而不会引发程序Crash。</p>
<p>&#160; &#160; &#160; &#160;从这里我们还可以看到，访问WaitableEvent的状态需要在加锁的情况下进行，该锁由其成员变量kernel<em>指向的一个WaitableEventKernel对象的成员变量lock</em>描述。同时，WaitableEvent类的成员函数TimedWait在返回之前，需要释放该锁。</p>
<p>&#160; &#160; &#160; &#160;第三段代码如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SyncWaiter sw;</span><br><span class="line">sw.lock()-&gt;Acquire();</span><br><span class="line">Enqueue(&amp;sw);</span><br><span class="line">kernel_-&gt;lock_.Release();</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这段代码在栈上创建一个SyncWaiter对象，并且通过调用成员函数Enqueue将其加入到当前正在处理的WaitableEvent的Waiter列表中，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WaitableEvent::Enqueue(Waiter* waiter) &#123;</span><br><span class="line">kernel_-&gt;waiters_.push_back(waiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;由于要操作当前正在处理的WaitableEvent的Waiter列表，因此WaitableEvent类的成员函数Enqueue需要在加锁的情况下进行操作。</p>
<p>&#160; &#160; &#160; &#160;SyncWaiter是一个用来描述同步Waiter的类，所谓同步Waiter，就是说在线程进入睡眠状态这段时间，它是不会被销毁的。因此，在线程进入睡眠状态这段时间里，我们可以安全地对它进行操作。</p>
<p>&#160; &#160; &#160; &#160;SyncWaiter类的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SyncWaiter : <span class="keyword">public</span> WaitableEvent::Waiter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SyncWaiter()</span><br><span class="line">: fired_(<span class="literal">false</span>),</span><br><span class="line">signaling_event_(<span class="literal">NULL</span>),</span><br><span class="line">lock_(),</span><br><span class="line">cv_(&amp;lock_) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Fire</span><span class="params">(WaitableEvent* signaling_event)</span> OVERRIDE </span>&#123;</span><br><span class="line">base::<span class="function">AutoLock <span class="title">locked</span><span class="params">(lock_)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (fired_)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">fired_ = <span class="literal">true</span>;</span><br><span class="line">signaling_event_ = signaling_event;</span><br><span class="line">cv_.Broadcast();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">WaitableEvent* <span class="title">signaling_event</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> signaling_event_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">void</span>* tag)</span> OVERRIDE </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span> == tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fired</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fired_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fired_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">base::<span class="function">Lock* <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;lock_;</span><br><span class="line">&#125;</span><br><span class="line">base::<span class="function">ConditionVariable* <span class="title">cv</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;cv_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">bool</span> fired_;</span><br><span class="line">WaitableEvent* signaling_event_; <span class="comment">// The WaitableEvent which woke us</span></span><br><span class="line">base::Lock lock_;</span><br><span class="line">base::ConditionVariable cv_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个类定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc中。 </p>
<p>&#160; &#160; &#160; &#160;SyncWaiter类的核心是定义了一个互斥锁lock<em>和一个条件变量cv</em>，它们分别可以通过成员函数lock和cv来获得。</p>
<p>&#160; &#160; &#160; &#160;SyncWaiter类有一个重要的成员函数Fire，它的作用唤醒睡眠在条件变量cv<em>的线程，并且将成员变量fired</em>设置为true，用来表示成员变量signaling<em>event</em>描述的WaitableEvent已经处于Signaled状态。</p>
<p>&#160; &#160; &#160; &#160;我们继续分析WaitableEvent类的成员函数TimedWait的最后一段代码，如下所示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> for (;;) &#123;</span><br><span class="line">const TimeTicks current_time(TimeTicks::Now());</span><br><span class="line">if (sw.fired() || (finite_time &amp;&amp; current_time &gt;= end_time)) &#123;</span><br><span class="line">const bool return_value = sw.fired();</span><br><span class="line">......</span><br><span class="line">sw.lock()-&gt;Release();</span><br><span class="line">kernel_-&gt;lock_.Acquire();</span><br><span class="line">kernel_-&gt;Dequeue(&amp;sw, &amp;sw);</span><br><span class="line">kernel_-&gt;lock_.Release();</span><br><span class="line">return return_value;</span><br><span class="line">&#125;</span><br><span class="line">if (finite_time) &#123;</span><br><span class="line">const TimeDelta max_wait(end_time - current_time);</span><br><span class="line">sw.cv()-&gt;TimedWait(max_wait);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">sw.cv()-&gt;Wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个for循环不断检查刚才已经加入到当前正在处理的WaitableEvent的Waiter列表的等待者sw是否已经被Fired。如果已经被Fired，那么就说明当前正在处理的WaitableEvent已经处理Signaled状态，因此就可以结束检查，并且返回了。不过在返回之前，会调用WaitableEventKernel类的成员函数Dequeue将等待者sw从当前正在处理的WaitableEvent的Waiter列表删除。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventKernel类的成员函数Dequeue的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> WaitableEvent::WaitableEventKernel::Dequeue(Waiter* waiter, <span class="keyword">void</span>* tag) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;Waiter*&gt;::iterator</span><br><span class="line">i = waiters_.begin(); i != waiters_.end(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (*i == waiter &amp;&amp; (*i)-&gt;Compare(tag)) &#123;</span><br><span class="line">waiters_.erase(i);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里我们可以看到，WaitableEventKernel类的成员函数Dequeue首先是在当前正在处理的WaitableEvent的Waiter列表找到参数waiter描述的Waiter，然后再将其从列表中删除。</p>
<p>&#160; &#160; &#160; &#160;在当前正在处理的WaitableEvent的Waiter列表中查找参数waiter描述的Waiter，不仅要对比列表的Waiter与参数waiter描述的Waiter的地址是否相等，还要进一步以参数tag为参数，调用前者的成员函数Compare，只有当该成员函数返回值等于true时，才会将参数waiter描述的Waiter从列表中删除。之所以要这样做，是与后面我们分析的异步Waiter有关的。这一点我们后面再详细分析。</p>
<p>&#160; &#160; &#160; &#160;回到WaitableEvent类的成员函数TimedWait的最后一段代码中。虽然等待者sw没有被Fired，但是WaitableEvent类的成员函数TimedWait的参数max_time指定了当前线程只可以等待有限的时候，并且这个有限时间已经过去。在这种情况下，即使等待者sw没有被Fired，那么WaitableEvent类的成员函数TimedWait也要返回了，不过这时候它的返回值为false。</p>
<p>&#160; &#160; &#160; &#160;最后，WaitableEvent类的成员函数TimedWait判断线程是否只是有限地进入睡眠状态，即判断变量finite<em>time的值是否等于true。如果等于true，那么就会通过调用等待者sw内部的条件变量cv</em>的成员函数TimedWait使得当前线程进入睡眠状态，并且指定最长的睡眠时间为max_wait。</p>
<p>&#160; &#160; &#160; &#160;另一方面，如果WaitableEvent类的成员函数TimedWait判断线程需要无限地进入睡眠状态，那么就会通过调用等待者sw内部的条件变量cv_的成员函数Timed使得当前线程进入无限睡眠状态，直到被其它线程唤醒为止。</p>
<h3 id="Signal实现"><a href="#Signal实现" class="headerlink" title="Signal实现"></a>Signal实现</h3><p>&#160; &#160; &#160; &#160;我们最后继续分析WaitableEvent类的成员函数Signal的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WaitableEvent::Signal() &#123;</span><br><span class="line">base::<span class="function">AutoLock <span class="title">locked</span><span class="params">(kernel_-&gt;lock_)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (kernel_-&gt;signaled_)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (kernel_-&gt;manual_reset_) &#123;</span><br><span class="line">SignalAll();</span><br><span class="line">kernel_-&gt;signaled_ = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// In the case of auto reset, if no waiters were woken, we remain</span></span><br><span class="line"><span class="comment">// signaled.</span></span><br><span class="line"><span class="keyword">if</span> (!SignalOne())</span><br><span class="line">kernel_-&gt;signaled_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;如果当前正在处理的WaitableEvent已经处于Signaled状态，那么WaitableEvent类的成员函数Signal就不需要再次将其修改为Signaled状态并且唤醒等待者了。否则的话，就继续往前执行。</p>
<p>&#160; &#160; &#160; &#160;如果当前正在处理的WaitableEvent的Signaled状态不可自动Reset为非Signaled状态，那么就调用成员函数SignalAll唤醒所有的等待者，并且保存当前正在处理的WaitableEvent的状态为Signaled状态。</p>
<p>&#160; &#160; &#160; &#160;如果当前正在处理的WaitableEvent的Signaled状态可以自动Reset为非Signaled状态，那么就调用成员函数SignalOne唤醒其中的一个等待者。但是如果一个等待者都没有被唤醒，那么就会继续保持当前正在处理的WaitableEvent的状态为Signaled状态。</p>
<p>&#160; &#160; &#160; &#160;WaitableEvent类的成员函数SignalAll的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> WaitableEvent::SignalAll() &#123;</span><br><span class="line"><span class="keyword">bool</span> signaled_at_least_one = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;Waiter*&gt;::iterator</span><br><span class="line">i = kernel_-&gt;waiters_.begin(); i != kernel_-&gt;waiters_.end(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*i)-&gt;Fire(<span class="keyword">this</span>))</span><br><span class="line">signaled_at_least_one = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">kernel_-&gt;waiters_.clear();</span><br><span class="line"><span class="keyword">return</span> signaled_at_least_one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;WaitableEvent类的成员函数SignalAll对当前正在处理的WaitableEvent的Waiter列表中的每一个Waiter，都调用其成员函数Fire，使得它们可以唤醒相应的线程。</p>
<p>&#160; &#160; &#160; &#160;最后，WaitableEvent类的成员函数SignalAll会清空当前正在处理的WaitableEvent的Waiter列表，并且在至少唤醒一个Waiter的情况下，返回一个true值给调用者，否则就返回false。</p>
<p>&#160; &#160; &#160; &#160;WaitableEvent类的成员函数SignalOne的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> WaitableEvent::SignalOne() &#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (kernel_-&gt;waiters_.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> r = (*kernel_-&gt;waiters_.begin())-&gt;Fire(<span class="keyword">this</span>);</span><br><span class="line">kernel_-&gt;waiters_.pop_front();</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;WaitableEvent类的成员函数SignalOne从当前正在处理的WaitableEvent的Waiter列表中的第一个Waiter开始，依次调用它们的成员函数Fire。只要其中的某一个Waiter的成员函数Fire的返回值为true，那么就会停止遍历Waiter列表，并且返回一个true值给调用者。如果没有一个Waiter的成员函数Fire返回值为true，那么WaitableEvent类的成员函数SignalOne的返回值就为false。注意，每一个被遍历过的Waiter，不管它的成员函数Fire的返回值是什么，它都会从Waiter列表删除。</p>
<p>&#160; &#160; &#160; &#160;以上就是WaitableEvent通过同步等待者(SyncWaiter)实现的Wait和Signal操作。</p>
<h3 id="异步等待者"><a href="#异步等待者" class="headerlink" title="异步等待者"></a>异步等待者</h3><p>&#160; &#160; &#160; &#160;WaitableEvent还可以通过异步等待者实现异步的Wait和Signal操作。为了理解这种异步Wait和Signal操作，我们先看一个例子，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoStuffWhenSignaled</span><span class="params">(WaitableEvent *waitable_event)</span> </span>&#123;</span><br><span class="line">watcher_.StartWatching(waitable_event,</span><br><span class="line">base::Bind(&amp;MyClass::OnWaitableEventSignaled, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">void</span> OnWaitableEventSignaled(WaitableEvent* waitable_event) &#123;</span><br><span class="line"><span class="comment">// OK, time to do stuff!</span></span><br><span class="line">&#125;</span><br><span class="line">base::WaitableEventWatcher watcher_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;当我们调用MyClass类的成员函数DoStuffWhenSignaled的时候，表示希望在参数waitable<em>event描述的一个WaitableEvent处于Signaled状态时，可以调用MyClass类的另外一个成员函数OnWaitableEventSignaled干点其它事情，这是通过成员变量watcher</em>描述的一个WaitableEventWatcher对象的成员函数StartWatching实现的。</p>
<p>&#160; &#160; &#160; &#160;也就是说，通过WaitableEventWatcher类，我们可以监控一个WaitableEvent，使得它处于Signaled状态时，获得通知。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventWatcher的定义如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT WaitableEventWatcher</span><br><span class="line">: <span class="keyword">public</span> MessageLoop::DestructionObserver &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> Callback&lt;<span class="keyword">void</span>(WaitableEvent*)&gt; EventCallback;</span><br><span class="line">WaitableEventWatcher();</span><br><span class="line"><span class="keyword">virtual</span> ~WaitableEventWatcher();</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StartWatching</span><span class="params">(WaitableEvent* event, <span class="keyword">const</span> EventCallback&amp; callback)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopWatching</span><span class="params">()</span></span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">......</span><br><span class="line">MessageLoop* message_loop_;</span><br><span class="line">scoped_refptr&lt;Flag&gt; cancel_flag_;</span><br><span class="line">AsyncWaiter* waiter_;</span><br><span class="line">base::Closure internal_callback_;</span><br><span class="line">scoped_refptr&lt;WaitableEvent::WaitableEventKernel&gt; kernel_;</span><br><span class="line">WaitableEvent* event_;</span><br><span class="line">EventCallback callback_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类定义在文件external/chromium_org/base/synchronization/waitable_event_watcher.h。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventWatcher类有两个重要的成员函数StartWatching和StopWatching。前者用来监控一个WaitableEvent，并且当该WaitableEvent状态变成Signaled时，调用一个EventCallback，它的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> WaitableEventWatcher::StartWatching(</span><br><span class="line">WaitableEvent* event,</span><br><span class="line"><span class="keyword">const</span> EventCallback&amp; callback) &#123;</span><br><span class="line"><span class="comment">//获取当前线程的消息循环,保存在一个线程局部变量中</span></span><br><span class="line">MessageLoop *<span class="keyword">const</span> current_ml = MessageLoop::current();</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了能够正确处理上述的异常情况，</span></span><br><span class="line"><span class="comment">//就必须要给一个WaitableEventWatcher关联一个生命周期更长的Flag对象，</span></span><br><span class="line"><span class="comment">//该Flag对象在要监控的WaitableEvent状态变为Signaled之前，不会被销毁</span></span><br><span class="line">cancel_flag_ = <span class="keyword">new</span> Flag;</span><br><span class="line"><span class="comment">//callback描述的一个EventCallback</span></span><br><span class="line">callback_ = callback;</span><br><span class="line">internal_callback_ =</span><br><span class="line">base::Bind(&amp;AsyncCallbackHelper, cancel_flag_, callback_, event);</span><br><span class="line">WaitableEvent::WaitableEventKernel* kernel = event-&gt;kernel_.get();</span><br><span class="line"><span class="function">AutoLock <span class="title">locked</span><span class="params">(kernel-&gt;lock_)</span></span>;</span><br><span class="line">event_ = event;</span><br><span class="line"><span class="comment">//当参数event描述的WaitableEvent状态变为Signaled时，</span></span><br><span class="line"><span class="comment">//将参数callback描述的一个EventCallback发送到该消息循环去，然后在当前线程中执行</span></span><br><span class="line"><span class="keyword">if</span> (kernel-&gt;signaled_) &#123;</span><br><span class="line"><span class="keyword">if</span> (!kernel-&gt;manual_reset_)</span><br><span class="line">kernel-&gt;signaled_ = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// No hairpinning - we can't call the delegate directly here. We have to</span></span><br><span class="line"><span class="comment">// enqueue a task on the MessageLoop as normal.</span></span><br><span class="line">current_ml-&gt;PostTask(FROM_HERE, internal_callback_);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">message_loop_ = current_ml;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果要监控的WaitableEvent的状态还没有变为Signaled，那么就需要进行等待了。</span></span><br><span class="line"><span class="comment">//这是通过创建一个类型为AsyncWaiter的异步等待者，</span></span><br><span class="line"><span class="comment">//并且将它加入到要监控的WaitableEvent的Waiter列表中去实现的。</span></span><br><span class="line">kernel_ = kernel;</span><br><span class="line">waiter_ = <span class="keyword">new</span> AsyncWaiter(current_ml, internal_callback_, cancel_flag_.get());</span><br><span class="line">event-&gt;Enqueue(waiter_);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_watcher_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventWatcher类的成员函数StartWatching首先是获得当前线程的消息循环，最终会保存在成员变量message<em>loop</em>，这样当参数event描述的WaitableEvent状态变为Signaled时，将参数callback描述的一个EventCallback发送到该消息循环去，然后在当前线程中执行。</p>
<p>&#160; &#160; &#160; &#160;接下来，WaitableEventWatcher类的成员函数StartWatching创建了一个Flag对象，并且保存在成员变量cancel<em>flag</em>中。这个Flag对象的作用是用来处理在异步等待WaitableEvent状态变为Signaled的过程中出现的异常情况的。由于是异步等待，因此就有可能要监控的WaitableEvent的状态还没有变为Signaled，进行监控的WaitableEventWatcher就已经被销毁。</p>
<p>&#160; &#160; &#160; &#160;例如，在前面举的例子中，我们创建一个MyClass对象，然后调用它的成员函数DoStuffWhenSignaled对一个WaitableEvent进行监控。但是有可能该WaitableEvent的状态还没有变为Signaled，前面创建的MyClass对象就被销毁。这意味着它内部通过成员变量watcher_描述的WaitableEventWatcher对象也会被销毁。在这种情况下，如果要监控的WaitableEvent状态变为Signaled，我们必须要保证已经被销毁的MyClass对象的成员函数OnWaitableEventSignaled不会被调用，否则的话就会出错了。</p>
<p>&#160; &#160; &#160; &#160;为了能够正确处理上述的异常情况，就必须要给一个WaitableEventWatcher关联一个生命周期更长的Flag对象，该Flag对象在要监控的WaitableEvent状态变为Signaled之前，不会被销毁。</p>
<p>&#160; &#160; &#160; &#160;Flag类的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Flag : <span class="keyword">public</span> RefCountedThreadSafe&lt;Flag&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Flag() &#123; flag_ = <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">AutoLock <span class="title">locked</span><span class="params">(lock_)</span></span>;</span><br><span class="line">flag_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="function">AutoLock <span class="title">locked</span><span class="params">(lock_)</span></span>;</span><br><span class="line"><span class="keyword">return</span> flag_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> RefCountedThreadSafe&lt;Flag&gt;;</span><br><span class="line">~Flag() &#123;&#125;</span><br><span class="line"><span class="keyword">mutable</span> Lock lock_;</span><br><span class="line"><span class="keyword">bool</span> flag_;</span><br><span class="line">DISALLOW_COPY_AND_ASSIGN(Flag);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个类定义在文件external/chromium_org/base/synchronization/waitable_event_watcher_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;当一个WaitableEventWatcher被销毁时，与它关联的Flag对象的成员变量flag_的值就会被设置true，这意味着当监控的WatiableEvent状态变为Signaled时，不需要执行之前指定的一个EventCallback。</p>
<p>&#160; &#160; &#160; &#160;回到WaitableEventWatcher类的成员函数StartWatching中，接下来它创建一个Closure对象，并且保存在成员变量internal<em>callback</em>中，该Closure对象绑定的函数为AsyncCallbackHelper，并且当它被调用时，传递给它的参数前面创建的Flag对象，以及参数callback和event描述的EventCallback对象和WaitableEvent对象。这样我们就可以推断出，当参数event描述的WaitableEvent对象状态变为Signaled时，会通过函数AsyncCallbackHelper来间接地执行参数event描述的EventCallback对象。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventWatcher类的成员函数StartWatching接下来获得要监控的WaitableEvent内部的一个WaitableEventKernel对象，然后通过该WaitableEventKernel对象判断要监控的WaitableEvent的状态是否已经是Signaled。如果是的话，那么就需要等待了，直接将前面创建的Closure发送到当前线程的消息循环去等待执行即可。</p>
<p>&#160; &#160; &#160; &#160;最后，如果要监控的WaitableEvent的状态还没有变为Signaled，那么就需要进行等待了。这是通过创建一个类型为AsyncWaiter的异步等待者，并且将它加入到要监控的WaitableEvent的Waiter列表中去实现的。这里我们就可以看到前面分析的同步等待和异步等待的区别。同步等待将一个SyncWaiter加入到一个WaitableEvent的Waiter列表去后，不能够马上返回，而是要通过一个for循环不断等待指定的WaitableEvent状态变为Signaled为止，或者直到等待的时候超出指定的时间为止。</p>
<p>&#160; &#160; &#160; &#160;AsyncWaiter类的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AsyncWaiter : <span class="keyword">public</span> WaitableEvent::Waiter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">AsyncWaiter(MessageLoop* message_loop,</span><br><span class="line"><span class="keyword">const</span> base::Closure&amp; callback,</span><br><span class="line">Flag* flag)</span><br><span class="line">: message_loop_(message_loop),</span><br><span class="line">callback_(callback),</span><br><span class="line">flag_(flag) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Fire</span><span class="params">(WaitableEvent* event)</span> OVERRIDE </span>&#123;</span><br><span class="line"><span class="comment">// Post the callback if we haven't been cancelled.</span></span><br><span class="line"><span class="keyword">if</span> (!flag_-&gt;value()) &#123;</span><br><span class="line">message_loop_-&gt;PostTask(FROM_HERE, callback_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We are removed from the wait-list by the WaitableEvent itself. It only</span></span><br><span class="line"><span class="comment">// remains to delete ourselves.</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// We can always return true because an AsyncWaiter is never in two</span></span><br><span class="line"><span class="comment">// different wait-lists at the same time.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// See StopWatching for discussion</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">void</span>* tag)</span> OVERRIDE </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tag == flag_.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MessageLoop *<span class="keyword">const</span> message_loop_;</span><br><span class="line">base::Closure callback_;</span><br><span class="line">scoped_refptr&lt;Flag&gt; flag_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个类定义在文件external/chromium_org/base/synchronization/waitable_event_watcher_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;从前面的分析可以知道，当要监控的WaitableEvent的状态变为Signaled时，前面已经已经加入到它的Waiter列表的AsyncWaiter对象的成员函数Fire就会被调用。</p>
<p>&#160; &#160; &#160; &#160;AsyncWaiter类的成员变量flag<em>指向的是一个Flag对象。前面提到，如果该Flag对象关联的WaitableEventWatcher在要监控的WaitableEvent状态还没有变为Signaled就已经被销毁，那么该Flag对象的成员变量flag</em>的值就会被设置为true。在这种情况下，AsyncWaiter类的成员函数Fire就不需要执行成员变量callback_描述的一个Closure。</p>
<p>&#160; &#160; &#160; &#160;另一方面，如果AsyncWaiter类的成员变量flag<em>指向的Flag对象的成员变量flag</em>的值保持为false，那么就需要将成员变量callback_描述的一个Closure发送到成员变量message<em>loop</em>描述的一个消息循环去执行。</p>
<p>&#160; &#160; &#160; &#160;从前面的分析可以知道，AsyncWaiter类的成员变量message<em>loop</em>描述的消息循环即为调用WaitableEventWatcher类的成员函数StartWatching的那个线程的消息循环，并且AsyncWaiter类的成员变量callback_描述的Closure绑定的函数为AsyncCallbackHelper，它的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AsyncCallbackHelper</span><span class="params">(Flag* flag,</span><br><span class="line"><span class="keyword">const</span> WaitableEventWatcher::EventCallback&amp; callback,</span><br><span class="line">WaitableEvent* event)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Runs in MessageLoop thread.</span></span><br><span class="line"><span class="keyword">if</span> (!flag-&gt;value()) &#123;</span><br><span class="line"><span class="comment">// This is to let the WaitableEventWatcher know that the event has occured</span></span><br><span class="line"><span class="comment">// because it needs to be able to return NULL from GetWatchedObject</span></span><br><span class="line">flag-&gt;Set();</span><br><span class="line">callback.Run(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_watcher_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;参数flag描述的Flag对象就是前面在WaitableEventWatcher类的成员函数StartWatching中创建的Flag对象，参数evnet描述的就是要监控的WaitableEvent，而参数callback就是当参数evnet描述的WaitableEvent状态变为Signaled时要执行的一个EventCallback。</p>
<p>&#160; &#160; &#160; &#160;只有在参数flag描述的Flag对象的成员变量flag<em>的值等于false的情况下，函数AsyncCallbackHelper才会执行参数callback描述的EventCallback，并且在执行该EventCallback之前，会将参数flag描述的Flag对象的成员变量flag</em>的值设置为true，用来表示参数callback描述的EventCallback已经执行过了。</p>
<p>&#160; &#160; &#160; &#160;以上就是通过一个WaitableEventWatcher来监控一个WaitableEvent的状态变为Signaled并且获得通知的过程。前面我们还提及到一种情况，就是要监控的WaitableEvent的状态尚未变为Signaled，执行监控的WaitableEventWatcher就已经被销毁。接下来我们就继续分析这种情况是如何处理的。</p>
<p>&#160; &#160; &#160; &#160;当一个WaitableEventWatcher被销毁时，它的析构函数就会被调用，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WaitableEventWatcher::~WaitableEventWatcher() &#123;</span><br><span class="line">StopWatching();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_watcher_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventWatcher类的析构函数调用另外一个成员函数StopWatching停止监控之前在成员函数StartWatching指定的WaitableEvent。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventWatcher类的成员函数StopWatching的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WaitableEventWatcher::StopWatching() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="function">AutoLock <span class="title">locked</span><span class="params">(kernel_-&gt;lock_)</span></span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (kernel_-&gt;Dequeue(waiter_, cancel_flag_.get())) &#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">delete</span> waiter_;</span><br><span class="line">internal_callback_.Reset();</span><br><span class="line">cancel_flag_ = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">cancel_flag_-&gt;Set();</span><br><span class="line">cancel_flag_ = <span class="literal">NULL</span>;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_watcher_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;WaitableEventWatcher类的成员函数StopWatching要处理的边界情况很多，这里我们只关心其中两个最主要的情况。</p>
<p>&#160; &#160; &#160; &#160;第一种情况是一个WaitableEventWatcher被销毁时，它要监控的WaitableEvent的状态依然是没有变为Signaled。这时候该WaitableEventWatcher的成员变量waiter_指向的一个AsyncWaiter对象是在要监控的WaitableEvent的Waiter列表中。因此这时候调用与该WaitableEvent关联的一个WaitableEventKernel对象的成员函数Dequeue可以将它从Waiter列表中删除，即调用上述WaitableEventKernel对象的成员函数Dequeue的返回值为true。这样就可以保证以后要监控的WaitableEvent的状态变为Signaled时，当前被销毁的WaitableEventWatcher不会获得任务通知。</p>
<p>&#160; &#160; &#160; &#160;第二种情况是一个WaitableEventWatcher被销毁时，它要监控的WaitableEvent的状态已经变为Signaled。从前面的分析可以知道，这时候该WaitableEventWatcher的成员变量waiter<em>指向的一个AsyncWaiter对象已经不在要监控的WaitableEvent的Waiter列表了，并且它的成员函数Fire已经被调用。但是该AsyncWaiter对象的成员变量callback</em>描述的一个Closure可能还没有被调度执行，这时候就需要将与它关联的一个Flag对象的成员变量flag_的值设置为true，保证该Closure不会被执行。这个Flag对象就是WaitableEventWatcher类的成员变量cancel<em>flag指向的Flag对象，调用它的成员函数Set即可将它的成员变量flag</em>的值设置为true。</p>
<p>&#160; &#160; &#160; &#160;这里有一点需要注意的是，WaitableEventWatcher类的成员函数StopWatching在调用WaitableEventKernel类的成员函数Dequeue从Waiter列表中删除成员变量waiter_描述的一个AsyncWaiter时，传递的参数除了要删除的AsyncWaiter的地址外，还包括与它关联的一个Flag对象的地址。为什么不可以只传递要删除的AsyncWaiter的地址给WaitableEventKernel类的成员函数Dequeue呢?这是为了处理一种称为<code>ABA</code>的问题的。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;当一个AsyncWaiter被Fired时，它的成员函数Fire会被调用，并且这个成员函数在执行自我销毁的操作。如果这时候恰好其它地方又创建了一个AsyncWaiter，并且这个新创建的AsyncWaiter被添加到了同样的WaitableEvent的Waiter列表中，更神奇的是这个新创建的AsyncWaiter占用的内存与前面被销毁的AsyncWaiter占用的内存是完全一样的。这样就会导致前面调用WaitableEventKernel类的成员函数Dequeue删除了一个不该删除的AsyncWaiter!</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;注意，这种情况只会出现在异步等待WaitableEvent状态变为Signaled的情况，对于同步等待WaitableEvent状态变为Signaled的情况是没有这样的问题的。分析为了避免这种情况，WaitableEventKernel类的成员函数Dequeue要求删除一个Waiter时，提供另外一个额外的参数tag，该参数会传递给即将被删除的Waiter的成员函数Compare。只有被删除的Waiter存在Waiter列表中，并且它的成员函数Compare的返回值也为true的情况下，WaitableEventKernel类的成员函数Dequeue才会将它从Waiter列表中删除，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> WaitableEvent::WaitableEventKernel::Dequeue(Waiter* waiter, <span class="keyword">void</span>* tag) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;Waiter*&gt;::iterator</span><br><span class="line">i = waiters_.begin(); i != waiters_.end(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (*i == waiter &amp;&amp; (*i)-&gt;Compare(tag)) &#123;</span><br><span class="line">waiters_.erase(i);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_posix.cc。</p>
<p>&#160; &#160; &#160; &#160;AsyncWaiter类的成员函数Compare的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AsyncWaiter : <span class="keyword">public</span> WaitableEvent::Waiter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line"><span class="comment">// See StopWatching for discussion</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">void</span>* tag)</span> OVERRIDE </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tag == flag_.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">......</span><br><span class="line">scoped_refptr&lt;Flag&gt; flag_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/synchronization/waitable_event_watcher_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里我们可以看到，只有当参数tag的值等于AsyncWaiter类的成员变量flag_引用的一个Flag对象的地址值时，AsyncWaiter类的成员函数Compare的返回值才为true。</p>
<p>&#160; &#160; &#160; &#160;由于AsyncWaiter类的成员变量flag_是一个scoped_refptr智能指针，它引用的Flag对象同时也被关联的WatiableEventWatcher对象通过scoped<em>refptr智能指针引用，这意味着当一个AsyncWaiter被销毁时，它的成员变量flag</em>引用的Flag对象是仍然存在的，这样通过比较它的地址值与参数tag的值，就可以区别出两个前后分配在同一块内存的AsyncWaiter对象来。</p>
<p>&#160; &#160; &#160; &#160;至此，我们就分析完成了WaitableEvent类是如何实现线程在无消息处理时进入睡眠状态，并且在有消息处理时从睡眠状态唤醒过来的。总结来说，就是通过条件变量来实现的。同时，我们还知道，WaitableEvent类不仅可以实现同步等待，还可以实现异步等待，前者通过配合SyncWaiter类实现，而后者通过配合AsyncWaiter类实现。异步等待，或者说异步操作，是Chromium的一大特色。正是由于使用了大量的异步操作，Chromium才能做到快速地响应用户输入，从而使得用户感觉到Chromium在打开网页的时候非常快。</p>
<h2 id="发送消息过程"><a href="#发送消息过程" class="headerlink" title="发送消息过程"></a>发送消息过程</h2><p>&#160; &#160; &#160; &#160;回到MessagePumpDefault类的成员函数Run中，我们前面提到，每次它通过成员变量event_描述的一个WaitableEvent从睡眠状态唤醒过来之后，会依次调用参数delegate描述的一个MessageLoop对象的成员函数DoWork和DoDelayedWork处理消息队列的消息以及成员函数DoIdleWork处理一些线程空闲时任务。</p>
<p>&#160; &#160; &#160; &#160;在分析MessageLoop类的成员函数DoWork、DoDelayedWork和DoIdleWork之前，我们首先分析向一个线程的消息队列发送消息的过程。这是通过我们在前面提到的MessageLoop类的成员函数PostTask、PostDelayedTask、 PostNonNestableTask和PostNonNestableDelayedTask实现的。它们的定义如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::PostTask(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task) &#123;</span><br><span class="line">......</span><br><span class="line">incoming_task_queue_-&gt;AddToIncomingQueue(from_here, task, TimeDelta(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MessageLoop::PostDelayedTask(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task,</span><br><span class="line">TimeDelta delay) &#123;</span><br><span class="line">......</span><br><span class="line">incoming_task_queue_-&gt;AddToIncomingQueue(from_here, task, delay, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MessageLoop::PostNonNestableTask(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task) &#123;</span><br><span class="line">......</span><br><span class="line">incoming_task_queue_-&gt;AddToIncomingQueue(from_here, task, TimeDelta(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MessageLoop::PostNonNestableDelayedTask(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task,</span><br><span class="line">TimeDelta delay) &#123;</span><br><span class="line">......</span><br><span class="line">incoming_task_queue_-&gt;AddToIncomingQueue(from_here, task, delay, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这四个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的上述四个成员函数都是通过调用成员变量incoming_task<em>queue</em>描述的一个IncomingTaskQueue对象的成员函数AddToIncomingQueue来发送参数task描述的一个Closure对象到线程的消息队列去的。</p>
<p>&#160; &#160; &#160; &#160;IncomingTaskQueue类的成员函数AddToIncomingQueue的实现如下所示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool IncomingTaskQueue::AddToIncomingQueue(</span><br><span class="line">const tracked_objects::Location&amp; from_here,</span><br><span class="line">const Closure&amp; task,</span><br><span class="line">TimeDelta delay,</span><br><span class="line">bool nestable) &#123;</span><br><span class="line">AutoLock locked(incoming_queue_lock_);</span><br><span class="line">PendingTask pending_task(</span><br><span class="line">from_here, task, CalculateDelayedRuntime(delay), nestable);</span><br><span class="line">return PostPendingTask(&amp;pending_task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/incoming_task_queue.cc中。</p>
<p>&#160; &#160; &#160; &#160;IncomingTaskQueue类的成员函数AddToIncomingQueue首先将参数task描述的Closure封装在一个PendingTask中，然后调用另外一个成员函数PostPendingTask将它发送到线程的消息队列中去。由于消息队列既会被发送消息的线程操作，也会被处理消息的线程操作，因此它需要在加锁的前提下进行操作。这个锁通过IncomingTaskQueue类的成员变量incoming_queue<em>lock</em>描述。</p>
<p>&#160; &#160; &#160; &#160;IncomingTaskQueue类的成员函数PostPendingTask的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> IncomingTaskQueue::PostPendingTask(PendingTask* pending_task) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// This should only be called while the lock is taken.</span></span><br><span class="line">incoming_queue_lock_.AssertAcquired();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">bool</span> was_empty = incoming_queue_.empty();</span><br><span class="line">incoming_queue_.push(*pending_task);</span><br><span class="line">pending_task-&gt;task.Reset();</span><br><span class="line"><span class="comment">// Wake up the pump.</span></span><br><span class="line">message_loop_-&gt;ScheduleWork(was_empty);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/incoming_task_queue.cc中。</p>
<p>&#160; &#160; &#160; &#160;IncomingTaskQueue类的成员函数PostPendingTask首先是调用成员变量incoming_queue<em>lock</em>描述的一个锁的成员函数AssertAcquired确保该锁已经被调用者获取，因为它接下来要操作线程的消息队列。</p>
<p>&#160; &#160; &#160; &#160;IncomingTaskQueue类的成员函数PostPendingTask接下来要做的事情很简单，一是将参数pending_task描述的一个PendingTask保存在成员变量incoming<em>queue</em>描述的一个TaskQueue中，二是调用成员变量message<em>loop</em>描述的一个MessageLoop的成员函数ScheduleWork唤醒线程对刚才添加在TaskQueue的PendingTask进行处理。</p>
<p>&#160; &#160; &#160; &#160;注意，在调用MessageLoop类的成员函数ScheduleWork的时候，传递有一个参数was_empty，该参数用来描述在添加参数pending_task描述的一个PendingTask到线程的消息队列之前，线程的消息队列是否为空。如果为空，意味着线程当前处于无限睡眠状态中，因此需要主动唤醒它。如果不为空，则说明线程当前要么正在运行，要么是处于一个会自动唤醒过来的睡眠状态中。后面这种情况不需要唤醒线程的。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数ScheduleWork的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AlwaysNotifyPump</span><span class="params">(MessageLoop::Type type)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line"><span class="keyword">return</span> type == MessageLoop::TYPE_UI || type == MessageLoop::TYPE_JAVA;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">void</span> MessageLoop::ScheduleWork(<span class="keyword">bool</span> was_empty) &#123;</span><br><span class="line"><span class="comment">// The Android UI message loop needs to get notified each time</span></span><br><span class="line"><span class="comment">// a task is added to the incoming queue.</span></span><br><span class="line"><span class="keyword">if</span> (was_empty || AlwaysNotifyPump(type_))</span><br><span class="line">pump_-&gt;ScheduleWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这两个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;如前所述，当参数was<em>empty的值等于true的时候，MessageLoop类的成员函数ScheduleWork就会调用成员变量pump</em>描述的一个MessagePump对象的成员函数ScheduleWork来唤醒线程。</p>
<p>&#160; &#160; &#160; &#160;但是对于Android平台来说，如果当前正在处理的MessageLoop关联的是一个UI线程或者Java线程，不管参数was_empty的值是否为true，都需要唤醒它们。这是因为对于Android平台来说，UI线程和Java线程在Java层有着自己的消息循环，Native层的消息循环是借助于Java层的消息循环来实现的。这意味着线程的消息循环不是由Native来管理的，也就是Native层不知道Java的消息循环的管理逻辑，它就只有每当有新的消息加入，都通知一下Java层对该消息进行处理。后面我们再详细分析Android平台的UI线程和Java线程在Native层的消息循环的实现。</p>
<p>&#160; &#160; &#160; &#160;前面我们假设MessageLoop类的成员变量pump_指向的是一个MessagePumpDefault对象，因此接下来MessageLoop类的成员函数ScheduleWork调用的是MessagePumpDefault类的成员函数ScheduleWork，它的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpDefault::ScheduleWork() &#123;</span><br><span class="line"><span class="comment">// Since this can be called on any thread, we need to ensure that our Run</span></span><br><span class="line"><span class="comment">// loop wakes up.</span></span><br><span class="line">event_.Signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_default.cc中。</p>
<p>&#160; &#160; &#160; &#160;前面分析MessagePumpDefault类的成员函数Run的时候提到，如果一个线程当前是处于睡眠状态的，那么它就是通过调用成员变量event_描述的一个WaitableEvent的成员函数Wait或者TimedWait进入到睡眠状态的，因此现在就可以通过调用该WaitableEvent的成员函数Signal来唤醒它。这个唤醒过程可以参考前面分析的WaitableEvent类的成员函数Signal的实现。</p>
<h2 id="消息执行过程"><a href="#消息执行过程" class="headerlink" title="消息执行过程"></a>消息执行过程</h2><p>&#160; &#160; &#160; &#160;线程被唤醒之后，如前所述，就会依次调用MessageLoop类的成员函数DoWork、DoDelayedWork和DoIdleWork。</p>
<h3 id="DoWork"><a href="#DoWork" class="headerlink" title="DoWork"></a>DoWork</h3><p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数DoWork的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoop::DoWork() &#123;</span><br><span class="line"><span class="comment">//在默认情况下，消息是禁止嵌套处理的</span></span><br><span class="line"><span class="keyword">if</span> (!nestable_tasks_allowed_) &#123;</span><br><span class="line"><span class="comment">// Task can't be executed right now.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">//提取出来消息</span></span><br><span class="line">ReloadWorkQueue();</span><br><span class="line"><span class="keyword">if</span> (work_queue_.empty())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// Execute oldest task.</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">PendingTask pending_task = work_queue_.front();</span><br><span class="line">work_queue_.pop();</span><br><span class="line"><span class="keyword">if</span> (!pending_task.delayed_run_time.is_null()) &#123;</span><br><span class="line">AddToDelayedWorkQueue(pending_task);</span><br><span class="line"><span class="comment">// If we changed the topmost task, then it is time to reschedule.</span></span><br><span class="line"><span class="keyword">if</span> (delayed_work_queue_.top().task.Equals(pending_task.task))</span><br><span class="line">pump_-&gt;ScheduleDelayedWork(pending_task.delayed_run_time);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (DeferOrRunPendingTask(pending_task))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (!work_queue_.empty());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Nothing happened.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;在默认情况下，消息是禁止嵌套处理的，也就是说，线程在处理一个消息的过程时，不能够处理其它消息，这时候MessageLoop类的成员变量nestable_tasks<em>allowed</em>的值会被设置为false。因此，MessageLoop类的成员函数DoWork首先是判断成员变量nestable_tasks<em>allowed</em>的值是否等于false。如果等于的话，就什么也不做就返回了。</p>
<p>&#160; &#160; &#160; &#160;如果我们确实嵌套处理消息，那么需要通过ScopedNestableTaskAllower类临时设置线程的MessageLoop允许执行嵌套消息，即将MessageLoop类的成员变量nestable_tasks<em>allowed</em>设置为true。</p>
<p>&#160; &#160; &#160; &#160;ScopedNestableTaskAllower类的实现如下所示:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class BASE_EXPORT MessageLoop : public MessagePump::Delegate &#123;</span><br><span class="line">public:</span><br><span class="line">......</span><br><span class="line">// Enables nestable tasks on |loop| while in scope.</span><br><span class="line">class ScopedNestableTaskAllower &#123;</span><br><span class="line">public:</span><br><span class="line">explicit ScopedNestableTaskAllower(MessageLoop* loop)</span><br><span class="line">: loop_(loop),</span><br><span class="line">old_state_(loop_-&gt;NestableTasksAllowed()) &#123;</span><br><span class="line">//将线程的消息循环设置为可嵌套执行消息</span><br><span class="line">loop_-&gt;SetNestableTasksAllowed(true);</span><br><span class="line">&#125;</span><br><span class="line">~ScopedNestableTaskAllower() &#123;</span><br><span class="line">loop_-&gt;SetNestableTasksAllowed(old_state_);</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">MessageLoop* loop_;</span><br><span class="line">bool old_state_;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个类定义在文件external/chromium_org/base/message_loop/message_loop.h中。</p>
<p>&#160; &#160; &#160; &#160;ScopedNestableTaskAllower类的构造函数调用了MessageLoop类的成员函数SetNestableTasksAllowed将线程的消息循环设置为可嵌套执行消息，并且在析构函数中也是调用MessageLoop类的成员函数SetNestableTasksAllowed将线程的消息循环设置为不可嵌套执行消息。</p>
<p>&#160; &#160; &#160; &#160;回到MessageLoop类的成员函数DoWork中，它接下来是通过两个循环不断地处理线程的消息队列的消息，直到该消息队列为空为止。</p>
<p>&#160; &#160; &#160; &#160;在外层的循环中，MessageLoop类的成员函数DoWork首先是调用另外一个成员函数ReloadWorkQueue将保存在成员变量incoming_task<em>queue</em>描述的一个IncomingTaskQueue中的消息提取出来，保存在成员变量work<em>queue</em>描述的一个TaskQueue中，然后再通过内层的循环对保存在该TaskQueue的每一个消息进行处理。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数ReloadWorkQueue的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::ReloadWorkQueue() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (work_queue_.empty())</span><br><span class="line">incoming_task_queue_-&gt;ReloadWorkQueue(&amp;work_queue_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;在成员变员work<em>queue</em>描述的TaskQueue为空的情况下， MessageLoop类的成员函数ReloadWorkQueue调用成员变量incoming_task<em>queue</em>描述的一个IncomingTaskQueue对象的成员函数ReloadWorkQueue将它里面消息都提取到成员变员work<em>queue</em>描述的一个TaskQueue中。</p>
<p>&#160; &#160; &#160; &#160;IncomingTaskQueue类的成员函数ReloadWorkQueue的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IncomingTaskQueue::ReloadWorkQueue(TaskQueue* work_queue) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Acquire all we can from the inter-thread queue with one lock acquisition.</span></span><br><span class="line"><span class="function">AutoLock <span class="title">lock</span><span class="params">(incoming_queue_lock_)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!incoming_queue_.empty())</span><br><span class="line">incoming_queue_.Swap(work_queue); <span class="comment">// Constant time</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/incoming_task_queue.cc中。</p>
<p>&#160; &#160; &#160; &#160;在成员变量incoming<em>queue</em>描述的TaskQueue不为空的情况下， IncomingTaskQueue类的成员函数ReloadWorkQueue通过交换它和参数work_queue描述的TaskQueue即可将它里面的消息都提取给参数work_queue描述的TaskQueue。</p>
<p>&#160; &#160; &#160; &#160;回到MessageLoop类的成员函数DoWork中，它接下来就通过内层循环对已经提取到成员变量work<em>queue</em>描述的TaskQueue的消息进行处理，为了方便描述，我们将相应的代码再列出来，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Execute oldest task.</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//提取出来一个消息</span></span><br><span class="line">PendingTask pending_task = work_queue_.front();</span><br><span class="line">work_queue_.pop();</span><br><span class="line"><span class="comment">//如果提取出来的是一个延时消息</span></span><br><span class="line"><span class="keyword">if</span> (!pending_task.delayed_run_time.is_null()) &#123;</span><br><span class="line">AddToDelayedWorkQueue(pending_task);<span class="comment">//将它添加进一个延时消息处理队列</span></span><br><span class="line"><span class="comment">// If we changed the topmost task, then it is time to reschedule.</span></span><br><span class="line"><span class="comment">//如果该延迟消息被添加到了延迟处理消息队列的头部，</span></span><br><span class="line"><span class="comment">//那么就意味着要修改线程的下一次进入睡眠状态的时间长度，</span></span><br><span class="line"><span class="comment">//这是因为保存在处迟处理消息队列的消息是按照延迟处理时间从小到大的顺序排序的。</span></span><br><span class="line"><span class="keyword">if</span> (delayed_work_queue_.top().task.Equals(pending_task.task))</span><br><span class="line">pump_-&gt;ScheduleDelayedWork(pending_task.delayed_run_time);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//马上处理消息</span></span><br><span class="line"><span class="keyword">if</span> (DeferOrRunPendingTask(pending_task))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (!work_queue_.empty());</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这段代码依次地将保存在成员变量work<em>queue</em>描述的TaskQueue中的消息提取出来。每一个消息都是通过一个PendingTask描述的。</p>
<p>&#160; &#160; &#160; &#160;如果提取出来的消息是一个延迟处理的消息，即对应的PendingTask对象的成员变量delayed_run_time设置的时间不为空，那么就会调用MessageLoop类的成员函数AddToDelayedWorkQueue将它添加到另外一个延迟处理的消息队列中。如果该延迟消息被添加到了延迟处理消息队列的头部，那么就意味着要修改线程的下一次进入睡眠状态的时间长度，这是因为保存在处迟处理消息队列的消息是按照延迟处理时间从小到大的顺序排序的。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数AddToDelayedWorkQueue的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::AddToDelayedWorkQueue(<span class="keyword">const</span> PendingTask&amp; pending_task) &#123;</span><br><span class="line"><span class="comment">// Move to the delayed work queue.</span></span><br><span class="line">delayed_work_queue_.push(pending_task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类使用的延迟处理消息队列由成员变量delayed_work<em>queue</em>描述的一个DelayedTaskQueue对象表示，当调用它的成员函数push新添加一个PendingTask时，就会根据该PendingTask延迟执行时间点将放在队列的合适位置，使得队列始终是按照延迟执行时间点从小到大的顺序排列它里面的PendingTask。</p>
<p>&#160; &#160; &#160; &#160;修改线程的下一次进入睡眠状态的时间长度是通过调用MessageLoop类的成员变量pump_指向的一个MessagePumpDefault对象的成员函数ScheduleDelayedWork实现的，它的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpDefault::ScheduleDelayedWork(</span><br><span class="line"><span class="keyword">const</span> TimeTicks&amp; delayed_work_time) &#123;</span><br><span class="line"><span class="comment">// We know that we can't be blocked on Wait right now since this method can</span></span><br><span class="line"><span class="comment">// only be called on the same thread as Run, so we only need to update our</span></span><br><span class="line"><span class="comment">// record of how long to sleep when we do sleep.</span></span><br><span class="line">delayed_work_time_ = delayed_work_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_default.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpDefault类的成员函数ScheduleDelayedWork只是简单地将参数delayed_work_time描述的时间保存在成员变量delayed_work<em>time</em>中。等到MessageLoop类的成员函数DoWork执行完毕回到MessagePumpDefault类的成员函数Run时，该时间就会用来计算线程下一次要进入睡眠状态的时间长度。</p>
<p>&#160; &#160; &#160; &#160;最后，如果一个消息需要马上处理，那么MessageLoop类的成员函数DoWork的内层循环就会调用另外一个成员函数DeferOrRunPendingTask来对它进行处理。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数DeferOrRunPendingTask的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoop::DeferOrRunPendingTask(<span class="keyword">const</span> PendingTask&amp; pending_task) &#123;</span><br><span class="line"><span class="keyword">if</span> (pending_task.nestable || run_loop_-&gt;run_depth_ == <span class="number">1</span>) &#123;</span><br><span class="line">RunTask(pending_task);</span><br><span class="line"><span class="comment">// Show that we ran a task (Note: a new one might arrive as a</span></span><br><span class="line"><span class="comment">// consequence!).</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We couldn't run the task now because we're in a nested message loop</span></span><br><span class="line"><span class="comment">// and the task isn't nestable.</span></span><br><span class="line">deferred_non_nestable_work_queue_.push(pending_task);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;参数pending_task描述的消息能够马上执行需要满足以下两个条件之一:</p>
<ol>
<li>参数pending_task描述的消息是一个可嵌套处理的消息，即对应的PendingTask对象的成员变量nestable的值等于true。</li>
<li>参数pending_task描述的消息不是一个可嵌套处理的消息，但是线程当前运行在最外层的消息循环中，即MessageLoop类的成员变量run<em>loop</em>描述的一个RunLoop对象的成员变量run<em>depth</em>的值等于1。</li>
</ol>
<p>&#160; &#160; &#160; &#160;如果以上两个条件都不能满足，那么就将参数pending_task描述的消息添加到成员变量deferred_non_nestable_work<em>queue</em>描述的一个TaskQueue中等待在合适的时候再处理。</p>
<p>&#160; &#160; &#160; &#160;如果能满足以上两个条件之一，那么就将参数pending_task描述的消息就会被MessageLoop类的成员函数RunTask进行处理，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::RunTask(<span class="keyword">const</span> PendingTask&amp; pending_task) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Execute the task and assume the worst: It is probably not reentrant.</span></span><br><span class="line">nestable_tasks_allowed_ = <span class="literal">false</span>;</span><br><span class="line">......</span><br><span class="line">pending_task.task.Run();</span><br><span class="line">......</span><br><span class="line">nestable_tasks_allowed_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里就可以看到，MessageLoop类的成员函数RunTask在执行参数pending_task描述的消息之前，会先将成员变量nestable_tasks<em>allowed</em>的值设置为false，用来禁止线程嵌套执行其它消息，并且在执行完成参数pending_task描述的消息的之后，将成员变量nestable_tasks<em>allowed</em>的值重新设置为true。 </p>
<p>&#160; &#160; &#160; &#160;从前面分析的MessageLoop类的成员函数PostTask、PostDelayedTask、 PostNonNestableTask和PostNonNestableDelayedTask的实现可以知道，参数pending_task描述的消息实际上是一个Closure对象，该Closure对象保存在参数pending_task指向的一个PendingTask对象的成员变量task中。从前面Chromium多线程通信的Closure机制分析一文可以知道，调用该Closure对象的成员函数Run即可执行它描述的任务。 </p>
<h3 id="DoDelayedWork"><a href="#DoDelayedWork" class="headerlink" title="DoDelayedWork"></a>DoDelayedWork</h3><p>&#160; &#160; &#160; &#160;接下来我们继续分析MessageLoop类的成员函数DoDelayedWork的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) &#123;</span><br><span class="line"><span class="comment">//如果不允许处理嵌套消息，或者延时消息队列为空，</span></span><br><span class="line"><span class="comment">//那么修改最早执行时间为当前之间，然后直接返回false</span></span><br><span class="line"><span class="keyword">if</span> (!nestable_tasks_allowed_ || delayed_work_queue_.empty()) &#123;</span><br><span class="line">recent_time_ = *next_delayed_work_time = TimeTicks();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;</span><br><span class="line"><span class="comment">//如果消息队列第一个消息执行时间大于当前时间</span></span><br><span class="line"><span class="comment">//则执行时间还未到，直接返回false</span></span><br><span class="line"><span class="keyword">if</span> (next_run_time &gt; recent_time_) &#123;</span><br><span class="line">recent_time_ = TimeTicks::Now(); <span class="comment">// Get a better view of Now();</span></span><br><span class="line"><span class="keyword">if</span> (next_run_time &gt; recent_time_) &#123;</span><br><span class="line">*next_delayed_work_time = next_run_time;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果消息队列第一个消息执行时间小与等于当前时间</span></span><br><span class="line"><span class="comment">//取出下一个消息的执行时间赋给next_delayed_work_time</span></span><br><span class="line"><span class="comment">//然后执行这个消息</span></span><br><span class="line">PendingTask pending_task = delayed_work_queue_.top();</span><br><span class="line">delayed_work_queue_.pop();</span><br><span class="line"><span class="keyword">if</span> (!delayed_work_queue_.empty())</span><br><span class="line">*next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;</span><br><span class="line"><span class="keyword">return</span> DeferOrRunPendingTask(pending_task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;参数DoDelayedWork描述的是下一个延迟处理消息的执行时间点。</p>
<p>&#160; &#160; &#160; &#160;如果线程的延迟处理消息队列空，那么MessageLoop类的成员函数DoDelayedWork就只是简单地置空成员变量recent<em>time</em>和参数next_delayed_work_time描述的时间变返回了。</p>
<p>&#160; &#160; &#160; &#160;另一方面，与MessageLoop类的成员函数DoWork类似，MessageLoop类的成员函数DoDelayedWork也禁止处理嵌套消息，因此，当MessageLoop类的成员变量nestable_tasks<em>allowed</em>的值等于false的时候，MessageLoop类的成员函数DoDelayedWork就直接返回。</p>
<p>&#160; &#160; &#160; &#160;如果MessageLoop类的成员函数DoDelayedWork可以继续往下执行，那么它就检查位于延迟处理消息队列头部的消息，并且判断它的执行时间是否大于当前时间。如果是的话的，那么就说明该消息还未到时间执行，因此MessageLoop类的成员函数DoDelayedWork不会执行它，而是直接返回。</p>
<p>&#160; &#160; &#160; &#160;最后，如果位于延迟处理消息队列头部的消息的执行时间小于等于当前时间，那么就是时间将它从队列中取出，并且执行了。在执行之前，MessageLoop类的成员函数DoDelayedWork会获得下一个延迟处理消息的执行时间点，并且保存在参数next_delayed_work_time描述的一个TimeTicks对象，以便返回到MessagePumpDefault类的成员函数Run的时候，后者可以计算出下一次进入睡眠状态的时间长度。</p>
<p>&#160; &#160; &#160; &#160;延迟处理消息同样是通过我们在前面分析的MessageLoop类的成员函数DeferOrRunPendingTask来执行的，因此这里不再复述。</p>
<h3 id="DoIdleWork"><a href="#DoIdleWork" class="headerlink" title="DoIdleWork"></a>DoIdleWork</h3><p>&#160; &#160; &#160; &#160;接下来我们继续分析MessageLoop类的成员函数DoIdleWork的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoop::DoIdleWork() &#123;</span><br><span class="line"><span class="keyword">if</span> (ProcessNextDelayedNonNestableTask())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (run_loop_-&gt;quit_when_idle_received_)</span><br><span class="line">pump_-&gt;Quit();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数DoIdleWork调用另外一个成员函数ProcessNextDelayedNonNestableTask处理那些被延迟的不能嵌套处理的消息。</p>
<p>&#160; &#160; &#160; &#160;如果线程没有被延迟的不能嵌套处理的消息，并且当前消息循环使用的RunLoop的成员变量quit_when_idle<em>received</em>的值被设置为true，即线程被设置在空闲时无事可做时，就会退出线程，这是通过调用成员变量pump_指向的一个MessagePumpDefault对象的成员函数Quit来实现的。</p>
<p>&#160; &#160; &#160; &#160;接下来我们主要分析MessageLoop类的成员函数ProcessNextDelayedNonNestableTask的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoop::ProcessNextDelayedNonNestableTask() &#123;</span><br><span class="line"><span class="keyword">if</span> (run_loop_-&gt;run_depth_ != <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (deferred_non_nestable_work_queue_.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">PendingTask pending_task = deferred_non_nestable_work_queue_.front();</span><br><span class="line">deferred_non_nestable_work_queue_.pop();</span><br><span class="line">RunTask(pending_task);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;被延迟的不能嵌套处理的消息保存在MessageLoop类的成员变量deferred_non_nestable_work<em>queue</em>描述的一个TaskQueue中，这些消息只能够在最外层的消息循环中执行。因此，MessageLoop类的成员函数ProcessNextDelayedNonNestableTask首先判断线程当前是否运行在最外层的消息循环中，即判断成员变量run<em>loop</em>指向的一个RunLoop对象的成员变量run<em>depth</em>的值是否等于1。如果不等于1，那么就直接返回不往下执行了。</p>
<p>&#160; &#160; &#160; &#160;如果线程当前是运行在最外层的消息循环中，那么接下就从成员变量deferred_non_nestable_work<em>queue</em>描述的一个TaskQueue的头部取出一个消息，并且调用前面分析过的成员函数RunTask对它进行处理。</p>
<p>&#160; &#160; &#160; &#160;至此，我们就分析完成了线程的启动、围绕消息队列运行、发送消息和处理消息的过程了。其中，围绕消息队列运行这一过程是针对普通的线程的。对于Android平台的UI线程和Java线程，由于它们在Java层使用了Android系统提供的消息循环机制，因此如果我们需要在Native层使用Chromium提供的消息循环机制，就要进行特殊处理。接下来我们就继续分析如何在Android平台的UI线程和Java线程中使用Chromium提供的消息循环机制。关于Android系统提供的消息循环机制，可以到我的破站参考Android应用程序消息处理机制(Looper、Handler)分析一文。</p>
<h1 id="Android平台的UI线程"><a href="#Android平台的UI线程" class="headerlink" title="Android平台的UI线程"></a>Android平台的UI线程</h1><p>对于Android平台的UI线程和Java线程来说，它们使用的消息循环和消息泵分别是通过MessageLoopForUI类和MessagePumpForUI类描述的，这就区别于一般线程使用MessageLoop类和MesagePumpDefault来描述消息循环和消息泵。接下来我们以UI线程为例来说明它是如何使用Chromium提供的消息循环机制的。对于Java线程，原理是一样的。</p>
<p>&#160; &#160; &#160; &#160;当我们在Android应用程序中使用WebView的时候，会在UI线程中调用BrowserMainRunnerImpl类的成员函数Initialize执行一些初始化工作，其中就包括在Native层中创建一个类型为MessageLoopForUI的消息循环。在后面的文章中，我们分析WebView的启动过程时，就会看到这一过程。现在我们直接分析BrowserMainRunnerImpl类的成员函数Initialize的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BrowserMainRunnerImpl : <span class="keyword">public</span> BrowserMainRunner &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">const</span> MainFunctionParams&amp; parameters)</span> OVERRIDE </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!initialization_started_) &#123;</span><br><span class="line">initialization_started_ = <span class="literal">true</span>;</span><br><span class="line">main_loop_.reset(<span class="keyword">new</span> BrowserMainLoop(parameters));</span><br><span class="line">......</span><br><span class="line">main_loop_-&gt;EarlyInitialization();</span><br><span class="line">......</span><br><span class="line">main_loop_-&gt;MainMessageLoopStart();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">int</span> result_code = main_loop_-&gt;GetResultCode();</span><br><span class="line"><span class="keyword">if</span> (result_code &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> result_code;</span><br><span class="line"><span class="comment">// Return -1 to indicate no early termination.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_main_runner.cc。</p>
<p>&#160; &#160; &#160; &#160;BrowserMainRunnerImpl类的成员函数Initialize首先是创建了一个BrowserMainLoop对象，并且保存在成员变量main<em>loop</em>中。接下来再调用该BrowserMainLoop对象的成员函数EarlyInitialization执行早期初始化工作。这个早期初始化工作就包括了创建一个类型为MessageLoopForUI的消息循环，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BrowserMainLoop::EarlyInitialization() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (parts_)</span><br><span class="line">parts_-&gt;PreEarlyInitialization();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_main_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserMainLoop类的成员变量parts_指向的是一个AwBrowserMainParts对象，这里调用它的成员函数PreEarlyInitialization创建一个类型为MessageLoopForUI的消息循环，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AwBrowserMainParts::PreEarlyInitialization() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Android WebView does not use default MessageLoop. It has its own</span></span><br><span class="line"><span class="comment">// Android specific MessageLoop. Also see MainMessageLoopRun.</span></span><br><span class="line">DCHECK(!main_message_loop_.get());</span><br><span class="line">main_message_loop_.reset(<span class="keyword">new</span> base::MessageLoopForUI);</span><br><span class="line">base::MessageLoopForUI::current()-&gt;Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/android_webview/browser/aw_browser_main_parts.cc中。</p>
<p>&#160; &#160; &#160; &#160;AwBrowserMainParts类的成员函数PreEarlyInitialization创建了一个MessageLoopForUI对象，接着再调用它的成员函数Start执行启动工作。</p>
<p>&#160; &#160; &#160; &#160;接下来我们先分析MessageLoopForUI对象的创建过程，即MessageLoopForUI类的构造函数的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT MessageLoopForUI : <span class="keyword">public</span> MessageLoop &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MessageLoopForUI() : MessageLoop(TYPE_UI) &#123;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.h中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoopForUI类继承了MessageLoop类。MessageLoopForUI类的构造函数在调用父类MessageLoop的构造函数时，传递进去的参数为TYPE_UI，表示要创建一个类型为TYPE_UI的消息循环。从前面的分析可以知道，MessageLoop类的构造函数会根据传递给它的参数TYPE<em>UI创建一个类型为MessagePumpForUI的消息泵，并且保存在成员变量pump</em>中。</p>
<p>&#160; &#160; &#160; &#160;回到AwBrowserMainParts类的成员函数PreEarlyInitialization中，当它创建了一个MessageLoopForUI对象之后，接下来就会调用它的成员函数Start执行启动工作，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageLoopForUI::Start() &#123;</span><br><span class="line"><span class="comment">// No Histogram support for UI message loop as it is managed by Java side</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;MessagePumpForUI*&gt;(pump_.get())-&gt;Start(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoopForUI类的成员变量pump_是从父类MessageLoop继承下来的，从前面的分析可以知道，它指向的是一个MessagePumpForUI对象，这里调用它的成员函数Start执行启动工作，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpForUI::Start(Delegate* delegate) &#123;</span><br><span class="line">run_loop_ = <span class="keyword">new</span> RunLoop();</span><br><span class="line"><span class="comment">// Since the RunLoop was just created above, BeforeRun should be guaranteed to</span></span><br><span class="line"><span class="comment">// return true (it only returns false if the RunLoop has been Quit already).</span></span><br><span class="line"><span class="keyword">if</span> (!run_loop_-&gt;BeforeRun())</span><br><span class="line">NOTREACHED();</span><br><span class="line">DCHECK(system_message_handler_obj_.is_null());</span><br><span class="line">JNIEnv* env = base::android::AttachCurrentThread();</span><br><span class="line">DCHECK(env);</span><br><span class="line">system_message_handler_obj_.Reset(</span><br><span class="line">Java_SystemMessageHandler_create(</span><br><span class="line">env, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">intptr_t</span>&gt;(delegate)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_android.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpForUI类的成员函数Start首先是创建了一个RunLoop对象，并且调用它的成员函数BeforeRun创建最外层的消息循环，接下来调用函数Java_SystemMessageHandler_create创建了一个Java层的SystemMessageHandler对象，并且保存在成员变量system_message_handler<em>obj</em>对象。这个SystemMessageHandler对象就是Java层和Native层的消息循环之间进行通信的桥梁。</p>
<p>&#160; &#160; &#160; &#160;这样，Android应用程序的UI线程在Chromium中使用的消息循环就启动起来了。注意，Android应用程序的UI线程是在Java层围绕Android的消息队列运行的，因此它不能像普通的线程一样，也在Native层围绕Chromium的消息队列运行，也就是Android应用程序的UI线程不会调用MessageLoopForUI类的成员函数Run进入运行状态。</p>
<p>&#160; &#160; &#160; &#160;这一步执行完成之后，一直返回到BrowserMainRunnerImpl类的成员函数Initialize，它接下来调用前面创建的BrowserMainLoop对象的成员函数MainMessageLoopStart，继续执行其它的初始化工作，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BrowserMainLoop::MainMessageLoopStart() &#123;</span><br><span class="line">......</span><br><span class="line">InitializeMainThread();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_main_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserMainLoop对象的成员函数MainMessageLoopStart执行的其中一个工作是调用另外一个成员函数InitializeMainThread初始化主线程，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BrowserMainLoop::InitializeMainThread() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Register the main thread by instantiating it, but don't call any methods.</span></span><br><span class="line">main_thread_.reset(</span><br><span class="line"><span class="keyword">new</span> BrowserThreadImpl(BrowserThread::UI, base::MessageLoop::current()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_main_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserMainLoop类的成员函数InitializeMainThread为主线程创建了一个BrowserThreadImpl对象，并且保存在成员变量main<em>thread</em>中。</p>
<p>&#160; &#160; &#160; &#160;BrowserThreadImpl对象的创建过程如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BrowserThreadImpl::BrowserThreadImpl(ID identifier,</span><br><span class="line">base::MessageLoop* message_loop)</span><br><span class="line">: Thread(message_loop-&gt;thread_name()), identifier_(identifier) &#123;</span><br><span class="line">set_message_loop(message_loop);</span><br><span class="line">Initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_thread_impl.cc。</p>
<p>&#160; &#160; &#160; &#160;从前面的调用过程可以知道，参数identifier的值为BrowserThread::UI，而参数message_loop指向的是一个MessageLoopForUI对象。</p>
<p>&#160; &#160; &#160; &#160;BrowserThreadImpl类是从我们前面分析过的base::Thread类继承下来的，BrowserThreadImpl类调用的成员函数set_message_loop也是从父类base::Thread继承下来的，这里调用它来为UI线程设置一个消息循环，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT Thread : PlatformThread::Delegate &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_message_loop</span><span class="params">(MessageLoop* message_loop)</span> </span>&#123;</span><br><span class="line">message_loop_ = message_loop;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">......</span><br><span class="line">MessageLoop* message_loop_;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/thread.h中。</p>
<p>&#160; &#160; &#160; &#160;这意味Android应用程序的UI线程虽然不像其它线程一样，不能在Native层围绕Chromium的消息队列运行，但是它也像其线程一样，使用一个Thead对象来描述，并且这个Thread对象具有一个类型为MessageLoopForUI的消息循环。</p>
<p>&#160; &#160; &#160; &#160;返回到BrowserThreadImpl类的构造函数中，设置了Android应用程序的UI线程的消息循环之外，接下来调用另外一个成员函数Initialize执行其它的初始化工作，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">base::LazyInstance&lt;BrowserThreadGlobals&gt;::Leaky</span><br><span class="line">g_globals = LAZY_INSTANCE_INITIALIZER;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">void</span> BrowserThreadImpl::Initialize() &#123;</span><br><span class="line">BrowserThreadGlobals&amp; globals = g_globals.Get();</span><br><span class="line">base::<span class="function">AutoLock <span class="title">lock</span><span class="params">(globals.lock)</span></span>;</span><br><span class="line">......</span><br><span class="line">globals.threads[identifier_] = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_thread_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserThreadImpl类的成员函数Initialize做的工作实际上就是将用来描述UI线程的一个BrowserThreadImpl对象注册在全局变量g_globals指向的一个BrowserThreadGlobals对象的成员变量threads描述的一个BrowserThreadImpl数组中。</p>
<p>&#160; &#160; &#160; &#160;有了这个BrowserThreadImpl数组之后，以后就可以通过BrowserThread类的静态成员函数PostTask、PostDelayedTask、PostNonNestableTask和PostNonNestableDelayedTask等向UI线程发送消息。以BrowserThread类的静态成员函数PostTask为例，调用它向UI线程发送消息的代码如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, task);</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;BrowserThread类的静态成员函数PostTask的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BrowserThread::PostTask(ID identifier,</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> base::Closure&amp; task) &#123;</span><br><span class="line"><span class="keyword">return</span> BrowserThreadImpl::PostTaskHelper(</span><br><span class="line">identifier, from_here, task, base::TimeDelta(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_thread_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserThread类的静态成员函数PostTask调用了BrowserThreadImpl类的静态成员函数PostTaskHelper向参数identifier描述的线程的消息队列发送一个Closure。</p>
<p>&#160; &#160; &#160; &#160;BrowserThreadImpl类的静态成员函数PostTaskHelper的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BrowserThreadImpl::PostTaskHelper(</span><br><span class="line">BrowserThread::ID identifier,</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> base::Closure&amp; task,</span><br><span class="line">base::TimeDelta delay,</span><br><span class="line"><span class="keyword">bool</span> nestable) &#123;</span><br><span class="line">......</span><br><span class="line">base::MessageLoop* message_loop =</span><br><span class="line">globals.threads[identifier] ? globals.threads[identifier]-&gt;message_loop()</span><br><span class="line">: <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (message_loop) &#123;</span><br><span class="line"><span class="keyword">if</span> (nestable) &#123;</span><br><span class="line">message_loop-&gt;PostDelayedTask(from_here, task, delay);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">message_loop-&gt;PostNonNestableDelayedTask(from_here, task, delay);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">return</span> !!message_loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_thread_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserThreadImpl类的静态成员函数PostTaskHelper首先是根据参数identifier在前面描述的全局变量g_globals指向的一个BrowserThreadGlobals对象的成员变量threads描述的一个BrowserThreadImpl数组中获得一个对应的BrowserThreadImpl对象，接着再通过调用BrowserThreadImpl对象的成员函数message_loop获得一个MessageLoop对象。有了这个MessageLoop对象之后，就可以调用它的成员函数PostDelayedTask或者PostNonNestableDelayedTask向指定的线程的消息队列发送消息了。</p>
<p>&#160; &#160; &#160; &#160;前面我们已经分析过MessageLoop类的成员函数PostDelayedTask和PostNonNestableDelayedTask了。从前面的分析可以知道，当它们向线程的消息队列发送了一个消息之后，最后会调用它的成员变量pump_描述的一个MessagePump对象的成员函数ScheduleWork唤醒线程，以便它可以处理新发送到消息队列的消息。</p>
<p>&#160; &#160; &#160; &#160;从前面的分析可以知道，对于UI线程来说，它使用的消息循环通过类MessageLoopForUI来描述，而MessageLoopForUI类的成员变量pump_指向的是一个MessagePumpForUI对象。MessagePumpForUI类是从MessagePump类继承下来的，并且重写了成员函数ScheduleWork，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpForUI::ScheduleWork() &#123;</span><br><span class="line">DCHECK(!system_message_handler_obj_.is_null());</span><br><span class="line">JNIEnv* env = base::android::AttachCurrentThread();</span><br><span class="line">DCHECK(env);</span><br><span class="line">Java_SystemMessageHandler_scheduleWork(env,</span><br><span class="line">system_message_handler_obj_.obj());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件/external/chromium_org/base/message_loop/message_pump_android.cc中。</p>
<p>&#160; &#160; &#160; &#160;前面提到，MessagePumpForUI类的成员变量system_message_handler<em>obj</em>描述的是一个Java层的SystemMessageHandler对象，这里通过函数Java_SystemMessageHandler_scheduleWork调用它的成员函数scheduleWork。</p>
<p>&#160; &#160; &#160; &#160;Java层的SystemMessageHandler类的成员函数scheduleWork的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpForUI::ScheduleWork() &#123;</span><br><span class="line">DCHECK(!system_message_handler_obj_.is_null());</span><br><span class="line">JNIEnv* env = base::android::AttachCurrentThread();</span><br><span class="line">DCHECK(env);</span><br><span class="line">Java_SystemMessageHandler_scheduleWork(env,</span><br><span class="line">system_message_handler_obj_.obj());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件/external/chromium_org/base/message_loop/message_pump_android.cc中。</p>
<p>&#160; &#160; &#160; &#160;前面提到，MessagePumpForUI类的成员变量system_message_handler<em>obj</em>描述的是一个Java层的SystemMessageHandler对象，这里通过函数Java_SystemMessageHandler_scheduleWork调用它的成员函数scheduleWork。</p>
<p>&#160; &#160; &#160; &#160;Java层的SystemMessageHandler类的成员函数scheduleWork的实现如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemMessageHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="meta">@CalledByNative</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sendEmptyMessage(SCHEDULED_WORK);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/android/java/src/org/chromium/base/SystemMessageHandler.java中。</p>
<p>&#160; &#160; &#160; &#160;SystemMessageHandler类的成员函数scheduleWork调用从父类Handler继承下来的成员函数sendEmptyMessage向Java层的消息队列发送一个类型为SCHEDULED_WORK的消息，该消息最终地在SystemMessageHandler类的成员函数handleMessage中得到处理，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemMessageHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Native class pointer set by the constructor of the SharedClient native class.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mMessagePumpDelegateNative = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SystemMessageHandler</span><span class="params">(<span class="keyword">long</span> messagePumpDelegateNative)</span> </span>&#123;</span><br><span class="line">mMessagePumpDelegateNative = messagePumpDelegateNative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">nativeDoRunLoopOnce(mMessagePumpDelegateNative, mDelayedScheduledTimeTicks);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/android/java/src/org/chromium/base/SystemMessageHandler.java中。</p>
<p>&#160; &#160; &#160; &#160;SystemMessageHandler类的成员变量mMessagePumpDelegateNative是在构造函数中初始化的，从前面分析的MessagePumpForUI的成员函数Start可以知道，它指向的是一个Native层的MessageLoopForUI对象。</p>
<p>&#160; &#160; &#160; &#160;SystemMessageHandler类的成员函数handleMessage调用JNI函数nativeDoRunLoopOnce通知成员变量mMessagePumpDelegateNative描述的一个Native层的MessageLoopForUI对象，它的消息队列有新的消息需要处理。</p>
<p>&#160; &#160; &#160; &#160;SystemMessageHandler类的JNI函数nativeDoRunLoopOnce由Naitve层的函数Java_com_android_org_chromium_base_SystemMessageHandler_nativeDoRunLoopOnce实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoRunLoopOnce</span><span class="params">(JNIEnv* env, jobject jcaller,</span><br><span class="line">jlong messagePumpDelegateNative,</span><br><span class="line">jlong delayedScheduledTimeTicks)</span></span>;</span><br><span class="line">__attribute__((visibility(<span class="string">"default"</span>)))</span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">Java_com_android_org_chromium_base_SystemMessageHandler_nativeDoRunLoopOnce</span><span class="params">(JNIEnv*</span><br><span class="line">env, jobject jcaller,</span><br><span class="line">jlong messagePumpDelegateNative,</span><br><span class="line">jlong delayedScheduledTimeTicks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> DoRunLoopOnce(env, jcaller, messagePumpDelegateNative,</span><br><span class="line">delayedScheduledTimeTicks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在编译时自动生成的文件out/target/product/generic/obj/GYP/shared_intermediates/base/jni/SystemMessageHandler_jni.h中。</p>
<p>&#160; &#160; &#160; &#160;函数Java_com_android_org_chromium_base_SystemMessageHandler_nativeDoRunLoopOnce调用了另外一个函数DoRunLoopOnce通知UI线程在Native的消息队列有新的消息需要处理。</p>
<p>&#160; &#160; &#160; &#160;函数DoRunLoopOnce的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoRunLoopOnce</span><span class="params">(JNIEnv* env, jobject obj, jlong native_delegate,</span><br><span class="line">jlong delayed_scheduled_time_ticks)</span> </span>&#123;</span><br><span class="line"><span class="comment">//实际上是一个MessageLoopForUI对象</span></span><br><span class="line">base::MessagePump::Delegate* delegate =</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;base::MessagePump::Delegate*&gt;(native_delegate);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//执行任务队列中的任务</span></span><br><span class="line"><span class="keyword">bool</span> did_work = delegate-&gt;DoWork();</span><br><span class="line">......</span><br><span class="line">base::TimeTicks next_delayed_work_time;</span><br><span class="line"><span class="comment">//执行延时任务</span></span><br><span class="line">did_work |= delegate-&gt;DoDelayedWork(&amp;next_delayed_work_time);</span><br><span class="line"><span class="keyword">if</span> (!next_delayed_work_time.is_null()) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果它有一个延迟处理的消息，那么需要通过函数</span></span><br><span class="line"><span class="comment">//Java_SystemMessageHandler_scheduleDelayedWork调用Java层的</span></span><br><span class="line"><span class="comment">//SystemMessageHandler类的成员函数scheduleDelayedWork来进行调度</span></span><br><span class="line"><span class="keyword">if</span> (delayed_scheduled_time_ticks == <span class="number">0</span> ||</span><br><span class="line">next_delayed_work_time &lt; base::TimeTicks::FromInternalValue(</span><br><span class="line">delayed_scheduled_time_ticks)) &#123;</span><br><span class="line">Java_SystemMessageHandler_scheduleDelayedWork(env, obj,</span><br><span class="line">next_delayed_work_time.ToInternalValue(),</span><br><span class="line">(next_delayed_work_time -</span><br><span class="line">base::TimeTicks::Now()).InMillisecondsRoundedUp());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (did_work)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//如果没有任务了，就处理闲置任务</span></span><br><span class="line">delegate-&gt;DoIdleWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_android.cc中。</p>
<p>&#160; &#160; &#160; &#160;函数DoRunLoopOnce首先是将参数native_delegate转化为一个Native层的base::MessagePump::Delegate对象。在我们这个情景中，这个base::MessagePump::Delegate对象实际上是一个MessageLoopForUI对象。</p>
<p>&#160; &#160; &#160; &#160;接下来函数DoRunLoopOnce执行的工作与前面分析的MessagePumpDefault类的成员函数Run是类似的，区别主要在于:</p>
<ol>
<li>函数DoRunLoopOnce只执行一次循环，而MessagePumpDefault类的成员函数Run执行的是无限循环。</li>
<li>函数DoRunLoopOnce不能够进入睡眠状态，如果它有一个延迟处理的消息，那么需要通过函数Java_SystemMessageHandler_scheduleDelayedWork调用Java层的SystemMessageHandler类的成员函数scheduleDelayedWork来进行调度，而MessagePumpDefault类的成员函数Run可以自行进入睡眠状态来调度延迟处理消息的执行。</li>
</ol>
<p>&#160; &#160; &#160; &#160;至此，我们就分析完成Android应用程序的UI线程是如何实现Chromium的消息循环了。接下来我们继续分析另外一个特殊的消息循环，那就是负责执行IPC的IO线程的消息循环。</p>
<h1 id="IPC的IO线程"><a href="#IPC的IO线程" class="headerlink" title="IPC的IO线程"></a>IPC的IO线程</h1><h2 id="创建消息泵-1"><a href="#创建消息泵-1" class="headerlink" title="创建消息泵"></a>创建消息泵</h2><p>&#160; &#160; &#160; &#160;在前面分析的BrowserMainRunnerImpl类的成员函数Initialize中，除了我们提到它会调用BrowserMainLoop类的成员函数EarlyInitialization和MainMessageLoopStart来执行一些与UI线程相关的工作之外，还会调用BrowserMainLoop类的成员函数CreateStartupTasks来执行其它的启动任务，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BrowserMainRunnerImpl : <span class="keyword">public</span> BrowserMainRunner &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">const</span> MainFunctionParams&amp; parameters)</span> OVERRIDE </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!initialization_started_) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">main_loop_-&gt;CreateStartupTasks();</span><br><span class="line"><span class="keyword">int</span> result_code = main_loop_-&gt;GetResultCode();</span><br><span class="line"><span class="keyword">if</span> (result_code &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> result_code;</span><br><span class="line"><span class="comment">// Return -1 to indicate no early termination.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_main_runner.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserMainLoop类的成员函数CreateStartupTasks执行的启动任务很多，这里我们只关心与IO线程相关的任务，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BrowserMainLoop::CreateStartupTasks() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!startup_task_runner_.get()) &#123;</span><br><span class="line"><span class="comment">//这个StartupTaskRunner对象封装了当前线程的一个消息循环，</span></span><br><span class="line"><span class="comment">//因此通过它可以向当前线程的消息队列发送消息</span></span><br><span class="line">startup_task_runner_ = make_scoped_ptr(<span class="keyword">new</span> StartupTaskRunner(</span><br><span class="line">base::Bind(&amp;BrowserStartupComplete),</span><br><span class="line">base::MessageLoop::current()-&gt;message_loop_proxy()));</span><br><span class="line">......</span><br><span class="line"><span class="comment">//创建了一个用来创建线程的StartupTask，</span></span><br><span class="line"><span class="comment">//这个StartupTask绑定的函数为BrowserMainLoop类的成员函数CreateThreads</span></span><br><span class="line"><span class="comment">//并且会保存在前面创建的一个StartupTaskRunner的内部等待执行</span></span><br><span class="line">StartupTask create_threads =</span><br><span class="line">base::Bind(&amp;BrowserMainLoop::CreateThreads, base::Unretained(<span class="keyword">this</span>));</span><br><span class="line">startup_task_runner_-&gt;AddTask(create_threads);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是使用异步方式启动WebView</span></span><br><span class="line"><span class="keyword">if</span> (BrowserMayStartAsynchronously()) &#123;</span><br><span class="line">startup_task_runner_-&gt;StartRunningTasksAsync();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是使用同步方式启动WebView</span></span><br><span class="line"><span class="keyword">if</span> (!BrowserMayStartAsynchronously()) &#123;</span><br><span class="line">......</span><br><span class="line">startup_task_runner_-&gt;RunAllTasksNow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_main_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserMainLoop类的成员函数CreateStartupTasks首先是会创建一个StartupTaskRunner对象，并且保存在成员变量startup_task<em>runner</em>中。这个StartupTaskRunner对象封装了当前线程的一个消息循环，因此通过它可以向当前线程的消息队列发送消息。当前线程即为Android应用程序的UI线程，因此有了这个StartupTaskRunner对象之后，接下来可以向UI线程的消息队列发送消息。</p>
<p>&#160; &#160; &#160; &#160;BrowserMainLoop类的成员函数CreateStartupTasks创建了一个用来创建线程的StartupTask，这个StartupTask绑定的函数为BrowserMainLoop类的成员函数CreateThreads，并且会保存在前面创建的一个StartupTaskRunner的内部等待执行。</p>
<p>&#160; &#160; &#160; &#160;最后，取决于Android应用程序的UI线程是使用同步还是异步方式来启动WebView，BrowserMainLoop类的成员函数CreateStartupTasks使用不同的方式来执行保存在成员变量startup_task<em>runner</em>指向的一个StartupTaskRunner对象中的StartupTask:</p>
<ol>
<li>如果是使用同步方式启动WebView，那么就调用上述StartupTaskRunner对象的成员函数RunAllTasksNow来执行保存在它里面的各个StartupTask对象的成员函数Run来执行它们。</li>
<li>如果是使用异步方式启动WebView，那么就调用上述StartupTaskRunner对象的成员函数StartRunningTasksAsync向UI线程的消息队列发送一个消息，当该消息被处理时，再执行保存在上述StartupTaskRunner对象里面的各个StartupTask对象的成员函数Run。</li>
</ol>
<p>&#160; &#160; &#160; &#160;无论是同步方式，还是异步方式，最终都会在UI线程调用BrowserMainLoop类的成员函数CreateThreads来创建一系列线程，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BrowserMainLoop::CreateThreads() &#123;</span><br><span class="line">......</span><br><span class="line">base::Thread::Options default_options;</span><br><span class="line">base::Thread::Options io_message_loop_options;</span><br><span class="line">io_message_loop_options.message_loop_type = base::MessageLoop::TYPE_IO;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> thread_id = BrowserThread::UI + <span class="number">1</span>;</span><br><span class="line">thread_id &lt; BrowserThread::ID_COUNT;</span><br><span class="line">++thread_id) &#123;</span><br><span class="line">scoped_ptr&lt;BrowserProcessSubThread&gt;* thread_to_start = <span class="literal">NULL</span>;</span><br><span class="line">base::Thread::Options* options = &amp;default_options;</span><br><span class="line"><span class="keyword">switch</span> (thread_id) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">case</span> BrowserThread::IO:</span><br><span class="line">......</span><br><span class="line">thread_to_start = &amp;io_thread_;</span><br><span class="line">options = &amp;io_message_loop_options;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">NOTREACHED();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">BrowserThread::ID id = <span class="keyword">static_cast</span>&lt;BrowserThread::ID&gt;(thread_id);</span><br><span class="line"><span class="keyword">if</span> (thread_to_start) &#123;</span><br><span class="line">(*thread_to_start).reset(<span class="keyword">new</span> BrowserProcessSubThread(id));</span><br><span class="line">(*thread_to_start)-&gt;StartWithOptions(*options);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> result_code_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/browser_main_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;BrowserMainLoop类的成员函数CreateThreads创建了很多线程，每一个线程都有专门的作用。这些线程的作用可以参考以下的枚举类型ID的定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CONTENT_EXPORT BrowserThread &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// An enumeration of the well-known threads.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> threads must be listed in the order of their life-time, with each</span></span><br><span class="line"><span class="comment">// thread outliving every other thread below it.</span></span><br><span class="line"><span class="keyword">enum</span> ID &#123;</span><br><span class="line"><span class="comment">// The main thread in the browser.</span></span><br><span class="line">UI,</span><br><span class="line"><span class="comment">// This is the thread that interacts with the database.</span></span><br><span class="line">DB,</span><br><span class="line"><span class="comment">// This is the thread that interacts with the file system.</span></span><br><span class="line">FILE,</span><br><span class="line"><span class="comment">// Used for file system operations that block user interactions.</span></span><br><span class="line"><span class="comment">// Responsiveness of this thread affect users.</span></span><br><span class="line">FILE_USER_BLOCKING,</span><br><span class="line"><span class="comment">// Used to launch and terminate Chrome processes.</span></span><br><span class="line">PROCESS_LAUNCHER,</span><br><span class="line"><span class="comment">// This is the thread to handle slow HTTP cache operations.</span></span><br><span class="line">CACHE,</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> do not add new threads here that are only used by a small number of</span></span><br><span class="line"><span class="comment">// files. Instead you should just use a Thread class and pass its</span></span><br><span class="line"><span class="comment">// MessageLoopProxy around. Named threads there are only for threads that</span></span><br><span class="line"><span class="comment">// are used in many places.</span></span><br><span class="line"><span class="comment">// This identifier does not represent a thread. Instead it counts the</span></span><br><span class="line"><span class="comment">// number of well-known threads. Insert new well-known threads before this</span></span><br><span class="line"><span class="comment">// identifier.</span></span><br><span class="line">ID_COUNT</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个枚举类型定义在文件external/chromium_org/content/public/browser/browser_thread.h中。</p>
<p>&#160; &#160; &#160; &#160;回到BrowserMainLoop类的成员函数CreateThreads中，我们只关注IO线程的创建过程。这个IO线程使用一个BrowserProcessSubThread对象来描述，并且通过调用该BrowserProcessSubThread对象的成员函数StartWithOptions来启动。</p>
<p>&#160; &#160; &#160; &#160;BrowserProcessSubThread类是从BrowserThreadImpl类继承下来的。从前面的分析又可以知道，BrowserThreadImpl类又是从base::Thread类继承下来的。因此，Android应用程序中用来负责执行IPC的IO线程实际上是通过Thread类的成员函数StartWithOptions来创建，并且在创建的时候，指定创建的消息循环的类型为base::MessageLoop::TYPE_IO。</p>
<p>&#160; &#160; &#160; &#160;从前面分析的MessageLoop类的成员函数CreateMessagePumpForType的实现可以知道，类型为base::MessageLoop::TYPE_IO的消息循环使用的消息泵的通过类MessagePumpLibevent来描述。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类是从MessagePump类继承下来的，它的定义如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT MessagePumpLibevent : <span class="keyword">public</span> MessagePump &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line">MessagePumpLibevent();</span><br><span class="line">......</span><br><span class="line"><span class="comment">// MessagePump methods:</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">(Delegate* delegate)</span> OVERRIDE</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Quit</span><span class="params">()</span> OVERRIDE</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ScheduleWork</span><span class="params">()</span> OVERRIDE</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ScheduleDelayedWork</span><span class="params">(<span class="keyword">const</span> TimeTicks&amp; delayed_work_time)</span> OVERRIDE</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Libevent dispatcher. Watches all sockets registered with it, and sends</span></span><br><span class="line"><span class="comment">// readiness callbacks when a socket is ready for I/O.</span></span><br><span class="line">event_base* event_base_;</span><br><span class="line"><span class="comment">// ... write end; ScheduleWork() writes a single byte to it</span></span><br><span class="line"><span class="keyword">int</span> wakeup_pipe_in_;</span><br><span class="line"><span class="comment">// ... read end; OnWakeup reads it and then breaks Run() out of its sleep</span></span><br><span class="line"><span class="keyword">int</span> wakeup_pipe_out_;</span><br><span class="line"><span class="comment">// ... libevent wrapper for read end</span></span><br><span class="line">event* wakeup_event_;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个类定义在文件external/chromium_org/base/message_loop/message_pump_libevent.h中。</p>
<p>MessagePumpLibevent类与前面分析的MessagePumpDefault类实现消息循环的最大区别是，前者通过Libevent实现线程睡眠与唤醒，而后者是通过条件变量实现线程睡眠与唤醒的。</p>
<p>&#160; &#160; &#160; &#160;Libevent在Android平台上实际上就是封装了由Linux内核提供的epoll机制。如果读过Android应用程序消息处理机制(Looper、Handler)分析这篇文章，Android应用程序使用的的消息循环机是基于epoll机制实现的。因此，Chromium里面的IO线程的消息循环机制与Android应用程序的消息循环机制的实现是很相似的。接下来我们就简单分析Chromium里面的IO线程的消息循环的实现，主要就是分析MessagePumpLibevent类的构造函数、成员函数Run和ScheduleWork的实现。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的构造函数的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessagePumpLibevent::MessagePumpLibevent()</span><br><span class="line">: .....</span><br><span class="line">event_base_(event_base_new()),</span><br><span class="line">wakeup_pipe_in_(<span class="number">-1</span>),</span><br><span class="line">wakeup_pipe_out_(<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!Init())</span><br><span class="line">NOTREACHED();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_libevent.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的构造函数主要就是调用成员函数Init初始化Libevent，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessagePumpLibevent::Init() &#123;</span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//创建一个管道</span></span><br><span class="line"><span class="keyword">if</span> (pipe(fds)) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//读端</span></span><br><span class="line">wakeup_pipe_out_ = fds[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//写端</span></span><br><span class="line">wakeup_pipe_in_ = fds[<span class="number">1</span>];</span><br><span class="line">wakeup_event_ = <span class="keyword">new</span> event;</span><br><span class="line"><span class="comment">//监控文件描述wakeup_pipe_out_的EV_READ和EV_PERSIST事件</span></span><br><span class="line"><span class="comment">//同时指定上述事件发生时，就调用MessagePumpLibevent类的静态成员函数OnWakeup</span></span><br><span class="line">event_set(wakeup_event_, wakeup_pipe_out_, EV_READ | EV_PERSIST,</span><br><span class="line">OnWakeup, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//通过Libevent提供的函数event_base_set创建了一个event_base</span></span><br><span class="line"><span class="comment">//这相当于是通过epoll提供的函数epoll_create创建了一个epoll文件描述符</span></span><br><span class="line">event_base_set(event_base_, wakeup_event_);</span><br><span class="line"><span class="comment">//event_add将前面创建的event加入到前面创建的event_base里面去，</span></span><br><span class="line"><span class="comment">//以便可以对指定的IO事件进行监控。</span></span><br><span class="line"><span class="comment">//这相当于是调用了epoll提供的函数epoll_ctl</span></span><br><span class="line"><span class="keyword">if</span> (event_add(wakeup_event_, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_libevent.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的成员函数Init首先是创创建一个管道，并且分别将该管道的读端和写端文件描述符保存在成员变量wakeup_pipe<em>out</em>和wakeup_pipe<em>in</em>中。</p>
<p>&#160; &#160; &#160; &#160;接下来，MessagePumpLibevent类的成员函数Init创建了一个Libevent里面的event，保存在成员变量wakeup<em>event</em>中，并且通过Libevent提供的函数event_set指定该event是用来监控文件描述wakeup_pipe<em>out</em>的EV_READ和EV_PERSIST事件的，同时指定上述事件发生时，就调用MessagePumpLibevent类的静态成员函数OnWakeup。这相当于是创建了一个epoll里面的epoll_event。</p>
<p>&#160; &#160; &#160; &#160;再接下来，MessagePumpLibevent类的成员函数Init通过Libevent提供的函数event_base_set创建了一个event_base。这相当于是通过epoll提供的函数epoll_create创建了一个epoll文件描述符。</p>
<p>&#160; &#160; &#160; &#160;最后，MessagePumpLibevent类的成员函数Init通过调用Libevent提供函数event_add将前面创建的event加入到前面创建的event_base里面去，以便可以对指定的IO事件进行监控。这相当于是调用了epoll提供的函数epoll_ctl。</p>
<h2 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h2><p>&#160; &#160; &#160; &#160;接下来，我们继续分析MessagePumpLibevent类的成员函数Run的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpLibevent::Run(Delegate* delegate) &#123;</span><br><span class="line">......</span><br><span class="line">scoped_ptr&lt;event&gt; timer_event(<span class="keyword">new</span> event);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//处理消息队列中的消息</span></span><br><span class="line"><span class="keyword">bool</span> did_work = delegate-&gt;DoWork();</span><br><span class="line"><span class="keyword">if</span> (!keep_running_)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//表示在没有IO事件发生的情况下，不会阻塞当前线程的执行</span></span><br><span class="line">event_base_loop(event_base_, EVLOOP_NONBLOCK);</span><br><span class="line">did_work |= processed_io_events_;</span><br><span class="line">processed_io_events_ = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!keep_running_)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//处理延时消息</span></span><br><span class="line">did_work |= delegate-&gt;DoDelayedWork(&amp;delayed_work_time_);</span><br><span class="line"><span class="keyword">if</span> (!keep_running_)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (did_work)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//如果没有任务处理，就处理空闲任务</span></span><br><span class="line">did_work = delegate-&gt;DoIdleWork();</span><br><span class="line"><span class="keyword">if</span> (!keep_running_)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (did_work)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// EVLOOP_ONCE tells libevent to only block once,</span></span><br><span class="line"><span class="comment">// but to service all pending events when it wakes up.</span></span><br><span class="line"><span class="keyword">if</span> (delayed_work_time_.is_null()) &#123;</span><br><span class="line"><span class="comment">//则表示在没有IO事件发生的情况下，会阻塞当前线程的执行，</span></span><br><span class="line"><span class="comment">//直到有IO事件发生，或者指定的阻塞时间超时为止。</span></span><br><span class="line"><span class="comment">//这相当于是调用了epoll提供的函数epoll_wait</span></span><br><span class="line">event_base_loop(event_base_, EVLOOP_ONCE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">TimeDelta delay = delayed_work_time_ - TimeTicks::Now();</span><br><span class="line"><span class="keyword">if</span> (delay &gt; TimeDelta()) &#123;</span><br><span class="line"><span class="keyword">struct</span> timeval poll_tv;</span><br><span class="line"><span class="comment">//延时秒数</span></span><br><span class="line">poll_tv.tv_sec = delay.InSeconds();</span><br><span class="line"><span class="comment">//延时微秒数</span></span><br><span class="line">poll_tv.tv_usec = delay.InMicroseconds() % Time::kMicrosecondsPerSecond;</span><br><span class="line">event_set(timer_event.get(), <span class="number">-1</span>, <span class="number">0</span>, timer_callback, event_base_);</span><br><span class="line">event_base_set(event_base_, timer_event.get());</span><br><span class="line"><span class="comment">//延时阻塞当前线程poll_tv</span></span><br><span class="line">event_add(timer_event.get(), &amp;poll_tv);</span><br><span class="line">event_base_loop(event_base_, EVLOOP_ONCE);</span><br><span class="line">event_del(timer_event.get());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It looks like delayed_work_time_ indicates a time in the past, so we</span></span><br><span class="line"><span class="comment">// need to call DoDelayedWork now.</span></span><br><span class="line"><span class="comment">//延时时间小于当前时间，要立刻执行这个消息</span></span><br><span class="line">delayed_work_time_ = TimeTicks();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_libevent.cc中。</p>
<p>&#160; &#160; &#160; &#160;与MessagePumpDefault类的成员函数Run相比，MessagePumpLibevent类的成员函数Run的执行流程是相似的，主要区别在于:</p>
<ol>
<li>MessagePumpLibevent类通过调用Libevent提供的函数event_base_loop使得线程进入睡眠状态，而MessagePumpDefault类通过条件变量使得程进入睡眠状态。<ol>
<li>MessagePumpLibevent除了用来监控消息队列有无新增消息之后，还用来监控指定的文件描述符的IO事件，如以下代码所示:</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  event_base_loop(event_base_, EVLOOP_NONBLOCK);</span><br><span class="line">did_work |= processed_io_events_;</span><br><span class="line">processed_io_events_ = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!keep_running_)</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这段代码调用Libevent提供的函数event_base_loop检查其它指定监控的文件描述是有IO事件发生。如果有发生的话，就调用它们指定的回调函数进行处理。注意，这里调用函数event_base_loop时，第二个参数指定为EVLOOP_NONBLOCK，表示在没有IO事件发生的情况下，不会阻塞当前线程的执行。</p>
<p>&#160; &#160; &#160; &#160;在调用函数event_base_loop时，如果第二个参数指定为EVLOOP_ONCE，则表示在没有IO事件发生的情况下，会阻塞当前线程的执行，直到有IO事件发生，或者指定的阻塞时间超时为止。这相当于是调用了epoll提供的函数epoll_wait。</p>
<p>&#160; &#160; &#160; &#160;接下来我们继续分析MessagePumpLibevent类的成员函数ScheduleWork的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpLibevent::ScheduleWork() &#123;</span><br><span class="line"><span class="comment">// Tell libevent (in a threadsafe way) that it should break out of its loop.</span></span><br><span class="line"><span class="keyword">char</span> buf = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nwrite = HANDLE_EINTR(write(wakeup_pipe_in_, &amp;buf, <span class="number">1</span>));</span><br><span class="line">DCHECK(nwrite == <span class="number">1</span> || errno == EAGAIN)</span><br><span class="line">&lt;&lt; <span class="string">"[nwrite:"</span> &lt;&lt; nwrite &lt;&lt; <span class="string">"] [errno:"</span> &lt;&lt; errno &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_libevent.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的成员函数ScheduleWork向成员变量wakeup_pipe<em>in</em>描述的管道写入一个字符，从前面分析的MessagePumpLibevent类的成员函数Init可以知道，这将会导致MessagePumpLibevent类的静态成员函数OnWakeup被调用，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpLibevent::OnWakeup(<span class="keyword">int</span> socket, <span class="keyword">short</span> flags, <span class="keyword">void</span>* context) &#123;</span><br><span class="line">MessagePumpLibevent* that = <span class="keyword">static_cast</span>&lt;MessagePumpLibevent*&gt;(context);</span><br><span class="line">DCHECK(that-&gt;wakeup_pipe_out_ == socket);</span><br><span class="line"><span class="comment">// Remove and discard the wakeup byte.</span></span><br><span class="line"><span class="keyword">char</span> buf;</span><br><span class="line"><span class="keyword">int</span> nread = HANDLE_EINTR(read(socket, &amp;buf, <span class="number">1</span>));</span><br><span class="line">DCHECK_EQ(nread, <span class="number">1</span>);</span><br><span class="line">that-&gt;processed_io_events_ = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Tell libevent to break out of inner loop.</span></span><br><span class="line">event_base_loopbreak(that-&gt;event_base_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_libevent.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的静态成员函数OnWakeup首先是调用函数read将前面写入到管道的字符读取出来，并且调用Libevent提供的函数event_base_loopbreak使得MessagePumpLibevent类的成员函数Run可以从函数event_base_loop返回，以便可以去处理消息队列的消息。</p>
<h2 id="监控文件描述符IO事件"><a href="#监控文件描述符IO事件" class="headerlink" title="监控文件描述符IO事件"></a>监控文件描述符IO事件</h2><p>&#160; &#160; &#160; &#160;前面提到，MessagePumpLibevent除了用来监控消息队列之外，还可以用来监控指定文件描述符的IO事件。这是通过调用MessagePumpLibevent类的成员函数WatchFileDescriptor实现的，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessagePumpLibevent::WatchFileDescriptor(<span class="keyword">int</span> fd,</span><br><span class="line"><span class="keyword">bool</span> persistent,</span><br><span class="line"><span class="keyword">int</span> mode,</span><br><span class="line">FileDescriptorWatcher *controller,</span><br><span class="line">Watcher *delegate) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//根据参数persistent和mode初始化好一个event_mask</span></span><br><span class="line"><span class="comment">//是否要持续监控参数mode描述的IO事件</span></span><br><span class="line"><span class="keyword">int</span> event_mask = persistent ? EV_PERSIST : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (mode &amp; WATCH_READ) &#123;</span><br><span class="line">event_mask |= EV_READ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mode &amp; WATCH_WRITE) &#123;</span><br><span class="line">event_mask |= EV_WRITE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数ReleaseEvent检查其内部是否提供了一个event</span></span><br><span class="line">scoped_ptr&lt;event&gt; evt(controller-&gt;ReleaseEvent());</span><br><span class="line"><span class="keyword">if</span> (evt.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//如果没有提供，那么创建一个新的event，以便用来监控文件描述符fd的IO事件</span></span><br><span class="line"><span class="comment">// Ownership is transferred to the controller.</span></span><br><span class="line">evt.reset(<span class="keyword">new</span> event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果有提供，则复用它</span></span><br><span class="line"><span class="comment">// Make sure we don't pick up any funky internal libevent masks.</span></span><br><span class="line"><span class="keyword">int</span> old_interest_mask = evt.get()-&gt;ev_events &amp;</span><br><span class="line">(EV_READ | EV_WRITE | EV_PERSIST);</span><br><span class="line"><span class="comment">//复用不仅仅是event对象本身，还包括该event对象原来设置的event_mask</span></span><br><span class="line"><span class="comment">// Combine old/new event masks.</span></span><br><span class="line">event_mask |= old_interest_mask;</span><br><span class="line"><span class="comment">// Must disarm the event before we can reuse it.</span></span><br><span class="line">event_del(evt.get());</span><br><span class="line"><span class="comment">//同时，能够复用有一个前提，就是被复用的event关联的文件描述符必须要与参数fd描述的文件描述符一致</span></span><br><span class="line"><span class="keyword">if</span> (EVENT_FD(evt.get()) != fd) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set current interest mask and message pump for this event.</span></span><br><span class="line"><span class="comment">//函数event_set重新设置前面获得的event的属性，</span></span><br><span class="line"><span class="comment">//包括它要监控的文件描述符、要监控的具体IO事件、以及监控的IO事件发生时的回调函数等</span></span><br><span class="line"><span class="comment">//当文件描述符fd指定的IO事件发生时，</span></span><br><span class="line"><span class="comment">//MessagePumpLibevent类的静态成员函数OnLibeventNotification就会被调用</span></span><br><span class="line">event_set(evt.get(), fd, event_mask, OnLibeventNotification, controller);</span><br><span class="line"><span class="comment">// Tell libevent which message pump this socket will belong to when we add it.</span></span><br><span class="line"><span class="comment">//函数event_base_set和event_add将前面已经设置好属性的event</span></span><br><span class="line"><span class="comment">//增加到成员变量event_base_描述的一个事件监控对象中去</span></span><br><span class="line"><span class="keyword">if</span> (event_base_set(event_base_, evt.get())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add this socket to the list of monitored sockets.</span></span><br><span class="line"><span class="keyword">if</span> (event_add(evt.get(), <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Transfer ownership of evt to controller.</span></span><br><span class="line">controller-&gt;Init(evt.release());</span><br><span class="line">controller-&gt;set_watcher(delegate);</span><br><span class="line">controller-&gt;set_pump(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_libevent.cc中。</p>
<p>&#160; &#160; &#160; &#160;各个参数的含义如下所示:</p>
<ol>
<li>fd:要监控其IO事件的文件描述符。</li>
<li>persistent:是否要持续监控参数mode描述的IO事件。</li>
<li>mode:具体的IO事件，例如读写事件等。</li>
<li>controller:指向一个负责接收IO事件通知的FileDescriptorWatcher对象。</li>
<li>delegate:指向一个Watcher对象，参数controller将接收到的IO事件转发给它处理。</li>
</ol>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的成员函数WatchFileDescriptor首先是根据参数persistent和mode初始化好一个event_mask，接下来调用event_set设置一个代表IO监控事件的event时要用到。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的成员函数WatchFileDescriptor接下来调用参数controller描述的一个FileDescriptorWatcher对象的成员函数ReleaseEvent检查其内部是否提供了一个event。如果没有提供，那么创建一个新的event，以便用来监控文件描述符fd的IO事件。如果有提供，则复用它。复用不仅仅是event对象本身，还包括该event对象原来设置的event_mask。同时，能够复用有一个前提，就是被复用的event关联的文件描述符必须要与参数fd描述的文件描述符一致。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的成员函数WatchFileDescriptor接下来调用Libevent提供的函数event_set重新设置前面获得的event的属性，包括它要监控的文件描述符、要监控的具体IO事件、以及监控的IO事件发生时的回调函数等。从这里就可以看到，当文件描述符fd指定的IO事件发生时，MessagePumpLibevent类的静态成员函数OnLibeventNotification就会被调用，并且会获得参数controller指向的一个FileDescriptorWatcher对象。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的成员函数WatchFileDescriptor接下来调用Libevent提供的函数event_base_set和event_add将前面已经设置好属性的event增加到成员变量event<em>base</em>描述的一个事件监控对象中去。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的成员函数WatchFileDescriptor最后将用来描述IO事件监控的event、负责处理IO事件的Watcher和以及当前正在处理的一个MessagePumpLibevent对象设置到参数controller描述的一个FileDescriptorWatcher对象的内部去，以便该FileDescriptorWatcher对象在接收到IO事件通知时可以进行相应的处理。</p>
<p>&#160; &#160; &#160; &#160;接下来我们再看被监控的文件描述符发生指定的IO事件时的处理流程，即MessagePumpLibevent类的静态成员函数OnLibeventNotification的实现，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpLibevent::OnLibeventNotification(<span class="keyword">int</span> fd, <span class="keyword">short</span> flags,</span><br><span class="line"><span class="keyword">void</span>* context) &#123;</span><br><span class="line"><span class="comment">//参数context指向的一个FileDescriptorWatcher对象，</span></span><br><span class="line">WeakPtr&lt;FileDescriptorWatcher&gt; controller =</span><br><span class="line"><span class="keyword">static_cast</span>&lt;FileDescriptorWatcher*&gt;(context)-&gt;weak_factory_.GetWeakPtr();</span><br><span class="line">DCHECK(controller.get());</span><br><span class="line">MessagePumpLibevent* pump = controller-&gt;pump();</span><br><span class="line"><span class="comment">//表示关联的MessagePumpLibevent对象有新的IO事件需要处理</span></span><br><span class="line">pump-&gt;processed_io_events_ = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//如果发生的是写事件</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; EV_WRITE) &#123;</span><br><span class="line">controller-&gt;OnFileCanWriteWithoutBlocking(fd, pump);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前面在处理写事件的过程中，</span></span><br><span class="line"><span class="comment">//有可能参数context指向的一个FileDescriptorWatcher对象已经被销毁</span></span><br><span class="line"><span class="comment">// Check |controller| in case it's been deleted in</span></span><br><span class="line"><span class="comment">// controller-&gt;OnFileCanWriteWithoutBlocking().</span></span><br><span class="line"><span class="comment">//如果发生的是读事件</span></span><br><span class="line"><span class="keyword">if</span> (controller.get() &amp;&amp; flags &amp; EV_READ) &#123;</span><br><span class="line">controller-&gt;OnFileCanReadWithoutBlocking(fd, pump);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_pump_libevent.cc中。</p>
<p>&#160; &#160; &#160; &#160;从前面的分析可以知道，参数context指向的一个FileDescriptorWatcher对象，因此MessagePumpLibevent类的静态成员函数OnLibeventNotification首先是将它强制转化为一个FileDescriptorWatcher对象，并且获得一个引用了它的WeakPtr弱智能指针。关于WeakPtr弱智能指针的实现和使用方式，可以参考前面Chromium和WebKit的智能指针实现原理分析一文。</p>
<p>&#160; &#160; &#160; &#160;这里为什么要获得参数context指向的一个FileDescriptorWatcher对象的一个弱智能指针呢?这是因为后面调用它的成员函数OnFileCanWriteWithoutBlocking时，然后该成员函数OnFileCanWriteWithoutBlocking将IO事件分发给它内部的一个Watcher处理时，该FileDescriptorWatcher对象可能会被销毁。为了不阻止该FileDescriptorWatcher对象销毁，于是就使用WeakPtr弱智能指针引用它了。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的静态成员函数OnLibeventNotification接下来调用前面获得的FileDescriptorWatcher对象的成员函数pump获得一个与它关联的MessagePumpLibevent对象，并且将它的成员变量processed_io<em>events</em>的值设置为true，表示关联的MessagePumpLibevent对象有新的IO事件需要处理。这个设置将会影响到前面分析的MessagePumpLibevent类的成员函数Run的运行，因为在这种情况下，MessagePumpLibevent类的成员函数Run不能够去处理延迟消息、也不能执行Idle Work以及进入睡眠等待状态，而是要马上重新执行一次for循环，以及检查有没有更多的需要马上处理IO事件需要处理。</p>
<p>&#160; &#160; &#160; &#160;MessagePumpLibevent类的静态成员函数OnLibeventNotification最后就通过参数flags检查具体发生的IO事件，并且执行相应的处理:</p>
<ol>
<li>如果发生的是写事件，那么就调用参数context指向的一个FileDescriptorWatcher对象的成员函数OnFileCanWriteWithoutBlocking进行处理。</li>
<li>如果发生的是读事件，那么就调用参数context指向的一个FileDescriptorWatcher对象的成员函数OnFileCanReadWithoutBlocking进行处理。如上所述，前面在处理写事件的过程中，有可能参数context指向的一个FileDescriptorWatcher对象已经被销毁，因此，这里要先调用一下WeakPtr弱智能指针controller的成员函数get判断它是否真的已经被销毁。如果已经被销毁，那么就不需要调用它的成员函数OnFileCanReadWithoutBlocking了。</li>
</ol>
<p>&#160; &#160; &#160; &#160;FileDescriptorWatcher类的成员函数OnFileCanWriteWithoutBlocking和OnFileCanReadWithoutBlocking的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessagePumpLibevent::FileDescriptorWatcher::OnFileCanReadWithoutBlocking(</span><br><span class="line"><span class="keyword">int</span> fd, MessagePumpLibevent* pump) &#123;</span><br><span class="line"><span class="comment">// Since OnFileCanWriteWithoutBlocking() gets called first, it can stop</span></span><br><span class="line"><span class="comment">// watching the file descriptor.</span></span><br><span class="line"><span class="comment">//如果一个文件描述符同时发生了读事件和写事件，那么如前所述，先处理写事件，再处理读事件。</span></span><br><span class="line"><span class="comment">//这样就有可能在处理写事件的时候，</span></span><br><span class="line"><span class="comment">//关联的FileDescriptorWatcher对象的成员变量watcher_指向的Watcher对象被销毁了，</span></span><br><span class="line"><span class="comment">//因此在处理读事件的时候，需要先判断成员变量watcher_的值是否为NULL。</span></span><br><span class="line"><span class="comment">//如果为NULL，那么就意味着它之前指向的Watcher对象被销毁了，于是就不用往下处理了。</span></span><br><span class="line"><span class="keyword">if</span> (!watcher_)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//通知关联的MessagePumpLibevent对象将有IO事件被处理</span></span><br><span class="line">pump-&gt;WillProcessIOEvent();</span><br><span class="line"><span class="comment">//将接收到的IO事件通知转发给成员变量watcher_描述的一个Watcher对象处理</span></span><br><span class="line">watcher_-&gt;OnFileCanReadWithoutBlocking(fd);</span><br><span class="line"><span class="comment">//IO事件已处理完毕</span></span><br><span class="line">pump-&gt;DidProcessIOEvent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MessagePumpLibevent::FileDescriptorWatcher::OnFileCanWriteWithoutBlocking(</span><br><span class="line"><span class="keyword">int</span> fd, MessagePumpLibevent* pump) &#123;</span><br><span class="line">DCHECK(watcher_);</span><br><span class="line">pump-&gt;WillProcessIOEvent();</span><br><span class="line"><span class="comment">////将接收到的IO事件通知转发给成员变量watcher_描述的一个Watcher对象处理</span></span><br><span class="line">watcher_-&gt;OnFileCanWriteWithoutBlocking(fd);</span><br><span class="line">pump-&gt;DidProcessIOEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这两个函数定义在文件external/chromium_org/base/message_loop/message_pump_libevent.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里就可以看到，FileDescriptorWatcher类的成员函数OnFileCanWriteWithoutBlocking和OnFileCanReadWithoutBlocking只是简单地将接收到的IO事件通知转发给成员变量watcher_描述的一个Watcher对象处理。在转发前后，它们也会分别调用MessagePumpLibevent类的成员函数WillProcessIOEvent和DidProcessIOEvent通知关联的MessagePumpLibevent对象将有IO事件被处理以及IO事件已处理完毕。</p>
<p>&#160; &#160; &#160; &#160;这里需要注意的一点是，如果一个文件描述符同时发生了读事件和写事件，那么如前所述，先处理写事件，再处理读事件。这样就有可能在处理写事件的时候，关联的FileDescriptorWatcher对象的成员变量watcher<em>指向的Watcher对象被销毁了，因此在处理读事件的时候，需要先判断成员变量watcher</em>的值是否为NULL。如果为NULL，那么就意味着它之前指向的Watcher对象被销毁了，于是就不用往下处理了。</p>
<p>&#160; &#160; &#160; &#160;以上就是通过MessagePumpLibevent类实现消息循环的原理，它与Android应用程序使用的消息循环的实现原理是一样的，因此这里我们并没有很深入地对它进行分析，例如没有深入到Libevent内部去分析，有兴趣的同学可以参考前面Android应用程序消息处理机制(Looper、Handler)分析一文。</p>
<p>&#160; &#160; &#160; &#160;IO线程的消息循环之所以要通过MessagePumpLibevent类来实现消息循环，是因为它的消息循环主要是用来监控一个负责执行IPC的UNIX Socket的，也就是说，Chromium的IPC是通过UNIX Socket进行的。这样当一个进程向另外一个进程发送消息时，就会触发使用的UNIX Socket发生IO事件，然后就会被IO线程的消息循环监控到，最后就可以得到处理。</p>
<h1 id="消息发送接口"><a href="#消息发送接口" class="headerlink" title="消息发送接口"></a>消息发送接口</h1><p>&#160; &#160; &#160; &#160;至此，关于Chromium的线程消息循环我们就分析完毕，但是关于消息发送，还有一些特性值得进一步分析，主要是关于消息的发送接口的。前面我们分析消息发送接口都是通过MessageLoop提供的。也就是说，在往一个线程的消息队列发送消息之前，我们首先要获得这个线程的消息循环，这是通过调用Thread类的成员函数message_loop获得的，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> BASE_EXPORT Thread : PlatformThread::Delegate &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line"><span class="function">MessageLoop* <span class="title">message_loop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> message_loop_; &#125;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个函数定义在文件external/chromium_org/base/threading/thread.h中。</p>
<p>&#160; &#160; &#160; &#160;通过调用Thread类的成员函数message_loop直接获取线程的关联的MessageLoop对象会有一个问题，我们以后通过该MessageLoop对象发送消息时，不能保证该MessageLoop对象是有效的，因为线程有可能退出了，这会导致其关联的MessageLoop对象被销毁了。</p>
<p>&#160; &#160; &#160; &#160;因此，我们需要有一种机制，即使是线程退出了，我们也可以继续持有一个消息发送接口。该消息发送接口能够保证，如果线程还没有退出，那么就能正常地向它发送消息。另一方面，如果线程已经退出，那么最多就是执行一空操作，但是不会造成非法内存访问。</p>
<p>&#160; &#160; &#160; &#160;学习过Chromium和WebKit的智能指针实现原理分析这篇文章之后，我们很容易想到，可以通过scoped_refptr智能指针来实现这种机制。Thread类提供了一个成员函数message_loop_proxy，可以获得线程的一个消息发送代理接口，即一个MessageLoopProxy接口，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT Thread : PlatformThread::Delegate &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line">scoped_refptr&lt;MessageLoopProxy&gt; message_loop_proxy() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> message_loop_ ? message_loop_-&gt;message_loop_proxy() : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/thread.h中。</p>
<p>&#160; &#160; &#160; &#160;这个MessageLoopProxy接口通过scoped_refptr智能指针引用，因此就能保证它还在使用的时候，不会被销毁，即使线程已经退出，这样就能够避免非法内存访问。</p>
<p>&#160; &#160; &#160; &#160;接下来我们就继续分析MessageLoopProxy接口是如何实现的。从Thread类的成员函数message_loop_proxy可以知道，它返回给调用者的MessageLoopProxy接口是通过成员变量message<em>loop</em>指向的一个MessageLoop对象的成员函数message_loop_proxy获得的。 </p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数message_loop_proxy的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT MessageLoop : <span class="keyword">public</span> MessagePump::Delegate &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line">scoped_refptr&lt;MessageLoopProxy&gt; message_loop_proxy() &#123;</span><br><span class="line"><span class="keyword">return</span> message_loop_proxy_;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">......</span><br><span class="line">scoped_refptr&lt;internal::MessageLoopProxyImpl&gt; message_loop_proxy_;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.h中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数message_loop_proxy返回的是成员变量message_loop<em>proxy</em>指向的一个MessageLoopProxyImpl对象。从前面的分析可以知道，这个成员变量是在MessageLoop类的成员函数Init中初始化的，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::Init() &#123;</span><br><span class="line">......</span><br><span class="line">incoming_task_queue_ = <span class="keyword">new</span> internal::IncomingTaskQueue(<span class="keyword">this</span>);</span><br><span class="line">message_loop_proxy_ =</span><br><span class="line"><span class="keyword">new</span> internal::MessageLoopProxyImpl(incoming_task_queue_);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数Init首先创建了一个用来描述线程消息队列的一个IncomingTaskQueue，然后再根据这个IncomingTaskQueue创建了一个MessageLoopProxyImpl对象，并且保存在成员变量message_loop<em>proxy</em>中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoopProxyImpl对象的创建过程如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageLoopProxyImpl::MessageLoopProxyImpl(</span><br><span class="line">scoped_refptr&lt;IncomingTaskQueue&gt; incoming_queue)</span><br><span class="line">: incoming_queue_(incoming_queue),</span><br><span class="line">valid_thread_id_(PlatformThread::CurrentId()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop_proxy_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoopProxyImpl类的构造函数主要就是将参数incoming_queue指向的一个IncomingTaskQueue对象保存在成员变量incoming<em>queue</em>中。注意，MessageLoopProxyImpl类的成员变量incoming<em>queue</em>是一个scoped_refptr智能指针，因此即使它所属的线程退出了，它所引用的IncomingTaskQueue对象仍然是存在的。</p>
<p>&#160; &#160; &#160; &#160;MessageLoopProxyImpl类的继承关系如图所示:</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/MessageLoopProxy.jpg" alt="messageloopproxy"></p>
<p>&#160; &#160; &#160; &#160;从图中可以看到，MessageLoopProxyImpl类从TaskRunner类一路继承下来。TaskRunner类定义了PostTask和PostDelayedTask两个接口。此外，SequencedTaskRunner类又定义了PostNonNestableTask和PostNonNestableDelayedTask两个接口。MessageLoopProxyImpl类本身重写了父类TaskRunner的PostDelayedTask接口以及SequencedTaskRunner类的PostNonNestableDelayedTask接口。这样就使得MessageLoopProxyImpl类像MessageLoop类一样，具有PostTask、PostDelayedTask、PostNonNestableTask和PostNonNestableDelayedTask四个消息发送接口。</p>
<p>&#160; &#160; &#160; &#160;TaskRunner类的成员函数PostTask的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> TaskRunner::PostTask(<span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task) &#123;</span><br><span class="line"><span class="keyword">return</span> PostDelayedTask(from_here, task, base::TimeDelta());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/task_runner.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里就可以看到，TaskRunner类的成员函数PostTask最终通过调用由子类MessageLoopProxyImpl重写的接口PostDelayedTask来向线程的消息队列发送消息。</p>
<p>&#160; &#160; &#160; &#160;SequencedTaskRunner类的成员函数PostNonNestableTask的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> SequencedTaskRunner::PostNonNestableTask(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task) &#123;</span><br><span class="line"><span class="keyword">return</span> PostNonNestableDelayedTask(from_here, task, base::TimeDelta());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/sequenced_task_runner.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里也可以看到，SequencedTaskRunner类的成员函数PostNonNestableTask最终通过调用由子类MessageLoopProxyImpl重写的接口PostNonNestableDelayedTask来向线程的消息队列发送消息。</p>
<p>&#160; &#160; &#160; &#160;因此，无论我们调用MessageLoopProxyImpl类的哪一个消息发送接口，最终都归结为调用PostDelayedTask和PostNonNestableDelayedTask这两个接口，它们的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLoopProxyImpl::PostDelayedTask(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> base::Closure&amp; task,</span><br><span class="line">base::TimeDelta delay) &#123;</span><br><span class="line">DCHECK(!task.is_null()) &lt;&lt; from_here.ToString();</span><br><span class="line"><span class="keyword">return</span> incoming_queue_-&gt;AddToIncomingQueue(from_here, task, delay, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> MessageLoopProxyImpl::PostNonNestableDelayedTask(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> base::Closure&amp; task,</span><br><span class="line">base::TimeDelta delay) &#123;</span><br><span class="line">DCHECK(!task.is_null()) &lt;&lt; from_here.ToString();</span><br><span class="line"><span class="keyword">return</span> incoming_queue_-&gt;AddToIncomingQueue(from_here, task, delay, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这两个函数定义在文件external/chromium_org/base/message_loop/message_loop_proxy_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoopProxyImpl类的成员函数PostDelayedTask和PostNonNestableDelayedTask都是通过调用成员变量imcoming<em>queue</em>指向的一个IncomingTaskQueue对象的成员函数AddToIncomingQueue向线程的消息队列发送消息。</p>
<p>&#160; &#160; &#160; &#160;从前面的分析可以知道，IncomingTaskQueue类的成员函数AddToIncomingQueue最终调用了另外一个成员函数PostPendingTask向线程的消息队列发送消息，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> IncomingTaskQueue::PostPendingTask(PendingTask* pending_task) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// This should only be called while the lock is taken.</span></span><br><span class="line">incoming_queue_lock_.AssertAcquired();</span><br><span class="line"><span class="keyword">if</span> (!message_loop_) &#123;</span><br><span class="line">pending_task-&gt;task.Reset();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">bool</span> was_empty = incoming_queue_.empty();</span><br><span class="line">incoming_queue_.push(*pending_task);</span><br><span class="line">pending_task-&gt;task.Reset();</span><br><span class="line"><span class="comment">// Wake up the pump.</span></span><br><span class="line">message_loop_-&gt;ScheduleWork(was_empty);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/incoming_task_queue.cc中。</p>
<p>&#160; &#160; &#160; &#160;我们注意到，IncomingTaskQueue类的成员函数PostPendingTask在将消息添加到线程的消息队列之前，首先会判断线程的消息循环是否还存在，即判断成员变量message<em>loop</em>的值是否等于NULL。如果等于NULL，那么就说明线程已经退出了，这时候就什么也不做就返回了。</p>
<p>&#160; &#160; &#160; &#160;IncomingTaskQueue类的成员变量message<em>loop</em>是在构造函数中初始化的，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IncomingTaskQueue::IncomingTaskQueue(MessageLoop* message_loop)</span><br><span class="line">: message_loop_(message_loop),</span><br><span class="line">...... &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/incoming_task_queue.cc中。</p>
<p>&#160; &#160; &#160; &#160;现在的重点问题就是，IncomingTaskQueue类的成员变量message<em>loop</em>是什么时候被设置为NULL的呢?也就是它是怎么知道线程退出的呢?</p>
<p>&#160; &#160; &#160; &#160;当线程退出时，MessageLoop对象会被销毁，这时候它的析构函数会被调用，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MessageLoop::~MessageLoop() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// Tell the incoming queue that we are dying.</span></span><br><span class="line">incoming_task_queue_-&gt;WillDestroyCurrentMessageLoop();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的析构函数会调用成员变量incoming_task<em>queue</em>指向的一个IncomingTaskQueue对象的成员函数WillDestroyCurrentMessageLoop通知它线程的消息循环要被销毁了。</p>
<p>&#160; &#160; &#160; &#160;IncomingTaskQueue类的成员函数WillDestroyCurrentMessageLoop的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IncomingTaskQueue::WillDestroyCurrentMessageLoop() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="function">AutoLock <span class="title">lock</span><span class="params">(incoming_queue_lock_)</span></span>;</span><br><span class="line">message_loop_ = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/message_loop/incoming_task_queue.cc中。</p>
<p>&#160; &#160; &#160; &#160;这时候IncomingTaskQueue类的成员变量message<em>loop</em>就会被设置为NULL，这样以后再调用IncomingTaskQueue类的成员函数AddToIncomingQueue就再无法向线程的消息队列发送消息了。</p>
<p>&#160; &#160; &#160; &#160;从图4还可以看到，我们除了可以使用MessageLoopProxy接口向线程的消息队列发送消息之外，还可以通过SingleThreadTaskRunner、SequencedTaskRunner和TaskRunner接口向线程的消息队列发送消息，这一类接口统称为TaskRunner接口。</p>
<p>&#160; &#160; &#160; &#160;TaskRunner是一个用来执行异步任务接口，我们通过它的成员函数PostTask和PostDelayedTask等可以将一个Closure发送给一个线程或者一个线程池执行。由于TaskRunner可能会将不同的Closure交给不同的线程执行，因此不能保证交给它的Closure的执行顺序。TaskRunner唯一能保证的是它不会同步执行交给它的Closure，也就是不会直接调用Closure的成员函数Run。</p>
<p>&#160; &#160; &#160; &#160;SequencedTaskRunner是从TaskRunner继承下来的，但是它比TaskRunner多出一个额外的保证，就是交给它的Closure是按照一定顺序执行的，不会出现两个Closure同时执行的情况。例如，给出两个Closure1和Closure2，如果满足以下三个条件，则能保证Closure2在Closure1之后执行:</p>
<ol>
<li>Closure1比Closure2先Post给SequencedTaskRunner;</li>
<li>Closure1指定的执行时间点小于等于Closure2指定的执行时间点;</li>
<li>Closure1可嵌套消息循环中执行或者Closure2不可嵌套消息循环中执行。</li>
</ol>
<p>&#160; &#160; &#160; &#160;保证Closure2在Closure1之后执行，是说Closure1执行完成之后，才执行Closure2，而不只是说Closure1的开始执行时间点比Closure2的开始执行时间点早。</p>
<p>&#160; &#160; &#160; &#160;SingleThreadTaskRunner是从SequencedTaskRunner继承下来的，但是它比SequencedTaskRunner又多出一个额外的保证，就是交给它的Closure都是由同一个线程执行的，不会出现一个Closure是在一个线程执行，另一个Closure是在另外一个线程执行的情况。</p>
<p>&#160; &#160; &#160; &#160;我们发现一个带消息循环的线程完全能够满足SingleThreadTaskRunner接口的要求，那么我们如何获得一个线程的SingleThreadTaskRunner接口呢?   </p>
<p>&#160; &#160; &#160; &#160;MessageLoop类有一个成员变量thread_task_runner<em>handle</em>，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT MessageLoop : <span class="keyword">public</span> MessagePump::Delegate &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">......</span><br><span class="line">scoped_ptr&lt;ThreadTaskRunnerHandle&gt; thread_task_runner_handle_;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个成员变量定义在文件external/chromium_org/base/message_loop/message_loop.h中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员变量thread_task_runner<em>handle</em>是在前面我们分析过的MessageLoop类的成员函数Init初始化的，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageLoop::Init() &#123;</span><br><span class="line">......</span><br><span class="line">incoming_task_queue_ = <span class="keyword">new</span> internal::IncomingTaskQueue(<span class="keyword">this</span>);</span><br><span class="line">message_loop_proxy_ =</span><br><span class="line"><span class="keyword">new</span> internal::MessageLoopProxyImpl(incoming_task_queue_);</span><br><span class="line">thread_task_runner_handle_.reset(</span><br><span class="line"><span class="keyword">new</span> ThreadTaskRunnerHandle(message_loop_proxy_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个成员变量定义在文件external/chromium_org/base/message_loop/message_loop.cc中。</p>
<p>&#160; &#160; &#160; &#160;MessageLoop类的成员函数Init根据前面创建出来的MessageLoopProxyImpl对象创建了一个ThreadTaskRunnerHandle对象。</p>
<p>&#160; &#160; &#160; &#160;一个ThreadTaskRunnerHandle对象的创建过程如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">base::LazyInstance&lt;base::ThreadLocalPointer&lt;ThreadTaskRunnerHandle&gt; &gt;</span><br><span class="line">lazy_tls_ptr = LAZY_INSTANCE_INITIALIZER;</span><br><span class="line">......</span><br><span class="line">ThreadTaskRunnerHandle::ThreadTaskRunnerHandle(</span><br><span class="line"><span class="keyword">const</span> scoped_refptr&lt;SingleThreadTaskRunner&gt;&amp; task_runner)</span><br><span class="line">: task_runner_(task_runner) &#123;</span><br><span class="line">......</span><br><span class="line">lazy_tls_ptr.Pointer()-&gt;Set(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/thread_task_runner_handle.cc中。</p>
<p>&#160; &#160; &#160; &#160;从图4可以知道，MessageLoopProxyImpl类是从SingleThreadTaskRunner类继承下来的，因此ThreadTaskRunnerHandle类的构造函数可以接受一个MessageLoopProxyImpl对象作为参数。</p>
<p>&#160; &#160; &#160; &#160;ThreadTaskRunnerHandle类的构造函数做了两件事情。第一件事情就是将参数task_runner描述的一个SingleThreadTaskRunner对象保存在成员变量task<em>runner</em>中。第二件事情就是将正在创建的ThreadTaskRunnerHandle对象保存线程局部存储变量lazy_tls_ptr中。</p>
<p>&#160; &#160; &#160; &#160;ThreadTaskRunnerHandle类还提供了一个静态成员函数Get，用来获得保存在线程局部存储变量lazy_tls_ptr的一个ThreadTaskRunnerHandle对象的成员变量task<em>runner</em>描述的一个SingleThreadTaskRunner对象，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scoped_refptr&lt;SingleThreadTaskRunner&gt; ThreadTaskRunnerHandle::Get() &#123;</span><br><span class="line">ThreadTaskRunnerHandle* current = lazy_tls_ptr.Pointer()-&gt;Get();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> current-&gt;task_runner_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/thread_task_runner_handle.cc中。</p>
<p>&#160; &#160; &#160; &#160;这样我们就可以获得一个带消息循环的线程的SingleThreadTaskRunner接口了，这个接口指向的实际上是一个MessageLoopProxyImpl对象，因此最终实际上是通过前面分析的MessageLoopProxyImpl接口来往线程发送消息。</p>
<p>&#160; &#160; &#160; &#160;从图4还可以知道，TaskRunner接口提供了一个成员函数PostTaskAndReply，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BASE_EXPORT TaskRunner</span><br><span class="line">: <span class="keyword">public</span> RefCountedThreadSafe&lt;TaskRunner, TaskRunnerTraits&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PostTaskAndReply</span><span class="params">(<span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; reply)</span></span>;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数声明在文件external/chromium_org/base/task_runner.h中。</p>
<p>&#160; &#160; &#160; &#160;从TaskRunner类的成员函数PostTaskAndReply的声明可以推断出，它用来向一个目标线程请求异步执行一个任务task，并且当该任务执行完成时，向发出请求的线程发送一个reply。它实现的功能正好就是我们在前面图1所描述的线程双向异步通信机制。接下来我们就分析它是如何实现的。</p>
<p>&#160; &#160; &#160; &#160;TaskRunner类的成员函数PostTaskAndReply的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> TaskRunner::PostTaskAndReply(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; reply) &#123;</span><br><span class="line"><span class="keyword">return</span> PostTaskAndReplyTaskRunner(<span class="keyword">this</span>).PostTaskAndReply(</span><br><span class="line">from_here, task, reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/task_runner.cc中。</p>
<p>&#160; &#160; &#160; &#160;TaskRunner类的成员函数PostTaskAndReply首先创建了一个PostTaskAndReplyTaskRunner对象，接着调用这个PostTaskAndReplyTaskRunner对象的成员函数 PostTaskAndReply来实现双向异步通信机制。 </p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyTaskRunner对象的创建过程如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PostTaskAndReplyTaskRunner::PostTaskAndReplyTaskRunner(</span><br><span class="line">TaskRunner* destination) : destination_(destination) &#123;</span><br><span class="line">DCHECK(destination_);</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/task_runner.cc中。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyTaskRunner类的构造函数将参数destination描述的一个TaskRunner对象保存在成员变量destination_中。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyTaskRunner类是从PostTaskAndReplyImpl类继承下来的，并且它的成员函数PostTaskAndReply也是从PostTaskAndReplyImpl类继承下来的，因此前面调用PostTaskAndReplyTaskRunner类的成员函数PostTaskAndReply实际上调用的是PostTaskAndReplyImpl类的成员函数PostTaskAndReply。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyImpl类的成员函数PostTaskAndReply的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PostTaskAndReplyImpl::PostTaskAndReply(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; reply) &#123;</span><br><span class="line">PostTaskAndReplyRelay* relay =</span><br><span class="line"><span class="keyword">new</span> PostTaskAndReplyRelay(from_here, task, reply);</span><br><span class="line"><span class="keyword">if</span> (!PostTask(from_here, Bind(&amp;PostTaskAndReplyRelay::Run,</span><br><span class="line">Unretained(relay)))) &#123;</span><br><span class="line"><span class="keyword">delete</span> relay;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/post_task_and_reply_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyImpl类的成员函数PostTaskAndReply先将参数from_here、task和reply封装在一个PostTaskAndReplyRelay对象中，然后再将调用函数Bind创建一个Closure，并且通过调用由子类PostTaskAndReplyTaskRunner实现的成员函数PostTask执行该Closure，注意，这个Closure绑定的是PostTaskAndReplyRelay类的成员函数Run。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyRelay对象的创建过程如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> PostTaskAndReplyRelay &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">PostTaskAndReplyRelay(<span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task, <span class="keyword">const</span> Closure&amp; reply)</span><br><span class="line">: from_here_(from_here),</span><br><span class="line">origin_loop_(ThreadTaskRunnerHandle::Get()) &#123;</span><br><span class="line">task_ = task;</span><br><span class="line">reply_ = reply;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">tracked_objects::Location from_here_;</span><br><span class="line">scoped_refptr&lt;SingleThreadTaskRunner&gt; origin_loop_;</span><br><span class="line">Closure reply_;</span><br><span class="line">Closure task_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/post_task_and_reply_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyRelay类的构造函数主要就是将参数from_here、task和reply描述的对象分别保存在成员变量from<em>here</em>、task<em>和reply</em>中。另外，它还会通过我们前面分析过的ThreadTaskRunnerHandle类的静态成员函数Get获得一个SingleThreadTaskRunner对象，并且保存在成员变量origin<em>loop</em>中。注意，这个SingleThreadTaskRunner对象是从当前线程获得的，也就是调用了TaskRunner类的成员函数PostTaskAndReply的线程。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyTaskRunner类的成员函数PostTask的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PostTaskAndReplyTaskRunner::PostTask(</span><br><span class="line"><span class="keyword">const</span> tracked_objects::Location&amp; from_here,</span><br><span class="line"><span class="keyword">const</span> Closure&amp; task) &#123;</span><br><span class="line"><span class="keyword">return</span> destination_-&gt;PostTask(from_here, task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/task_runner.cc中。</p>
<p>&#160; &#160; &#160; &#160;从前面的分析可以知道，PostTaskAndReplyTaskRunner类的成员变量destination_指向的一个TaskRunner接口。假设这个TaskRunner接口描述的是一个从带消息循环的线程的获得的MessageLoopProxyImpl对象，那么PostTaskAndReplyTaskRunner类的成员函数PostTask就是通过该MessageLoopProxyImpl对象向线程的消息队列发送参数task描述的一个消息。</p>
<p>&#160; &#160; &#160; &#160;由于参数task指向的是一个Closure对象，并且它绑定的是PostTaskAndReplyRelay类的成员函数Run，因此当上述消息被处理时，PostTaskAndReplyRelay类的成员函数Run就会被调用。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyRelay类的成员函数Run的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> PostTaskAndReplyRelay &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">task_.Run();</span><br><span class="line">origin_loop_-&gt;PostTask(</span><br><span class="line">from_here_,</span><br><span class="line">Bind(&amp;PostTaskAndReplyRelay::RunReplyAndSelfDestruct,</span><br><span class="line">base::Unretained(<span class="keyword">this</span>)));</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/post_task_and_reply_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyRelay类的成员函数Run调用了成员变量task_指向的一个Closure对象的成员函数Run。从前面的分析可以知道，该Closure对象就是最初调用TaskRunner类的成员函数PostTaskAndReply所要执行的Task。</p>
<p>&#160; &#160; &#160; &#160;执行完成成员变量task_指向的一个Closure之后，接下来PostTaskAndReplyRelay类的成员函数Run接下来向最初调用了TaskRunner类的成员函数PostTaskAndReply的线程发送一个Closure，该Closure绑定的是当前正在处理的PostTaskAndReplyRelay对象的成员函数RunReplyAndSelfDestruct。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyRelay类的成员函数RunReplyAndSelfDestruct的实现如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> PostTaskAndReplyRelay &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunReplyAndSelfDestruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DCHECK(origin_loop_-&gt;BelongsToCurrentThread());</span><br><span class="line"><span class="comment">// Force |task_| to be released before |reply_| is to ensure that no one</span></span><br><span class="line"><span class="comment">// accidentally depends on |task_| keeping one of its arguments alive while</span></span><br><span class="line"><span class="comment">// |reply_| is executing.</span></span><br><span class="line">task_.Reset();</span><br><span class="line">reply_.Run();</span><br><span class="line"><span class="comment">// Cue mission impossible theme.</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/base/threading/post_task_and_reply_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;PostTaskAndReplyRelay类的成员函数RunReplyAndSelfDestruct所做的事情就是在最初调用了TaskRunner类的成员函数PostTaskAndReply的线程中执行成员变量reply_描述的一个Closure对象。从前面的分析可以知道，该Closure对象就是最初用TaskRunner类的成员函数PostTaskAndReply时指定的第三个参数reply所描述的Closure对象。</p>
<p>&#160; &#160; &#160; &#160;最后，PostTaskAndReplyRelay类的成员函数RunReplyAndSelfDestruct将当前正在处理的PostTaskAndReplyRelay对象销毁掉。这样，一个双向的异步通信就执行完成了。</p>
<p>&#160; &#160; &#160; &#160;至此，我们就分析完成Chromium的线程消息循环和消息发送机制了。Chromium的多线程模型正是基于这种线程消息循环和消息发送机制设计和实现的，其最大的特点是一切皆异步通信，从而提高各个线程，特别是UI线程的响应性，从而让用户觉得Chromium加载网页的速度很快。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#160; &#160; &#160; &#160;最后，我们分别对Chromium在Android平台实现的线程消息循环和消息发送作一个简要的总结。</p>
<p>&#160; &#160; &#160; &#160;Chromium的线程消息循环根据不同的线程具有不同的实现，具体来说，就是:</p>
<ol>
<li>UI线程和Java线程的消息循环是通过Java层的消息循环实现的，也就是通过Android应用程序使用的消息循环实现的。</li>
<li>IO线程的消息循环是基于Libevent实现的，也就是通过epoll实现的，这是因为IO线程主要是用来执行IPC，而这种IPC是通过UNIX Socket实现的，这意味IO线程的消息循环主要用来监控UNIX Socket文件描述符的，因此就适合使用epoll来实现。</li>
<li>其它类型的线程的消息循环是基于条件变量实现的。</li>
</ol>
<p>&#160; &#160; &#160; &#160;Chromium的线程消息发送可以通过以下三种接口实现:</p>
<ol>
<li>SingleThreadTaskRunner、SequencedTaskRunner和TaskRunner，这三个接口是比MessageLoopProxy和MessageLoop更一般的接口，因为它们不关心负责处理消息的线程是如何实现的。</li>
<li>MessageLoopProxy，这个接口比MessageLoop更好用，因为消息的发送者可以一直持有该接口，而不用关心该接口所关联的线程是否已经退出。</li>
<li>MessageLoop，这个接口要求使用者确保它所关联的线程是否已经退出，如果已经退出，那么是不可以使用的。</li>
</ol>
<p>&#160; &#160; &#160; &#160;理解Chromium的线程消息循环和消息发送机制对理解Chromium的多线程模型非常重要，而在Chromium的源码里大量地使用了这些消息循环和消息处理机制。</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%B8%89%29----%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/meizi.jpeg" alt="meizi"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat.jpg" alt="windrunnerlihuan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="windrunnerlihuan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Chromium/" rel="tag"># Chromium</a>
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/12/Chromium学习之路-二-多线程通信callback回调机制/" rel="next" title="Chromium学习之路(二)----多线程通信callback回调机制">
                <i class="fa fa-chevron-left"></i> Chromium学习之路(二)----多线程通信callback回调机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/02/Chromium学习之路-四-Chromium多进程架构简要介绍和学习计划/" rel="prev" title="Chromium学习之路(四)----Chromium多进程架构简要介绍和学习计划">
                Chromium学习之路(四)----Chromium多进程架构简要介绍和学习计划 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTQwMC83OTYz"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="windrunnerlihuan" />
          <p class="site-author-name" itemprop="name">windrunnerlihuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="mailto:937874128@qq.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope-o"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/windrunnerlihuan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://gank.io/" title="干货集中营" target="_blank">干货集中营</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jcodecraeer.com/" title="泡在网上的日子" target="_blank">泡在网上的日子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#异步通信概述"><span class="nav-number">1.</span> <span class="nav-text">异步通信概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基于任务队列的线程运行模式"><span class="nav-number">1.1.</span> <span class="nav-text">基于任务队列的线程运行模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程模型"><span class="nav-number">2.</span> <span class="nav-text">线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#属性概述"><span class="nav-number">2.1.</span> <span class="nav-text">属性概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的执行过程概述"><span class="nav-number">2.2.</span> <span class="nav-text">线程的执行过程概述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程执行过程"><span class="nav-number">3.</span> <span class="nav-text">线程执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MessageLoop创建"><span class="nav-number">3.1.</span> <span class="nav-text">MessageLoop创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建消息泵"><span class="nav-number">3.1.1.</span> <span class="nav-text">创建消息泵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的运行过程"><span class="nav-number">3.2.</span> <span class="nav-text">线程的运行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WaitableEvent线程睡眠变量"><span class="nav-number">3.2.1.</span> <span class="nav-text">WaitableEvent线程睡眠变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wait实现"><span class="nav-number">3.2.2.</span> <span class="nav-text">Wait实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signal实现"><span class="nav-number">3.2.3.</span> <span class="nav-text">Signal实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步等待者"><span class="nav-number">3.2.4.</span> <span class="nav-text">异步等待者</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发送消息过程"><span class="nav-number">3.3.</span> <span class="nav-text">发送消息过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息执行过程"><span class="nav-number">3.4.</span> <span class="nav-text">消息执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DoWork"><span class="nav-number">3.4.1.</span> <span class="nav-text">DoWork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DoDelayedWork"><span class="nav-number">3.4.2.</span> <span class="nav-text">DoDelayedWork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DoIdleWork"><span class="nav-number">3.4.3.</span> <span class="nav-text">DoIdleWork</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android平台的UI线程"><span class="nav-number">4.</span> <span class="nav-text">Android平台的UI线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IPC的IO线程"><span class="nav-number">5.</span> <span class="nav-text">IPC的IO线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建消息泵-1"><span class="nav-number">5.1.</span> <span class="nav-text">创建消息泵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息循环"><span class="nav-number">5.2.</span> <span class="nav-text">消息循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#监控文件描述符IO事件"><span class="nav-number">5.3.</span> <span class="nav-text">监控文件描述符IO事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息发送接口"><span class="nav-number">6.</span> <span class="nav-text">消息发送接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">windrunnerlihuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("bJlEg1N9ed75pssz1m514avl-gzGzoHsz", "Swtq2cOp8A7KYeJ9lpD5nKAy");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
