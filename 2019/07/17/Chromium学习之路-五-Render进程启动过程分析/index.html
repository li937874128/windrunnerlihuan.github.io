<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="3Gndr5oonivG3ajghQU1MgL0IHoMHT4esMsPKjnbeis" />













  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Chromium,多进程," />





  <link rel="alternate" href="/atom.xml" title="April is your lie" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;有时候我也在想，学这个玩意儿有毛用～其实所学的不一定都能用在工作生活中，但是我们可以借鉴其中的精妙设计，来扩充自己的思维，为以后解决实际问题提供更多的选择。">
<meta property="og:type" content="article">
<meta property="og:title" content="Chromium学习之路(五)----Render进程启动过程分析">
<meta property="og:url" content="http://windrunnerlihuan.com/2019/07/17/Chromium学习之路-五-Render进程启动过程分析/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;有时候我也在想，学这个玩意儿有毛用～其实所学的不一定都能用在工作生活中，但是我们可以借鉴其中的精妙设计，来扩充自己的思维，为以后解决实际问题提供更多的选择。">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/brower_render.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderViewHostImpl.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderProcessHostImpl.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderViewImpl.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderThreadImpl.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderProcessImpl.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderStart_1.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/loadurl.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/ChildProcessService.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/warmup.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/JNI_OnLoad.jpg">
<meta property="og:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/meizi.jpg">
<meta property="og:updated_time" content="2019-08-04T18:05:26.249Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chromium学习之路(五)----Render进程启动过程分析">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;有时候我也在想，学这个玩意儿有毛用～其实所学的不一定都能用在工作生活中，但是我们可以借鉴其中的精妙设计，来扩充自己的思维，为以后解决实际问题提供更多的选择。">
<meta name="twitter:image" content="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/brower_render.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://windrunnerlihuan.com/2019/07/17/Chromium学习之路-五-Render进程启动过程分析/"/>





  <title>Chromium学习之路(五)----Render进程启动过程分析 | April is your lie</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-100464707-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bb4df6db80a16ce54c1fb2c6e1767e18";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=62459705";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500465801");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>




  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1262111741&web_id=1262111741" language="JavaScript"></script>
  </div>






  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">April is your lie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">四月是你的谎言</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://windrunnerlihuan.com/2019/07/17/Chromium学习之路-五-Render进程启动过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="windrunnerlihuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="April is your lie">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Chromium学习之路(五)----Render进程启动过程分析</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-17T15:03:00+08:00">
                2019-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Chromium/" itemprop="url" rel="index">
                    <span itemprop="name">Chromium</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/07/17/Chromium学习之路-五-Render进程启动过程分析/" class="leancloud_visitors" data-flag-title="Chromium学习之路(五)----Render进程启动过程分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&#160; &#160; &#160; &#160;有时候我也在想，学这个玩意儿有毛用～其实所学的不一定都能用在工作生活中，但是我们可以借鉴其中的精妙设计，来扩充自己的思维，为以后解决实际问题提供更多的选择。<br><a id="more"></a></p>
<h1 id="Render进程概述"><a href="#Render进程概述" class="headerlink" title="Render进程概述"></a>Render进程概述</h1><p>&#160; &#160; &#160; &#160;Chrome强大的地方就在于对于对进程的合理应用，比如独特的标签页设计。在配置多进程的情况下，Chromium的网页渲染和JS执行在一个单独的进程中进行。这个进程称为Render进程，由Browser进程启动。在Android平台中，Browser进程就是Android应用程序的主进程，而Render进程就是Android应用程序的Service进程，它们通过UNIX Socket进行通信。</p>
<p>&#160; &#160; &#160; &#160;Render进程启动完成之后，将与Browser进程建立以下的IPC通道，如下图所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/brower_render.jpg" alt="Browser进程与Render进程的IPC通信过程"></p>
<p>&#160; &#160; &#160; &#160;在Browser进程中，一个RenderProcessHost对象用来描述它所启动的一个Render进程，而一个RenderViewHost对象用来描述运行在一个Render进程中的一个网页，我们可以将它理解为浏览器中的一个TAB。这两个对象在Render进程中都有一个对等体，它们分别是一个RenderProcess对象和一个RenderView对象。这里说的对等体，就是它们是Browser进程和Render进程进行IPC的两个端点，类似于TCP/IP网络堆栈中的层对层通信。例如，RenderViewHost和RenderView之间的IPC通信，就代表了Browser进程请求Render进程加载、更新和渲染一个网页。</p>
<p>&#160; &#160; &#160; &#160;RenderViewHost和RenderView之间的IPC通信，实际上是通过一个UNIX Socket进行的。这个UNIX Socket的两端分别被封装为两个Channel对象，分别运行在Browser进程和Render进程各自的IO线程中。这样RenderViewHost和RenderView之间的IPC通信就要通过上述的两个Channel对象进行。</p>
<p>&#160; &#160; &#160; &#160;在Browser进程中，由于RenderViewHost对象运行在主线程中，因此当它需要请求运行在IO线程中的Channel对象执行一次IPC时，就要通过IO线程的消息循环进行。这符合我们在前面Chromium多线程模型设计和实现分析一文中提到的Chromium的多线程设计哲学：每一个对象都只运行在一个线程中，对象之间需要通信时就通过消息循环进行。同样，在Render进程中，由于RenderView对象运行在Render线程中，因此当Render进程的Channel对象接收一个来自Browser进程的RenderViewHost对象的IPC消息时，需要通过Render线程的消息循环将IPC消息转发给RenderView进行处理。从RenderView对象到RenderViewHost对象的通信过程也是类似的。<br>我们分析Render进程的启动过程，目的就是为了能够理解Browser进程和Render进程是如何建立IPC通道的，因为以后Browser进程与Render进程的交互和协作，都是通过这个IPC通道进行的。为此，我们在分析Render进程的启动过程中，将着重分析涉及到的各个对象的初始过程。</p>
<h2 id="相关类结构"><a href="#相关类结构" class="headerlink" title="相关类结构"></a>相关类结构</h2><p>&#160; &#160; &#160; &#160;我们注意到，运行在Browser进程中的通信对象是以Host结尾的，而在运行在Render进程中的对等通信对象，则是没有Host结尾的，因此当我们Chromium的源代码中看到一个对象的类型时，就可以推断出该对象运行在哪个进程中。</p>
<p>&#160; &#160; &#160; &#160;事实上，RenderProcessHost、RenderViewHost、RenderProcess和RenderView仅仅是定义了一个抽象接口，真正用来执行IPC通信的对象，是实现了上述抽象接口的一个实现者对象，这些实现者对象的类型以Impl结尾，因此，RenderProcessHost、RenderViewHost、RenderProcess和RenderView对应的实现者对象的类型就分别为RenderProcessHostImpl、RenderViewHostImpl、RenderProcessImpl和RenderViewImpl。</p>
<p>&#160; &#160; &#160; &#160;为了更好地理解Render进程的启动过程，我们有必要了解上述Impl对象的类关系图。</p>
<p>&#160; &#160; &#160; &#160;RenderViewHostImpl对象的类关系图如下所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderViewHostImpl.jpg" alt="RenderViewHostImpl"></p>
<p>&#160; &#160; &#160; &#160;RenderViewHostImpl类多重继承了RenderViewHost类和RenderWidgetHostImpl类，后面这两个类又有一个共同的虚基类RenderWidgetHost，该虚基类又实现了一个Sender接口，该接口定义了一个重要的成员函数Send，用来执行IPC通信。</p>
<p>&#160; &#160; &#160; &#160;RenderWidgetHostImpl类还实现了一个Listener接口，该接口定义了两个重要的成员函数OnMessageReceived和OnChannelConnected。前者用来接收IPC消息并且进行分发，后者用来在IPC通道建立时执行一些初始化工作。</p>
<p>&#160; &#160; &#160; &#160;实际上，当RenderViewHostImpl类需要发起一次IPC时，它是通过父类RenderWidgetHostImpl的成员变量process_指向的一个RenderProcessHost接口进行的。该RenderProcessHost接口指向的实际上是一个RenderProcessHostImpl对象，它的类关系图如图所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderProcessHostImpl.jpg" alt="RenderProcessHostImpl"></p>
<p>&#160; &#160; &#160; &#160;RenderProcessHostImpl类实现了RenderProcessHost接口，后者又多重继承了Sender和Listener类。</p>
<p>&#160; &#160; &#160; &#160;RenderProcessHostImpl类有一个成员变量channel_，它指向了一个ChannelProxy对象。ChannelProxy类实现了Sender接口，RenderProcessHostImpl类就是通过它来发送IPC消息的。</p>
<p>&#160; &#160; &#160; &#160;ChannelProxy类有一个成员变量context_，它指向了一个ChannelProxy::Context对象。ChannelProxy::Context类实现了Listener接口，因此它可以用来接收IPC消息。ChannelProxy类就是通过ChannelProxy::Context类来发送和接收IPC消息的。</p>
<p>&#160; &#160; &#160; &#160;ChannelProxy::Context类有一个类型为Channel的成员变量channel_，它指向的实际上是一个ChannelPosix对象。ChannelPosix类继承了Channel类，后者又实现了Sender接口。ChannelProxy::Context类就是通过ChannelPosix类发送IPC消息的。</p>
<p>&#160; &#160; &#160; &#160;绕了一圈，总结来说，就是RenderProcessHostImpl类是分别通过ChannelPosix类和ChannelProxy::Context类来发送和接收IPC消息的。</p>
<p>&#160; &#160; &#160; &#160;上面分析的RenderViewHostImpl对象和RenderProcessHostImpl对象都是运行在Browser进程的，接下来要分析的RenderViewImpl类和RenderProcessImpl类是运行在Render进程的。</p>
<p>&#160; &#160; &#160; &#160;RenderViewImpl对象的类关系图如下所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderViewImpl.jpg" alt="RenderViewImpl"></p>
<p>&#160; &#160; &#160; &#160;RenderViewImpl类多重继承了RenderView类和RenderWidget类。RenderView类实现了Sender接口。RenderWidget类也实现了Sender接口，同时也实现了Listener接口，因此它可以用来发送和接收IPC消息。</p>
<p>&#160; &#160; &#160; &#160;RenderWidget类实现了接口Sender的成员函数Send，RenderViewImpl类就是通过它来发送IPC消息的。RenderWidget类的成员函数Send又是通过一个用来描述Render线程的RenderThreadImpl对象来发送IPC类的。这个RenderThreadImpl对象可以通过调用RenderThread类的静态成员函数Get获得。</p>
<p>&#160; &#160; &#160; &#160;RenderThreadImpl对象的类关系图如下所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderThreadImpl.jpg" alt="RenderThreadImpl"></p>
<p>&#160; &#160; &#160; &#160;RenderThreadImpl类多重继承了RenderThread类和ChildThread类。RenderThread类实现了Sender接口。ChildThread类也实现Sender接口，同时也实现了Listener接口，因此它可以用来发送和接收IPC消息。</p>
<p>&#160; &#160; &#160; &#160;ChildThread类有一个成员变量channel<em>，它指向了一个SyncChannel对象。SyncChannel类继承了上面提到的ChannelProxy类，因此，ChildThread类通过其成员变量channel</em>指向的SyncChannel对象可以发送IPC消息。</p>
<p>&#160; &#160; &#160; &#160;从上面的分析又可以知道，ChannelProxy类最终是通过ChannelPosix类发送IPC消息的，因此总结来说，就是RenderThreadImpl是通过ChannelPosix类发送IPC消息的。</p>
<p>&#160; &#160; &#160; &#160;接下来我们再来看RenderProcessImpl对象的类关系图，如下所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderProcessImpl.jpg" alt="RenderProcessImpl"></p>
<p>&#160; &#160; &#160; &#160;RenderProcessImpl类继承了RenderProcess类，RenderProcess类又继承了ChildProcess类。ChildProcess类有一个成员变量io<em>thread</em>，它指向了一个Thread对象。该Thread对象描述的就是Render进程的IO线程。</p>
<h1 id="Render进程启动过程"><a href="#Render进程启动过程" class="headerlink" title="Render进程启动过程"></a>Render进程启动过程</h1><p>&#160; &#160; &#160; &#160;有了上面的基础知识之后，接下来我们开始分析Render进程的启动过程。我们将Render进程的启动过程划分为两部分。第一部分是在Browser进程中执行的，它主要负责创建一个UNIX Socket，并且将该UNIX Socket的Client端描述符传递给接下来要创建的Render进程。第二部分是在Render进程中执行的，它负责执行一系列的初始化工作，其中之一就是将Browser进程传递过来的UNIX Socket的Client端描述符封装在一个Channel对象中，以便以后可以通过它来和Browser进程执行IPC。</p>
<h2 id="Render进程启动过程的第一部分"><a href="#Render进程启动过程的第一部分" class="headerlink" title="Render进程启动过程的第一部分"></a>Render进程启动过程的第一部分</h2><p>&#160; &#160; &#160; &#160;Render进程启动过程的第一部分子过程如下所示：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/RenderStart_1.jpg" alt="RenderStart_1"></p>
<p>&#160; &#160; &#160; &#160;图中列出的仅仅是一些核心过程，接下来我们通过代码来分析这些核心过程。</p>
<p>&#160; &#160; &#160; &#160;我们首先了解什么情况下Browser进程会启动一个Render进程。当我们在Chromium的地址栏输入一个网址，然后进行加载的时候，Browser进程经过判断，发现需要在一个新的Render进程中渲染该网址的内容时，就会创建一个RenderViewHostImpl对象，并且调用它的成员函数CreateRenderView触发启动一个新的Render进程。后面我们分析WebView加载一个URL的时候，就会看到触发创建RenderViewHostImpl对象的流程。</p>
<p>&#160; &#160; &#160; &#160;RenderViewHostImpl对象的创建过程，即RenderViewHostImpl类的构造函数的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RenderViewHostImpl::RenderViewHostImpl(</span><br><span class="line">    SiteInstance* instance,</span><br><span class="line">    RenderViewHostDelegate* delegate,</span><br><span class="line">    RenderWidgetHostDelegate* widget_delegate,</span><br><span class="line">    <span class="keyword">int</span> routing_id,</span><br><span class="line">    <span class="keyword">int</span> main_frame_routing_id,</span><br><span class="line">    <span class="keyword">bool</span> swapped_out,</span><br><span class="line">    <span class="keyword">bool</span> hidden)</span><br><span class="line">    : RenderWidgetHostImpl(widget_delegate,</span><br><span class="line">                           instance-&gt;GetProcess(),</span><br><span class="line">                           routing_id,</span><br><span class="line">                           hidden),</span><br><span class="line">      ...... &#123;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/renderer_host/render_view_host_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;这里我们主要关注类型为SiteInstance的参数instance，它指向的实际上是一个SiteInstanceImpl对象，用来描述Chromium当前加载的一个网站实例。RenderViewHostImpl类的构造函数调用该SiteInstanceImpl对象的成员函数GetProcess获得一个RenderProcessHostImpl对象，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">RenderProcessHost* SiteInstanceImpl::GetProcess() &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Create a new process if ours went away or was reused.</span></span><br><span class="line">  <span class="comment">//如果process_为null表示没有为当前site创建一个render对象</span></span><br><span class="line">  <span class="keyword">if</span> (!process_) &#123;</span><br><span class="line">    BrowserContext* browser_context = browsing_instance_-&gt;browser_context();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If we should use process-per-site mode (either in general or for the</span></span><br><span class="line">    <span class="comment">// given site), then look for an existing RenderProcessHost for the site.</span></span><br><span class="line">    <span class="comment">//指定了同一个网站的所有网页都在同一个Render进程中加载，</span></span><br><span class="line">    <span class="comment">//检查之前是否已经为当前正在处理的SiteInstanceImpl对象描述的网站创建过Render进程，</span></span><br><span class="line">    <span class="comment">//如果已经创建过，那么就可以获得一个对应的RenderProcessHostImpl对象</span></span><br><span class="line">    <span class="keyword">bool</span> use_process_per_site = has_site_ &amp;&amp;</span><br><span class="line">        RenderProcessHost::ShouldUseProcessPerSite(browser_context, site_);</span><br><span class="line">    <span class="keyword">if</span> (use_process_per_site) &#123;</span><br><span class="line">      process_ = RenderProcessHostImpl::GetProcessHostForSite(browser_context,</span><br><span class="line">                                                              site_);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If not (or if none found), see if we should reuse an existing process.</span></span><br><span class="line">    <span class="comment">//如果上面case不通过</span></span><br><span class="line">    <span class="comment">//由于当前创建的Render进程已经超出预设的最大数量了</span></span><br><span class="line">    <span class="comment">//就要服用已经创建过的render进程了</span></span><br><span class="line">    <span class="keyword">if</span> (!process_ &amp;&amp; RenderProcessHostImpl::ShouldTryToUseExistingProcessHost(</span><br><span class="line">            browser_context, site_)) &#123;</span><br><span class="line">      process_ = RenderProcessHostImpl::GetExistingProcessHost(browser_context,</span><br><span class="line">                                                               site_);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Otherwise (or if that fails), create a new one.</span></span><br><span class="line">    <span class="comment">//如果上面两种case都failed，就得自己创建一个render进程了</span></span><br><span class="line">    <span class="keyword">if</span> (!process_) &#123;</span><br><span class="line">      <span class="comment">//如果该静态成员变量被设置了指向一个RenderProcessHostFactory对象，</span></span><br><span class="line">      <span class="comment">//那么就调用该RenderProcessHostFactory对象的成员函数CreateRenderProcessHost创建一个从RenderProcessHost类继承下来的子类对象</span></span><br><span class="line">      <span class="keyword">if</span> (g_render_process_host_factory_) &#123;</span><br><span class="line">        process_ = g_render_process_host_factory_-&gt;CreateRenderProcessHost(</span><br><span class="line">            browser_context, <span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则的话，就直接创建一个RenderProcessHostImpl对象。</span></span><br><span class="line">        StoragePartitionImpl* partition =</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;StoragePartitionImpl*&gt;(</span><br><span class="line">                BrowserContext::GetStoragePartition(browser_context, <span class="keyword">this</span>));</span><br><span class="line">        process_ = <span class="keyword">new</span> RenderProcessHostImpl(browser_context,</span><br><span class="line">                                             partition,</span><br><span class="line">                                             site_.SchemeIs(kGuestScheme));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> process_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/site_instance_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;SiteInstanceImpl对象的成员变量process<em>是一个RenderProcessHost指针，当它的值等于NULL的时候，就表示Chromium还没有为当前正在处理的一个SiteInstanceImpl对象创建过Render进程，这时候就需要创建一个RenderProcessHostImpl对象，并且保存在成员变量process</em>中，以及返回给调用者，以便调用者接下来可以通过它启动一个Render进程。另一方面，如果SiteInstanceImpl对象的成员变量process_已经指向了一个RenderProcessHostImpl对象，那么就直接将该RenderProcessHostImpl对象返回给调用者即可。</p>
<p>&#160; &#160; &#160; &#160;注意上述RenderProcessHostImpl对象的创建过程：</p>
<ol>
<li><p>如果Chromium启动时，指定了同一个网站的所有网页都在同一个Render进程中加载，即本地变量use_process_per_site的值等于true，那么这时候SiteInstanceImpl类的成员函数GetProcess就会先调用RenderProcessHostImpl类的静态函数GetProcessHostForSite检查之前是否已经为当前正在处理的SiteInstanceImpl对象描述的网站创建过Render进程。如果已经创建过，那么就可以获得一个对应的RenderProcessHostImpl对象。</p>
</li>
<li><p>如果按照上面的方法找不到一个相应的RenderProcessHostImpl对象，本来就应该要创建一个新的Render进程了，也就是要创建一个新的RenderProcessHostImpl对象了。但是由于当前创建的Render进程已经超出预设的最大数量了，这时候就要复用前面已经启动的Render进程，即使这个Render进程加载的是另一个网站的内容。</p>
</li>
<li><p>如果通过前面两步仍然找不到一个对应的RenderProcessHostImpl对象，这时候就真的是需要创建一个RenderProcessHostImpl对象了。取决于SiteInstanceImpl类的静态成员变量g_render_process_host<em>factory</em>是否被设置，创建一个新的RenderProcessHostImpl对象的方式有所不同。如果该静态成员变量被设置了指向一个RenderProcessHostFactory对象，那么就调用该RenderProcessHostFactory对象的成员函数CreateRenderProcessHost创建一个从RenderProcessHost类继承下来的子类对象。否则的话，就直接创建一个RenderProcessHostImpl对象。</p>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;这一步执行完成后，回到RenderViewHostImpl类的构造函数中，从这里返回的RenderProcessHostImpl对象用来初始化RenderViewHostImpl类的父类RenderWidgetHostImpl，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RenderWidgetHostImpl::RenderWidgetHostImpl(RenderWidgetHostDelegate* delegate,</span><br><span class="line">                                           RenderProcessHost* process,</span><br><span class="line">                                           <span class="keyword">int</span> routing_id,</span><br><span class="line">                                           <span class="keyword">bool</span> hidden)</span><br><span class="line">    : ......,</span><br><span class="line">      process_(process),</span><br><span class="line">      ...... &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/renderer_host/render_widget_host_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;参数process指向的RenderProcessHostImpl对象保存在RenderWidgetHostImpl类的成员变量process_中，以后就可以通过RenderWidgetHostImpl类的成员函数GetProcess获得该RenderProcessHostImpl对象，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RenderProcessHost* RenderWidgetHostImpl::GetProcess() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> process_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/renderer_host/render_widget_host_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;有了RenderProcessHostImpl之后，接下来我们就开始分析RenderViewHostImpl类的成员函数CreateRenderView创建一个新的Render进程的过程了，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RenderViewHostImpl::CreateRenderView(</span><br><span class="line">    <span class="keyword">const</span> base::string16&amp; frame_name,</span><br><span class="line">    <span class="keyword">int</span> opener_route_id,</span><br><span class="line">    <span class="keyword">int</span> proxy_route_id,</span><br><span class="line">    int32 max_page_id,</span><br><span class="line">    <span class="keyword">bool</span> window_was_created_with_opener) &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!GetProcess()-&gt;Init())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/renderer_host/render_view_host_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;RenderViewHostImpl类的成员函数CreateRenderView首先调用从父类RenderWidgetHostImpl继承下来的成员函数GetProcess获得一个RenderProcessHostImpl对象，接着再调用该RenderProcessHostImpl对象的成员函数Init检查是否需要为当前加载的网页创建一个新的Render进程。</p>
<p>&#160; &#160; &#160; &#160;RenderProcessHostImpl类的成员函数Init的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RenderProcessHostImpl::Init() &#123;</span><br><span class="line">  <span class="comment">// calling Init() more than once does nothing, this makes it more convenient</span></span><br><span class="line">  <span class="comment">// for the view host which may not be sure in some cases</span></span><br><span class="line">  <span class="comment">//已经为当前要加载的网而创建过Render进程了</span></span><br><span class="line">  <span class="keyword">if</span> (channel_)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Setup the IPC channel.</span></span><br><span class="line">  <span class="comment">//为IPC channel创建一个唯一id</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> channel_id =</span><br><span class="line">      IPC::Channel::GenerateVerifiedChannelID(<span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line">  <span class="comment">//创建IPC Channel Server</span></span><br><span class="line">  channel_ = IPC::ChannelProxy::Create(</span><br><span class="line">      channel_id,</span><br><span class="line">      IPC::Channel::MODE_SERVER,</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      BrowserThread::GetMessageLoopProxyForThread(BrowserThread::IO).get());</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//创建一系列的Message Filter，用来过滤IPC消息。</span></span><br><span class="line">  CreateMessageFilters();</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//如果所有网页都在Browser进程中加载，即不单独创建Render进程来加载网页</span></span><br><span class="line">  <span class="keyword">if</span> (run_renderer_in_process()) &#123;</span><br><span class="line">    ......</span><br><span class="line">    in_process_renderer_.reset(g_renderer_main_thread_factory(channel_id));</span><br><span class="line"> </span><br><span class="line">    base::Thread::Options options;</span><br><span class="line">    ......</span><br><span class="line">    options.message_loop_type = base::MessageLoop::TYPE_DEFAULT;</span><br><span class="line">    </span><br><span class="line">    in_process_renderer_-&gt;StartWithOptions(options);</span><br><span class="line"> </span><br><span class="line">    g_in_process_thread = in_process_renderer_-&gt;message_loop();</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果网页要单独的Render进程中加载，那么调用创建一个命令行</span></span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    CommandLine* cmd_line = <span class="keyword">new</span> CommandLine(renderer_path);</span><br><span class="line">    ......</span><br><span class="line">    AppendRendererCommandLine(cmd_line);</span><br><span class="line">    cmd_line-&gt;AppendSwitchASCII(switches::kProcessChannelID, channel_id);</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//ChildProcessLauncher对象在创建的过程，就会启动一个新的Render进程。</span></span><br><span class="line">    child_process_launcher_.reset(<span class="keyword">new</span> ChildProcessLauncher(</span><br><span class="line">        <span class="keyword">new</span> RendererSandboxedProcessLauncherDelegate(channel_.get()),</span><br><span class="line">        cmd_line,</span><br><span class="line">        GetID(),</span><br><span class="line">        <span class="keyword">this</span>));</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/renderer_host/render_process_host_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;RenderProcessHostImpl类有一个类型为scoped<em>ptr<ipc::channelproxy>成员变量channel</ipc::channelproxy></em>，当它引用了一个IPC::ChannelProxy对象的时候，就表明已经为当前要加载的网而创建过Render进程了，因此在这种情况下，就无需要往前执行了。</p>
<p>&#160; &#160; &#160; &#160;我们假设到目前为止，还没有为当前要加载的网页创建过Render进程。接下来RenderProcessHostImpl类的成员函数Init就会做以下四件事情：</p>
<ol>
<li><p>先调用IPC::Channel类的静态成员函数GenerateVerifiedChannelID生成一个接下来用于创建UNIX Socket的名字，接着再以该名字为参数，调用IPC::ChannelProxy类的静态成员函数Create创建一个用于执行IPC的Channel，该Channel就保存在RenderProcessHostImpl类的成员变量channel_中。</p>
</li>
<li><p>调用RenderProcessHostImpl类的成员函数CreateMessageFilters创建一系列的Message Filter，用来过滤IPC消息。</p>
</li>
<li><p>如果所有网页都在Browser进程中加载，即不单独创建Render进程来加载网页，那么这时候调用父类RenderProcessHost的静态成员函数run_renderer_in_process的返回值就等于true。在这种情况下，就会通过在本进程（即Browser进程）创建一个新的线程来渲染网页。这个线程由RenderProcessHostImpl类的静态成员变量g_renderer_main_thread_factory描述的一个函数创建，它的类型为InProcessRendererThread。InProcessRendererThread类继承了base::Thread类，从前面Chromium多线程模型设计和实现分析一文可以知道，当调用它的成员函数StartWithOptions的时候，新的线程就会运行起来。这时候如果我们再调用它的成员函数message_loop，就可以获得它的Message Loop。有了这个Message Loop之后，以后就可以向它发送消息了。</p>
</li>
<li><p>如果网页要单独的Render进程中加载，那么调用创建一个命令行，并且以该命令行以及前面创建的IPC::ChannelProxy对象为参数，创建一个ChildProcessLauncher对象，而该ChildProcessLauncher对象在创建的过程，就会启动一个新的Render进程。</p>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;接下来，我们主要分析第1、3和4件事情，第2件事情在接下来的一篇文章中分析IPC消息分发机制时再分析。</p>
<h3 id="IPC-Channel-Server创建"><a href="#IPC-Channel-Server创建" class="headerlink" title="IPC Channel Server创建"></a>IPC Channel Server创建</h3><p>&#160; &#160; &#160; &#160;第一件事情涉及到IPC::Channel类的静态成员函数GenerateVerifiedChannelID和IPC::ChannelProxy类的静态成员函数Create。</p>
<p>&#160; &#160; &#160; &#160;IPC::Channel类的静态成员函数GenerateVerifiedChannelID的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Channel::GenerateVerifiedChannelID(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; prefix) &#123;</span><br><span class="line">  <span class="comment">// A random name is sufficient validation on posix systems, so we don't need</span></span><br><span class="line">  <span class="comment">// an additional shared secret.</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> id = prefix;</span><br><span class="line">  <span class="keyword">if</span> (!id.empty())</span><br><span class="line">    id.append(<span class="string">"."</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> id.append(GenerateUniqueRandomChannelID());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;IPC::Channel类的静态成员函数GenerateVerifiedChannelID实际上是调用另外一个静态成员函数GenerateUniqueRandomChannelID生成一个唯一的随机名字，后者的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">base::StaticAtomicSequenceNumber g_last_id;</span><br><span class="line"> </span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Channel::GenerateUniqueRandomChannelID() &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> process_id = base::GetCurrentProcId();</span><br><span class="line">  <span class="keyword">return</span> base::StringPrintf(<span class="string">"%d.%u.%d"</span>,</span><br><span class="line">      process_id,</span><br><span class="line">      g_last_id.GetNext(),</span><br><span class="line">      base::RandInt(<span class="number">0</span>, <span class="built_in">std</span>::numeric_limits&lt;int32&gt;::max()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里就可以看到，这个用来创建UNIX Socket的名字由当前进程的PID、一个顺序数和一个随机数通过”.”符号连接而成的。</p>
<p>&#160; &#160; &#160; &#160;回到RenderProcessHostImpl类的成员函数Init中，有了用来创建UNIX Socket的名字之后，就可以调用IPC::ChannelProxy类的静态成员函数Create创建一个Channel了，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scoped_ptr&lt;ChannelProxy&gt; ChannelProxy::Create(</span><br><span class="line">    <span class="keyword">const</span> IPC::ChannelHandle&amp; channel_handle,</span><br><span class="line">    Channel::Mode mode,</span><br><span class="line">    Listener* listener,</span><br><span class="line">    base::SingleThreadTaskRunner* ipc_task_runner) &#123;</span><br><span class="line">  scoped_ptr&lt;ChannelProxy&gt; channel(<span class="keyword">new</span> ChannelProxy(listener, ipc_task_runner));</span><br><span class="line">  channel-&gt;Init(channel_handle, mode, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> channel.Pass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_proxy.cc中。</p>
<p>&#160; &#160; &#160; &#160;IPC::ChannelProxy类的静态成员函数Create首先是创建了一个ChannelProxy对象，然后再调用该ChannelProxy对象的成员函数Init执行初始化工作，最后返回该ChannelProxy对象给调用者。</p>
<p>&#160; &#160; &#160; &#160;ChannelProxy对象的创建过程如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ChannelProxy::ChannelProxy(Listener* listener,</span><br><span class="line">                           base::SingleThreadTaskRunner* ipc_task_runner)</span><br><span class="line">    : context_(<span class="keyword">new</span> Context(listener, ipc_task_runner)), did_init_(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_proxy.cc。</p>
<p>&#160; &#160; &#160; &#160;ChannelProxy类的构造函数主要是创建一个ChannelProxy::Context对象，并且将该ChannelProxy::Context对象保存在成员变量context_中。</p>
<p>&#160; &#160; &#160; &#160;ChannelProxy::Context对象的创建过程如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChannelProxy::Context::Context(Listener* listener,</span><br><span class="line">                               base::SingleThreadTaskRunner* ipc_task_runner)</span><br><span class="line">    : listener_task_runner_(base::ThreadTaskRunnerHandle::Get()),</span><br><span class="line">      listener_(listener),</span><br><span class="line">      ipc_task_runner_(ipc_task_runner),</span><br><span class="line">      ......</span><br><span class="line">      message_filter_router_(<span class="keyword">new</span> MessageFilterRouter()),</span><br><span class="line">      ...... &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_proxy.cc中。</p>
<p>&#160; &#160; &#160; &#160;ChannelProxy::Context类有三个成员变量是需要特别关注的，它们分别是：</p>
<ol>
<li><p>listenter_task<em>runner</em>。这个成员变量的类型为scoped_refptr&lt; base::SingleThreadTaskRunner &gt;，它指向的是一个SingleThreadTaskRunner对象。这个SingleThreadTaskRunner对象通过调用ThreadTaskRunnerHandle类的静态成员函数Get获得。从前面Chromium多线程模型设计和实现分析一文可以知道，ThreadTaskRunnerHandle类的静态成员函数Get返回的SingleThreadTaskRunner对象实际上是当前线程的一个MessageLoopProxy对象，通过该MessageLoopProxy对象可以向当前线程的消息队列发送消息。当前线程即为Browser进程的主线程。</p>
</li>
<li><p>listener<em>。这是一个IPC::Listener指针，它的值设置为参数listener的值。从前面的图3可以知道，RenderProcessHostImpl类实现了IPC::Listener接口，而且从前面的调用过程过程可以知道，参数listener指向的就是一个RenderProcessHostImpl对象。以后正在创建的ChannelProxy::Context对象在IO线程中接收到Render进程发送过来的IPC消息之后，就会转发给成员变量listener</em>指向的RenderProcessHostImpl对象处理，但是并不是让后者直接在IO线程处理，而是让后者在成员变量listener_task<em>runner</em>描述的线程中处理，即Browser进程的主线程处理。也就是说，ChannelProxy::Context类的成员变量listener_task<em>runner</em>和listener_是配合在一起使用的，后面我们分析IPC消息的分发机制时就可以看到这一点。</p>
</li>
<li><p>ipc_task<em>runner</em>。这个成员变量与前面分析的成员变量listener_task_runner一样，类型都为scoped_refptr&lt; base::SingleThreadTaskRunner &gt;，指向的者是一个SingleThreadTaskRunner对象。不过，这个SingleThreadTaskRunner对象由参数ipc_task_runner指定。从前面的调用过程可以知道，这个SingleThreadTaskRunner对象实际上是与Browser进程的IO线程关联的一个MessageLoopProxy对象。这个MessageLoopProxy对象用来接收Render进程发送过来的IPC消息。也就是说，Browser进程在IO线程中接收IPC消息。</p>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;ChannelProxy::Context类还有一个重要的成员变量message_filter<em>router</em>，它指向一个MessageFilterRouter对象，用来过滤IPC消息，后面我们分析IPC消息的分发机制时再详细分析。</p>
<p>&#160; &#160; &#160; &#160;回到ChannelProxy类的静态成员函数Create中，创建了一个ChannelProxy对象之后，接下来就调用它的成员函数Init进行初始化，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ChannelProxy::Init(<span class="keyword">const</span> IPC::ChannelHandle&amp; channel_handle,</span><br><span class="line">                        Channel::Mode mode,</span><br><span class="line">                        <span class="keyword">bool</span> create_pipe_now) &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (create_pipe_now) &#123;<span class="comment">//true，在当前线程中创建</span></span><br><span class="line">    ......</span><br><span class="line">    context_-&gt;CreateChannel(channel_handle, mode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//而是在IO线程中创建</span></span><br><span class="line">    context_-&gt;ipc_task_runner()-&gt;PostTask(</span><br><span class="line">        FROM_HERE, base::Bind(&amp;Context::CreateChannel, context_.get(),</span><br><span class="line">                              channel_handle, mode));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// complete initialization on the background thread</span></span><br><span class="line">  <span class="comment">//往IO线程中发送一个OnChannelOpened消息函数</span></span><br><span class="line">  context_-&gt;ipc_task_runner()-&gt;PostTask(</span><br><span class="line">      FROM_HERE, base::Bind(&amp;Context::OnChannelOpened, context_.get()));</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_proxy.cc中。      </p>
<p>&#160; &#160; &#160; &#160;从前面的调用过程知道，参数channel_handle描述的是一个UNIX Socket名称，参数mode的值为IPC::Channel::MODE_SERVER，参数create_pipe_now的值为true。这样，ChannelProxy类的成员函数Init就会马上调用前面创建的ChannelProxy::Context对象的成员函数CreateChannel创建一个IPC通信通道，也就是在当前线程中创建一个IPC通信通道 。</p>
<p>&#160; &#160; &#160; &#160;另一个方面，如果参数create_pipe_now的值等于false，那么ChannelProxy类的成员函数Init就不是在当前线程创建IPC通信通道，而是在IO线程中创建。因为它先通过前面创建的ChannelProxy::Context对象的成员函数ipc_task_runner获得其成员变量ipc_task<em>runner</em>描述的SingleThreadTaskRunner对象，然后再将创建IPC通信通道的任务发送到该SingleThreadTaskRunner对象描述的IO线程的消息队列去。当该任务被处理时，就会调用ChannelProxy::Context类的成员函数CreateChannel。</p>
<p>&#160; &#160; &#160; &#160;当调用ChannelProxy::Context类的成员函数CreateChannel创建好一个IPC通信通道之后，ChannelProxy类的成员函数Init还会向当前进程的IO线程的消息队列发送一个消息，该消息绑定的是ChannelProxy::Context类的成员函数OnChannelOpened。因此，接下来我们就分别分析ChannelProxy::Context类的成员函数CreateChannel和OnChannelOpened。</p>
<p>&#160; &#160; &#160; &#160;ChannelProxy::Context类的成员函数CreateChannel的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ChannelProxy::Context::CreateChannel(<span class="keyword">const</span> IPC::ChannelHandle&amp; handle,</span><br><span class="line">                                          <span class="keyword">const</span> Channel::Mode&amp; mode) &#123;</span><br><span class="line">  ......</span><br><span class="line">  channel_ = Channel::Create(handle, mode, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_proxy.cc中。   </p>
<p>&#160; &#160; &#160; &#160;ChannelProxy::Context类的成员函数CreateChannel调用Channel类的成员函数Create创建了一个IPC通信通道，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scoped_ptr&lt;Channel&gt; Channel::Create(</span><br><span class="line">    <span class="keyword">const</span> IPC::ChannelHandle &amp;channel_handle, Mode mode, Listener* listener) &#123;</span><br><span class="line">  <span class="keyword">return</span> make_scoped_ptr(<span class="keyword">new</span> ChannelPosix(</span><br><span class="line">      channel_handle, mode, listener)).PassAs&lt;Channel&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里可以看到，对于Android平台来说，IPC通信通道通过一个ChannelPosix对象描述，该ChannelPosix对象的创建过程如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ChannelPosix::ChannelPosix(<span class="keyword">const</span> IPC::ChannelHandle&amp; channel_handle,<span class="comment">//UNIX Socket名称</span></span><br><span class="line">                           Mode mode, Listener* listener)</span><br><span class="line">    : ChannelReader(listener),</span><br><span class="line">      mode_(mode),<span class="comment">//IPC::Channel::MODE_SERVER</span></span><br><span class="line">      ......</span><br><span class="line">      pipe_(<span class="number">-1</span>),<span class="comment">//server端文件描述符</span></span><br><span class="line">      client_pipe_(<span class="number">-1</span>),<span class="comment">//client文件描述符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(IPC_USES_READWRITE)<span class="comment">//如果发送的消息包含文件描述符</span></span></span><br><span class="line">      fd_pipe_(<span class="number">-1</span>),<span class="comment">//server</span></span><br><span class="line">      remote_fd_pipe_(<span class="number">-1</span>),<span class="comment">//clent</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// IPC_USES_READWRITE 使用专用UNIX Socket传输</span></span></span><br><span class="line">      pipe_name_(channel_handle.name),</span><br><span class="line">      ...... &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (!CreatePipe(channel_handle)) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;从前面的调用过程可以知道，参数channel_handle描述的是一个UNIX Socket名称，参数mode的值等于IPC::Channel::MODE_SERVER，参数listener指向的是前面创建的ChannelProxy::Context对象。</p>
<p>&#160; &#160; &#160; &#160;ChannelPosix类继承了ChannelReader类，后者用来读取从Render进程发送过来的IPC消息，并且将读取到的IPC消息发送给参数listener描述的ChannelProxy::Context对象，因此这里会将参数listener描述的ChannelProxy::Context对象传递给ChannelReader的构造函数。</p>
<p>&#160; &#160; &#160; &#160;ChannelPosix类通过UNIX Socket来描述IPC通信通道，这个UNIX Socket的Server端和Client文件描述符分别保存在成员变量pipe_和client<em>pipe</em>中。如果定义了宏IPC_USES_READWRITE，那么当发送的消息包含有文件描述时，就会使用另外一个专用的UNIX Socket来传输文件描述符给对方。这个专用的UNIX Socket的Server端和Client端文件描述符保存在成员变量fd<em>pipe</em>和remote_fd<em>pipe</em>中。后面分析IPC消息的分发过程时，我们再详细分析这一点。</p>
<p>&#160; &#160; &#160; &#160;ChannelPosix类的构造函数最后调用了另外一个成员函数CreatePipe开始创建IPC通信通道，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ChannelPosix::CreatePipe(</span><br><span class="line">    <span class="keyword">const</span> IPC::ChannelHandle&amp; channel_handle) &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> local_pipe = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (channel_handle.socket.fd != <span class="number">-1</span>) &#123;<span class="comment">//仅仅保存了即将要创建的UNIX Socket的名称</span></span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode_ &amp; MODE_NAMED_FLAG) &#123;<span class="comment">//IPC::Channel::MODE_SERVER，它的MODE_NAMED_FLAG位等于0</span></span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Pipe Map中检查是否存在一个UNIX Socket文件描述符与成员变量pipe_name_对应</span></span><br><span class="line">    local_pipe = PipeMap::GetInstance()-&gt;Lookup(pipe_name_);</span><br><span class="line">    <span class="keyword">if</span> (mode_ &amp; MODE_CLIENT_FLAG) &#123;<span class="comment">//client端</span></span><br><span class="line">      <span class="keyword">if</span> (local_pipe != <span class="number">-1</span>) &#123;<span class="comment">//如果存在</span></span><br><span class="line">        ......</span><br><span class="line">        local_pipe = HANDLE_EINTR(dup(local_pipe));<span class="comment">//就是用这个fd</span></span><br><span class="line">        ......</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不存在</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//那么再到Global Descriptors中检查是否存在一个UNIX Socket文件描述符与常量kPrimaryIPCChannel对应</span></span><br><span class="line">        local_pipe =</span><br><span class="line">            base::GlobalDescriptors::GetInstance()-&gt;Get(kPrimaryIPCChannel);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode_ &amp; MODE_SERVER_FLAG) &#123;<span class="comment">//server端</span></span><br><span class="line">      ......</span><br><span class="line">      base::AutoLock lock(client_pipe_lock_);</span><br><span class="line">      <span class="keyword">if</span> (!SocketPair(&amp;local_pipe, &amp;client_pipe_))<span class="comment">//创建了一个UNIX Socket</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//保存在一个Pipe Map中  </span></span><br><span class="line">      PipeMap::GetInstance()-&gt;Insert(pipe_name_, client_pipe_);</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(IPC_USES_READWRITE)<span class="comment">//创建一个专门用来在进程间传递文件描述的UNIX Socket</span></span></span><br><span class="line">  <span class="comment">// Create a dedicated socketpair() for exchanging file descriptors.</span></span><br><span class="line">  <span class="comment">// See comments for IPC_USES_READWRITE for details.</span></span><br><span class="line">  <span class="keyword">if</span> (mode_ &amp; MODE_CLIENT_FLAG) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SocketPair(&amp;fd_pipe_, &amp;remote_fd_pipe_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// IPC_USES_READWRITE</span></span></span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  pipe_ = local_pipe;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;ChannelHandle类除了用来保存UNIX Socket的名称之外，还可以用来保存与该名称对应的UNIX Socket的文件描述符。在我们这个情景中，参数channel_handle仅仅保存了即将要创建的UNIX Socket的名称。</p>
<p>&#160; &#160; &#160; &#160;ChannelPosix类的成员变量mode_的值等于IPC::Channel::MODE_SERVER，它的MODE_NAMED<em>FLAG位等于0。Render进程启动之后，也会调用到ChannelPosix类的成员函数CreatePipe创建一个Client端的IPC通信通道，那时候用来描述Client端IPC通信通道的ChannelPosix对象的成员变量mode</em>的值IPC::Channel::MODE_CLIENT，它的MODE_NAMED_FLAG位同样等于0。因此，无论是在Browser进程中创建的Server端IPC通信通道，还是在Render进程中创建的Client端IPC通信通道，在调用ChannelPosix类的成员函数CreatePipe时，都按照以下逻辑进行。</p>
<p>&#160; &#160; &#160; &#160;对于Client端的IPC通信通道，即ChannelPosix类的成员变量mode_的MODE_CLIENT_FLAG位等于1的情况，首先是在一个Pipe Map中检查是否存在一个UNIX Socket文件描述符与成员变量pipe<em>name</em>对应。如果存在，那么就使用该文件描述符进行IPC通信。如果不存在，那么再到Global Descriptors中检查是否存在一个UNIX Socket文件描述符与常量kPrimaryIPCChannel对应。如果存在，那么就使用该文件描述符进行IPC通信。实际上，当网页不是在独立的Render进程中加载时，执行的是前一个逻辑，而当网页是在独立的Render进程中加载时，执行的是后一个逻辑。</p>
<p>&#160; &#160; &#160; &#160;Chromium为了能够统一地处理网页在独立Render进程和不在独立Render进程加载两种情况，会对后者进行一个抽象，即会假设后者也是在独立的Render进程中加载一样。这样，Browser进程在加载该网页时，同样会创建一个图1所示的RenderProcess对象，不过该RenderProcess对象没有对应的一个真正的进程，对应的仅仅是Browser进程中的一个线程。也就是这时候，图1所示的RenderPocessHost对象和RenderProcess对象执行的仅仅是进程内通信而已，不过它们仍然是按照进程间的通信规则进行，也就是通过IO线程来间接进行。不过，在进程内建立IPC通信通道和在进程间建立IPC通信通道的方式是不一样的。具体来说，就是在进程间建立IPC通信通道，需要将描述该通道的UNIX Socket的Client端文件描述符从Browser进程传递到Render进程，Render进程接收到该文件描述符之后，就会以kPrimaryIPCChannel为键值保存在Global Descriptors中。而在进程内建立IPC通信通道时，描述IPC通信通道的UNIX Socket的Client端文件描述符直接以UNIX Socket名称为键值，保存在一个Pipe Map中即可。后面我们分析在进程内在进程间创建Client端IPC通信通道时，会继续看到这些相关的区别。</p>
<p>&#160; &#160; &#160; &#160;对于Server端的IPC通信通道，即ChannelPosix类的成员变量mode_的MODE_SERVER<em>FLAG位等于1的情况，ChannelPosix类的成员函数CreatePipe调用函数SocketPair创建了一个UNIX Socket，其中，Server端文件描述符保存在成员变量pipe</em>中，而Client端文件描述符保存在成员变量client<em>pipe</em>中，并且Client端文件描述符还会以与前面创建的UNIX Socket对应的名称为键值，保存在一个Pipe Map中，这就是为建立进程内IPC通信通道而准备的。</p>
<p>&#160; &#160; &#160; &#160;最后，如果定义了IPC_USES_READWRITE宏，如前面提到的，那么还会继续创建一个专门用来在进程间传递文件描述的UNIX Socket，该UNIX Socket的Server端和Client端文件描述符分别保存在成员变量fd<em>pipe</em>和remote_fd<em>pipe</em>中。</p>
<p>&#160; &#160; &#160; &#160;这一步执行完成之后，一个Server端IPC通信通道就创建完成了。回到ChannelProxy类的成员函数Init中，它接下来是发送一个消息到Browser进程的IO线程的消息队列中，该消息绑定的是ChannelProxy::Context类的成员函数OnChannelOpened，它的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ChannelProxy::Context::OnChannelOpened() &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!channel_-&gt;Connect()) &#123;</span><br><span class="line">    OnChannelError();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_proxy.cc中。</p>
<p>&#160; &#160; &#160; &#160;从前面的分析可以知道，ChannelProxy::Context类的成员变量channel_指向的是一个ChannelPosix对象，这里调用它的成员函数Connect将它描述的IPC通信通道交给当前进程的IO线程进行监控。</p>
<p>&#160; &#160; &#160; &#160;ChannelPosix类的成员函数Connect的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ChannelPosix::Connect() &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">bool</span> did_connect = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (server_listen_pipe_ != <span class="number">-1</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    did_connect = AcceptConnection();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> did_connect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_posix.cc中。</p>
<p>&#160; &#160; &#160; &#160;当ChannelPosix类的成员变量server_listen<em>pipe</em>的值不等于-1时，表示它描述的是一个用来负责监听IPC通信通道连接消息的Socket中，也就是这个Socket不是真正用来执行Browser进程和Render进程之间的通信的，而是Browser进程首先对ChannelPosix类的成员变量server_listen<em>pipe</em>描述的Socket进行listen，接着Render进程通过connect连接到该Socket，使得Browser进程accepet到一个新的Socket，然后再通过这个新的Socket与Render进程执行IPC。</p>
<p>&#160; &#160; &#160; &#160;在我们这个情景中，ChannelPosix类的成员变量server_listen<em>pipe</em>的值等于-1，因此接下来ChannelPosix类的成员函数Connect调用了另外一个成员函数AcceptConnection，它的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ChannelPosix::AcceptConnection() &#123;</span><br><span class="line">  <span class="comment">//对fd进行监控</span></span><br><span class="line">  base::MessageLoopForIO::current()-&gt;WatchFileDescriptor(</span><br><span class="line">      pipe_, <span class="literal">true</span>, base::MessageLoopForIO::WATCH_READ, &amp;read_watcher_, <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//创建一个Hello Message，并且将该Message添加到内部的一个IPC消息队列去等待发送给对方进程</span></span><br><span class="line">  QueueHelloMessage();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode_ &amp; MODE_CLIENT_FLAG) &#123;<span class="comment">//client端通信通道</span></span><br><span class="line">    <span class="comment">// If we are a client we want to send a hello message out immediately.</span></span><br><span class="line">    <span class="comment">// In server mode we will send a hello message when we receive one from a</span></span><br><span class="line">    <span class="comment">// client.</span></span><br><span class="line">    waiting_connect_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> ProcessOutgoingMessages();<span class="comment">//把Hello Message发送给Server端</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode_ &amp; MODE_SERVER_FLAG) &#123;<span class="comment">//server端通信通道</span></span><br><span class="line">    waiting_connect_ = <span class="literal">true</span>;<span class="comment">//等待Client端发送一个Hello Message过来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    NOTREACHED();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_proxy.cc中。</p>
<p>&#160; &#160; &#160; &#160;ChannelPosix类的成员函数AcceptConnection首先是获得与当前进程的IO线程关联的一个MessageLoopForIO对象，接着再调用该MessageLoopForIO对象的成员函数WatchFileDescriptor对成员变量pipe_ 描述的一个UNIX Socket进行监控。MessageLoopForIO类的成员函数WatchFileDescriptor最终会调用到在前面Chromium多线程模型设计和实现分析一文中提到的MessagePumpLibevent对该UNIX Socket进行监控。这意味着当该UNIX Socket有新的IPC消息需要接收时，当前正在处理的ChannelPosix对象的成员函数OnFileCanReadWithoutBlocking就会被调用。这一点需要理解Chromium的多线程机制，具体可以参考Chromium多线程模型设计和实现分析一文。</p>
<p>&#160; &#160; &#160; &#160;接下来，ChannelPosix类的成员函数AcceptConnection还会调用另外一个成员函数QueueHelloMessage创建一个Hello Message，并且将该Message添加到内部的一个IPC消息队列去等待发送给对方进程。执行IPC的双方，就是通过这个Hello Message进行握手的。具体来说，就是Server端和Client端进程建立好连接之后，由Client端发送一个Hello Message给Server端，Server端接收到该Hello Message之后，就认为双方已经准备就绪，可以进行IPC了。</p>
<p>&#160; &#160; &#160; &#160;因此，如果当前正在处理的ChannelPosix对象描述的是Client端的通信通道，即它的成员变量mode_的MODE_CLIENT_FLAG位等于1，那么ChannelPosix类的成员函数AcceptConnection就会马上调用另外一个成员函数ProcessOutgoingMessages前面创建的Hello Message发送给Server端。</p>
<p>&#160; &#160; &#160; &#160;另一方面，如果当前正在处理的ChannelPosix对象描述的是Server端的通信通道，那么ChannelPosix类的成员函数AcceptConnection就仅仅是将成员变量waiting<em>connect</em>的值设置为true，表示正在等待Client端发送一个Hello Message过来。</p>
<p>&#160; &#160; &#160; &#160;关于Hello Message的发送和接收，我们在接下来的一篇文章分析IPC消息分发机制时再详细分析。</p>
<p>&#160; &#160; &#160; &#160;这一步执行完成之后，Server端的IPC通信通道就创建完成了，也就是Browser进程已经创建好了一个Server端的IPC通信通道。回到RenderProcessHostImpl类的成员函数Init中，它接下来要做的事情就是启动Render进程。</p>
<h3 id="非独立进程Render"><a href="#非独立进程Render" class="headerlink" title="非独立进程Render"></a>非独立进程Render</h3><p>&#160; &#160; &#160; &#160;我们首先考虑网页不是在独立的Render进程加载的情况，即在Browser进程加载的情况，这时候并没有真的启动了一个Render进程，而仅仅是在Browser进程中创建了一个RenderProcess对象而已，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RenderProcessHostImpl::Init() &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Setup the IPC channel.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> channel_id =</span><br><span class="line">      IPC::Channel::GenerateVerifiedChannelID(<span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line">  channel_ = IPC::ChannelProxy::Create(</span><br><span class="line">      channel_id,</span><br><span class="line">      IPC::Channel::MODE_SERVER,</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      BrowserThread::GetMessageLoopProxyForThread(BrowserThread::IO).get());</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (run_renderer_in_process()) &#123;<span class="comment">//非独立进程启动render进程</span></span><br><span class="line">    ......</span><br><span class="line">    in_process_renderer_.reset(g_renderer_main_thread_factory(channel_id));</span><br><span class="line"> </span><br><span class="line">    base::Thread::Options options;</span><br><span class="line">    ......</span><br><span class="line">    options.message_loop_type = base::MessageLoop::TYPE_DEFAULT;</span><br><span class="line">    </span><br><span class="line">    in_process_renderer_-&gt;StartWithOptions(options);</span><br><span class="line"> </span><br><span class="line">    g_in_process_thread = in_process_renderer_-&gt;message_loop();</span><br><span class="line"> </span><br><span class="line">    OnProcessLaunched();  <span class="comment">// Fake a callback that the process is ready.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/renderer_host/render_process_host_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;前面在分析RenderProcessHostImpl类的成员函数Init时提到，RenderProcessHostImpl类的静态成员变量g_renderer_main_thread_factory描述的是一个函数，通过它可以创建一个类型为InProcessRendererThread的线程。</p>
<p>&#160; &#160; &#160; &#160;一个类型为InProcessRendererThread的线程的创建过程如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InProcessRendererThread::InProcessRendererThread(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; channel_id)</span><br><span class="line">    : Thread(<span class="string">"Chrome_InProcRendererThread"</span>), channel_id_(channel_id) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/renderer/in_process_renderer_thread.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里就可以看到，InProcessRendererThread类是从Thread类继承下来的，因此这里调用了Thread类的构造函数。</p>
<p>&#160; &#160; &#160; &#160;此外，InProcessRendererThread类的构造函数还会将参数channel_id描述的一个UNIX Socket名称保存在成员变量channel<em>id</em>中。从前面的分析可以知道，该名称对应的UNIX Socket已经创建出来了，并且它的Client端文件描述符以该名称为键值，保存在一个Pipe Map中。</p>
<p>&#160; &#160; &#160; &#160;回到RenderProcessHostImpl类的成员函数Init中，接下来它会调用前面创建的InProcessRendererThread对象的成员函数StartWithOptions启动一个线程。从前面Chromium多线程模型设计和实现分析一文可以知道，当该线程启动起来之后，并且在进入消息循环之前，会被调用InProcessRendererThread类的成员函数Init执行初始化工作。</p>
<p>&#160; &#160; &#160; &#160;InProcessRendererThread类的成员函数Init的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InProcessRendererThread::Init() &#123;</span><br><span class="line">  render_process_.reset(<span class="keyword">new</span> RenderProcessImpl());</span><br><span class="line">  <span class="keyword">new</span> RenderThreadImpl(channel_id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/renderer/in_process_renderer_thread.cc中。</p>
<p>&#160; &#160; &#160; &#160;InProcessRendererThread类的成员函数Init首先在当前进程，即Browser进程，创建了一个RenderProcessImpl对象，保存在成员变量render<em>process</em>中，描述一个假的Render进程，接着再创建了一个RenderThreadImpl对象描述当前线程，即当前正在处理的InProcessRendererThread对象描述的线程。</p>
<p>&#160; &#160; &#160; &#160;在RenderProcessImpl对象的创建中，会创建一个IO线程，该IO线程负责与Browser进程启动时就创建的一个IO线程执行IPC通信。从图6可以知道，RenderProcessImpl类继承了RenderProcess类，RenderProcess类又继承了ChildProcess类，创建IO线程的工作是从ChildProcess类的构造函数中进行的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChildProcess::ChildProcess()</span><br><span class="line">    : ...... &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// We can't recover from failing to start the IO thread.</span></span><br><span class="line">  CHECK(io_thread_.StartWithOptions(</span><br><span class="line">      base::Thread::Options(base::MessageLoop::TYPE_IO, <span class="number">0</span>)));</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/child/child_process.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里就可以看到，ChildProcess类的构造函数调用了成员变量io<em>thread</em>描述的一个Thread对象的成员函数StartWithOptions创建了一个IO线程。</p>
<p>&#160; &#160; &#160; &#160;回到InProcessRendererThread类的成员函数Init中，在RenderThreadImpl对象的创建过程，会创建一个Client端的IPC通信通道，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RenderThreadImpl::RenderThreadImpl(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; channel_name)</span><br><span class="line">    : ChildThread(channel_name) &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/renderer/render_thread_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里可以看到，RenderThreadImpl类继承了ChildThread类，创建Client端IPC通信通道的过程是在ChildThread类的构造函数中进行的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ChildThread::ChildThread(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; channel_name)</span><br><span class="line">    : channel_name_(channel_name),</span><br><span class="line">      ..... &#123;</span><br><span class="line">  Init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> &#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/child/child_thread.cc中。</p>
<h3 id="IPC-Channel-Client创建"><a href="#IPC-Channel-Client创建" class="headerlink" title="IPC Channel Client创建"></a>IPC Channel Client创建</h3><p>&#160; &#160; &#160; &#160;ChildThread类的构造函数将参数channel_name描述的一个UNIX Socket的名称保存在成员变量channel<em>name</em>之后，就调用了另外一个成员函数Init执行创建Client端IPC通信通道的工作，如下所示： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ChildThread::Init() &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  channel_ =</span><br><span class="line">      IPC::SyncChannel::Create(channel_name_,</span><br><span class="line">                               IPC::Channel::MODE_CLIENT,</span><br><span class="line">                               <span class="keyword">this</span>,</span><br><span class="line">                               ChildProcess::current()-&gt;io_message_loop_proxy(),</span><br><span class="line">                               <span class="literal">true</span>,</span><br><span class="line">                               ChildProcess::current()-&gt;GetShutDownEvent());</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/child/child_thread.cc中。</p>
<p>&#160; &#160; &#160; &#160;Client端IPC通信通道通过IPC::SyncChannel类的静态成员函数Create进行创建，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scoped_ptr&lt;SyncChannel&gt; SyncChannel::Create(</span><br><span class="line">    <span class="keyword">const</span> IPC::ChannelHandle&amp; channel_handle,</span><br><span class="line">    Channel::Mode mode,</span><br><span class="line">    Listener* listener,</span><br><span class="line">    base::SingleThreadTaskRunner* ipc_task_runner,</span><br><span class="line">    <span class="keyword">bool</span> create_pipe_now,</span><br><span class="line">    base::WaitableEvent* shutdown_event) &#123;</span><br><span class="line">  scoped_ptr&lt;SyncChannel&gt; channel =</span><br><span class="line">      Create(listener, ipc_task_runner, shutdown_event);</span><br><span class="line">  channel-&gt;Init(channel_handle, mode, create_pipe_now);</span><br><span class="line">  <span class="keyword">return</span> channel.Pass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_sync_channel.cc中。</p>
<p>&#160; &#160; &#160; &#160;IPC::SyncChannel类的静态成员函数Create首先调用另外一个重载版本的静态成员函数Create创建一个SyncChannel对象，接着再调用该SyncChannel的成员函数Init执行初始化工作。</p>
<p>&#160; &#160; &#160; &#160;IPC::SyncChannel类是从IPC::ChannelProxy类继承下来的，它与IPC::ChannelProxy的区别在于，前者既可以用来发送同步的IPC消息，也可以用来发送异步的IPC消息，而后者只可以用来发送异步消息。所谓同步IPC消息，就是发送者发送它给对端之后，会一直等待对方发送一个回复，而对于异步IPC消息，发送者把它发送给对端之后，不会进行等待，而是直接返回。后面分析IPC消息的分发机制时我们再详细分析这一点。</p>
<p>&#160; &#160; &#160; &#160;IPC::SyncChannel类的成员函数Init是从父类IPC::ChannelProxy类继承下来的，后者我们前面已经分析过了，主要区别在于这里传递第二个参数mode的值等于IPC::Channel::MODE_CLIENT，表示要创建的是一个Client端的IPC通信通道。</p>
<p>&#160; &#160; &#160; &#160;接下来，我们就主要分析IPC::SyncChannel类三个参数版本的静态成员函数Create创建SyncChannel对象的过程，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scoped_ptr&lt;SyncChannel&gt; SyncChannel::Create(</span><br><span class="line">    Listener* listener,</span><br><span class="line">    base::SingleThreadTaskRunner* ipc_task_runner,</span><br><span class="line">    WaitableEvent* shutdown_event) &#123;</span><br><span class="line">  <span class="keyword">return</span> make_scoped_ptr(</span><br><span class="line">      <span class="keyword">new</span> SyncChannel(listener, ipc_task_runner, shutdown_event));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_sync_channel.cc中。</p>
<p>&#160; &#160; &#160; &#160;IPC::SyncChannel类三个参数版本的静态成员函数Create创建了一个SyncChannel对象，并且将该SyncChannel对象返回给调用者。</p>
<p>&#160; &#160; &#160; &#160;SyncChannel对象的创建过程如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SyncChannel::SyncChannel(</span><br><span class="line">    Listener* listener,</span><br><span class="line">    base::SingleThreadTaskRunner* ipc_task_runner,</span><br><span class="line">    WaitableEvent* shutdown_event)</span><br><span class="line">    : ChannelProxy(<span class="keyword">new</span> SyncContext(listener, ipc_task_runner, shutdown_event)) &#123;</span><br><span class="line">  ......</span><br><span class="line">  StartWatching();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_sync_channel.cc中。</p>
<p>&#160; &#160; &#160; &#160;从前面的调用过程可以知道，参数listener描述的是一个ChildThread对象，参数ipc_task_runner描述的是与前面在ChildProcess类的构造函数中创建的IO线程关联的一个MessageLoopProxy对象，参数shutdown_event描述的是一个ChildProcess关闭事件。</p>
<p>&#160; &#160; &#160; &#160;对于第三个参数shutdown_event的作用，我们这里做一个简单的介绍，在接下来一篇文章中分析IPC消息的分发机制时再详细分析。前面提到，SyncChannel可以用来发送同步消息，这意味着发送线程需要进行等待。这个等待过程是通过我们在前面Chromium多线程模型设计和实现分析一文中提到的WaitableEvent类实现的。也就是说，每一个同步消息都有一个关联的WaitableEvent对象。此外，还有一些异常情况需要处理。例如，SyncChannel在等待一个同步消息的过程中，有可能对方已经退出了，这相当于是发生了一个ChildProcess关闭事件。在这种情况下，继续等待是没有意义的。因此，当SyncChannel监控到ChildProcess关闭事件时，就可以执行一些清理工作了。此外，SyncChannel在等待一个同步消息的过程中，也有可能收到对方发送过来的非回复消息。在这种情况下，SyncChannel需要获得通知，以便可以对这些非回复消息进行处理。SyncChannel获得此类非回复消息的事件通知是通过另外一个称为Dispatch Event的WaitableEvent对象获得的。这意味着SyncChannel在发送一个同步消息的过程中，需要同时监控多个WaitableEvent对象。</p>
<p>&#160; &#160; &#160; &#160;了解了各个参数的含义之后，我们就开始分析SyncChannel类的构造函数。它首先是创建了一个SyncChannel::SyncContext对象，并且以该SyncChannel::SyncContext对象为参数，调用父类ChannelProxy的构造函数，以便可以对父类ChannelProxy进行初始化。</p>
<p>&#160; &#160; &#160; &#160;SyncChannel::SyncContext对象的创建过程如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SyncChannel::SyncContext::SyncContext(</span><br><span class="line">    Listener* listener,</span><br><span class="line">    base::SingleThreadTaskRunner* ipc_task_runner,</span><br><span class="line">    WaitableEvent* shutdown_event)</span><br><span class="line">    : ChannelProxy::Context(listener, ipc_task_runner),</span><br><span class="line">      ......,</span><br><span class="line">      shutdown_event_(shutdown_event),</span><br><span class="line">      ...... &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160; 这个函数定义在文件external/chromium_org/ipc/ipc_sync_channel.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里可以看到，SyncChannel::SyncContext类是从ChannelProxy::Context类继承下来的，因此这里会调用ChannelProxy::Context类的构造函数进行初始化。此外，SyncChannel::SyncContext类的构造函数还会将参数shutdown_event描述的一个ChildProcess关闭事件保存在成员变量shutdown<em>event</em>中。</p>
<p>&#160; &#160; &#160; &#160;回到SyncChannel类的构造函数中，当它创建了一个SyncChannel::SyncContext对象之后，就使用该SyncChannel::SyncContext对象来初始化父类ChannelProxy，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ChannelProxy::ChannelProxy(Context* context)</span><br><span class="line">    : context_(context), </span><br><span class="line">      did_init_(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_channel_proxy.cc。</p>
<p>&#160; &#160; &#160; &#160;注意，参数context的类型虽然为一个ChannelProxy::Context指针，但是它实际上指向的是一个SyncChannel::SyncContext对象，该SyncChannel::SyncContext对象保存在成员变量context_中。</p>
<p>&#160; &#160; &#160; &#160;继续回到SyncChannel类的构造函数中，它用一个SyncChannel::SyncContext对象初始化了父类ChannelProxy之后，继续调用另外一个成员函数StartWatching监控我们在前面提到的一个Dispatch Event，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SyncChannel::StartWatching() &#123;</span><br><span class="line">  ......</span><br><span class="line">  dispatch_watcher_callback_ =</span><br><span class="line">      base::Bind(&amp;SyncChannel::OnWaitableEventSignaled,</span><br><span class="line">                  base::Unretained(<span class="keyword">this</span>));</span><br><span class="line">  dispatch_watcher_.StartWatching(sync_context()-&gt;GetDispatchEvent(),</span><br><span class="line">                                  dispatch_watcher_callback_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_sync_channel.cc中。</p>
<p>&#160; &#160; &#160; &#160;SyncChannel类的成员函数StartWatching调用成员变量dispatch<em>watcher</em>描述的一个WaitableEventWatcher对象的成员函数StartWatching对Dispatch Event进行监控，从这里就可以看到，Dispatch Event可以通过前面创建的SyncChannel::SyncContext对象的成员函数sync_context获得，并且当该Display Event发生时，SyncChannel类的成员函数OnWaitableEventSignaled就会被调用。</p>
<p>&#160; &#160; &#160; &#160;前面在分析ChannelProxy类的成员函数Init时，我们提到，当它调用另外一个成员函数CreateChannel创建了一个IPC通信通道之后，会调用其成员变量context<em>描述的一个ChannelProxy::Context对象的成员函数OnChannelOpened将已经创建好的的IPC通信通道增加到IO线程的消息队列中去监控。由于在我们这个情景中，ChannelProxy类的成员变量context</em>指向的是一个SyncChannel::SyncContext对象，因此，当ChannelProxy类的成员函数Init创建了一个IPC通信通道之后，它接下来调用的是SyncChannel::SyncContext类的成员函数OnChanneIOpened将已经创建好的IPC通信通道增加到IO线程的消息队列中去监控。</p>
<p>&#160; &#160; &#160; &#160;SyncChannel::SyncContext类的成员函数OnChanneIOpened的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SyncChannel::SyncContext::OnChannelOpened() &#123;</span><br><span class="line">  shutdown_watcher_.StartWatching(</span><br><span class="line">      shutdown_event_,</span><br><span class="line">      base::Bind(&amp;SyncChannel::SyncContext::OnWaitableEventSignaled,</span><br><span class="line">                 base::Unretained(<span class="keyword">this</span>)));</span><br><span class="line">  Context::OnChannelOpened();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/ipc/ipc_sync_channel.cc中。</p>
<p>&#160; &#160; &#160; &#160;SyncChannel::SyncContext类的成员函数OnChanneIOpened首先是调用成员变量shutdown<em>watcher</em>描述的一个WaitableEventWatcher对象的成员函数StartWatching监控成员变量shutdown<em>event</em>描述的一个ChildProcess关闭事件。从这里就可以看到，当ChildProcess关闭事件发生时，SyncChannel::SyncContext类的成员函数OnWaitableEventSignaled就会被调用。</p>
<p>&#160; &#160; &#160; &#160;最后，SyncChannel::SyncContext类的成员函数OnChanneIOpened调用了父类ChannelProxy的成员函数OnChannelOpened将IPC通信通道增加到IO线程的的消息队列中去监控。</p>
<p>&#160; &#160; &#160; &#160;这一步执行完成之后，一个Client端的IPC通信通道就创建完成了。这里我们描述的Client端IPC通信通道的创建过程虽然是发生在Browser进程中的，不过这个过程与在独立的Render进程中创建的Client端IPC通信通道的过程是一样的。这一点在接下来的分析中就可以看到。</p>
<h3 id="独立进程Render启动"><a href="#独立进程Render启动" class="headerlink" title="独立进程Render启动"></a>独立进程Render启动</h3><p>&#160; &#160; &#160; &#160;回到前面分析的RenderProcessHostImpl类的成员函数Init中，对于需要在独立的Render进程加载网页的情况，它就会启动一个Render进程，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RenderProcessHostImpl::Init() &#123;</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Setup the IPC channel.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> channel_id =</span><br><span class="line">      IPC::Channel::GenerateVerifiedChannelID(<span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line">  channel_ = IPC::ChannelProxy::Create(</span><br><span class="line">      channel_id,</span><br><span class="line">      IPC::Channel::MODE_SERVER,</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      BrowserThread::GetMessageLoopProxyForThread(BrowserThread::IO).get());</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (run_renderer_in_process()) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//独立进程render启动</span></span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    CommandLine* cmd_line = <span class="keyword">new</span> CommandLine(renderer_path);</span><br><span class="line">    ......</span><br><span class="line">    AppendRendererCommandLine(cmd_line);</span><br><span class="line">    cmd_line-&gt;AppendSwitchASCII(switches::kProcessChannelID, channel_id);</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    child_process_launcher_.reset(<span class="keyword">new</span> ChildProcessLauncher(</span><br><span class="line">        <span class="keyword">new</span> RendererSandboxedProcessLauncherDelegate(channel_.get()),</span><br><span class="line">        cmd_line,</span><br><span class="line">        GetID(),</span><br><span class="line">        <span class="keyword">this</span>));</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/renderer_host/render_process_host_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;RenderProcessHostImpl类的成员函数Init创建了一个Server端的IPC通信通道之后，就会通过一个ChildProcessLauncher对象来启动一个Render进程。不过在启动该Render进程之前，首先要构造好它的启动参数，也就是命令行参数。</p>
<p>&#160; &#160; &#160; &#160;Render进程的启动命令行参数通过一个CommandLine对象来描述，它包含有很多选项，不过现在我们只关心两个。一个是switches::kProcessType，另外一个是switches::kProcessChannelID。其中，switches::kProcessChannelID选项对应的值设置为本地变量channel_id描述的值，即前面调用IPC::Channel类的静态成员函数GenerateVerifiedChannelID生成的一个UNIX Socket名称。</p>
<p>&#160; &#160; &#160; &#160;选项switches::kProcessType的值是通过RenderProcessHostImpl类的成员函数AppendRendererCommandLine设置的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RenderProcessHostImpl::AppendRendererCommandLine(</span><br><span class="line">    CommandLine* command_line) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// Pass the process type first, so it shows first in process listings.</span></span><br><span class="line">  command_line-&gt;AppendSwitchASCII(switches::kProcessType,</span><br><span class="line">                                  switches::kRendererProcess);</span><br><span class="line">  </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/renderer_host/render_process_host_impl.cc中。</p>
<p>&#160; &#160; &#160; &#160;从这里就可以看到，选项switches::kProcessType的值设置为kRendererProcess，这表示接下来我们通过ChildProcessLauncher类启动的进程是一个Render进程。</p>
<p>&#160; &#160; &#160; &#160;回到RenderProcessHostImpl类的成员函数Init中，当要启动的Render进程的命令行参数准备好之后，接下来就通过ChildProcessLauncher类的构造函数启动一个Render进程，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ChildProcessLauncher::ChildProcessLauncher(</span><br><span class="line">    SandboxedProcessLauncherDelegate* delegate,</span><br><span class="line">    CommandLine* cmd_line,</span><br><span class="line">    <span class="keyword">int</span> child_process_id,</span><br><span class="line">    Client* client) &#123;</span><br><span class="line">  context_ = <span class="keyword">new</span> Context();</span><br><span class="line">  context_-&gt;Launch(</span><br><span class="line">      delegate,</span><br><span class="line">      cmd_line,</span><br><span class="line">      child_process_id,</span><br><span class="line">      client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/child_process_launcher.cc中。</p>
<p>&#160; &#160; &#160; &#160;ChildProcessLauncher类的构造函数首先创建了一个ChildProcessLauncher::Context对象，保存在成员变量context_中，并且调用该ChildProcessLauncher::Context对象的成员函数Launch启动一个Render进程。</p>
<p>&#160; &#160; &#160; &#160;ChildProcessLauncher::Context类的成员函数Launch的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ChildProcessLauncher::Context</span><br><span class="line">    : <span class="keyword">public</span> base::RefCountedThreadSafe&lt;ChildProcessLauncher::Context&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ......</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Launch</span><span class="params">(</span><br><span class="line">      SandboxedProcessLauncherDelegate* delegate,</span><br><span class="line">      CommandLine* cmd_line,</span><br><span class="line">      <span class="keyword">int</span> child_process_id,</span><br><span class="line">      Client* client)</span> </span>&#123;</span><br><span class="line">    client_ = client;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    BrowserThread::PostTask(</span><br><span class="line">        BrowserThread::PROCESS_LAUNCHER, FROM_HERE,</span><br><span class="line">        base::Bind(</span><br><span class="line">            &amp;Context::LaunchInternal,</span><br><span class="line">            make_scoped_refptr(<span class="keyword">this</span>),</span><br><span class="line">            client_thread_id_,</span><br><span class="line">            child_process_id,</span><br><span class="line">            delegate,</span><br><span class="line">            cmd_line));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/child_process_launcher.cc中。</p>
<p>&#160; &#160; &#160; &#160;ChildProcessLauncher::Context类的成员函数Launch通过调用BrowserThread类的静态成员函数PostTask向Browser进程的一个专门用来启动子进程的BrowserThread::PROCESS_LAUNCHER线程的消息队列发送一个任务，该任务绑定了ChildProcessLauncher::Context类的成员函数LaunchInternal。因此，接下来ChildProcessLauncher::Context类的成员函数LaunchInternal就会在BrowserThread::PROCESS_LAUNCHER线程中执行，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LaunchInternal</span><span class="params">(</span><br><span class="line">      <span class="comment">// |this_object| is NOT thread safe. Only use it to post a task back.</span></span><br><span class="line">      scoped_refptr&lt;Context&gt; this_object,</span><br><span class="line">      BrowserThread::ID client_thread_id,</span><br><span class="line">      <span class="keyword">int</span> child_process_id,</span><br><span class="line">      SandboxedProcessLauncherDelegate* delegate,</span><br><span class="line">      CommandLine* cmd_line)</span> </span>&#123;</span><br><span class="line">    scoped_ptr&lt;SandboxedProcessLauncherDelegate&gt; delegate_deleter(delegate);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_WIN)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_ANDROID)</span></span><br><span class="line">    <span class="keyword">int</span> ipcfd = delegate-&gt;GetIpcFd();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_MACOSX)</span></span><br><span class="line">...   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_POSIX)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    scoped_ptr&lt;CommandLine&gt; cmd_line_deleter(cmd_line);</span><br><span class="line">    base::TimeTicks begin_launch_time = base::TimeTicks::Now();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_WIN)</span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_POSIX)</span></span><br><span class="line">    <span class="comment">//renderer</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> process_type =</span><br><span class="line">        cmd_line-&gt;GetSwitchValueASCII(switches::kProcessType);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileDescriptorInfo&gt; files_to_register;</span><br><span class="line">    <span class="comment">//ipc fd</span></span><br><span class="line">    files_to_register.push_back(</span><br><span class="line">        FileDescriptorInfo(kPrimaryIPCChannel,</span><br><span class="line">                           base::FileDescriptor(ipcfd, <span class="literal">false</span>)));</span><br><span class="line">    base::StatsTable* stats_table = base::StatsTable::current();</span><br><span class="line">    <span class="keyword">if</span> (stats_table &amp;&amp;</span><br><span class="line">        base::SharedMemory::IsHandleValid(</span><br><span class="line">            stats_table-&gt;GetSharedMemoryHandle())) &#123;</span><br><span class="line">      files_to_register.push_back(</span><br><span class="line">          FileDescriptorInfo(kStatsTableSharedMemFd,</span><br><span class="line">                             stats_table-&gt;GetSharedMemoryHandle()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">    <span class="comment">// Android WebView runs in single process, ensure that we never get here</span></span><br><span class="line">    <span class="comment">// when running in single process mode.</span></span><br><span class="line">    CHECK(!cmd_line-&gt;HasSwitch(switches::kSingleProcess));</span><br><span class="line">    <span class="comment">//ContentBrowserClient，browser进程创建的对象，以后分析browser进程会讲到</span></span><br><span class="line">    <span class="comment">//添加额外的映射文件描述符给files_to_register</span></span><br><span class="line">    GetContentClient()-&gt;browser()-&gt;</span><br><span class="line">        GetAdditionalMappedFilesForChildProcess(*cmd_line, child_process_id,</span><br><span class="line">                                                &amp;files_to_register);</span><br><span class="line">    <span class="comment">//启动render进程</span></span><br><span class="line">    StartChildProcess(cmd_line-&gt;argv(), child_process_id, files_to_register,</span><br><span class="line">        base::Bind(&amp;ChildProcessLauncher::Context::OnChildProcessStarted,</span><br><span class="line">                   this_object, client_thread_id, begin_launch_time));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_POSIX)</span></span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(OS_MACOSX)</span></span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(OS_MACOSX)</span></span><br><span class="line">     ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// defined(OS_MACOSX)</span></span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_MACOSX)</span></span><br><span class="line">     ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// defined(OS_MACOSX)</span></span></span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// defined(OS_MACOSX)</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// else defined(OS_POSIX)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(OS_ANDROID)</span></span><br><span class="line"> ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_POSIX) &amp;&amp; !defined(OS_MACOSX)</span></span><br><span class="line">        ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !defined(OS_ANDROID)</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这个函数定义在文件external/chromium_org/content/browser/child_process_launcher.cc中。</p>
<p>&#160; &#160; &#160; &#160;上面有很多宏定义，但是我们只看Android的，核心就是StartChildProcess用来启动Render进程，参数有启动命令行，封装的文件描述符，创建的唯一子进程id，还有OnChildProcessStarted这个回调函数。</p>
<p>&#160; &#160; &#160; &#160;StartChildProcess实现位于external/chromium_org/content/browser/android/child_process_launcher_android.cc中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartChildProcess</span><span class="params">(</span><br><span class="line">    <span class="keyword">const</span> CommandLine::StringVector&amp; argv,</span><br><span class="line">    <span class="keyword">int</span> child_process_id,</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;content::FileDescriptorInfo&gt;&amp; files_to_register,</span><br><span class="line">    <span class="keyword">const</span> StartChildProcessCallback&amp; callback)</span> </span>&#123;</span><br><span class="line">  JNIEnv* env = AttachCurrentThread();</span><br><span class="line">  DCHECK(env);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the Command line String[]</span></span><br><span class="line">  ScopedJavaLocalRef&lt;jobjectArray&gt; j_argv = ToJavaArrayOfStrings(env, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> file_count = files_to_register.size();</span><br><span class="line">  DCHECK(file_count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  ScopedJavaLocalRef&lt;jintArray&gt; j_file_ids(env, env-&gt;NewIntArray(file_count));</span><br><span class="line">  base::android::CheckException(env);</span><br><span class="line">  jint* file_ids = env-&gt;GetIntArrayElements(j_file_ids.obj(), <span class="literal">NULL</span>);</span><br><span class="line">  base::android::CheckException(env);</span><br><span class="line">  ScopedJavaLocalRef&lt;jintArray&gt; j_file_fds(env, env-&gt;NewIntArray(file_count));</span><br><span class="line">  base::android::CheckException(env);</span><br><span class="line">  jint* file_fds = env-&gt;GetIntArrayElements(j_file_fds.obj(), <span class="literal">NULL</span>);</span><br><span class="line">  base::android::CheckException(env);</span><br><span class="line">  ScopedJavaLocalRef&lt;jbooleanArray&gt; j_file_auto_close(</span><br><span class="line">      env, env-&gt;NewBooleanArray(file_count));</span><br><span class="line">  base::android::CheckException(env);</span><br><span class="line">  jboolean* file_auto_close =</span><br><span class="line">      env-&gt;GetBooleanArrayElements(j_file_auto_close.obj(), <span class="literal">NULL</span>);</span><br><span class="line">  base::android::CheckException(env);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; file_count; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> content::FileDescriptorInfo&amp; fd_info = files_to_register[i];</span><br><span class="line">    file_ids[i] = fd_info.id;</span><br><span class="line">    file_fds[i] = fd_info.fd.fd;</span><br><span class="line">    file_auto_close[i] = fd_info.fd.auto_close;</span><br><span class="line">  &#125;</span><br><span class="line">  env-&gt;ReleaseIntArrayElements(j_file_ids.obj(), file_ids, <span class="number">0</span>);</span><br><span class="line">  env-&gt;ReleaseIntArrayElements(j_file_fds.obj(), file_fds, <span class="number">0</span>);</span><br><span class="line">  env-&gt;ReleaseBooleanArrayElements(j_file_auto_close.obj(), file_auto_close, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  Java_ChildProcessLauncher_start(env,</span><br><span class="line">      base::android::GetApplicationContext(),</span><br><span class="line">      j_argv.obj(),</span><br><span class="line">      child_process_id,</span><br><span class="line">      j_file_ids.obj(),</span><br><span class="line">      j_file_fds.obj(),</span><br><span class="line">      j_file_auto_close.obj(),</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">intptr_t</span>&gt;(<span class="keyword">new</span> StartChildProcessCallback(callback)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;其实就是将参数封装成jni类型的对象，然后反调Java层对应的方法。依然是启动命令行，封装的文件描述符，创建的唯一子进程id，还有OnChildProcessStarted这个回调函数。</p>
<p>&#160; &#160; &#160; &#160;反调Java层实现位于external/chromium_org/content/public/android/java/src/org/chromium/content/browser/ChildProcessLauncher.java中，调用它的start方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Spawns and connects to a child process. May be called on any thread. It will not block, but</span><br><span class="line">     * will instead callback to &#123;<span class="doctag">@link</span> #nativeOnChildProcessStarted&#125; when the connection is</span><br><span class="line">     * established. Note this callback will not necessarily be from the same thread (currently it</span><br><span class="line">     * always comes from the main thread).</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> context Context used to obtain the application context.</span><br><span class="line">     * <span class="doctag">@param</span> commandLine The child process command line argv.</span><br><span class="line">     * <span class="doctag">@param</span> fileIds The ID that should be used when mapping files in the created process.</span><br><span class="line">     * <span class="doctag">@param</span> fileFds The file descriptors that should be mapped in the created process.</span><br><span class="line">     * <span class="doctag">@param</span> fileAutoClose Whether the file descriptors should be closed once they were passed to</span><br><span class="line">     * the created process.</span><br><span class="line">     * <span class="doctag">@param</span> clientContext Arbitrary parameter used by the client to distinguish this connection.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="meta">@CalledByNative</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(</span><br><span class="line">            Context context,</span><br><span class="line">            <span class="keyword">final</span> String[] commandLine,</span><br><span class="line">            <span class="keyword">int</span> childProcessId,</span><br><span class="line">            <span class="keyword">int</span>[] fileIds,</span><br><span class="line">            <span class="keyword">int</span>[] fileFds,</span><br><span class="line">            <span class="keyword">boolean</span>[] fileAutoClose,</span><br><span class="line">            <span class="keyword">long</span> clientContext)</span> </span>&#123;</span><br><span class="line">        TraceEvent.begin();</span><br><span class="line">        <span class="keyword">assert</span> fileIds.length == fileFds.length &amp;&amp; fileFds.length == fileAutoClose.length;</span><br><span class="line">        <span class="comment">//将UNIX Socket的Client端描述符取出来封装</span></span><br><span class="line">        FileDescriptorInfo[] filesToBeMapped = <span class="keyword">new</span> FileDescriptorInfo[fileFds.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileFds.length; i++) &#123;</span><br><span class="line">            filesToBeMapped[i] =</span><br><span class="line">                    <span class="keyword">new</span> FileDescriptorInfo(fileIds[i], fileFds[i], fileAutoClose[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> clientContext != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> callbackType = CALLBACK_FOR_UNKNOWN_PROCESS;</span><br><span class="line">        <span class="keyword">boolean</span> inSandbox = <span class="keyword">true</span>;</span><br><span class="line">        String processType = getSwitchValue(commandLine, SWITCH_PROCESS_TYPE);</span><br><span class="line">        <span class="keyword">if</span> (SWITCH_RENDERER_PROCESS.equals(processType)) &#123;<span class="comment">//我们创建的是render进程</span></span><br><span class="line">            callbackType = CALLBACK_FOR_RENDERER_PROCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SWITCH_GPU_PROCESS.equals(processType)) &#123;</span><br><span class="line">            callbackType = CALLBACK_FOR_GPU_PROCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SWITCH_PPAPI_BROKER_PROCESS.equals(processType)) &#123;</span><br><span class="line">            inSandbox = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChildProcessConnection allocatedConnection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (ChildProcessLauncher.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inSandbox) &#123;<span class="comment">//true</span></span><br><span class="line">                allocatedConnection = sSpareSandboxedConnection;</span><br><span class="line">                sSpareSandboxedConnection = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (allocatedConnection == <span class="keyword">null</span>) &#123;<span class="comment">//会创建一个ChildProcessConnection对象</span></span><br><span class="line">            allocatedConnection = allocateBoundConnection(context, commandLine, inSandbox);</span><br><span class="line">            <span class="keyword">if</span> (allocatedConnection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Notify the native code so it can free the heap allocated callback.</span></span><br><span class="line">                nativeOnChildProcessStarted(clientContext, <span class="number">0</span>);</span><br><span class="line">                Log.e(TAG, <span class="string">"Allocation of new service failed."</span>);</span><br><span class="line">                TraceEvent.end();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"Setting up connection to process: slot="</span> +</span><br><span class="line">                allocatedConnection.getServiceNumber());</span><br><span class="line">        <span class="comment">//出发连接browser进程和render进程，就是利用socket</span></span><br><span class="line">        triggerConnectionSetup(allocatedConnection, commandLine, childProcessId, filesToBeMapped,</span><br><span class="line">                callbackType, clientContext);</span><br><span class="line">        TraceEvent.end();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;1）将UNIX Socket的Client端描述符取出来封装成FileDescriptorInfo，塞进filesToBeMapped数组；<br>&#160; &#160; &#160; &#160;2）processType类型为renderer，因此inSandbox为true。<br>&#160; &#160; &#160; &#160;3）调用allocateBoundConnection方法创建一个ChildProcessConnection对象。这一步其实就创建了ChildProcessService这个沙箱进程，是一个Service进程，我们接下来分析；<br>&#160; &#160; &#160; &#160;4）triggerConnectionSetup会把将UNIX Socket的Client端fd送给render进程保存，这样就可以和browser进程通信了。</p>
<p>&#160; &#160; &#160; &#160;我们先看第三部allocateBoundConnection实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ChildProcessConnection <span class="title">allocateBoundConnection</span><span class="params">(Context context,</span><br><span class="line">            String[] commandLine, <span class="keyword">boolean</span> inSandbox)</span> </span>&#123;</span><br><span class="line">        ChromiumLinkerParams chromiumLinkerParams = getLinkerParamsForNewConnection();</span><br><span class="line">        ChildProcessConnection connection =</span><br><span class="line">                allocateConnection(context, inSandbox, chromiumLinkerParams);</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.start(commandLine);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ChromiumLinkerParams <span class="title">getLinkerParamsForNewConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!sLinkerInitialized) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Linker.isUsed()) &#123;</span><br><span class="line">                sLinkerLoadAddress = Linker.getBaseLoadAddress();</span><br><span class="line">                <span class="keyword">if</span> (sLinkerLoadAddress == <span class="number">0</span>) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"Shared RELRO support disabled!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sLinkerInitialized = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sLinkerLoadAddress == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always wait for the shared RELROs in service processes.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> waitForSharedRelros = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChromiumLinkerParams(sLinkerLoadAddress,</span><br><span class="line">                                waitForSharedRelros,</span><br><span class="line">                                Linker.getTestRunnerClassName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;首先调用getLinkerParamsForNewConnection获取动态链接的参数，这里使用的是<strong>RELRO(Relocation Read Only)</strong>技术。</p>
<blockquote>
<p>&#160; &#160; &#160; &#160;在Linux系统安全领域数据可以写的存储区就会是攻击的目标,尤其是存储函数指针的区域. 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.<br>&#160; &#160; &#160; &#160;GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation.大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.<br>&#160; &#160; &#160; &#160;relro是一种比较古老的技术,至少2008年之前就已经进入了upstream.所以本文涉及到的GNU toolchains源代码版本来说选择非常自由,我使用的是我熟悉的版本: GCC-4.8.2 &amp; binutils/ld-2.26 &amp; eglibc-2.19</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;就不仔细看代码，里面无非就是和RELRO相关的so库的加载。</p>
<p>&#160; &#160; &#160; &#160;接着调用allocateConnection创建一个ChildProcessConnection对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Service class for child process. As the default value it uses SandboxedProcessService0 and</span></span><br><span class="line">    <span class="comment">// PrivilegedProcessService0.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ChildConnectionAllocator sSandboxedChildConnectionAllocator =</span><br><span class="line">            <span class="keyword">new</span> ChildConnectionAllocator(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ChildConnectionAllocator sPrivilegedChildConnectionAllocator =</span><br><span class="line">            <span class="keyword">new</span> ChildConnectionAllocator(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sConnectionAllocated = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ChildProcessConnection <span class="title">allocateConnection</span><span class="params">(Context context,</span><br><span class="line">            <span class="keyword">boolean</span> inSandbox, ChromiumLinkerParams chromiumLinkerParams)</span> </span>&#123;</span><br><span class="line">        ChildProcessConnection.DeathCallback deathCallback =</span><br><span class="line">            <span class="keyword">new</span> ChildProcessConnection.DeathCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChildProcessDied</span><span class="params">(ChildProcessConnection connection)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (connection.getPid() != <span class="number">0</span>) &#123;</span><br><span class="line">                        stop(connection.getPid());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        freeConnection(connection);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        sConnectionAllocated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//其实是创建一个ChildConnectionAllocator对象，构造函数的参数为true</span></span><br><span class="line">        <span class="comment">//然后调用ChildConnectionAllocator的allocate方法创建一个ChildProcessConnection对象</span></span><br><span class="line">        <span class="keyword">return</span> getConnectionAllocator(inSandbox).allocate(context, deathCallback,</span><br><span class="line">                chromiumLinkerParams);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其实是创建一个ChildConnectionAllocator对象，构造函数的参数为true，然后调用ChildConnectionAllocator的allocate方法创建一个ChildProcessConnection对象。</p>
<p>&#160; &#160; &#160; &#160;ChildConnectionAllocator的构造函数和allocate方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// The upper limit on the number of simultaneous sandboxed and privileged child service process</span></span><br><span class="line">    <span class="comment">// instances supported. Each limit must not exceed total number of SandboxedProcessServiceX</span></span><br><span class="line">    <span class="comment">// classes and PrivilegedProcessServiceX classes declared in this package and defined as</span></span><br><span class="line">    <span class="comment">// services in the embedding application's manifest file.</span></span><br><span class="line">    <span class="comment">// (See &#123;@link ChildProcessService&#125; for more details on defining the services.)</span></span><br><span class="line">    <span class="comment">/* package */</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_REGISTERED_SANDBOXED_SERVICES = <span class="number">13</span>;</span><br><span class="line">    <span class="comment">/* package */</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_REGISTERED_PRIVILEGED_SERVICES = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChildConnectionAllocator</span><span class="params">(<span class="keyword">boolean</span> inSandbox)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//13</span></span><br><span class="line">            <span class="keyword">int</span> numChildServices = inSandbox ?</span><br><span class="line">                    MAX_REGISTERED_SANDBOXED_SERVICES : MAX_REGISTERED_PRIVILEGED_SERVICES;</span><br><span class="line">            mChildProcessConnections = <span class="keyword">new</span> ChildProcessConnectionImpl[numChildServices];</span><br><span class="line">            <span class="comment">//创建一个mFreeConnectionIndices对象池，最大容量为13</span></span><br><span class="line">            mFreeConnectionIndices = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(numChildServices);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numChildServices; i++) &#123;</span><br><span class="line">                mFreeConnectionIndices.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//inSandbox为true，所以mChildClass为SandboxedProcessService.class</span></span><br><span class="line">            setServiceClass(inSandbox ?</span><br><span class="line">                    SandboxedProcessService.class : PrivilegedProcessService.class);</span><br><span class="line">            mInSandbox = inSandbox;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceClass</span><span class="params">(Class&lt;? extends ChildProcessService&gt; childClass)</span> </span>&#123;</span><br><span class="line">            mChildClass = childClass;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChildProcessConnection <span class="title">allocate</span><span class="params">(</span><br><span class="line">                Context context, ChildProcessConnection.DeathCallback deathCallback,</span><br><span class="line">                ChromiumLinkerParams chromiumLinkerParams)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mConnectionLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mFreeConnectionIndices.isEmpty()) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Ran out of service."</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从池中取出一个对象</span></span><br><span class="line">                <span class="keyword">int</span> slot = mFreeConnectionIndices.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">assert</span> mChildProcessConnections[slot] == <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//然后创建一个ChildProcessConnectionImpl对象，并返回</span></span><br><span class="line">                mChildProcessConnections[slot] = <span class="keyword">new</span> ChildProcessConnectionImpl(context, slot,</span><br><span class="line">                        mInSandbox, deathCallback, mChildClass, chromiumLinkerParams);</span><br><span class="line">                <span class="keyword">return</span> mChildProcessConnections[slot];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;可以看到ChildConnectionAllocator构造方法中创建一个mFreeConnectionIndices对象池，因为参数inSandbox为true，所以我们创建的是一个沙箱进程，最大容量为13，所以最多可以有13个render进程。由于inSandbox为true，所以mChildClass为SandboxedProcessService.class，接下来启动的Service对象进程的class就是SandboxedProcessService。</p>
<p>&#160; &#160; &#160; &#160;allocate方法就是从池中取出一个对象，然后创建一个ChildProcessConnectionImpl对象，然后将对应slot标记的变量赋值，并返回。</p>
<p>&#160; &#160; &#160; &#160;回到allocateBoundConnection方法中，接着调用刚才返回的ChildProcessConnectionImpl对象的start方法，位于external/chromium_org/content/public/android/java/src/org/chromium/content/browser/ChildProcessConnectionImpl.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ChildProcessConnectionImpl(Context context, <span class="keyword">int</span> number, <span class="keyword">boolean</span> inSandbox,</span><br><span class="line">            ChildProcessConnection.DeathCallback deathCallback,</span><br><span class="line">            Class&lt;? extends ChildProcessService&gt; serviceClass,</span><br><span class="line">            ChromiumLinkerParams chromiumLinkerParams) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mServiceNumber = number;</span><br><span class="line">        mInSandbox = inSandbox;</span><br><span class="line">        mDeathCallback = deathCallback;</span><br><span class="line">        mServiceClass = serviceClass;</span><br><span class="line">        mLinkerParams = chromiumLinkerParams;</span><br><span class="line">        mInitialBinding = <span class="keyword">new</span> ChildServiceConnection(Context.BIND_AUTO_CREATE);</span><br><span class="line">        mStrongBinding = <span class="keyword">new</span> ChildServiceConnection(</span><br><span class="line">                Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT);</span><br><span class="line">        mWaivedBinding = <span class="keyword">new</span> ChildServiceConnection(</span><br><span class="line">                Context.BIND_AUTO_CREATE | Context.BIND_WAIVE_PRIORITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String[] commandLine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            TraceEvent.begin();</span><br><span class="line">            <span class="keyword">assert</span> !ThreadUtils.runningOnUiThread();</span><br><span class="line">            <span class="keyword">assert</span> mConnectionParams == <span class="keyword">null</span> :</span><br><span class="line">                    <span class="string">"setupConnection() called before start() in ChildProcessConnectionImpl."</span>;</span><br><span class="line">            <span class="comment">//mInitialBinding.bind在构造函数中初始化过了，为ChildServiceConnection对象</span></span><br><span class="line">            <span class="comment">//调用ChildServiceConnection的bind方法</span></span><br><span class="line">            <span class="keyword">if</span> (!mInitialBinding.bind(commandLine)) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Failed to establish the service connection."</span>);</span><br><span class="line">                <span class="comment">// We have to notify the caller so that they can free-up associated resources.</span></span><br><span class="line">                <span class="comment">// TODO(ppi): Can we hard-fail here?</span></span><br><span class="line">                mDeathCallback.onChildProcessDied(ChildProcessConnectionImpl.<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWaivedBinding.bind(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TraceEvent.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;ChildProcessConnectionImpl的构造方法对mInitialBinding进行初始化，是一个ChildServiceConnection对象。接着start方法中调用mInitialBinding的bind方法。我们继续看ChildServiceConnection的bind方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">createServiceBindIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">            <span class="comment">//mServiceClass类型为SandboxedProcessService，上面提过</span></span><br><span class="line">            intent.setClassName(mContext, mServiceClass.getName() + mServiceNumber);</span><br><span class="line">            intent.setPackage(mContext.getPackageName());</span><br><span class="line">            <span class="keyword">return</span> intent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChildServiceConnection</span><span class="params">(<span class="keyword">int</span> bindFlags)</span> </span>&#123;</span><br><span class="line">            mBindFlags = bindFlags;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">bind</span><span class="params">(String[] commandLine)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!mBound) &#123;</span><br><span class="line">                TraceEvent.begin();</span><br><span class="line">                <span class="keyword">final</span> Intent intent = createServiceBindIntent();</span><br><span class="line">                <span class="keyword">if</span> (commandLine != <span class="keyword">null</span>) &#123;<span class="comment">//将命令行放入intent的extras</span></span><br><span class="line">                    intent.putExtra(EXTRA_COMMAND_LINE, commandLine);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mLinkerParams != <span class="keyword">null</span>)<span class="comment">//将链接参数也放进去</span></span><br><span class="line">                    mLinkerParams.addIntentExtras(intent);</span><br><span class="line">                <span class="comment">//然后启动SandboxedProcessService这个render进程</span></span><br><span class="line">                mBound = mContext.bindService(intent, <span class="keyword">this</span>, mBindFlags);</span><br><span class="line">                TraceEvent.end();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mBound;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;bind函数首先创建Service进程的Intent，我们上面知道他的类型为SandboxedProcessService.class，然后将命令行放入intent的extras，再将链接参数也放进去。最后调用Context的bindService函数启动SandboxedProcessService。</p>
<p>&#160; &#160; &#160; &#160;<strong>还有第四步，triggerConnectionSetup会把将UNIX Socket的Client端fd送给render进程保存，这样就可以和browser进程通信了。我们放到Render进程启动的第二部分再讲。</strong></p>
<p>&#160; &#160; &#160; &#160;这样我们Render进程启动过程的第一部分就分析完了。</p>
<h2 id="Render进程启动的第二部分"><a href="#Render进程启动的第二部分" class="headerlink" title="Render进程启动的第二部分"></a>Render进程启动的第二部分</h2><p>&#160; &#160; &#160; &#160;如果是正常启动一个网页，load一个url，流程是这样的：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/loadurl.jpg" alt="loadurl"></p>
<p>&#160; &#160; &#160; &#160;render进程是应用程序的子进程，以service的形式提供给应用程序。需要在应用程序的AndroidMenifest.xml中声明render进程中运行的service。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- The following service entries exist in order to allow us to</span><br><span class="line">             start more than one sandboxed process. --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- NOTE: If you change the values of "android:process" for any of the below services,</span><br><span class="line">             you also need to update kHelperProcessExecutableName in chrome_constants.cc. --&gt;</span><br><span class="line">        &lt;service android:name="org.chromium.content.app.SandboxedProcessService0"</span><br><span class="line">                 android:process=":sandboxed_process0"</span><br><span class="line">                 android:permission="org.chromium.content_shell.permission.SANDBOX"</span><br><span class="line">                 android:isolatedProcess="true"</span><br><span class="line">                 android:exported="false" /&gt;</span><br><span class="line">        &lt;service android:name="org.chromium.content.app.SandboxedProcessService1"</span><br><span class="line">                 android:process=":sandboxed_process1"</span><br><span class="line">                 android:permission="org.chromium.content_shell.permission.SANDBOX"</span><br><span class="line">                 android:isolatedProcess="true"</span><br><span class="line">                 android:exported="false" /&gt;</span><br><span class="line">        &lt;service android:name="org.chromium.content.app.SandboxedProcessService2"</span><br><span class="line">                 android:process=":sandboxed_process2"</span><br><span class="line">                 </span><br><span class="line">                 ...</span><br><span class="line"></span><br><span class="line">        &lt;service android:name="org.chromium.content.app.SandboxedProcessService12"</span><br><span class="line">                 android:process=":sandboxed_process12"</span><br><span class="line">                 android:permission="org.chromium.content_shell.permission.SANDBOX"</span><br><span class="line">                 android:isolatedProcess="true"</span><br><span class="line">                 android:exported="false" /&gt;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;可以看出一共有13个沙箱Service，分别从0～12。那么我们再看看它的继承结构：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/ChildProcessService.jpg" alt="ChildProcessService"></p>
<h3 id="插个嘴：第一个tab页面"><a href="#插个嘴：第一个tab页面" class="headerlink" title="插个嘴：第一个tab页面"></a>插个嘴：第一个tab页面</h3><p>&#160; &#160; &#160; &#160;这里我们插个嘴（<code>后面会讲为什么</code>）：<strong>不过有一点我们提前注意，SandboxedProcessService0的创建过程是由ChildProcessLauncher的warmUp方法触发的，并非start方法。</strong>warmUp方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Should be called early in startup so the work needed to spawn the child process can be done</span><br><span class="line"> * in parallel to other startup work. Must not be called on the UI thread. Spare connection is</span><br><span class="line"> * created in sandboxed child process.</span><br><span class="line"> * @param context the application context used for the connection.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">warmUp</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    synchronized (ChildProcessLauncher.<span class="keyword">class</span>) &#123;</span><br><span class="line">        assert !ThreadUtils.runningOnUiThread();</span><br><span class="line">        <span class="keyword">if</span> (sSpareSandboxedConnection == null) &#123;</span><br><span class="line">            sSpareSandboxedConnection = allocateBoundConnection(context, null, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;应用程序调用warmUp触发的ChildProcessService的创建过程：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/warmup.jpg" alt="warmUp"></p>
<p>&#160; &#160; &#160; &#160;再次插个嘴（<code>后面会讲为什么</code>）：<strong>并且SandboxedProcessService0创建时候，ChildProcessService的onCreate方法中并没有触发到底层process的创建，即ChildProcessService的onCreate()没有执行到ContentMain.initApplicationContext，就被阻塞了。</strong></p>
<p>&#160; &#160; &#160; &#160;创建第一个tab时候，render进程的更通用的创建方式是由native层的ChildProcessLauncher(定义在child_process_launcher.cc中)回调java层的ChildProcessLauncher的Start方法触发的。</p>
<p>&#160; &#160; &#160; &#160;第三次插个嘴（<code>后面会讲为什么</code>）<strong>ChildProcessLauncher.start函数在第一次调用时，由于SandboxedProcessService0已经创建，并阻塞在ChildProcessService的onCreate方法中，所以ChildProcessLauncher.start使ChildProcessService的onCreate方法在上次warmUp调用时序阻塞的地方notify了，即阻塞接触了，完成了render进程的创建。</strong></p>
<h3 id="第二个tab页"><a href="#第二个tab页" class="headerlink" title="第二个tab页"></a>第二个tab页</h3><p>&#160; &#160; &#160; &#160;在创建第二个Tab时，SandboxedProcessService1的创建是由以下调用触发的：</p>
<ol>
<li>ChildProcessLauncher.start函数调用allocateBoundConnection，</li>
<li>allocateBoundConnection调用allocateConnection生成一个ChildProcessConnection实例。</li>
<li>allocateBoundConnection调用新生成的ChildProcessConnection的bind方法，</li>
<li>ChildProcessConnection的bind调用Context::bindService()，</li>
<li>bindService触发SandboxedProcessService1的onCreate方法。</li>
<li>SandboxedProcessService1是ChildProcessService的基类，从ChildProcessService继承onCreate方法。</li>
<li>所以实际执行的是ChildProcessService::onCreate。</li>
</ol>
<p>&#160; &#160; &#160; &#160;由于第一个tab页流程有些乱，所以我们选第二个tab页流程分析，也正好解答第一个tab页插嘴不明白的地方。</p>
<p>&#160; &#160; &#160; &#160;从render进程启动第一部分得知，使用Context的bindService启动的ChildProcessService，因此会触发ServiceConnection的onServiceConnected方法。对应的是ChildServiceConnection类对象，依然位于external/chromium_org/content/public/android/java/src/org/chromium/content/browser/ChildProcessConnectionImpl.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildServiceConnection</span> <span class="keyword">implements</span> <span class="title">ServiceConnection</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;<span class="comment">//这个同步锁是为了保证和第一部分第4步骤的triggerConnectionSetup排队执行</span></span><br><span class="line">            <span class="comment">// A flag from the parent class ensures we run the post-connection logic only once</span></span><br><span class="line">            <span class="comment">// (instead of once per each ChildServiceConnection).</span></span><br><span class="line">            <span class="keyword">if</span> (mServiceConnectComplete) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TraceEvent.begin();</span><br><span class="line">            <span class="comment">//bindService之后将mServiceConnectComplete置为true</span></span><br><span class="line">            mServiceConnectComplete = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//拿到远端Serivice的ChildProcessService的binder代理</span></span><br><span class="line">            mService = IChildProcessService.Stub.asInterface(service);</span><br><span class="line">            <span class="comment">// Run the setup if the connection parameters have already been provided. If not,</span></span><br><span class="line">            <span class="comment">// doConnectionSetupLocked() will be called from setupConnection().</span></span><br><span class="line">            <span class="comment">//此时可能第一部分第4步骤的triggerConnectionSetup 会调用setupConnection还没有调用</span></span><br><span class="line">            <span class="comment">//triggerConnectionSetup里面会给mConnectionParams赋值</span></span><br><span class="line">            <span class="comment">//但如果没有调用，就不会继续调用doConnectionSetupLocked了</span></span><br><span class="line">            <span class="keyword">if</span> (mConnectionParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">                doConnectionSetupLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            TraceEvent.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;1）onServiceConnected方法里首先将mServiceConnectComplete置为true；<br>&#160; &#160; &#160; &#160;2）拿到远端Serivice的ChildProcessService的binder代理，赋值给mService变量；<br>&#160; &#160; &#160; &#160;3）由于synchronized (mLock)同步锁，锁住了代码块，而第一部分第4步骤的triggerConnectionSetup 同样用mLock这个同步锁，所以可能第一部分第4步骤的triggerConnectionSetup 会调用setupConnection还没有调用，triggerConnectionSetup里面会给mConnectionParams赋值，但如果没有调用，就不会继续调用doConnectionSetupLocked了。</p>
<p>&#160; &#160; &#160; &#160;我们把doConnectionSetupLocked放到triggerConnectionSetup流程。好的，我们继续分析第一部分第4步骤的triggerConnectionSetup的实现，回到ChildProcessLauncher中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triggerConnectionSetup</span><span class="params">(</span><br><span class="line">            <span class="keyword">final</span> ChildProcessConnection connection,</span><br><span class="line">            String[] commandLine,</span><br><span class="line">            <span class="keyword">int</span> childProcessId,</span><br><span class="line">            FileDescriptorInfo[] filesToBeMapped,</span><br><span class="line">            <span class="keyword">int</span> callbackType,</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> clientContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ConnectionCallback</span></span><br><span class="line">        ChildProcessConnection.ConnectionCallback connectionCallback =</span><br><span class="line">                <span class="keyword">new</span> ChildProcessConnection.ConnectionCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnected</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"on connect callback, pid="</span> + pid + <span class="string">" context="</span> + clientContext);</span><br><span class="line">                        <span class="keyword">if</span> (pid != NULL_PROCESS_HANDLE) &#123;</span><br><span class="line">                            sBindingManager.addNewConnection(pid, connection);</span><br><span class="line">                            sServiceMap.put(pid, connection);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// If the connection fails and pid == 0, the Java-side cleanup was already</span></span><br><span class="line">                        <span class="comment">// handled by DeathCallback. We still have to call back to native for</span></span><br><span class="line">                        <span class="comment">// cleanup there.</span></span><br><span class="line">                        <span class="keyword">if</span> (clientContext != <span class="number">0</span>) &#123;  <span class="comment">// Will be 0 in Java instrumentation tests.</span></span><br><span class="line">                            nativeOnChildProcessStarted(clientContext, pid);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO(sievers): Revisit this as it doesn't correctly handle the utility process</span></span><br><span class="line">        <span class="comment">// assert callbackType != CALLBACK_FOR_UNKNOWN_PROCESS;</span></span><br><span class="line">        <span class="comment">//然后调用ChildProcessConnectionImpl的setupConnection方法</span></span><br><span class="line">        connection.setupConnection(commandLine,</span><br><span class="line">                                   filesToBeMapped,</span><br><span class="line">                                   createCallback(childProcessId, callbackType),</span><br><span class="line">                                   connectionCallback,</span><br><span class="line">                                   Linker.getSharedRelros());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;先创建一个ConnectionCallback，然后调用ChildProcessConnectionImpl的setupConnection方法，并把filesToBeMapped代表的IPC Socket client端的fd，connectionCallback作为参数穿进去。</p>
<p>&#160; &#160; &#160; &#160;ChildProcessConnectionImpl的setupConnection方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupConnection</span><span class="params">(</span><br><span class="line">            String[] commandLine,</span><br><span class="line">            FileDescriptorInfo[] filesToBeMapped,</span><br><span class="line">            IChildProcessCallback processCallback,</span><br><span class="line">            ConnectionCallback connectionCallback,</span><br><span class="line">            Bundle sharedRelros)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">assert</span> mConnectionParams == <span class="keyword">null</span>;<span class="comment">//null</span></span><br><span class="line">            <span class="keyword">if</span> (mServiceDisconnected) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Tried to setup a connection that already disconnected."</span>);</span><br><span class="line">                connectionCallback.onConnected(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TraceEvent.begin();</span><br><span class="line">            <span class="comment">//将上一步创建的ConnectionCallback赋给mConnectionCallback</span></span><br><span class="line">            mConnectionCallback = connectionCallback;</span><br><span class="line">            <span class="comment">//创建一个ConnectionParams赋给mConnectionParams</span></span><br><span class="line">            mConnectionParams = <span class="keyword">new</span> ConnectionParams(</span><br><span class="line">                    commandLine, filesToBeMapped, processCallback, sharedRelros);</span><br><span class="line">            <span class="comment">// Run the setup if the service is already connected. If not, doConnectionSetupLocked()</span></span><br><span class="line">            <span class="comment">// will be called from onServiceConnected().</span></span><br><span class="line">            <span class="comment">//true 就会调用doConnectionSetupLocked</span></span><br><span class="line">            <span class="keyword">if</span> (mServiceConnectComplete) &#123;</span><br><span class="line">                doConnectionSetupLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            TraceEvent.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;1）我们看到setupConnection和上一步的onServiceConnected持有的是同一把锁mLock。<br>&#160; &#160; &#160; &#160;2）接着就是将上一步创建的ConnectionCallback赋给mConnectionCallback；<br>&#160; &#160; &#160; &#160;3）然后创建一个ConnectionParams赋给mConnectionParams。<strong>这个很重要，我们之前说ChildProcessLauncher的warmUp方法启动ChildProcessService会在onCreate中阻塞，就是因为mConnectionParams为null，先提前告你，等会儿分析。</strong><br>&#160; &#160; &#160; &#160;4）如果mServiceConnectComplete为true，表示onServiceConnected先抢到了同步锁，因此这里执行doConnectionSetupLocked方法。</p>
<p>&#160; &#160; &#160; &#160;我们接着看doConnectionSetupLocked方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Called after the connection parameters have been set (in setupConnection()) *and* a</span><br><span class="line">     * connection has been established (as signaled by onServiceConnected()). These two events can</span><br><span class="line">     * happen in any order. Has to be called with mLock.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doConnectionSetupLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TraceEvent.begin();</span><br><span class="line">        <span class="keyword">assert</span> mServiceConnectComplete &amp;&amp; mService != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">assert</span> mConnectionParams != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        <span class="comment">//塞进启动命令行</span></span><br><span class="line">        bundle.putStringArray(EXTRA_COMMAND_LINE, mConnectionParams.mCommandLine);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是塞进IPC Socket 文件描述符相关</span></span><br><span class="line">        FileDescriptorInfo[] fileInfos = mConnectionParams.mFilesToBeMapped;</span><br><span class="line">        ParcelFileDescriptor[] parcelFiles = <span class="keyword">new</span> ParcelFileDescriptor[fileInfos.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileInfos.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileInfos[i].mFd == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// If someone provided an invalid FD, they are doing something wrong.</span></span><br><span class="line">                Log.e(TAG, <span class="string">"Invalid FD (id="</span> + fileInfos[i].mId + <span class="string">") for process connection, "</span></span><br><span class="line">                      + <span class="string">"aborting connection."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String idName = EXTRA_FILES_PREFIX + i + EXTRA_FILES_ID_SUFFIX;</span><br><span class="line">            String fdName = EXTRA_FILES_PREFIX + i + EXTRA_FILES_FD_SUFFIX;</span><br><span class="line">            <span class="keyword">if</span> (fileInfos[i].mAutoClose) &#123;</span><br><span class="line">                <span class="comment">// Adopt the FD, it will be closed when we close the ParcelFileDescriptor.</span></span><br><span class="line">                parcelFiles[i] = ParcelFileDescriptor.adoptFd(fileInfos[i].mFd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    parcelFiles[i] = ParcelFileDescriptor.fromFd(fileInfos[i].mFd);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Log.e(TAG,</span><br><span class="line">                          <span class="string">"Invalid FD provided for process connection, aborting connection."</span>,</span><br><span class="line">                          e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            bundle.putParcelable(fdName, parcelFiles[i]);</span><br><span class="line">            bundle.putInt(idName, fileInfos[i].mId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Add the CPU properties now.</span></span><br><span class="line">        <span class="comment">//塞进cpu属性相关</span></span><br><span class="line">        bundle.putInt(EXTRA_CPU_COUNT, CpuFeatures.getCount());</span><br><span class="line">        bundle.putLong(EXTRA_CPU_FEATURES, CpuFeatures.getMask());</span><br><span class="line">        <span class="comment">//塞进RELROS技术相关内容</span></span><br><span class="line">        bundle.putBundle(Linker.EXTRA_LINKER_SHARED_RELROS,</span><br><span class="line">                         mConnectionParams.mSharedRelros);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过这个ChildProcessService的Binder代理，调用远程服务的setupConnection方法，并把刚才塞进bundle的相关内容传递到render进程</span></span><br><span class="line">            <span class="comment">//返回的是render进程的pid</span></span><br><span class="line">            mPid = mService.setupConnection(bundle, mConnectionParams.mCallback);</span><br><span class="line">            <span class="keyword">assert</span> mPid != <span class="number">0</span> : <span class="string">"Child service claims to be run by a process of pid=0."</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (android.os.RemoteException re) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to setup connection."</span>, re);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We proactively close the FDs rather than wait for GC &amp; finalizer.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (ParcelFileDescriptor parcelFile : parcelFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parcelFile != <span class="keyword">null</span>) parcelFile.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Failed to close FD."</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">        mConnectionParams = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//mConnectionCallback就是刚才triggerConnectionSetup中创建的connectionCallback</span></span><br><span class="line">        <span class="keyword">if</span> (mConnectionCallback != <span class="keyword">null</span>) &#123;<span class="comment">//然后执行connectionCallback的onConnected方法，参数为render进程的pid</span></span><br><span class="line">            mConnectionCallback.onConnected(mPid);</span><br><span class="line">        &#125;</span><br><span class="line">        mConnectionCallback = <span class="keyword">null</span>;</span><br><span class="line">        TraceEvent.end();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;Browser进程和Render进程需要IPC通信，所以需要把相关参数塞进Bundle中，然后传给Render进程。</p>
<p>&#160; &#160; &#160; &#160;因此先创建一个Bundle对象，然后塞进启动命令行，塞进IPC Socket 文件描述符相关，在塞进其他，最后通过全局变量mServicce这个ChildProcessService的Binder代理，调用远程服务的setupConnection方法，并把刚才塞进bundle的相关内容传递到render进程，返回render进程的pid。最后执行connectionCallback的onConnected方法，参数为render进程的pid。</p>
<p>&#160; &#160; &#160; &#160;1）我们先看看通过全局变量mServicce这个ChildProcessService的Binder代理，调用远程服务的setupConnection方法，位于external/chromium_org/content/public/android/java/src/org/chromium/content/app/ChildProcessService.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binder object used by clients for this service.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IChildProcessService.Stub mBinder = <span class="keyword">new</span> IChildProcessService.Stub() &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Implement any IChildProcessService methods here.</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">setupConnection</span><span class="params">(Bundle args, IChildProcessCallback callback)</span> </span>&#123;</span><br><span class="line">            mCallback = callback;</span><br><span class="line">            <span class="keyword">synchronized</span> (mMainThread) &#123;</span><br><span class="line">                <span class="comment">// Allow the command line to be set via bind() intent or setupConnection, but</span></span><br><span class="line">                <span class="comment">// the FD can only be transferred here.</span></span><br><span class="line">                <span class="comment">//获取命令行参数</span></span><br><span class="line">                <span class="keyword">if</span> (mCommandLineParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCommandLineParams = args.getStringArray(</span><br><span class="line">                            ChildProcessConnection.EXTRA_COMMAND_LINE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We must have received the command line by now</span></span><br><span class="line">                <span class="keyword">assert</span> mCommandLineParams != <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//cpu count</span></span><br><span class="line">                mCpuCount = args.getInt(ChildProcessConnection.EXTRA_CPU_COUNT);</span><br><span class="line">                <span class="comment">// cpu features</span></span><br><span class="line">                mCpuFeatures = args.getLong(ChildProcessConnection.EXTRA_CPU_FEATURES);</span><br><span class="line">                <span class="keyword">assert</span> mCpuCount &gt; <span class="number">0</span>;</span><br><span class="line">                mFileIds = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                mFileFds = <span class="keyword">new</span> ArrayList&lt;ParcelFileDescriptor&gt;();</span><br><span class="line">                <span class="comment">//获取IPC Socket Client相关文件描述符</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">                    String fdName = ChildProcessConnection.EXTRA_FILES_PREFIX + i</span><br><span class="line">                            + ChildProcessConnection.EXTRA_FILES_FD_SUFFIX;</span><br><span class="line">                    ParcelFileDescriptor parcel = args.getParcelable(fdName);</span><br><span class="line">                    <span class="keyword">if</span> (parcel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// End of the file list.</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mFileFds.add(parcel);</span><br><span class="line">                    String idName = ChildProcessConnection.EXTRA_FILES_PREFIX + i</span><br><span class="line">                            + ChildProcessConnection.EXTRA_FILES_ID_SUFFIX;</span><br><span class="line">                    mFileIds.add(args.getInt(idName));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//RELROS相关技术属性</span></span><br><span class="line">                Bundle sharedRelros = args.getBundle(Linker.EXTRA_LINKER_SHARED_RELROS);</span><br><span class="line">                <span class="keyword">if</span> (sharedRelros != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Linker.useSharedRelros(sharedRelros);</span><br><span class="line">                    sharedRelros = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//唤醒阻塞ChildProcessService onCreate重的睡眠，后面会讲到</span></span><br><span class="line">                mMainThread.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回render进程的pid</span></span><br><span class="line">            <span class="keyword">return</span> Process.myPid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;ChildProcessService的Binder代理的setupConnection会依次获取从Browser进程传递过来的命令行参数、cpu count、cpu features、IPC Socket Client相关文件描述符、RELROS相关技术属性，然后唤醒阻塞ChildProcessService onCreate重的睡眠，<code>后面会讲到</code>，最后返回render进程的pid。</p>
<p>&#160; &#160; &#160; &#160;2）再看看执行connectionCallback的onConnected方法，参数为render进程的pid。从上面得知ConnectionCallback定义如下，位于external/chromium_org/content/public/android/java/src/org/chromium/content/browser/ChildProcessLauncher.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ChildProcessConnection.ConnectionCallback connectionCallback =</span><br><span class="line">                <span class="keyword">new</span> ChildProcessConnection.ConnectionCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnected</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"on connect callback, pid="</span> + pid + <span class="string">" context="</span> + clientContext);</span><br><span class="line">                        <span class="keyword">if</span> (pid != NULL_PROCESS_HANDLE) &#123;</span><br><span class="line">                            sBindingManager.addNewConnection(pid, connection);</span><br><span class="line">                            sServiceMap.put(pid, connection);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// If the connection fails and pid == 0, the Java-side cleanup was already</span></span><br><span class="line">                        <span class="comment">// handled by DeathCallback. We still have to call back to native for</span></span><br><span class="line">                        <span class="comment">// cleanup there.</span></span><br><span class="line">                        <span class="keyword">if</span> (clientContext != <span class="number">0</span>) &#123;  <span class="comment">// Will be 0 in Java instrumentation tests.</span></span><br><span class="line">                            nativeOnChildProcessStarted(clientContext, pid);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeOnChildProcessStarted</span><span class="params">(<span class="keyword">long</span> clientContext, <span class="keyword">int</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;忽略其他，只看nativeOnChildProcessStarted这方法，它是一个native方法。通过上面child_process_launcher的Launch函数的值，这个native犯法最终会通过JNI调用child_process_launcher的OnChildProcessStarted函数。位于external/chromium_org/content/browser/child_process_launcher.cc：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnChildProcessStarted</span><span class="params">(</span><br><span class="line">      <span class="comment">// |this_object| is NOT thread safe. Only use it to post a task back.</span></span><br><span class="line">      scoped_refptr&lt;Context&gt; this_object,</span><br><span class="line">      BrowserThread::ID client_thread_id,</span><br><span class="line">      <span class="keyword">const</span> base::TimeTicks begin_launch_time,</span><br><span class="line">      base::ProcessHandle handle)</span> </span>&#123;</span><br><span class="line">    RecordHistograms(begin_launch_time);</span><br><span class="line">    <span class="keyword">if</span> (BrowserThread::CurrentlyOn(client_thread_id)) &#123;</span><br><span class="line">      <span class="comment">// This is always invoked on the UI thread which is commonly the</span></span><br><span class="line">      <span class="comment">// |client_thread_id| so we can shortcut one PostTask.</span></span><br><span class="line">      this_object-&gt;Notify(handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      BrowserThread::PostTask(</span><br><span class="line">          client_thread_id, FROM_HERE,</span><br><span class="line">          base::Bind(</span><br><span class="line">              &amp;ChildProcessLauncher::Context::Notify,</span><br><span class="line">              this_object,</span><br><span class="line">              handle));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;如果实在当前线程，就直接执行Notify函数，否则就把它发到指定线程去执行。Notify定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  void Notify(</span><br><span class="line">#if defined(OS_POSIX) &amp;&amp; !defined(OS_MACOSX) &amp;&amp; !defined(OS_ANDROID)</span><br><span class="line">      bool zygote,</span><br><span class="line">#endif</span><br><span class="line">      base::ProcessHandle handle) &#123;</span><br><span class="line">#if defined(OS_ANDROID)</span><br><span class="line">    // Finally close the ipcfd</span><br><span class="line">    base::ScopedFD ipcfd_closer(ipcfd_);</span><br><span class="line">#endif</span><br><span class="line">    starting_ = false;</span><br><span class="line">    process_.set_handle(handle);</span><br><span class="line">    if (!handle)</span><br><span class="line">      LOG(ERROR) &lt;&lt; "Failed to launch child process";</span><br><span class="line"></span><br><span class="line">#if defined(OS_POSIX) &amp;&amp; !defined(OS_MACOSX) &amp;&amp; !defined(OS_ANDROID)</span><br><span class="line">    zygote_ = zygote;</span><br><span class="line">#endif</span><br><span class="line">    if (client_) &#123;</span><br><span class="line">      if (handle) &#123;</span><br><span class="line">        client_-&gt;OnProcessLaunched();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        client_-&gt;OnProcessLaunchFailed();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Terminate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;最后和非独立进程Render的最后一步一样，调用OnProcessLaunched，是一个fake的通知。这一步就不用管了。</p>
<p>&#160; &#160; &#160; &#160;这些传递给Render进程相关参数的工作做完了，就改继续看看Render进程启动的Service类的流程了，即ChildProcessService类绑定过程。</p>
<h3 id="ChildProcessService类绑定过程"><a href="#ChildProcessService类绑定过程" class="headerlink" title="ChildProcessService类绑定过程"></a>ChildProcessService类绑定过程</h3><p>&#160; &#160; &#160; &#160;Service启动先走onCreate，我们看看ChildProcessService的onCreate方法，位于external/chromium_org/content/public/android/java/src/org/chromium/content/app/ChildProcessService.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"Creating new ChildProcessService pid="</span> + Process.myPid());</span><br><span class="line">        <span class="keyword">if</span> (sContext.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"ChildProcessService created again in process!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sContext.set(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">//创建一个线程</span></span><br><span class="line">        mMainThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//RELRO技术相关</span></span><br><span class="line">                    <span class="keyword">boolean</span> useLinker = Linker.isUsed();</span><br><span class="line">                    <span class="keyword">if</span> (useLinker) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (mMainThread) &#123;</span><br><span class="line">                            <span class="keyword">while</span> (!mIsBound) &#123;</span><br><span class="line">                                mMainThread.wait();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (mLinkerParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mLinkerParams.mWaitForSharedRelro)</span><br><span class="line">                                Linker.initServiceProcess(mLinkerParams.mBaseLoadAddress);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                Linker.disableSharedRelros();</span><br><span class="line"></span><br><span class="line">                            Linker.setTestRunnerClassName(mLinkerParams.mTestRunnerClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//加载chromuim相关的so，比如webview相关的</span></span><br><span class="line">                        <span class="comment">//并且会出发JNI_OnLoad函数</span></span><br><span class="line">                        <span class="comment">//这一步会向ContentMain注册ContentMainDelegate</span></span><br><span class="line">                        LibraryLoader.loadNow(getApplicationContext(), <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ProcessInitException e) &#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">"Failed to load native library, exiting child process"</span>, e);</span><br><span class="line">                        System.exit(-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mMainThread) &#123;</span><br><span class="line">                        <span class="comment">//之前讲过，ChildProcessLauncher的warmUp启动时候，</span></span><br><span class="line">                        <span class="comment">//会在onCreate方法中阻塞，</span></span><br><span class="line">                        <span class="comment">//就是因为warmUp中没有给mCommandLineParams赋值，为null</span></span><br><span class="line">                        <span class="keyword">while</span> (mCommandLineParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mMainThread.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    LibraryLoader.initialize(mCommandLineParams);</span><br><span class="line">                    <span class="keyword">synchronized</span> (mMainThread) &#123;</span><br><span class="line">                        mLibraryInitialized = <span class="keyword">true</span>;</span><br><span class="line">                        mMainThread.notifyAll();</span><br><span class="line">                        <span class="keyword">while</span> (mFileIds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mMainThread.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//然后取出IPC Socket Client的文件描述符</span></span><br><span class="line">                    <span class="keyword">assert</span> mFileIds.size() == mFileFds.size();</span><br><span class="line">                    <span class="keyword">int</span>[] fileIds = <span class="keyword">new</span> <span class="keyword">int</span>[mFileIds.size()];</span><br><span class="line">                    <span class="keyword">int</span>[] fileFds = <span class="keyword">new</span> <span class="keyword">int</span>[mFileFds.size()];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mFileIds.size(); ++i) &#123;</span><br><span class="line">                        fileIds[i] = mFileIds.get(i);</span><br><span class="line">                        fileFds[i] = mFileFds.get(i).detachFd();</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//初始化所有类型进程                    ContentMain.initApplicationContext(sContext.get().getApplicationContext());</span></span><br><span class="line"><span class="comment">//将所有的客户端IPC 的fd保存起来，就是第一部分分析的独立render进程启动时候保存</span></span><br><span class="line"><span class="comment">//IPC client的base::GlobalDescriptors::GetInstance()                  nativeInitChildProcess(sContext.get().getApplicationContext(),</span></span><br><span class="line">                            ChildProcessService.<span class="keyword">this</span>, fileIds, fileFds,</span><br><span class="line">                            mCpuCount, mCpuFeatures);</span><br><span class="line">                    <span class="comment">//这一步会讲IPC client的fd取出封装成ChannelProxy        </span></span><br><span class="line">                    ContentMain.start();</span><br><span class="line">                    <span class="comment">//上一步消息循环会轮训，因此退出消息循环就会退render进程</span></span><br><span class="line">                    nativeExitChildProcess();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Log.w(TAG, MAIN_THREAD_NAME + <span class="string">" startup failed: "</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ProcessInitException e) &#123;</span><br><span class="line">                    Log.w(TAG, MAIN_THREAD_NAME + <span class="string">" startup failed: "</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, MAIN_THREAD_NAME);</span><br><span class="line">        mMainThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;我们看到在Service进程里先起了一个线程，然后直接start。<br>&#160; &#160; &#160; &#160;1）检测RELRO技术相关库和链接是否成功，如果不ok就要等待；<br>&#160; &#160; &#160; &#160;2）加载chromuim相关的so，比如webview相关的，并且会出发JNI_OnLoad函数，这一步会向ContentMain注册ContentMainDelegate；我们下面会讲到；<br>&#160; &#160; &#160; &#160;3）之前讲过，ChildProcessLauncher的warmUp启动时候，会在onCreate方法中阻塞，就是因为warmUp中没有给mCommandLineParams赋值，为null；<br>&#160; &#160; &#160; &#160;4）然后取出IPC Socket Client的文件描述符；<br>&#160; &#160; &#160; &#160;5）初始化所有类型进程；<br>&#160; &#160; &#160; &#160;6）将所有的客户端IPC 的fd保存起来，就是第一部分分析的独立render进程启动时候保存；<br>&#160; &#160; &#160; &#160;7）这一步会讲IPC client的fd取出封装成ChannelProxy ；<br>&#160; &#160; &#160; &#160;8）上一步消息循环会轮训，因此退出消息循环就会退render进程。</p>
<p>&#160; &#160; &#160; &#160;详细看看第五步后面的内容。<br>&#160; &#160; &#160; &#160;我们先看看ContentMain的类结构，位于external/chromium_org/content/public/android/java/src/org/chromium/content/app/ContentMain.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JNINamespace</span>(<span class="string">"content"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentMain</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Initialize application context in native side.</span><br><span class="line">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        nativeInitApplicationContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Start the ContentMainRunner in native side.</span><br><span class="line">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nativeStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeInitApplicationContext</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">nativeStart</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;先看看initApplicationContext，C++层调用的是external/chromium_org/content/app/android/content_main.cc：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitApplicationContext</span><span class="params">(JNIEnv* env, jclass clazz, jobject context)</span> </span>&#123;</span><br><span class="line">  base::android::ScopedJavaLocalRef&lt;jobject&gt; scoped_context(env, context);</span><br><span class="line">  base::android::InitApplicationContext(env, scoped_context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;就是保存了上层传来的Context，没什么。</p>
<p>&#160; &#160; &#160; &#160;接着看onCreate中的nativeInitChildProcess方法，依然对应C++层external/chromium_org/content/app/android/child_process_service.cc：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitChildProcess</span><span class="params">(JNIEnv* env,</span><br><span class="line">                      jclass clazz,</span><br><span class="line">                      jobject context,</span><br><span class="line">                      jobject service,</span><br><span class="line">                      jintArray j_file_ids,</span><br><span class="line">                      jintArray j_file_fds,</span><br><span class="line">                      jint cpu_count,</span><br><span class="line">                      jlong cpu_features)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; file_ids;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; file_fds;</span><br><span class="line">  JavaIntArrayToIntVector(env, j_file_ids, &amp;file_ids);</span><br><span class="line">  JavaIntArrayToIntVector(env, j_file_fds, &amp;file_fds);</span><br><span class="line"></span><br><span class="line">  InternalInitChildProcess(</span><br><span class="line">      file_ids, file_fds, env, clazz, context, service,</span><br><span class="line">      cpu_count, cpu_features);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome actually uses the renderer code path for all of its child</span></span><br><span class="line"><span class="comment">// processes such as renderers, plugins, etc.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InternalInitChildProcess</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; file_ids,</span><br><span class="line">                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; file_fds,</span><br><span class="line">                              JNIEnv* env,</span><br><span class="line">                              jclass clazz,</span><br><span class="line">                              jobject context,</span><br><span class="line">                              jobject service_in,</span><br><span class="line">                              jint cpu_count,</span><br><span class="line">                              jlong cpu_features)</span> </span>&#123;</span><br><span class="line">  base::android::ScopedJavaLocalRef&lt;jobject&gt; service(env, service_in);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the CPU properties.</span></span><br><span class="line">  android_setCpu(cpu_count, cpu_features);</span><br><span class="line">  <span class="comment">// Register the file descriptors.</span></span><br><span class="line">  <span class="comment">// This includes the IPC channel, the crash dump signals and resource related</span></span><br><span class="line">  <span class="comment">// files.</span></span><br><span class="line">  DCHECK(file_fds.size() == file_ids.size());</span><br><span class="line">  <span class="comment">//将所有的客户端IPC 的fd保存起来，就是第一部分分析的独立render进程启动时候保存</span></span><br><span class="line">  <span class="comment">//IPC client的base::GlobalDescriptors::GetInstance() </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; file_ids.size(); ++i)</span><br><span class="line">    base::GlobalDescriptors::GetInstance()-&gt;Set(file_ids[i], file_fds[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SurfaceTexturePeerChildImpl implements the SurfaceTextureLookup interface,</span></span><br><span class="line">  <span class="comment">// which need to be set before we create a compositor thread that could be</span></span><br><span class="line">  <span class="comment">// using it to initialize resources.</span></span><br><span class="line">  content::SurfaceTexturePeer::InitInstance(</span><br><span class="line">      <span class="keyword">new</span> SurfaceTexturePeerChildImpl(service));</span><br><span class="line"></span><br><span class="line">  base::android::MemoryPressureListenerAndroid::RegisterSystemCallback(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;其他内容忽略，我们只关注将所有的客户端IPC 的fd保存起来，就是第一部分分析的独立render进程启动时候保存IPC client的base::GlobalDescriptors::GetInstance()，这样就为接下来创建ChannelProxy Client打下基础了。</p>
<p>&#160; &#160; &#160; &#160;最后再看看ContentMain的start方法，依然对应content_main.cc中的Start函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//g_content_main_delegate是个单例</span><br><span class="line">LazyInstance&lt;scoped_ptr&lt;ContentMainDelegate&gt; &gt; g_content_main_delegate =</span><br><span class="line">    LAZY_INSTANCE_INITIALIZER;</span><br><span class="line">    </span><br><span class="line">static jint Start(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">  TRACE_EVENT0("startup", "content::Start");</span><br><span class="line"></span><br><span class="line">  // On Android we can have multiple requests to start the browser in process</span><br><span class="line">  // simultaneously. If we get an asynchonous request followed by a synchronous</span><br><span class="line">  // request then we have to call this a second time to finish starting the</span><br><span class="line">  // browser synchronously.</span><br><span class="line">  if (!g_content_runner.Get().get()) &#123;</span><br><span class="line">    //取出g_content_main_delegate</span><br><span class="line">    ContentMainParams params(g_content_main_delegate.Get().get());</span><br><span class="line">    //为g_content_runner赋值</span><br><span class="line">    g_content_runner.Get().reset(ContentMainRunner::Create());</span><br><span class="line">    //调用g_content_runner的Initialize函数</span><br><span class="line">    g_content_runner.Get()-&gt;Initialize(params);</span><br><span class="line">  &#125;</span><br><span class="line">  //调用g_content_runner的Run函数</span><br><span class="line">  return g_content_runner.Get()-&gt;Run();</span><br><span class="line">&#125;</span><br><span class="line">//在ChildProcessService的onCreate会触发chromium webview相关库加载</span><br><span class="line">//在jni_onLoad中会调用这个函数为g_content_main_delegate赋值</span><br><span class="line">void SetContentMainDelegate(ContentMainDelegate* delegate) &#123;</span><br><span class="line">  DCHECK(!g_content_main_delegate.Get().get());</span><br><span class="line">  g_content_main_delegate.Get().reset(delegate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上面说到，在ChildProcessService的onCreate会触发chromium webview相关库加载，在jni_onLoad中会调用这个函数为g_content_main_delegate赋值。这个步骤如下图：</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/JNI_OnLoad.jpg" alt="JNI_OnLoad"></p>
<p>&#160; &#160; &#160; &#160;虚拟机在动态库加载完成后调用全局函数JNI_OnLoad,定义在chrome_jni_onload.cc中。位于external/chromium_org/chrome/app/android/chrome_jni_onload.cc：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNI_EXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> RunChrome(vm, ChromeMainDelegateAndroid::Create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;JNI_OnLoad调用全局函数RunChrome，定义在chrome_android_initializer.cc中，位于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">RunChrome</span><span class="params">(JavaVM* vm, ChromeMainDelegateAndroid* main_delegate)</span> </span>&#123;</span><br><span class="line">  base::android::InitVM(vm);</span><br><span class="line">  JNIEnv* env = base::android::AttachCurrentThread();</span><br><span class="line">  <span class="keyword">if</span> (!base::android::RegisterLibraryLoaderEntryHook(env))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass the library version number to content so that we can check it from the</span></span><br><span class="line">  <span class="comment">// Java side before continuing initialization</span></span><br><span class="line">  chrome::VersionInfo vi;</span><br><span class="line">  base::android::SetLibraryLoadedHook(&amp;content::LibraryLoaded);</span><br><span class="line">  base::android::SetVersionNumber(vi.Version().c_str());</span><br><span class="line"></span><br><span class="line">  DCHECK(main_delegate);</span><br><span class="line">  <span class="comment">//我们只关注这一个</span></span><br><span class="line">  content::SetContentMainDelegate(main_delegate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;RunChrome调用content命名空间的全局函数SetContentMainDelegate()定义在content_main.cc中。SetContentMainDelegate()将指向ChromeMainDelegateAndroid对象的指针保存到全局变量g_content_main_delegate中。</p>
<p>&#160; &#160; &#160; &#160;回到content_main.cc中，我们因此得知g_content_main_delegate指向的就是ChromeMainDelegateAndroid的对象。</p>
<p>&#160; &#160; &#160; &#160;我们继续往下看，为g_content_runner指针赋值。调用ContentMainRunner的Create函数，这个位于external/chromium_org/content/app/content_main_runner.cc：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">ContentMainRunner* ContentMainRunner::Create() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ContentMainRunnerImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;创建一个ContentMainRunnerImpl对象。</p>
<p>&#160; &#160; &#160; &#160;接着调用ContentMainRunnerImpl的Initialize函数，虽然这个函数很长，但是对于Android的宏定义不多，核心久一句位于external/chromium_org/content/app/content_main_runner.cc：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">const</span> ContentMainParams&amp; params)</span> OVERRIDE </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ContentClientInitializer::Set(process_type, delegate_);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ContentClientInitializer &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; process_type,</span><br><span class="line">                  ContentMainDelegate* delegate)</span> </span>&#123;</span><br><span class="line">    ContentClient* content_client = GetContentClient();</span><br><span class="line">    <span class="keyword">if</span> (process_type.empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (delegate)</span><br><span class="line">        content_client-&gt;browser_ = delegate-&gt;CreateContentBrowserClient();</span><br><span class="line">      <span class="keyword">if</span> (!content_client-&gt;browser_)</span><br><span class="line">        content_client-&gt;browser_ = &amp;g_empty_content_browser_client.Get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(OS_IOS) &amp;&amp; !defined(CHROME_MULTIPLE_DLL_BROWSER)</span></span><br><span class="line">    <span class="keyword">if</span> (process_type == switches::kPluginProcess ||</span><br><span class="line">        process_type == switches::kPpapiPluginProcess) &#123;</span><br><span class="line">      <span class="keyword">if</span> (delegate)</span><br><span class="line">        content_client-&gt;plugin_ = delegate-&gt;CreateContentPluginClient();</span><br><span class="line">      <span class="keyword">if</span> (!content_client-&gt;plugin_)</span><br><span class="line">        content_client-&gt;plugin_ = &amp;g_empty_content_plugin_client.Get();</span><br><span class="line">      <span class="comment">// Single process not supported in split dll mode.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process_type == switches::kRendererProcess ||</span><br><span class="line">               CommandLine::ForCurrentProcess()-&gt;HasSwitch(</span><br><span class="line">                   switches::kSingleProcess)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (delegate)</span><br><span class="line">        content_client-&gt;renderer_ = delegate-&gt;CreateContentRendererClient();</span><br><span class="line">      <span class="keyword">if</span> (!content_client-&gt;renderer_)</span><br><span class="line">        content_client-&gt;renderer_ = &amp;g_empty_content_renderer_client.Get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process_type == switches::kUtilityProcess ||</span><br><span class="line">        CommandLine::ForCurrentProcess()-&gt;HasSwitch(</span><br><span class="line">            switches::kSingleProcess)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (delegate)</span><br><span class="line">        content_client-&gt;utility_ = delegate-&gt;CreateContentUtilityClient();</span><br><span class="line">      <span class="comment">// TODO(scottmg): http://crbug.com/237249 Should be in _child.</span></span><br><span class="line">      <span class="keyword">if</span> (!content_client-&gt;utility_)</span><br><span class="line">        content_client-&gt;utility_ = &amp;g_empty_content_utility_client.Get();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !OS_IOS &amp;&amp; !CHROME_MULTIPLE_DLL_BROWSER</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;ContentMainRunnerImpl::Initialize接口调用ContentClientInitializer::Set(process<em>type, delegate</em>)，ContentClientInitializer定义在content_main_runner.cc中，这个类只有一个static方法Set。<br>&#160; &#160; &#160; &#160;Set方法的职责是调用ContentMainDelegate的相应接口设置ContentClient的实例域ContentBrowserClient，ContentPluginClient,ContentRenderClient,ContentUtilityClient。</p>
<p>&#160; &#160; &#160; &#160;从上面g_content_main_delegate的赋值过程得知，ContentMainDelegate是客户端程序注册给content_main_runner.cc的回调接口，content_main_runner.cc通过调用ContentMainDelegate的接口来通知客户端当前Content框架的状态。<br>&#160; &#160; &#160; &#160;客户端程序通过ContentMainDelegate::RegisterApplicationNativeMethods接口注册自己的本地方法。<br>&#160; &#160; &#160; &#160;ContentMainDelegate中的有四个函数：</p>
<ul>
<li>CreateContentBrowserClient();</li>
<li>CreateContentPluginClient();</li>
<li>CreateContentRendererClient();</li>
<li>CreateContentUtilityClient();<br>用来分别创建ContentBrowserClient，ContentPlunginClient，ContentRendererClient。就是上面刚才说的那个四个实例。</li>
</ul>
<p>&#160; &#160; &#160; &#160;这就是ContentMainRunnerImpl的Initialize函数的作用。</p>
<p>&#160; &#160; &#160; &#160;我们接着看ContentMainRunnerImpl的Run函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span> OVERRIDE </span>&#123;</span><br><span class="line">    DCHECK(is_initialized_);</span><br><span class="line">    DCHECK(!is_shutdown_);</span><br><span class="line">    <span class="keyword">const</span> CommandLine&amp; command_line = *CommandLine::ForCurrentProcess();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> process_type =</span><br><span class="line">          command_line.GetSwitchValueASCII(switches::kProcessType);</span><br><span class="line"></span><br><span class="line">    <span class="function">MainFunctionParams <span class="title">main_params</span><span class="params">(command_line)</span></span>;</span><br><span class="line">    main_params.ui_task = ui_task_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_WIN)</span></span><br><span class="line">    main_params.sandbox_info = &amp;sandbox_info_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(OS_MACOSX)</span></span><br><span class="line">    main_params.autorelease_pool = autorelease_pool_.get();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(OS_IOS)</span></span><br><span class="line">    <span class="keyword">return</span> RunNamedProcessTypeMain(process_type, main_params, delegate_);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;核心还是RunNamedProcessTypeMain函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Run the FooMain() for a given process type.</span></span><br><span class="line"><span class="comment">// If |process_type| is empty, runs BrowserMain().</span></span><br><span class="line"><span class="comment">// Returns the exit code for this process.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RunNamedProcessTypeMain</span><span class="params">(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; process_type,</span><br><span class="line">    <span class="keyword">const</span> MainFunctionParams&amp; main_function_params,</span><br><span class="line">    ContentMainDelegate* delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MainFunction kMainFunctions[] = &#123;</span><br><span class="line">#<span class="keyword">if</span> !defined(CHROME_MULTIPLE_DLL_CHILD)</span><br><span class="line">    &#123; <span class="string">""</span>,                            BrowserMain &#125;,</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> !defined(CHROME_MULTIPLE_DLL_BROWSER)</span><br><span class="line">#<span class="keyword">if</span> defined(ENABLE_PLUGINS)</span><br><span class="line">#<span class="keyword">if</span> !defined(OS_LINUX)</span><br><span class="line">   ...</span><br><span class="line">#endif</span><br><span class="line">    &#123; switches::kWorkerProcess,      WorkerMain &#125;,</span><br><span class="line">    &#123; switches::kPpapiPluginProcess, PpapiPluginMain &#125;,</span><br><span class="line">    &#123; switches::kPpapiBrokerProcess, PpapiBrokerMain &#125;,</span><br><span class="line">#endif  <span class="comment">// ENABLE_PLUGINS</span></span><br><span class="line">    &#123; switches::kUtilityProcess,     UtilityMain &#125;,</span><br><span class="line">    <span class="comment">//我们的tpye等于renderer</span></span><br><span class="line">    &#123; switches::kRendererProcess,    RendererMain &#125;,</span><br><span class="line">    &#123; switches::kGpuProcess,         GpuMain &#125;,</span><br><span class="line">#endif  <span class="comment">// !CHROME_MULTIPLE_DLL_BROWSER</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//前面在分析RenderProcessHostImpl类的成员函数Init时提到，</span></span><br><span class="line">  <span class="comment">//RenderProcessHostImpl类的静态成员变量g_renderer_main_thread_factory</span></span><br><span class="line">  <span class="comment">//描述的是一个函数，通过它可以创建一个类型为InProcessRendererThread的线程</span></span><br><span class="line">  RegisterMainThreadFactories();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; arraysize(kMainFunctions); ++i) &#123;</span><br><span class="line">    <span class="comment">//如果type等于renderer</span></span><br><span class="line">    <span class="keyword">if</span> (process_type == kMainFunctions[i].name) &#123;</span><br><span class="line">      <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        <span class="comment">//调用android平台的ChromeMainDelegate::RunProcess</span></span><br><span class="line">        <span class="comment">//但是它返回-1，后面会贴代码</span></span><br><span class="line">        <span class="keyword">int</span> exit_code = delegate-&gt;RunProcess(process_type,</span><br><span class="line">            main_function_params);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_ANDROID)</span></span><br><span class="line">        <span class="comment">// In Android's browser process, the negative exit code doesn't mean the</span></span><br><span class="line">        <span class="comment">// default behavior should be used as the UI message loop is managed by</span></span><br><span class="line">        <span class="comment">// the Java and the browser process's default behavior is always</span></span><br><span class="line">        <span class="comment">// overridden.</span></span><br><span class="line">        <span class="keyword">if</span> (process_type.empty())</span><br><span class="line">          <span class="keyword">return</span> exit_code;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (exit_code &gt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> exit_code;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//所以最后调用了RendererMain函数</span></span><br><span class="line">      <span class="keyword">return</span> kMainFunctions[i].function(main_function_params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(OS_POSIX) &amp;&amp; !defined(OS_MACOSX) &amp;&amp; !defined(OS_ANDROID)</span></span><br><span class="line">  <span class="comment">// Zygote startup is special -- see RunZygote comments above</span></span><br><span class="line">  <span class="comment">// for why we don't use ZygoteMain directly.</span></span><br><span class="line">  <span class="keyword">if</span> (process_type == switches::kZygoteProcess)</span><br><span class="line">    <span class="keyword">return</span> RunZygote(main_function_params, delegate);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it's a process we don't know about, the embedder should know.</span></span><br><span class="line">  <span class="keyword">if</span> (delegate)</span><br><span class="line">    <span class="keyword">return</span> delegate-&gt;RunProcess(process_type, main_function_params);</span><br><span class="line"></span><br><span class="line">  NOTREACHED() &lt;&lt; <span class="string">"Unknown process type: "</span> &lt;&lt; process_type;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;1）创建一个type-func键值对的数组kMainFunctions，我们的type为renderer。<br>&#160; &#160; &#160; &#160;2）然后调用RegisterMainThreadFactories函数注册RendererProcess，GpuProcess，UtilityProcess中创建IPC线程的工厂类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(OS_IOS)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterMainThreadFactories</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CHROME_MULTIPLE_DLL_BROWSER)</span></span><br><span class="line">  UtilityProcessHostImpl::RegisterUtilityMainThreadFactory(</span><br><span class="line">      CreateInProcessUtilityThread);</span><br><span class="line">  RenderProcessHostImpl::RegisterRendererMainThreadFactory(</span><br><span class="line">      CreateInProcessRendererThread);</span><br><span class="line">  GpuProcessHost::RegisterGpuMainThreadFactory(</span><br><span class="line">      CreateInProcessGpuThread);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  CommandLine&amp; command_line = *CommandLine::ForCurrentProcess();</span><br><span class="line">  <span class="keyword">if</span> (command_line.HasSwitch(switches::kSingleProcess)) &#123;</span><br><span class="line">    LOG(FATAL) &lt;&lt;</span><br><span class="line">        <span class="string">"--single-process is not supported in chrome multiple dll browser."</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (command_line.HasSwitch(switches::kInProcessGPU)) &#123;</span><br><span class="line">    LOG(FATAL) &lt;&lt;</span><br><span class="line">        <span class="string">"--in-process-gpu is not supported in chrome multiple dll browser."</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;我们只关注RendererProcess的，看看RegisterRendererMainThreadFactory函数，位于external/chromium_org/content/browser/renderer_host/render_process_host_impl.cc：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RenderProcessHostImpl::RegisterRendererMainThreadFactory(</span><br><span class="line">    RendererMainThreadFactoryFunction create) &#123;</span><br><span class="line">  g_renderer_main_thread_factory = create;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;参数CreateInProcessRendererThread实现如下，位于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">InProcessRendererThread::InProcessRendererThread(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; channel_id)</span><br><span class="line">    : Thread(<span class="string">"Chrome_InProcRendererThread"</span>), channel_id_(channel_id) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">base::<span class="function">Thread* <span class="title">CreateInProcessRendererThread</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; channel_id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> InProcessRendererThread(channel_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这时就一目了然了，前面在分析RenderProcessHostImpl类的成员函数Init时提到，RenderProcessHostImpl类的静态成员变量g_renderer_main_thread_factory描述的是一个函数，通过它可以创建一个类型为InProcessRendererThread的线程。</p>
<p>&#160; &#160; &#160; &#160;回到RunNamedProcessTypeMain里，走到for循环里面。如果type等于renderer，就会执行ChromeMainDelegateAndroid的RunProcess函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ChromeMainDelegateAndroid::RunProcess(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; process_type,</span><br><span class="line">    <span class="keyword">const</span> content::MainFunctionParams&amp; main_function_params) &#123;</span><br><span class="line">  TRACE_EVENT0(<span class="string">"startup"</span>, <span class="string">"ChromeMainDelegateAndroid::RunProcess"</span>)</span><br><span class="line">  <span class="keyword">if</span> (process_type.empty()) &#123;</span><br><span class="line">    JNIEnv* env = base::android::AttachCurrentThread();</span><br><span class="line">    RegisterApplicationNativeMethods(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Because the browser process can be started asynchronously as a series of</span></span><br><span class="line">    <span class="comment">// UI thread tasks a second request to start it can come in while the</span></span><br><span class="line">    <span class="comment">// first request is still being processed. Chrome must keep the same</span></span><br><span class="line">    <span class="comment">// browser runner for the second request.</span></span><br><span class="line">    <span class="comment">// Also only record the start time the first time round, since this is the</span></span><br><span class="line">    <span class="comment">// start time of the application, and will be same for all requests.</span></span><br><span class="line">    <span class="keyword">if</span> (!browser_runner_.get()) &#123;</span><br><span class="line">      base::Time startTime = chrome::android::GetMainEntryPointTime();</span><br><span class="line">      startup_metric_utils::RecordSavedMainEntryPointTime(startTime);</span><br><span class="line">      browser_runner_.reset(content::BrowserMainRunner::Create());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> browser_runner_-&gt;Initialize(main_function_params);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//所以最后执行ChromeMainDelegate的RunProcess函数</span></span><br><span class="line">  <span class="keyword">return</span> ChromeMainDelegate::RunProcess(process_type, main_function_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;所以最后执行ChromeMainDelegate的RunProcess函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ChromeMainDelegate::RunProcess(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; process_type,</span><br><span class="line">    <span class="keyword">const</span> content::MainFunctionParams&amp; main_function_params) &#123;</span><br><span class="line">  <span class="comment">// ANDROID doesn't support "service", so no ServiceProcessMain, and arraysize</span></span><br><span class="line">  <span class="comment">// doesn't support empty array. So we comment out the block for Android.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(OS_ANDROID)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MainFunction kMainFunctions[] = &#123;</span><br><span class="line">#<span class="keyword">if</span> defined(ENABLE_FULL_PRINTING) &amp;&amp; !defined(CHROME_MULTIPLE_DLL_CHILD)</span><br><span class="line">    &#123; switches::kServiceProcess,     ServiceProcessMain &#125;,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> defined(OS_MACOSX)</span><br><span class="line">    &#123; switches::kRelauncherProcess,</span><br><span class="line">      mac_relauncher::internal::RelauncherMain &#125;,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This entry is not needed on Linux, where the NaCl loader</span></span><br><span class="line">    <span class="comment">// process is launched via nacl_helper instead.</span></span><br><span class="line">#<span class="keyword">if</span> !defined(DISABLE_NACL) &amp;&amp; !defined(CHROME_MULTIPLE_DLL_BROWSER) &amp;&amp; \</span><br><span class="line">    !defined(OS_LINUX)</span><br><span class="line">    &#123; switches::kNaClLoaderProcess,  NaClMain &#125;,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    &#123; <span class="string">"&lt;invalid&gt;"</span>, <span class="literal">NULL</span> &#125;,  <span class="comment">// To avoid constant array of size 0</span></span><br><span class="line">                            <span class="comment">// when DISABLE_NACL and CHROME_MULTIPLE_DLL_CHILD</span></span><br><span class="line">#endif  <span class="comment">// DISABLE_NACL</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; arraysize(kMainFunctions); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process_type == kMainFunctions[i].name)</span><br><span class="line">      <span class="keyword">return</span> kMainFunctions[i].function(main_function_params);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">//但是它返回-1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;但是它返回-1。因此又回到RunNamedProcessTypeMain函数的最后一行，即执行kMainFunctions[i].function(main_function_params)，即RendererMain函数。</p>
<p>&#160; &#160; &#160; &#160;RendererMain函数定义在external/chromium_org/content/renderer/renderer_main.cc，虽然很长，但我们关注的很少：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainline routine for running as the Renderer process</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RendererMain</span><span class="params">(<span class="keyword">const</span> MainFunctionParams&amp; parameters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//创建一个RenderProcessImpl实例</span></span><br><span class="line">    RenderProcessImpl render_process;</span><br><span class="line">    <span class="comment">//创建一个RenderThreadImpl对象</span></span><br><span class="line">    <span class="keyword">new</span> RenderThreadImpl();</span><br><span class="line">    ......</span><br><span class="line">    TRACE_EVENT_BEGIN_ETW(<span class="string">"RendererMain.START_MSG_LOOP"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//开启线程消息循环</span></span><br><span class="line">    base::MessageLoop::current()-&gt;Run();</span><br><span class="line">    TRACE_EVENT_END_ETW(<span class="string">"RendererMain.START_MSG_LOOP"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这时候就一目了然了，创建一个RenderProcessImpl实例，再new一个RenderThreadImpl对象。我们回忆Render进程启动第一部分：</p>
<p>&#160; &#160; &#160; &#160;<code>回到RenderProcessHostImpl类的成员函数Init中，接下来它会调用前面创建的InProcessRendererThread对象的成员函数StartWithOptions启动一个线程。从前面Chromium多线程模型设计和实现分析一文可以知道，当该线程启动起来之后，并且在进入消息循环之前，会被调用InProcessRendererThread类的成员函数Init执行初始化工作。</code></p>
<p>&#160; &#160; &#160; &#160;<code>InProcessRendererThread类的成员函数Init的实现如下所示：</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InProcessRendererThread::Init() &#123;</span><br><span class="line">  render_process_.reset(<span class="keyword">new</span> RenderProcessImpl());</span><br><span class="line">  <span class="keyword">new</span> RenderThreadImpl(channel_id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以回到上述RendererMain函数中，接下来的事情就一目了然，就是创建ChannelProxy Client端对象，然后封装client的fd到到这个proxy和browser进程通信。</p>
<p>&#160; &#160; &#160; &#160;最后开启线程消息循环，保持轮训，不让他退出。<br>&#160; &#160; &#160; &#160;回到ChildProcessService的onCreate第8步骤，上一步消息循环会轮训，因此退出消息循环就会退render进程。</p>
<p>&#160; &#160; &#160; &#160;到此render进程启动过程就分析完了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&#160; &#160; &#160; &#160;Render进程启动第二部分相对于第一部分比较复杂，并且很多设计browser进程启动的内容（以后分析）。下一节分析一下进程间通信的消息分发机制（我们分析的是chromium IPC，但是现在已经用mojo了）。</p>
<p><img src="http://images.windrunnerlihuan.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Chromium%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%28%E4%BA%94%29----Render%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/meizi.jpg" alt="meizi"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat.jpg" alt="windrunnerlihuan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="windrunnerlihuan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Chromium/" rel="tag"># Chromium</a>
          
            <a href="/tags/多进程/" rel="tag"># 多进程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/02/Chromium学习之路-四-Chromium多进程架构简要介绍和学习计划/" rel="next" title="Chromium学习之路(四)----Chromium多进程架构简要介绍和学习计划">
                <i class="fa fa-chevron-left"></i> Chromium学习之路(四)----Chromium多进程架构简要介绍和学习计划
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/03/分享本人赴美生子的前前后后，以及所感受的一些心得-8月31日更新/" rel="prev" title="分享本人赴美生子的前前后后，以及所感受的一些心得(8月31日更新)">
                分享本人赴美生子的前前后后，以及所感受的一些心得(8月31日更新) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTQwMC83OTYz"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="windrunnerlihuan" />
          <p class="site-author-name" itemprop="name">windrunnerlihuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="mailto:937874128@qq.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope-o"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/windrunnerlihuan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://gank.io/" title="干货集中营" target="_blank">干货集中营</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jcodecraeer.com/" title="泡在网上的日子" target="_blank">泡在网上的日子</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Render进程概述"><span class="nav-number">1.</span> <span class="nav-text">Render进程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相关类结构"><span class="nav-number">1.1.</span> <span class="nav-text">相关类结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Render进程启动过程"><span class="nav-number">2.</span> <span class="nav-text">Render进程启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Render进程启动过程的第一部分"><span class="nav-number">2.1.</span> <span class="nav-text">Render进程启动过程的第一部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC-Channel-Server创建"><span class="nav-number">2.1.1.</span> <span class="nav-text">IPC Channel Server创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非独立进程Render"><span class="nav-number">2.1.2.</span> <span class="nav-text">非独立进程Render</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC-Channel-Client创建"><span class="nav-number">2.1.3.</span> <span class="nav-text">IPC Channel Client创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#独立进程Render启动"><span class="nav-number">2.1.4.</span> <span class="nav-text">独立进程Render启动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Render进程启动的第二部分"><span class="nav-number">2.2.</span> <span class="nav-text">Render进程启动的第二部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插个嘴：第一个tab页面"><span class="nav-number">2.2.1.</span> <span class="nav-text">插个嘴：第一个tab页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二个tab页"><span class="nav-number">2.2.2.</span> <span class="nav-text">第二个tab页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChildProcessService类绑定过程"><span class="nav-number">2.2.3.</span> <span class="nav-text">ChildProcessService类绑定过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">3.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">windrunnerlihuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("bJlEg1N9ed75pssz1m514avl-gzGzoHsz", "Swtq2cOp8A7KYeJ9lpD5nKAy");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
