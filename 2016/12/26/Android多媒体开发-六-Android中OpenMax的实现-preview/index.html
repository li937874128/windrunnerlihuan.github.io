<!DOCTYPE html>
<html >
<head>
  
    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="zzKGwrFJYw" />
  
  <title>Android多媒体开发(六)----Android中OpenMax的实现(preview) | April is your lie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇对OpenMax有了简单介绍，本篇就讲讲Android上对OpenMax IL层的实现。（可以忽略，下一篇会分析流程）">
<meta property="og:type" content="article">
<meta property="og:title" content="Android多媒体开发(六)----Android中OpenMax的实现(preview)">
<meta property="og:url" content="http://windrunnerlihuan.com/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/index.html">
<meta property="og:site_name" content="April is your lie">
<meta property="og:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇对OpenMax有了简单介绍，本篇就讲讲Android上对OpenMax IL层的实现。（可以忽略，下一篇会分析流程）">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/state.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/tiopenmaxil.png">
<meta property="og:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/meizi.png">
<meta property="og:updated_time" content="2016-12-26T17:41:04.672Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android多媒体开发(六)----Android中OpenMax的实现(preview)">
<meta name="twitter:description" content="&amp;#160; &amp;#160; &amp;#160; &amp;#160;上一篇对OpenMax有了简单介绍，本篇就讲讲Android上对OpenMax IL层的实现。（可以忽略，下一篇会分析流程）">
<meta name="twitter:image" content="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/state.png">
  
    <link rel="alternative" href="/atom.xml" title="April is your lie" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
          search: true
      }
  </script>

  
      <script>
          yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
      </script>
  

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
  <!-- 自动推送工具代码 start -->
  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- 自动推送工具代码 end -->
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">windrunnerlihuan</a></h1>
        </hgroup>

        
        <p class="header-subtitle">四月是你的谎言</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" results="0" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="undefined" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">时间轴</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:937874128@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/windrunnerlihuan" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPC/">IPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SO库/">SO库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客搭建/">博客搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/壁纸/">壁纸</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多媒体/">多媒体</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/属性动画/">属性动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开始/">开始</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/弹幕/">弹幕</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件开发/">插件开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能指针/">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息/">消息</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动直播/">移动直播</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程池/">线程池</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://gank.io/">干货集中营</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jcodecraeer.com/">泡在网上的日子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://trinea.cn/">Trinea</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">windrunnerlihuan，开发小菜一枚，坐标位于上海。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">windrunnerlihuan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">windrunnerlihuan</a></h1>
            </hgroup>
            
            <p class="header-subtitle">四月是你的谎言</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">时间轴</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:937874128@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/windrunnerlihuan" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Android多媒体开发-六-Android中OpenMax的实现-preview" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/" class="article-date">
      <time datetime="2016-12-26T12:13:12.000Z" itemprop="datePublished">2016-12-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android多媒体开发(六)----Android中OpenMax的实现(preview)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Android技术点/">Android技术点</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多媒体/">多媒体</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>&#160; &#160; &#160; &#160;上一篇对OpenMax有了简单介绍，本篇就讲讲Android上对OpenMax IL层的实现。（可以忽略，下一篇会分析流程）<br><a id="more"></a></p>
<h1 id="OpenMax的接口与实现"><a href="#OpenMax的接口与实现" class="headerlink" title="OpenMax的接口与实现"></a>OpenMax的接口与实现</h1><p>&#160; &#160; &#160; &#160;在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节。</p>
<ul>
<li><strong>编解码驱动程序</strong>：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。</li>
<li><strong>OpenMax IL层</strong>：根据OpenMax IL层的标准头文件实现不同功能的组件。</li>
</ul>
<p>&#160; &#160; &#160; &#160;Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配），它作为Android本地层的接口，可以被Android的多媒体引擎调用。</p>
<h2 id="OpenMax-IL层接口"><a href="#OpenMax-IL层接口" class="headerlink" title="OpenMax IL层接口"></a>OpenMax IL层接口</h2><p>&#160; &#160; &#160; &#160;OpenMax IL层的接口定义由若干个头文件组成，这也是实现它需要实现的内容，位于frameworks/native/include/media/openmax下，它们的基本描述如下所示：</p>
<blockquote>
<p>OMX_Types.h：OpenMax Il的数据类型定义<br>OMX_Core.h：OpenMax IL核心的API<br>OMX_Component.h：OpenMax IL 组件相关的 API<br>OMX_Audio.h：音频相关的常量和数据结构<br>OMX_IVCommon.h：图像和视频公共的常量和数据结构<br>OMX_Image.h：图像相关的常量和数据结构<br>OMX_Video.h：视频相关的常量和数据结构<br>OMX_Other.h：其他数据结构（包括A/V 同步）<br>OMX_Index.h：OpenMax IL定义的数据结构索引<br>OMX_ContentPipe.h：内容的管道定义</p>
</blockquote>
<p>&#160; &#160; &#160; &#160;<strong>提示：OpenMax标准只有头文件，没有标准的库，设置没有定义函数接口。对于实现者，需要实现的主要是包含函数指针的结构体。</strong></p>
<p>&#160; &#160; &#160; &#160;其中，OMX_Component.h中定义的OMX_COMPONENTTYPE结构体是OpenMax IL层的核心内容，表示一个组件，其内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> OMX_COMPONENTTYPE    </span><br><span class="line">&#123;  </span><br><span class="line">    OMX_U32 nSize;                          <span class="comment">/* 这个结构体的大小 */</span>    </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本号 */</span>    </span><br><span class="line">    OMX_PTR pComponentPrivate;          <span class="comment">/* 这个组件的私有数据指针. */</span>    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 调用者（IL client）设置的指针，用于保存它的私有数据，传回给所有的回调函数 */</span>    </span><br><span class="line">    OMX_PTR pApplicationPrivate;    </span><br><span class="line">    <span class="comment">/* 以下的函数指针返回OMX_core.h中的对应内容 */</span>    </span><br><span class="line">    OMX_ERRORTYPE (*GetComponentVersion)(<span class="comment">/* 获得组件的版本*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STRING pComponentName,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pComponentVersion,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pSpecVersion,    </span><br><span class="line">        OMX_OUT OMX_UUIDTYPE* pComponentUUID);    </span><br><span class="line">    OMX_ERRORTYPE (*SendCommand)(<span class="comment">/* 发送命令 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_COMMANDTYPE Cmd,    </span><br><span class="line">        OMX_IN  OMX_U32 nParam1,    </span><br><span class="line">        OMX_IN  OMX_PTR pCmdData);    </span><br><span class="line">    OMX_ERRORTYPE (*GetParameter)(<span class="comment">/* 获得参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nParamIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetParameter)(<span class="comment">/* 设置参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetConfig)(<span class="comment">/* 获得配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetConfig)(<span class="comment">/* 设置配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetExtensionIndex)(<span class="comment">/* 转换成OMX结构的索引 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_STRING cParameterName,    </span><br><span class="line">        OMX_OUT OMX_INDEXTYPE* pIndexType);    </span><br><span class="line">    OMX_ERRORTYPE (*GetState)(<span class="comment">/* 获得组件当前的状态 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STATETYPE* pState);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentTunnelRequest)(<span class="comment">/* 用于连接到另一个组件*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nPort,    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hTunneledComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nTunneledPort,    </span><br><span class="line">        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup);    </span><br><span class="line">    OMX_ERRORTYPE (*UseBuffer)(<span class="comment">/* 为某个端口使用Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes,    </span><br><span class="line">        OMX_IN OMX_U8* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*AllocateBuffer)(<span class="comment">/* 在某个端口分配Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes);    </span><br><span class="line">    OMX_ERRORTYPE (*FreeBuffer)(<span class="comment">/*将某个端口Buffer释放*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*EmptyThisBuffer)(<span class="comment">/* 让组件消耗这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*FillThisBuffer)(<span class="comment">/* 让组件填充这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*SetCallbacks)(<span class="comment">/* 设置回调函数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_CALLBACKTYPE* pCallbacks,    </span><br><span class="line">        OMX_IN  OMX_PTR pAppData);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentDeInit)(<span class="comment">/* 反初始化组件 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent);    </span><br><span class="line">    OMX_ERRORTYPE (*UseEGLImage)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN <span class="keyword">void</span>* eglImage);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentRoleEnum)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_U8 *cRole,    </span><br><span class="line">        OMX_IN OMX_U32 nIndex);    </span><br><span class="line">&#125; OMX_COMPONENTTYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;1）EmptyThisBuffer和FillThisBuffer是驱动组件运行的基本的机制，前者表示让组件消耗缓冲区，表示对应组件输入的内容；后者表示让组件填充缓冲区，表示对应组件输出的内容。<br>&#160; &#160; &#160; &#160;2）UseBuffer，AllocateBuffer，FreeBuffer为和端口相关的缓冲区管理函数，对于组件的端口有些可以自己分配缓冲区，有些可以使用外部的缓冲区，因此有不同的接口对其进行操作。<br>&#160; &#160; &#160; &#160;3）SendCommand表示向组件发送控制类的命令。GetParameter，SetParameter，GetConfig，SetConfig几个接口用于辅助的参数和配置的设置和获取。<br>&#160; &#160; &#160; &#160;4）ComponentTunnelRequest用于组件之间的隧道化连接，其中需要制定两个组件及其相连的端口。<br>&#160; &#160; &#160; &#160;5）ComponentDeInit用于组件的反初始化。</p>
<p>&#160; &#160; &#160; &#160;OMX_COMPONENTTYPE结构体实现后，其中的各个函数指针就是调用者可以使用的内容。<strong>各个函数指针和OMX_core.h中定义的内容相对应</strong>。<br>&#160; &#160; &#160; &#160;提示：OpenMax函数的参数中，经常包含OMX_IN和OMX_OUT等宏，它们的实际内容为空，只是为了标记参数的方向是输入还是输出。</p>
<p>&#160; &#160; &#160; &#160;OMX_Component.h中端口类型的定义为OMX_PORTDOMAINTYPE枚举类型，内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_PORTDOMAINTYPE &#123;   </span><br><span class="line">    OMX_PortDomainAudio,        <span class="comment">/* 音频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainVideo,        <span class="comment">/* 视频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainImage,        <span class="comment">/* 图像类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainOther,        <span class="comment">/* 其他类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainKhronosExtensions = <span class="number">0x6F000000</span>,   <span class="comment">//为Khronos标准预留宽展</span></span><br><span class="line">    OMX_PortDomainVendorStartUnused = <span class="number">0x7F000000</span>    <span class="comment">//为厂商预留扩展</span></span><br><span class="line">    OMX_PortDomainMax = <span class="number">0x7ffffff</span>  </span><br><span class="line">&#125; OMX_PORTDOMAINTYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;音频类型，视频类型，图像类型，其他类型是OpenMax IL层此所定义的四种端口的类型。</p>
<p>端口具体内容的定义使用OMX_PARAM_PORTDEFINITIONTYPE类（也在OMX_Component.h中定义）来表示，其内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> OMX_PARAM_PORTDEFINITIONTYPE &#123;   </span><br><span class="line">    OMX_U32 nSize;                      <span class="comment">/* 结构体大小 */</span>   </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本*/</span>   </span><br><span class="line">    OMX_U32 nPortIndex;             <span class="comment">/* 端口号 */</span>   </span><br><span class="line">    OMX_DIRTYPE eDir;                   <span class="comment">/* 端口的方向 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountActual;         <span class="comment">/* 为这个端口实际分配的Buffer的数目 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountMin;            <span class="comment">/* 这个端口最小Buffer的数目*/</span>   </span><br><span class="line">    OMX_U32 nBufferSize;                <span class="comment">/* 缓冲区的字节数 */</span>   </span><br><span class="line">    OMX_BOOL bEnabled;                  <span class="comment">/* 是否使能 */</span>   </span><br><span class="line">    OMX_BOOL bPopulated;                <span class="comment">/* 是否在填充 */</span>   </span><br><span class="line">    OMX_PORTDOMAINTYPE eDomain;         <span class="comment">/* 端口的类型 */</span>   </span><br><span class="line">    <span class="keyword">union</span> &#123;                         <span class="comment">/* 端口实际的内容，由类型确定具体结构 */</span>   </span><br><span class="line">        OMX_AUDIO_PORTDEFINITIONTYPE audio;   </span><br><span class="line">        OMX_VIDEO_PORTDEFINITIONTYPE video;   </span><br><span class="line">        OMX_IMAGE_PORTDEFINITIONTYPE image;   </span><br><span class="line">        OMX_OTHER_PORTDEFINITIONTYPE other;   </span><br><span class="line">    &#125; format;   </span><br><span class="line">    OMX_BOOL bBuffersContiguous;   </span><br><span class="line">    OMX_U32 nBufferAlignment;   </span><br><span class="line">&#125; OMX_PARAM_PORTDEFINITIONTYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;对于一个端口，其重点的内容如下:</p>
<ul>
<li>端口的方向（OMX_DIRTYPE）：包含OMX_DirInput（输入）和OMX_DirOutput（输出）两种</li>
<li>端口分配的缓冲区数目和最小缓冲区数目</li>
<li>端口的类型（OMX_PORTDOMAINTYPE）：可以是四种类型</li>
<li>端口格式的数据结构：使用format联合体来表示，具体由四种不同类型来表示，与端口的类型相对应<br>OMX_AUDIO_PORTDEFINITIONTYPE，OMX_VIDEO_PORTDEFINITIONTYPE，OMX_IMAGE_PORTDEFINITIONTYPE和OMX_OTHER_PORTDEFINITIONTYPE等几个具体的格式类型，分别在OMX_Audio.h，OMX_Video.h，OMX_Image.h和OMX_Other.h这四个头文件中定义。</li>
</ul>
<p>&#160; &#160; &#160; &#160;OMX_Core.h中定义的枚举类型OMX_STATETYPE命令表示OpenMax的状态机，内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_STATETYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_StateInvalid,                   <span class="comment">/* 组件监测到内部的数据结构被破坏 */</span>   </span><br><span class="line">    OMX_StateLoaded,                    <span class="comment">/* 组件被加载但是没有完成初始化 */</span>   </span><br><span class="line">    OMX_StateIdle,                      <span class="comment">/* 组件初始化完成，准备开始 */</span>   </span><br><span class="line">    OMX_StateExecuting,             <span class="comment">/* 组件接受了开始命令，正在树立数据 */</span>   </span><br><span class="line">    OMX_StatePause,                     <span class="comment">/* 组件接受暂停命令*/</span>   </span><br><span class="line">    OMX_StateWaitForResources,      <span class="comment">/* 组件正在等待资源 */</span>   </span><br><span class="line">    OMX_StateKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_StateVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_StateMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_STATETYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OpenMax组件的状态机可以由外部的命令改变，也可以由内部发生的情况改变。OpenMax IL组件的状态机的迁移关系如图所示：<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/state.png" alt="状态机"></p>
<p>&#160; &#160; &#160; &#160;OMX_Core.h中定义的枚举类型OMX_COMMANDTYPE表示对组件的命令类型，内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_COMMANDTYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_CommandStateSet,                <span class="comment">/* 改变状态机器 */</span>   </span><br><span class="line">    OMX_CommandFlush,                   <span class="comment">/* 刷新数据队列 */</span>   </span><br><span class="line">    OMX_CommandPortDisable,             <span class="comment">/* 禁止端口 */</span>   </span><br><span class="line">    OMX_CommandPortEnable,              <span class="comment">/* 使能端口 */</span>   </span><br><span class="line">    OMX_CommandMarkBuffer,              <span class="comment">/* 标记组件或Buffer用于观察 */</span>   </span><br><span class="line">    OMX_CommandKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_CommandVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_CommandMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_COMMANDTYPE;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;OMX_COMMANDTYPE类型在SendCommand调用中作为参数被使用，其中OMX_CommandStateSet就是改变状态机的命令。</p>
<h2 id="OpenMax-IL实现的内容"><a href="#OpenMax-IL实现的内容" class="headerlink" title="OpenMax IL实现的内容"></a>OpenMax IL实现的内容</h2><p>&#160; &#160; &#160; &#160;对于OpenMax IL层的实现，一般的方式并不调用OpenMax DL层。具体实现的内容就是各个不同的组件。<br>&#160; &#160; &#160; &#160;OpenMax IL组件的实现包含以下两个步骤：</p>
<ul>
<li>组件的初始化函数：硬件和OpenMax数据结构的初始化，一般分成函数指针初始化、私有数据结构的初始化、端口的初始化等几个步骤，使用OMX_Component.h其中的pComponentPrivate成员保留本组件的私有数据为上下文，最后获得填充完成OMX_COMPONENTTYPE类型的结构体。</li>
<li>OMX_COMPONENTTYPE类型结构体的各个指针：实现其中的各个函数指针，需要使用私有数据的时候，从其中的pComponentPrivate得到指针，转化成实际的数据结构使用。</li>
</ul>
<p>&#160; &#160; &#160; &#160;端口的定义是OpenMax IL组件对外部的接口。OpenMax IL常用的组件大都是输入和输出端口各一个。对于最常用的编解码（Codec）组件，通常需要在每个组件的实现过程中，调用硬件的编解码接口来实现。在组件的内部处理中，可以建立线程来处理。OpenMax的组件的端口有默认参数，但也可以在运行时设置，因此一个端口也可以支持不同的编码格式。音频编码组件的输出和音频编码组件的输入通常是原始数据格式（PCM格式），视频编码组件的输出和视频编码组件的输入通常是原始数据格式（YUV格式）。<br>&#160; &#160; &#160; &#160;提示：在一种特定的硬件实现中，编解码部分具有相似性，因此通常可以构建一个OpenMax组件的”基类”或者公共函数，来完成公共性的操作。</p>
<h1 id="Android中OpenMax的适配层"><a href="#Android中OpenMax的适配层" class="headerlink" title="Android中OpenMax的适配层"></a>Android中OpenMax的适配层</h1><p>&#160; &#160; &#160; &#160;Android中的OpenMax适配层的接口在frameworks/av/include/media/IOMX.h文件定义，其内容如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> IOMX : <span class="keyword">public</span> IInterface &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    DECLARE_META_INTERFACE(OMX);    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *buffer_id;    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *node_id;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">livesLocally</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">struct</span> ComponentInfo &#123;<span class="comment">// 组件的信息    </span></span><br><span class="line">        String8 mName;    </span><br><span class="line">        List&lt;String8&gt; mRoles;    </span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">listNodes</span><span class="params">(List&lt;ComponentInfo&gt; *<span class="built_in">list</span>)</span> </span>= <span class="number">0</span>;  <span class="comment">// 节点列表    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateNode</span><span class="params">(    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer,  <span class="comment">// 分配节点    </span></span><br><span class="line">        node_id *node)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">freeNode</span><span class="params">(node_id node)</span> </span>= <span class="number">0</span>; <span class="comment">// 找到节点    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">sendCommand</span><span class="params">(<span class="comment">// 发送命令    </span></span><br><span class="line">        node_id node, OMX_COMMANDTYPE cmd, OMX_S32 param)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getParameter</span><span class="params">(<span class="comment">// 获得参数    </span></span><br><span class="line">        node_id node, OMX_INDEXTYPE index,    </span><br><span class="line">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setParameter</span><span class="params">(<span class="comment">// 设置参数    </span></span><br><span class="line">        node_id node, OMX_INDEXTYPE index,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getConfig</span><span class="params">(<span class="comment">// 获得配置    </span></span><br><span class="line">        node_id node, OMX_INDEXTYPE index,    </span><br><span class="line">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setConfig</span><span class="params">(<span class="comment">// 设置配置    </span></span><br><span class="line">        node_id node, OMX_INDEXTYPE index,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">useBuffer</span><span class="params">(<span class="comment">// 使用缓冲区    </span></span><br><span class="line">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span><br><span class="line">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateBuffer</span><span class="params">(<span class="comment">// 分配缓冲区    </span></span><br><span class="line">        node_id node, OMX_U32 port_index, <span class="keyword">size_t</span> size,    </span><br><span class="line">        buffer_id *buffer, <span class="keyword">void</span> **buffer_data)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateBufferWithBackup</span><span class="params">(<span class="comment">// 分配带后备缓冲区    </span></span><br><span class="line">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span><br><span class="line">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">freeBuffer</span><span class="params">(<span class="comment">// 释放缓冲区    </span></span><br><span class="line">        node_id node, OMX_U32 port_index, buffer_id buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">fillBuffer</span><span class="params">(node_id node, buffer_id buffer)</span> </span>= <span class="number">0</span>; <span class="comment">// 填充缓冲区    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">emptyBuffer</span><span class="params">(<span class="comment">// 消耗缓冲区    </span></span><br><span class="line">        node_id node,    </span><br><span class="line">        buffer_id buffer,    </span><br><span class="line">        OMX_U32 range_offset, OMX_U32 range_length,    </span><br><span class="line">        OMX_U32 flags, OMX_TICKS timestamp)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getExtensionIndex</span><span class="params">(    </span><br><span class="line">        node_id node,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *parameter_name,    </span><br><span class="line">        OMX_INDEXTYPE *index)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IOMXRenderer&gt; createRenderer(<span class="comment">// 创建渲染器（从ISurface）    </span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;ISurface&gt; &amp;surface,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName,    </span><br><span class="line">        OMX_COLOR_FORMATTYPE colorFormat,    </span><br><span class="line">        <span class="keyword">size_t</span> encodedWidth, <span class="keyword">size_t</span> encodedHeight,    </span><br><span class="line">        <span class="keyword">size_t</span> displayWidth, <span class="keyword">size_t</span> displayHeight) = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    ......   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;IOMX表示的是OpenMax的一个组件，根据Android的Binder IPC机制，<strong>BnOMX继承IOMX，实现者需要继承实现BnOMX</strong>。IOMX类中，有标准的OpenMax的GetParameter，SetParameter，GetConfig，SetConfig，SendCommand，UseBuffer，AllocateBuffer，FreeBuffer，FillThisBuffer和EmptyThisBuffer等接口。<br>&#160; &#160; &#160; &#160;在IOMX.h文件中，另有表示观察器类的IOMXObserver，这个类表示OpenMax的观察者，其中只包含一个onMessage()函数，其参数为omx_message接口体，其中包含Event事件类型、FillThisBuffer完成和EmptyThisBuffer完成几种类型。<br>&#160; &#160; &#160; &#160;提示：Android中OpenMax的适配层是OpenMAX IL层至上的封装层，在Android系统中被StageFright调用，也可以被其他部分调用。</p>
<h1 id="TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现"><a href="#TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现" class="headerlink" title="TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现"></a>TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现</h1><h2 id="TI-OpenMax-IL实现的结构和机制"><a href="#TI-OpenMax-IL实现的结构和机制" class="headerlink" title="TI OpenMax IL实现的结构和机制"></a>TI OpenMax IL实现的结构和机制</h2><p>&#160; &#160; &#160; &#160;Android的开源代码中，已经包含了TI的OpenMax IL层的实现代码，其路径如hardware/ti/omap3/omx下。其中包含的主要目录如下所示：</p>
<ul>
<li>system：OpenMax核心和公共部分</li>
<li>audio：音频处理部分的OpenMax IL组件</li>
<li>video：视频处理部分OpenMax IL组件</li>
<li>image：图像处理部分OpenMax IL组件</li>
</ul>
<p>&#160; &#160; &#160; &#160;TI OpenMax IL实现的结构如图所示:<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/tiopenmaxil.png" alt="TI openmax IL实现"></p>
<p>&#160; &#160; &#160; &#160;在TI OpenMax IL实现中，最上面的内容是OpenMax的管理者用于管理和初始化，中间层是各个编解码单元的OpenMax IL标准组件，下层是LCML层，供各个OpenMax IL标准组件所调用。<br>&#160; &#160; &#160; &#160;（1）TI OpenMax IL实现的公共部分在system/src/openmax_il/目录中，主要的内容如下所示。</p>
<ul>
<li>omx_core/src：OpenMax IL的核心，生成动态库<strong>libOMX_Core.so</strong></li>
<li>lcml/：LCML的工具库，生成动态库libLCML.so</li>
</ul>
<p>&#160; &#160; &#160; &#160;（2）I OpenMax IL的视频（Video）相关的组件在video/src/openmax_il/目录中，主要的内容如下所示。</p>
<ul>
<li>prepost_processor：Video数据的前处理和后处理，生成动态库libOMX.TI.VPP.so</li>
<li>video_decode：Video解码器，生成动态库libOMX.TI.Video.Decoder.so</li>
<li>video_encode：Video编码器，生成动态库libOMX.TI.Video.encoder.so</li>
</ul>
<p>&#160; &#160; &#160; &#160;（3）TI OpenMax IL的音频（Audio）相关的组件在audio/src/openmax_il/目录中，主要的内容如下所示。</p>
<ul>
<li>g711_dec：G711解码器，生成动态库libOMX.TI.G711.decode.so</li>
<li>g711_enc：G711编码器，生成动态库libOMX.TI.G711.encode.so</li>
<li>g722_dec：G722解码器，生成动态库libOMX.TI.G722.decode.so</li>
<li>g722_enc：G722编码器，生成动态库libOMX.TI.G722.encode.so</li>
<li>g726_dec：G726解码器，生成动态库libOMX.TI.G726.decode.so</li>
<li>g726_enc：G726编码器，生成动态库libOMX.TI.G726.encode.so</li>
<li>g729_dec：G729解码器，生成动态库libOMX.TI.G729.decode.so</li>
<li>g729_enc：G720编码器，生成动态库libOMX.TI.G729.encode.so</li>
<li>nbamr_dec：AMR窄带解码器，生成动态库libOMX.TI.AMR.decode.so</li>
<li>nbamr_enc：AMR窄带编码器，生成动态库libOMX.TI.AMR.encode.so</li>
<li>wbamr_dec：AMR宽带解码器，生成动态库libOMX.TI.WBAMR.decode.so</li>
<li>wbamr_enc：AMR宽带编码器，生成动态库libOMX.TI.WBAMR.encode.so</li>
<li>mp3_dec：MP3解码器，生成动态库libOMX.TI.MP3.decode.so</li>
<li>aac_dec：AAC解码器，生成动态库libOMX.TI.AAC.decode.so</li>
<li>aac_enc：AAC编码器，生成动态库libOMX.TI.AAC.encode.so</li>
<li>wma_dec：WMA解码器，生成动态库libOMX.TI.WMA.decode.so</li>
</ul>
<p>&#160; &#160; &#160; &#160;（4）TI OpenMax IL的图像（Image）相关的组件在image/src/openmax_il/目录中，主要的内容如下所示。</p>
<ul>
<li>jpeg_enc：JPEG编码器，生成动态库libOMX.TI.JPEG.Encoder.so</li>
<li>jpeg_dec：JPEG解码器，生成动态库libOMX.TI.JPEG.decoder.so</li>
</ul>
<h2 id="TI-OpenMax-IL的核心和公共内容"><a href="#TI-OpenMax-IL的核心和公共内容" class="headerlink" title="TI OpenMax IL的核心和公共内容"></a>TI OpenMax IL的核心和公共内容</h2><p>&#160; &#160; &#160; &#160;LCML的全称是”<strong>Linux Common Multimedia Layer</strong>“，是TI的Linux公共多媒体层。在OpenMax IL的实现中，这个内容在system/src/openmax_il/lcml/目录中，主要文件是子目录src中的LCML_DspCodec.c文件。通过调用DSPBridge的内容， 让ARM和DSP进行通信，然DSP进行编解码方面的处理。DSP的运行还需要固件的支持。<br>&#160; &#160; &#160; &#160;<strong>TI OpenMax IL的核心实现在system/src/openmax_il/omx_core/目录中，生成TI OpenMax IL的核心库libOMX_Core.so。</strong><br>&#160; &#160; &#160; &#160;其中子目录src中的<strong>OMX_Core.c</strong>为主要文件，其中定义了编解码器的名称等，其片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *tComponentName[MAXCOMP][<span class="number">2</span>] = &#123;    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.JPEG.decoder"</span>, <span class="string">"image_decoder.jpeg"</span>&#125;,<span class="comment">/* 图像和视频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.JPEG.Encoder"</span>, <span class="string">"image_encoder.jpeg"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.avc"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.mpeg4"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.wmv"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.mpeg4"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.h263"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.avc"</span>&#125;,    </span><br><span class="line">     <span class="comment">/* ......省略 ，语音相关组件*/</span>    </span><br><span class="line">#ifdef BUILD_WITH_TI_AUDIO <span class="comment">/* 音频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.MP3.decode"</span>, <span class="string">"audio_decoder.mp3"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AAC.encode"</span>, <span class="string">"audio_encoder.aac"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AAC.decode"</span>, <span class="string">"audio_decoder.aac"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WMA.decode"</span>, <span class="string">"audio_decoder.wma"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WBAMR.decode"</span>, <span class="string">"audio_decoder.amrwb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AMR.decode"</span>, <span class="string">"audio_decoder.amrnb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AMR.encode"</span>, <span class="string">"audio_encoder.amrnb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WBAMR.encode"</span>, <span class="string">"audio_encoder.amrwb"</span>&#125;,    </span><br><span class="line">#endif    </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;tComponentName数组的各个项中，第一个表示<strong>编解码库内容</strong>，第二个表示<strong>库所实现的功能</strong>。<br>&#160; &#160; &#160; &#160;其中，<strong>TIOMX_GetHandle()函数用于获得各个组件的句柄</strong>，其实现的主要片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">TIOMX_GetHandle</span><span class="params">( OMX_HANDLETYPE* pHandle, OMX_STRING cComponentName,    </span><br><span class="line">    OMX_PTR pAppData, OMX_CALLBACKTYPE* pCallBacks)</span>   </span><br><span class="line"></span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> prefix[] = <span class="string">"lib"</span>;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> postfix[] = <span class="string">".so"</span>;    </span><br><span class="line">    OMX_ERRORTYPE (*pComponentInit)(OMX_HANDLETYPE*);    </span><br><span class="line">    OMX_ERRORTYPE err = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *componentType;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pErr = dlerror();    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; COUNTOF(pModules); i++) &#123;       <span class="comment">// 循环查找    </span></span><br><span class="line">        <span class="keyword">if</span>(pModules[i] == <span class="literal">NULL</span>) <span class="keyword">break</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> refIndex = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (refIndex=<span class="number">0</span>; refIndex &lt; MAX_TABLE_SIZE; refIndex++) &#123;    </span><br><span class="line">    <span class="comment">// 循环查找组件列表    </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(componentTable[refIndex].name, cComponentName) == <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (componentTable[refIndex].refCount&gt;= MAX_CONCURRENT_INSTANCES) &#123;    </span><br><span class="line">            <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(prefix) + MAXNAMESIZE+ <span class="keyword">sizeof</span>(postfix)];    </span><br><span class="line">                <span class="built_in">strcpy</span>(buf, prefix);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, cComponentName);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, postfix);    </span><br><span class="line">                pModules[i] = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                <span class="comment">// 动态取出初始化的符号    </span></span><br><span class="line">                pComponentInit = dlsym(pModules[i], <span class="string">"OMX_ComponentInit"</span>);    </span><br><span class="line">                pErr = dlerror();    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                *pHandle = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OMX_COMPONENTTYPE));    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                pComponents[i] = *pHandle;    </span><br><span class="line">                componentType = (OMX_COMPONENTTYPE*) *pHandle;    </span><br><span class="line">                componentType-&gt;nSize = <span class="keyword">sizeof</span>(OMX_COMPONENTTYPE);    </span><br><span class="line">                err = (*pComponentInit)(*pHandle);   <span class="comment">// 执行初始化工作    </span></span><br><span class="line">                <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    err = OMX_ErrorComponentNotFound;    </span><br><span class="line">    <span class="keyword">goto</span> UNLOCK_MUTEX;    </span><br><span class="line">    <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">     <span class="keyword">return</span> (err);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在TIOMX_GetHandle()函数中，根据tComponentName数组中动态库的名称，动态打开各个编解码实现的动态库，取出其中的<strong>OMX_ComponentInit</strong>符号来执行各个组件的初始化。</p>
<h2 id="一个TI-OpenMax-IL组件的实现"><a href="#一个TI-OpenMax-IL组件的实现" class="headerlink" title="一个TI OpenMax IL组件的实现"></a>一个TI OpenMax IL组件的实现</h2><p>&#160; &#160; &#160; &#160;TI OpenMax IL中各个组件都是通过调用LCML来实现的，实现的方式基本类似。主要都是实现了名称为<strong>OMX_ComponentInit</strong>的初始化函数，实现OMX_COMPONENTTYPE类型的结构体中的各个成员。各个组件其目录结构和文件结构也类似。</p>
<p>&#160; &#160; &#160; &#160;以MP3解码器的实现为例，在audio/src/openmax_il/mp3_dec/src目录中，主要包含以下文件：</p>
<ul>
<li>OMX_Mp3Decoder.c：MP3解码器组件实现</li>
<li>OMX_Mp3Dec_CompThread.c：MP3解码器组件的线程循环</li>
<li>OMX_Mp3Dec_Utils.c：MP3解码器的相关工具，调用LCML实现真正的MP3解码的功能</li>
</ul>
<p>&#160; &#160; &#160; &#160;OMX_Mp3Decoder.c中的OMX_ComponentInit()函数负责组件的初始化，返回的内容再从参数中得到，这个函数的主要片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">OMX_ComponentInit</span> <span class="params">(OMX_HANDLETYPE hComp)</span>    </span><br><span class="line"></span>&#123;    </span><br><span class="line">    OMX_ERRORTYPE eError = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *pHandle = (OMX_COMPONENTTYPE*) hComp;    </span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE *pPortDef_ip = <span class="literal">NULL</span>, *pPortDef_op = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFormat = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_MP3TYPE *mp3_ip = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PCMMODETYPE *mp3_op = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3DEC_COMPONENT_PRIVATE *pComponentPrivate = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_AUDIODEC_PORT_TYPE *pCompPort = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_BUFFERLIST *pTemp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;    </span><br><span class="line">  </span><br><span class="line">    MP3D_OMX_CONF_CHECK_CMD(pHandle,<span class="number">1</span>,<span class="number">1</span>);    </span><br><span class="line">    <span class="comment">/* ......省略，初始化OMX_COMPONENTTYPE类型的指针pHandle */</span>    </span><br><span class="line">    OMX_MALLOC_GENERIC(pHandle-&gt;pComponentPrivate, MP3DEC_COMPONENT_PRIVATE);    </span><br><span class="line">    pComponentPrivate = pHandle-&gt;pComponentPrivate; <span class="comment">/* 私有指针互相指向 */</span>    </span><br><span class="line">    pComponentPrivate-&gt;pHandlepHandle = pHandle;    </span><br><span class="line">    <span class="comment">/* ......略，初始化似有数据指针pComponentPrivate */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_ip-&gt;nSize                   = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_ip-&gt;nPortIndex             = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortDef_ip-&gt;eDir                    = OMX_DirInput;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountActual    = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountMin        = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferSize             = MP3D_INPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferAlignment       = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_ip-&gt;bEnabled                 = OMX_TRUE;    </span><br><span class="line">    pPortDef_ip-&gt;bPopulated               = OMX_FALSE;    </span><br><span class="line">    pPortDef_ip-&gt;eDomain                   = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.eEncoding = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.cMIMEType = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.pNativeRender           = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* 设置输出端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_op-&gt;nSize                 = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_op-&gt;nPortIndex           = MP3D_OUTPUT_PORT;    </span><br><span class="line">    pPortDef_op-&gt;eDir                  = OMX_DirOutput;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountMin     = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountActual  = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferSize          = MP3D_OUTPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_op-&gt;nBufferAlignment    = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_op-&gt;bEnabled              = OMX_TRUE;    </span><br><span class="line">    pPortDef_op-&gt;bPopulated            = OMX_FALSE;    </span><br><span class="line">    pPortDef_op-&gt;eDomain               = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.eEncoding      = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.cMIMEType      = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.pNativeRender = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* ......省略，分配端口 */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_INPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">    pPortFormat-&gt;nPortIndex         = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortFormat-&gt;nIndex             = OMX_IndexParamAudioMp3;    </span><br><span class="line">    pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    <span class="comment">/* 设置输出端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_OUTPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">        pPortFormat-&gt;nPortIndex         = MP3D_OUTPUT_PORT;    </span><br><span class="line">        pPortFormat-&gt;nIndex             = OMX_IndexParamAudioPcm;    </span><br><span class="line">        pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    eError = Mp3Dec_StartCompThread(pHandle);   <span class="comment">// 启动MP3解码线程    </span></span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    <span class="keyword">return</span> eError;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个组件是OpenMax的标准实现方式，对外的接口的内容只有一个初始化函数。完成OMX_COMPONENTTYPE类型的初始化。输入端口的编号为MP3D_INPUT_PORT（==0），类型为OMX_PortDomainAudio，格式为OMX_AUDIO_CodingMP3。输出端口的编号是MP3D_OUTPUT_PORT（==1），类型为OMX_PortDomainAudio，格式为OMX<em>AUDIO</em> CodingPCM。</p>
<p>&#160; &#160; &#160; &#160;OMX_Mp3Dec_CompThread.c中定义了MP3DEC_ComponentThread()函数，用于创建MP3解码的线程的执行函数。<br>&#160; &#160; &#160; &#160;OMX_Mp3Dec_Utils.c中的Mp3Dec_StartCompThread()函数，调用了POSIX的线程库建立MP3解码的线程，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nRet = pthread_create (&amp;(pComponentPrivate-&gt;ComponentThread), <span class="literal">NULL</span>,    </span><br><span class="line">    MP3DEC_ComponentThread, pComponentPrivate);</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Mp3Dec_StartCompThread()函数就是在组件初始化函数OMX_ComponentInit()最后调用的内容。MP3线程的开始并不表示解码过程开始，线程需要等待通过pipe机制获得命令和数据（cmdPipe和dataPipe），在适当的时候开始工作。这个pipe在MP3解码组件的SendCommand等实现写操作，在线程中读取其内容。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&#160; &#160; &#160; &#160;本篇和上一篇都是科普一下OpenMax和它在android上的实现，可以忽略不用看。下一篇我们将承接上上一篇和上一篇结尾的部分，分析android平台Stagefright和codec的交互。<br><img src="http://o7xxrho8u.bkt.clouddn.com/img/windrunnerlihuan%E5%8D%9A%E5%AE%A2/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91%28%E5%85%AD%29----Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0%28preview%29/meizi.png" alt="妹子"></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/">Android多媒体开发(六)----Android中OpenMax的实现(preview)</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">windrunnerlihuan</a></p>
        <p><span>发布时间:</span>2016-12-26, 20:13:12</p>
        <p><span>最后更新:</span>2016-12-27, 01:41:04</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/" title="Android多媒体开发(六)----Android中OpenMax的实现(preview)">http://windrunnerlihuan.com/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/</a>
            <span class="copy-path" data-clipboard-text="原文: http://windrunnerlihuan.com/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/　　作者: windrunnerlihuan" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/12/15/Android多媒体开发-五-OpenMax简介/">
                    Android多媒体开发(五)----OpenMax简介
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenMax的接口与实现"><span class="toc-number">1.</span> <span class="toc-text">OpenMax的接口与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenMax-IL层接口"><span class="toc-number">1.1.</span> <span class="toc-text">OpenMax IL层接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenMax-IL实现的内容"><span class="toc-number">1.2.</span> <span class="toc-text">OpenMax IL实现的内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android中OpenMax的适配层"><span class="toc-number">2.</span> <span class="toc-text">Android中OpenMax的适配层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现"><span class="toc-number">3.</span> <span class="toc-text">TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TI-OpenMax-IL实现的结构和机制"><span class="toc-number">3.1.</span> <span class="toc-text">TI OpenMax IL实现的结构和机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TI-OpenMax-IL的核心和公共内容"><span class="toc-number">3.2.</span> <span class="toc-text">TI OpenMax IL的核心和公共内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个TI-OpenMax-IL组件的实现"><span class="toc-number">3.3.</span> <span class="toc-text">一个TI OpenMax IL组件的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-number">4.</span> <span class="toc-text">结语</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Android多媒体开发(六)----Android中OpenMax的实现(preview)　| April is your lie　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
      <div class="duoshuo" id="comments">
    <!-- ��˵���ۿ� start -->
    <div class="ds-thread" data-thread-key="2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/" data-title="Android多媒体开发(六)----Android中OpenMax的实现(preview)" data-url="http://windrunnerlihuan.com/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/"></div>
    <!-- ��˵���ۿ� end -->
    <!-- ��˵����JS���� start (һ����ҳֻ������һ��) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"windrunnerlihuan"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://windrunnerlihuan.com/js/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- ��˵����JS���� end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/12/15/Android多媒体开发-五-OpenMax简介/" title="下一篇: Android多媒体开发(五)----OpenMax简介">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/26/Android多媒体开发-六-Android中OpenMax的实现-preview/">Android多媒体开发(六)----Android中OpenMax的实现(preview)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/15/Android多媒体开发-五-OpenMax简介/">Android多媒体开发(五)----OpenMax简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/Android多媒体开发-四-AwesomePlayer数据源处理/">Android多媒体开发(四)----AwesomePlayer数据源处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/11/Android多媒体开发-三-从StageFright到AwesomePlayer/">Android多媒体开发(三)----从StageFright到AwesomePlayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/30/Android多媒体开发-二-MediaPlayer的C-S架构以及C-层调用步骤/">Android多媒体开发(二)----MediaPlayer的C/S架构以及C++层调用步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/Android多媒体开发-一-MediaPlayer框架开始/">Android多媒体开发(一)----MediaPlayer框架开始</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/31/JAVA线程池简单分析/">JAVA线程池简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/08/Android壁纸开发流程分析/">Android壁纸开发流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/18/如何实现1080P延迟低于500ms的实时超清直播传输技术/">如何实现1080P延迟低于500ms的实时超清直播传输技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/插件开发中的资源问题分析及填坑处理/">插件开发中的资源问题分析及填坑处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/23/智能指针简单分析/">智能指针简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/31/Android消息机制零散分析/">Android消息处理零散分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/12/浅析Bitmap占据内存大小/">浅析Bitmap占据内存大小</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/DanmakuFlameMaster简单分析/">弹幕框架DanmakuFlameMaster简单分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/24/Android属性动画原理分析/">Android属性动画流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/12/Binder简要分析/">Android跨进程通信机制Binder简要分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/06/移动直播技术秒开优化经验/">移动直播技术秒开优化经验</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/27/博客搭建历程/">博客搭建历程————————Github和Hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/27/新的开始/">新的开始</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 windrunnerlihuan
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.0">Yelee</a> by HuanLi & MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>